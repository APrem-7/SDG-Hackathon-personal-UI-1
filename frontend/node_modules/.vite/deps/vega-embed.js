import {
  __export,
  __privateAdd,
  __privateGet,
  __privateSet,
  __publicField
} from "./chunk-NNPG3NYD.js";

// node_modules/json-stringify-pretty-compact/index.js
var stringOrChar = /("(?:[^\\"]|\\.)*")|[:,]/g;
function stringify(passedObj, options = {}) {
  const indent = JSON.stringify(
    [1],
    void 0,
    options.indent === void 0 ? 2 : options.indent
  ).slice(2, -3);
  const maxLength = indent === "" ? Infinity : options.maxLength === void 0 ? 80 : options.maxLength;
  let { replacer: replacer2 } = options;
  return function _stringify(obj, currentIndent, reserved) {
    if (obj && typeof obj.toJSON === "function") {
      obj = obj.toJSON();
    }
    const string = JSON.stringify(obj, replacer2);
    if (string === void 0) {
      return string;
    }
    const length2 = maxLength - currentIndent.length - reserved;
    if (string.length <= length2) {
      const prettified = string.replace(
        stringOrChar,
        (match2, stringLiteral) => {
          return stringLiteral || `${match2} `;
        }
      );
      if (prettified.length <= length2) {
        return prettified;
      }
    }
    if (replacer2 != null) {
      obj = JSON.parse(string);
      replacer2 = void 0;
    }
    if (typeof obj === "object" && obj !== null) {
      const nextIndent = currentIndent + indent;
      const items = [];
      let index4 = 0;
      let start;
      let end;
      if (Array.isArray(obj)) {
        start = "[";
        end = "]";
        const { length: length3 } = obj;
        for (; index4 < length3; index4++) {
          items.push(
            _stringify(obj[index4], nextIndent, index4 === length3 - 1 ? 0 : 1) || "null"
          );
        }
      } else {
        start = "{";
        end = "}";
        const keys5 = Object.keys(obj);
        const { length: length3 } = keys5;
        for (; index4 < length3; index4++) {
          const key4 = keys5[index4];
          const keyPart = `${JSON.stringify(key4)}: `;
          const value7 = _stringify(
            obj[key4],
            nextIndent,
            keyPart.length + (index4 === length3 - 1 ? 0 : 1)
          );
          if (value7 !== void 0) {
            items.push(keyPart + value7);
          }
        }
      }
      if (items.length > 0) {
        return [start, indent + items.join(`,
${nextIndent}`), end].join(
          `
${currentIndent}`
        );
      }
    }
    return string;
  }(passedObj, "", 0);
}

// node_modules/vega/build/vega.module.js
var vega_module_exports = {};
__export(vega_module_exports, {
  Bounds: () => Bounds3,
  CanvasHandler: () => CanvasHandler3,
  CanvasRenderer: () => CanvasRenderer3,
  DATE: () => DATE8,
  DAY: () => DAY8,
  DAYOFYEAR: () => DAYOFYEAR8,
  Dataflow: () => Dataflow,
  Debug: () => Debug,
  DisallowedObjectProperties: () => DisallowedObjectProperties,
  Error: () => Error$1,
  EventStream: () => EventStream,
  Gradient: () => Gradient,
  GroupItem: () => GroupItem3,
  HOURS: () => HOURS8,
  Handler: () => Handler3,
  HybridHandler: () => HybridHandler3,
  HybridRenderer: () => HybridRenderer3,
  Info: () => Info,
  Item: () => Item3,
  MILLISECONDS: () => MILLISECONDS8,
  MINUTES: () => MINUTES8,
  MONTH: () => MONTH8,
  Marks: () => Marks3,
  MultiPulse: () => MultiPulse,
  None: () => None,
  Operator: () => Operator,
  Parameters: () => Parameters,
  Pulse: () => Pulse,
  QUARTER: () => QUARTER8,
  RenderType: () => RenderType,
  Renderer: () => Renderer3,
  ResourceLoader: () => ResourceLoader3,
  SECONDS: () => SECONDS8,
  SVGHandler: () => SVGHandler3,
  SVGRenderer: () => SVGRenderer3,
  SVGStringRenderer: () => SVGStringRenderer3,
  Scenegraph: () => Scenegraph,
  TIME_UNITS: () => TIME_UNITS8,
  Transform: () => Transform,
  View: () => View,
  WEEK: () => WEEK8,
  Warn: () => Warn,
  YEAR: () => YEAR8,
  accessor: () => accessor,
  accessorFields: () => accessorFields,
  accessorName: () => accessorName,
  array: () => array,
  ascending: () => ascending,
  bandwidthNRD: () => estimateBandwidth,
  bin: () => bin2,
  bootstrapCI: () => bootstrapCI,
  boundClip: () => boundClip2,
  boundContext: () => boundContext3,
  boundItem: () => boundItem2,
  boundMark: () => boundMark,
  boundStroke: () => boundStroke3,
  changeset: () => changeset,
  clampRange: () => clampRange,
  codegenExpression: () => codegen,
  compare: () => compare,
  constant: () => constant,
  cumulativeLogNormal: () => cumulativeLogNormal,
  cumulativeNormal: () => cumulativeNormal,
  cumulativeUniform: () => cumulativeUniform,
  dayofyear: () => dayofyear,
  debounce: () => debounce,
  defaultLocale: () => defaultLocale4,
  definition: () => definition,
  densityLogNormal: () => densityLogNormal,
  densityNormal: () => densityNormal,
  densityUniform: () => densityUniform,
  domChild: () => domChild3,
  domClear: () => domClear3,
  domCreate: () => domCreate3,
  domFind: () => domFind3,
  dotbin: () => dotbin,
  error: () => error,
  expressionFunction: () => expressionFunction,
  extend: () => extend,
  extent: () => extent,
  extentIndex: () => extentIndex,
  falsy: () => falsy,
  fastmap: () => fastmap,
  field: () => field,
  flush: () => flush,
  font: () => font3,
  fontFamily: () => fontFamily3,
  fontSize: () => fontSize3,
  format: () => format7,
  formatLocale: () => numberFormatDefaultLocale2,
  formats: () => formats7,
  hasOwnProperty: () => has,
  id: () => id,
  identity: () => identity,
  inferType: () => inferType2,
  inferTypes: () => inferTypes2,
  ingest: () => ingest$1,
  inherits: () => inherits,
  inrange: () => inrange,
  interpolate: () => interpolate6,
  interpolateColors: () => interpolateColors6,
  interpolateRange: () => interpolateRange2,
  intersect: () => intersect3,
  intersectBoxLine: () => intersectBoxLine3,
  intersectPath: () => intersectPath3,
  intersectPoint: () => intersectPoint3,
  intersectRule: () => intersectRule3,
  isArray: () => isArray,
  isBoolean: () => isBoolean,
  isDate: () => isDate,
  isFunction: () => isFunction,
  isIterable: () => isIterable,
  isNumber: () => isNumber,
  isObject: () => isObject,
  isRegExp: () => isRegExp,
  isString: () => isString,
  isTuple: () => isTuple,
  key: () => key,
  lerp: () => lerp,
  lineHeight: () => lineHeight3,
  loader: () => loader4,
  locale: () => locale3,
  logger: () => logger,
  lruCache: () => lruCache,
  markup: () => markup3,
  merge: () => merge,
  mergeConfig: () => mergeConfig,
  multiLineOffset: () => multiLineOffset2,
  one: () => one,
  pad: () => pad,
  panLinear: () => panLinear,
  panLog: () => panLog,
  panPow: () => panPow,
  panSymlog: () => panSymlog,
  parse: () => parse11,
  parseExpression: () => parser,
  parseSelector: () => eventSelector,
  path: () => path,
  pathCurves: () => curves3,
  pathEqual: () => pathEqual,
  pathParse: () => parse7,
  pathRectangle: () => vg_rect3,
  pathRender: () => pathRender3,
  pathSymbols: () => symbols9,
  pathTrail: () => vg_trail3,
  peek: () => peek,
  point: () => point14,
  projection: () => projection2,
  quantileLogNormal: () => quantileLogNormal,
  quantileNormal: () => quantileNormal,
  quantileUniform: () => quantileUniform,
  quantiles: () => quantiles,
  quantizeInterpolator: () => quantizeInterpolator2,
  quarter: () => quarter,
  quartiles: () => quartiles,
  random: () => random,
  randomInteger: () => integer,
  randomKDE: () => kde,
  randomLCG: () => lcg,
  randomLogNormal: () => lognormal,
  randomMixture: () => mixture,
  randomNormal: () => gaussian,
  randomUniform: () => uniform,
  read: () => read2,
  regressionConstant: () => constant5,
  regressionExp: () => exp2,
  regressionLinear: () => linear,
  regressionLoess: () => loess,
  regressionLog: () => log2,
  regressionPoly: () => poly,
  regressionPow: () => pow2,
  regressionQuad: () => quad,
  renderModule: () => renderModule,
  repeat: () => repeat,
  resetDefaultLocale: () => resetDefaultLocale,
  resetSVGDefIds: () => resetSVGDefIds,
  responseType: () => responseType2,
  runtimeContext: () => context6,
  sampleCurve: () => sampleCurve,
  sampleLogNormal: () => sampleLogNormal,
  sampleNormal: () => sampleNormal,
  sampleUniform: () => sampleUniform,
  scale: () => scale9,
  sceneEqual: () => sceneEqual,
  sceneFromJSON: () => sceneFromJSON,
  scenePickVisit: () => pickVisit3,
  sceneToJSON: () => sceneToJSON,
  sceneVisit: () => visit3,
  sceneZOrder: () => zorder3,
  scheme: () => scheme33,
  serializeXML: () => serializeXML3,
  setHybridRendererOptions: () => setHybridRendererOptions,
  setRandom: () => setRandom,
  span: () => span,
  splitAccessPath: () => splitAccessPath,
  stringValue: () => $,
  textMetrics: () => textMetrics3,
  timeBin: () => bin4,
  timeFloor: () => timeFloor2,
  timeFormatLocale: () => timeFormatDefaultLocale4,
  timeInterval: () => timeInterval9,
  timeOffset: () => timeOffset,
  timeSequence: () => timeSequence,
  timeUnitSpecifier: () => timeUnitSpecifier,
  timeUnits: () => timeUnits2,
  toBoolean: () => toBoolean,
  toDate: () => toDate,
  toNumber: () => toNumber,
  toSet: () => toSet,
  toString: () => toString,
  transform: () => transform,
  transforms: () => transforms,
  truncate: () => truncate,
  truthy: () => truthy,
  tupleid: () => tupleid,
  typeParsers: () => typeParsers2,
  utcFloor: () => utcFloor2,
  utcInterval: () => utcInterval8,
  utcOffset: () => utcOffset,
  utcSequence: () => utcSequence,
  utcdayofyear: () => utcdayofyear,
  utcquarter: () => utcquarter,
  utcweek: () => utcweek,
  version: () => version,
  visitArray: () => visitArray,
  week: () => week,
  writeConfig: () => writeConfig,
  zero: () => zero,
  zoomLinear: () => zoomLinear,
  zoomLog: () => zoomLog,
  zoomPow: () => zoomPow,
  zoomSymlog: () => zoomSymlog
});

// node_modules/vega/node_modules/vega-util/build/vega-util.js
function accessor(fn, fields, name) {
  fn.fields = fields || [];
  fn.fname = name;
  return fn;
}
function accessorName(fn) {
  return fn == null ? null : fn.fname;
}
function accessorFields(fn) {
  return fn == null ? null : fn.fields;
}
function getter(path7) {
  return path7.length === 1 ? get1(path7[0]) : getN(path7);
}
var get1 = (field25) => function(obj) {
  return obj[field25];
};
var getN = (path7) => {
  const len = path7.length;
  return function(obj) {
    for (let i = 0; i < len; ++i) {
      obj = obj[path7[i]];
    }
    return obj;
  };
};
function error(message) {
  throw Error(message);
}
function splitAccessPath(p) {
  const path7 = [], n = p.length;
  let q = null, b6 = 0, s2 = "", i, j, c5;
  p = p + "";
  function push() {
    path7.push(s2 + p.substring(i, j));
    s2 = "";
    i = j + 1;
  }
  for (i = j = 0; j < n; ++j) {
    c5 = p[j];
    if (c5 === "\\") {
      s2 += p.substring(i, j++);
      i = j;
    } else if (c5 === q) {
      push();
      q = null;
      b6 = -1;
    } else if (q) {
      continue;
    } else if (i === b6 && c5 === '"') {
      i = j + 1;
      q = c5;
    } else if (i === b6 && c5 === "'") {
      i = j + 1;
      q = c5;
    } else if (c5 === "." && !b6) {
      if (j > i) {
        push();
      } else {
        i = j + 1;
      }
    } else if (c5 === "[") {
      if (j > i)
        push();
      b6 = i = j + 1;
    } else if (c5 === "]") {
      if (!b6)
        error("Access path missing open bracket: " + p);
      if (b6 > 0)
        push();
      b6 = 0;
      i = j + 1;
    }
  }
  if (b6)
    error("Access path missing closing bracket: " + p);
  if (q)
    error("Access path missing closing quote: " + p);
  if (j > i) {
    j++;
    push();
  }
  return path7;
}
function field(field25, name, opt) {
  const path7 = splitAccessPath(field25);
  field25 = path7.length === 1 ? path7[0] : field25;
  return accessor((opt && opt.get || getter)(path7), [field25], name || field25);
}
var id = field("id");
var identity = accessor((_) => _, [], "identity");
var zero = accessor(() => 0, [], "zero");
var one = accessor(() => 1, [], "one");
var truthy = accessor(() => true, [], "true");
var falsy = accessor(() => false, [], "false");
var DisallowedObjectProperties = /* @__PURE__ */ new Set([...Object.getOwnPropertyNames(Object.prototype).filter((name) => typeof Object.prototype[name] === "function"), "__proto__"]);
function log$1(method10, level, input) {
  const args = [level].concat([].slice.call(input));
  console[method10].apply(console, args);
}
var None = 0;
var Error$1 = 1;
var Warn = 2;
var Info = 3;
var Debug = 4;
function logger(_, method10, handler = log$1) {
  let level = _ || None;
  return {
    level(_2) {
      if (arguments.length) {
        level = +_2;
        return this;
      } else {
        return level;
      }
    },
    error() {
      if (level >= Error$1)
        handler(method10 || "error", "ERROR", arguments);
      return this;
    },
    warn() {
      if (level >= Warn)
        handler(method10 || "warn", "WARN", arguments);
      return this;
    },
    info() {
      if (level >= Info)
        handler(method10 || "log", "INFO", arguments);
      return this;
    },
    debug() {
      if (level >= Debug)
        handler(method10 || "log", "DEBUG", arguments);
      return this;
    }
  };
}
var isArray = Array.isArray;
function isObject(_) {
  return _ === Object(_);
}
var isLegalKey = (key4) => key4 !== "__proto__";
function mergeConfig(...configs) {
  return configs.reduce((out, source3) => {
    for (const key4 in source3) {
      if (key4 === "signals") {
        out.signals = mergeNamed(out.signals, source3.signals);
      } else {
        const r = key4 === "legend" ? {
          layout: 1
        } : key4 === "style" ? true : null;
        writeConfig(out, key4, source3[key4], r);
      }
    }
    return out;
  }, {});
}
function writeConfig(output3, key4, value7, recurse6) {
  if (!isLegalKey(key4))
    return;
  let k3, o;
  if (isObject(value7) && !isArray(value7)) {
    o = isObject(output3[key4]) ? output3[key4] : output3[key4] = {};
    for (k3 in value7) {
      if (recurse6 && (recurse6 === true || recurse6[k3])) {
        writeConfig(o, k3, value7[k3]);
      } else if (isLegalKey(k3)) {
        o[k3] = value7[k3];
      }
    }
  } else {
    output3[key4] = value7;
  }
}
function mergeNamed(a4, b6) {
  if (a4 == null)
    return b6;
  const map13 = {}, out = [];
  function add10(_) {
    if (!map13[_.name]) {
      map13[_.name] = 1;
      out.push(_);
    }
  }
  b6.forEach(add10);
  a4.forEach(add10);
  return out;
}
function peek(array22) {
  return array22[array22.length - 1];
}
function toNumber(_) {
  return _ == null || _ === "" ? null : +_;
}
var exp = (sign4) => (x9) => sign4 * Math.exp(x9);
var log = (sign4) => (x9) => Math.log(sign4 * x9);
var symlog = (c5) => (x9) => Math.sign(x9) * Math.log1p(Math.abs(x9 / c5));
var symexp = (c5) => (x9) => Math.sign(x9) * Math.expm1(Math.abs(x9)) * c5;
var pow = (exponent) => (x9) => x9 < 0 ? -Math.pow(-x9, exponent) : Math.pow(x9, exponent);
function pan(domain3, delta, lift, ground) {
  const d0 = lift(domain3[0]), d1 = lift(peek(domain3)), dd = (d1 - d0) * delta;
  return [ground(d0 - dd), ground(d1 - dd)];
}
function panLinear(domain3, delta) {
  return pan(domain3, delta, toNumber, identity);
}
function panLog(domain3, delta) {
  var sign4 = Math.sign(domain3[0]);
  return pan(domain3, delta, log(sign4), exp(sign4));
}
function panPow(domain3, delta, exponent) {
  return pan(domain3, delta, pow(exponent), pow(1 / exponent));
}
function panSymlog(domain3, delta, constant15) {
  return pan(domain3, delta, symlog(constant15), symexp(constant15));
}
function zoom(domain3, anchor, scale19, lift, ground) {
  const d0 = lift(domain3[0]), d1 = lift(peek(domain3)), da2 = anchor != null ? lift(anchor) : (d0 + d1) / 2;
  return [ground(da2 + (d0 - da2) * scale19), ground(da2 + (d1 - da2) * scale19)];
}
function zoomLinear(domain3, anchor, scale19) {
  return zoom(domain3, anchor, scale19, toNumber, identity);
}
function zoomLog(domain3, anchor, scale19) {
  const sign4 = Math.sign(domain3[0]);
  return zoom(domain3, anchor, scale19, log(sign4), exp(sign4));
}
function zoomPow(domain3, anchor, scale19, exponent) {
  return zoom(domain3, anchor, scale19, pow(exponent), pow(1 / exponent));
}
function zoomSymlog(domain3, anchor, scale19, constant15) {
  return zoom(domain3, anchor, scale19, symlog(constant15), symexp(constant15));
}
function quarter(date2) {
  return 1 + ~~(new Date(date2).getMonth() / 3);
}
function utcquarter(date2) {
  return 1 + ~~(new Date(date2).getUTCMonth() / 3);
}
function array(_) {
  return _ != null ? isArray(_) ? _ : [_] : [];
}
function clampRange(range7, min5, max5) {
  let lo = range7[0], hi = range7[1], span12;
  if (hi < lo) {
    span12 = hi;
    hi = lo;
    lo = span12;
  }
  span12 = hi - lo;
  return span12 >= max5 - min5 ? [min5, max5] : [lo = Math.min(Math.max(lo, min5), max5 - span12), lo + span12];
}
function isFunction(_) {
  return typeof _ === "function";
}
var DESCENDING = "descending";
function compare(fields, orders, opt) {
  opt = opt || {};
  orders = array(orders) || [];
  const ord = [], get23 = [], fmap = {}, gen = opt.comparator || comparator;
  array(fields).forEach((f, i) => {
    if (f == null)
      return;
    ord.push(orders[i] === DESCENDING ? -1 : 1);
    get23.push(f = isFunction(f) ? f : field(f, null, opt));
    (accessorFields(f) || []).forEach((_) => fmap[_] = 1);
  });
  return get23.length === 0 ? null : accessor(gen(get23, ord), Object.keys(fmap));
}
var ascending = (u4, v2) => (u4 < v2 || u4 == null) && v2 != null ? -1 : (u4 > v2 || v2 == null) && u4 != null ? 1 : (v2 = v2 instanceof Date ? +v2 : v2, u4 = u4 instanceof Date ? +u4 : u4) !== u4 && v2 === v2 ? -1 : v2 !== v2 && u4 === u4 ? 1 : 0;
var comparator = (fields, orders) => fields.length === 1 ? compare1(fields[0], orders[0]) : compareN(fields, orders, fields.length);
var compare1 = (field25, order) => function(a4, b6) {
  return ascending(field25(a4), field25(b6)) * order;
};
var compareN = (fields, orders, n) => {
  orders.push(0);
  return function(a4, b6) {
    let f, c5 = 0, i = -1;
    while (c5 === 0 && ++i < n) {
      f = fields[i];
      c5 = ascending(f(a4), f(b6));
    }
    return c5 * orders[i];
  };
};
function constant(_) {
  return isFunction(_) ? _ : () => _;
}
function debounce(delay, handler) {
  let tid;
  return (e3) => {
    if (tid)
      clearTimeout(tid);
    tid = setTimeout(() => (handler(e3), tid = null), delay);
  };
}
function extend(_) {
  for (let x9, k3, i = 1, len = arguments.length; i < len; ++i) {
    x9 = arguments[i];
    for (k3 in x9) {
      _[k3] = x9[k3];
    }
  }
  return _;
}
function extent(array22, f) {
  let i = 0, n, v2, min5, max5;
  if (array22 && (n = array22.length)) {
    if (f == null) {
      for (v2 = array22[i]; i < n && (v2 == null || v2 !== v2); v2 = array22[++i])
        ;
      min5 = max5 = v2;
      for (; i < n; ++i) {
        v2 = array22[i];
        if (v2 != null) {
          if (v2 < min5)
            min5 = v2;
          if (v2 > max5)
            max5 = v2;
        }
      }
    } else {
      for (v2 = f(array22[i]); i < n && (v2 == null || v2 !== v2); v2 = f(array22[++i]))
        ;
      min5 = max5 = v2;
      for (; i < n; ++i) {
        v2 = f(array22[i]);
        if (v2 != null) {
          if (v2 < min5)
            min5 = v2;
          if (v2 > max5)
            max5 = v2;
        }
      }
    }
  }
  return [min5, max5];
}
function extentIndex(array22, f) {
  const n = array22.length;
  let i = -1, a4, b6, c5, u4, v2;
  if (f == null) {
    while (++i < n) {
      b6 = array22[i];
      if (b6 != null && b6 >= b6) {
        a4 = c5 = b6;
        break;
      }
    }
    if (i === n)
      return [-1, -1];
    u4 = v2 = i;
    while (++i < n) {
      b6 = array22[i];
      if (b6 != null) {
        if (a4 > b6) {
          a4 = b6;
          u4 = i;
        }
        if (c5 < b6) {
          c5 = b6;
          v2 = i;
        }
      }
    }
  } else {
    while (++i < n) {
      b6 = f(array22[i], i, array22);
      if (b6 != null && b6 >= b6) {
        a4 = c5 = b6;
        break;
      }
    }
    if (i === n)
      return [-1, -1];
    u4 = v2 = i;
    while (++i < n) {
      b6 = f(array22[i], i, array22);
      if (b6 != null) {
        if (a4 > b6) {
          a4 = b6;
          u4 = i;
        }
        if (c5 < b6) {
          c5 = b6;
          v2 = i;
        }
      }
    }
  }
  return [u4, v2];
}
function has(object2, property2) {
  return Object.hasOwn(object2, property2);
}
var NULL = {};
function fastmap(input) {
  let obj = {}, test2;
  function has$1(key4) {
    return has(obj, key4) && obj[key4] !== NULL;
  }
  const map13 = {
    size: 0,
    empty: 0,
    object: obj,
    has: has$1,
    get(key4) {
      return has$1(key4) ? obj[key4] : void 0;
    },
    set(key4, value7) {
      if (!has$1(key4)) {
        ++map13.size;
        if (obj[key4] === NULL)
          --map13.empty;
      }
      obj[key4] = value7;
      return this;
    },
    delete(key4) {
      if (has$1(key4)) {
        --map13.size;
        ++map13.empty;
        obj[key4] = NULL;
      }
      return this;
    },
    clear() {
      map13.size = map13.empty = 0;
      map13.object = obj = {};
    },
    test(_) {
      if (arguments.length) {
        test2 = _;
        return map13;
      } else {
        return test2;
      }
    },
    clean() {
      const next = {};
      let size = 0;
      for (const key4 in obj) {
        const value7 = obj[key4];
        if (value7 !== NULL && (!test2 || !test2(value7))) {
          next[key4] = value7;
          ++size;
        }
      }
      map13.size = size;
      map13.empty = 0;
      map13.object = obj = next;
    }
  };
  if (input)
    Object.keys(input).forEach((key4) => {
      map13.set(key4, input[key4]);
    });
  return map13;
}
function flush(range7, value7, threshold2, left, right, center) {
  if (!threshold2 && threshold2 !== 0)
    return center;
  const t = +threshold2;
  let a4 = range7[0], b6 = peek(range7), l;
  if (b6 < a4) {
    l = a4;
    a4 = b6;
    b6 = l;
  }
  l = Math.abs(value7 - a4);
  const r = Math.abs(b6 - value7);
  return l < r && l <= t ? left : r <= t ? right : center;
}
function inherits(child, parent, members) {
  const proto = child.prototype = Object.create(parent.prototype);
  Object.defineProperty(proto, "constructor", {
    value: child,
    writable: true,
    enumerable: true,
    configurable: true
  });
  return extend(proto, members);
}
function inrange(value7, range7, left, right) {
  let r0 = range7[0], r1 = range7[range7.length - 1], t;
  if (r0 > r1) {
    t = r0;
    r0 = r1;
    r1 = t;
  }
  left = left === void 0 || left;
  right = right === void 0 || right;
  return (left ? r0 <= value7 : r0 < value7) && (right ? value7 <= r1 : value7 < r1);
}
function isBoolean(_) {
  return typeof _ === "boolean";
}
function isDate(_) {
  return Object.prototype.toString.call(_) === "[object Date]";
}
function isIterable(_) {
  return _ && isFunction(_[Symbol.iterator]);
}
function isNumber(_) {
  return typeof _ === "number";
}
function isRegExp(_) {
  return Object.prototype.toString.call(_) === "[object RegExp]";
}
function isString(_) {
  return typeof _ === "string";
}
function key(fields, flat, opt) {
  if (fields) {
    fields = flat ? array(fields).map((f) => f.replace(/\\(.)/g, "$1")) : array(fields);
  }
  const len = fields && fields.length, gen = opt && opt.get || getter, map13 = (f) => gen(flat ? [f] : splitAccessPath(f));
  let fn;
  if (!len) {
    fn = function() {
      return "";
    };
  } else if (len === 1) {
    const get23 = map13(fields[0]);
    fn = function(_) {
      return "" + get23(_);
    };
  } else {
    const get23 = fields.map(map13);
    fn = function(_) {
      let s2 = "" + get23[0](_), i = 0;
      while (++i < len)
        s2 += "|" + get23[i](_);
      return s2;
    };
  }
  return accessor(fn, fields, "key");
}
function lerp(array22, frac) {
  const lo = array22[0], hi = peek(array22), f = +frac;
  return !f ? lo : f === 1 ? hi : lo + f * (hi - lo);
}
var DEFAULT_MAX_SIZE = 1e4;
function lruCache(maxsize) {
  maxsize = +maxsize || DEFAULT_MAX_SIZE;
  let curr, prev, size;
  const clear2 = () => {
    curr = {};
    prev = {};
    size = 0;
  };
  const update3 = (key4, value7) => {
    if (++size > maxsize) {
      prev = curr;
      curr = {};
      size = 1;
    }
    return curr[key4] = value7;
  };
  clear2();
  return {
    clear: clear2,
    has: (key4) => has(curr, key4) || has(prev, key4),
    get: (key4) => has(curr, key4) ? curr[key4] : has(prev, key4) ? update3(key4, prev[key4]) : void 0,
    set: (key4, value7) => has(curr, key4) ? curr[key4] = value7 : update3(key4, value7)
  };
}
function merge(compare10, array0, array1, output3) {
  const n0 = array0.length, n1 = array1.length;
  if (!n1)
    return array0;
  if (!n0)
    return array1;
  const merged = output3 || new array0.constructor(n0 + n1);
  let i0 = 0, i1 = 0, i = 0;
  for (; i0 < n0 && i1 < n1; ++i) {
    merged[i] = compare10(array0[i0], array1[i1]) > 0 ? array1[i1++] : array0[i0++];
  }
  for (; i0 < n0; ++i0, ++i) {
    merged[i] = array0[i0];
  }
  for (; i1 < n1; ++i1, ++i) {
    merged[i] = array1[i1];
  }
  return merged;
}
function repeat(str, reps) {
  let s2 = "";
  while (--reps >= 0)
    s2 += str;
  return s2;
}
function pad(str, length2, padchar, align2) {
  const c5 = padchar || " ", s2 = str + "", n = length2 - s2.length;
  return n <= 0 ? s2 : align2 === "left" ? repeat(c5, n) + s2 : align2 === "center" ? repeat(c5, ~~(n / 2)) + s2 + repeat(c5, Math.ceil(n / 2)) : s2 + repeat(c5, n);
}
function span(array22) {
  return array22 && peek(array22) - array22[0] || 0;
}
function $(x9) {
  return isArray(x9) ? `[${x9.map((v2) => v2 === null ? "null" : $(v2))}]` : isObject(x9) || isString(x9) ? (
    // Output valid JSON and JS source strings.
    // See https://github.com/judofyr/timeless/blob/master/posts/json-isnt-a-javascript-subset.md
    JSON.stringify(x9).replaceAll("\u2028", "\\u2028").replaceAll("\u2029", "\\u2029")
  ) : x9;
}
function toBoolean(_) {
  return _ == null || _ === "" ? null : !_ || _ === "false" || _ === "0" ? false : !!_;
}
var defaultParser = (_) => isNumber(_) ? _ : isDate(_) ? _ : Date.parse(_);
function toDate(_, parser3) {
  parser3 = parser3 || defaultParser;
  return _ == null || _ === "" ? null : parser3(_);
}
function toString(_) {
  return _ == null || _ === "" ? null : _ + "";
}
function toSet(_) {
  const s2 = {}, n = _.length;
  for (let i = 0; i < n; ++i)
    s2[_[i]] = true;
  return s2;
}
function truncate(str, length2, align2, ellipsis) {
  const e3 = ellipsis != null ? ellipsis : "…", s2 = str + "", n = s2.length, l = Math.max(0, length2 - e3.length);
  return n <= length2 ? s2 : align2 === "left" ? e3 + s2.slice(n - l) : align2 === "center" ? s2.slice(0, Math.ceil(l / 2)) + e3 + s2.slice(n - ~~(l / 2)) : s2.slice(0, l) + e3;
}
function visitArray(array22, filter4, visitor) {
  if (array22) {
    if (filter4) {
      const n = array22.length;
      for (let i = 0; i < n; ++i) {
        const t = filter4(array22[i]);
        if (t)
          visitor(t, i, array22);
      }
    } else {
      array22.forEach(visitor);
    }
  }
}

// node_modules/vega-dataflow/node_modules/vega-util/build/vega-util.js
function accessor2(fn, fields, name) {
  fn.fields = fields || [];
  fn.fname = name;
  return fn;
}
function getter2(path7) {
  return path7.length === 1 ? get12(path7[0]) : getN2(path7);
}
var get12 = (field25) => function(obj) {
  return obj[field25];
};
var getN2 = (path7) => {
  const len = path7.length;
  return function(obj) {
    for (let i = 0; i < len; ++i) {
      obj = obj[path7[i]];
    }
    return obj;
  };
};
function error2(message) {
  throw Error(message);
}
function splitAccessPath2(p) {
  const path7 = [], n = p.length;
  let q = null, b6 = 0, s2 = "", i, j, c5;
  p = p + "";
  function push() {
    path7.push(s2 + p.substring(i, j));
    s2 = "";
    i = j + 1;
  }
  for (i = j = 0; j < n; ++j) {
    c5 = p[j];
    if (c5 === "\\") {
      s2 += p.substring(i, j++);
      i = j;
    } else if (c5 === q) {
      push();
      q = null;
      b6 = -1;
    } else if (q) {
      continue;
    } else if (i === b6 && c5 === '"') {
      i = j + 1;
      q = c5;
    } else if (i === b6 && c5 === "'") {
      i = j + 1;
      q = c5;
    } else if (c5 === "." && !b6) {
      if (j > i) {
        push();
      } else {
        i = j + 1;
      }
    } else if (c5 === "[") {
      if (j > i)
        push();
      b6 = i = j + 1;
    } else if (c5 === "]") {
      if (!b6)
        error2("Access path missing open bracket: " + p);
      if (b6 > 0)
        push();
      b6 = 0;
      i = j + 1;
    }
  }
  if (b6)
    error2("Access path missing closing bracket: " + p);
  if (q)
    error2("Access path missing closing quote: " + p);
  if (j > i) {
    j++;
    push();
  }
  return path7;
}
function field2(field25, name, opt) {
  const path7 = splitAccessPath2(field25);
  field25 = path7.length === 1 ? path7[0] : field25;
  return accessor2((opt && opt.get || getter2)(path7), [field25], name || field25);
}
var id2 = field2("id");
var identity2 = accessor2((_) => _, [], "identity");
var zero2 = accessor2(() => 0, [], "zero");
var one2 = accessor2(() => 1, [], "one");
var truthy2 = accessor2(() => true, [], "true");
var falsy2 = accessor2(() => false, [], "false");
var DisallowedObjectProperties2 = /* @__PURE__ */ new Set([...Object.getOwnPropertyNames(Object.prototype).filter((name) => typeof Object.prototype[name] === "function"), "__proto__"]);
function log$12(method10, level, input) {
  const args = [level].concat([].slice.call(input));
  console[method10].apply(console, args);
}
var None2 = 0;
var Error$12 = 1;
var Warn2 = 2;
var Info2 = 3;
var Debug2 = 4;
function logger2(_, method10, handler = log$12) {
  let level = _ || None2;
  return {
    level(_2) {
      if (arguments.length) {
        level = +_2;
        return this;
      } else {
        return level;
      }
    },
    error() {
      if (level >= Error$12)
        handler(method10 || "error", "ERROR", arguments);
      return this;
    },
    warn() {
      if (level >= Warn2)
        handler(method10 || "warn", "WARN", arguments);
      return this;
    },
    info() {
      if (level >= Info2)
        handler(method10 || "log", "INFO", arguments);
      return this;
    },
    debug() {
      if (level >= Debug2)
        handler(method10 || "log", "DEBUG", arguments);
      return this;
    }
  };
}
var isArray2 = Array.isArray;
function isObject2(_) {
  return _ === Object(_);
}
function toNumber2(_) {
  return _ == null || _ === "" ? null : +_;
}
function array2(_) {
  return _ != null ? isArray2(_) ? _ : [_] : [];
}
function isFunction2(_) {
  return typeof _ === "function";
}
function constant2(_) {
  return isFunction2(_) ? _ : () => _;
}
function debounce2(delay, handler) {
  let tid;
  return (e3) => {
    if (tid)
      clearTimeout(tid);
    tid = setTimeout(() => (handler(e3), tid = null), delay);
  };
}
function extend2(_) {
  for (let x9, k3, i = 1, len = arguments.length; i < len; ++i) {
    x9 = arguments[i];
    for (k3 in x9) {
      _[k3] = x9[k3];
    }
  }
  return _;
}
function has2(object2, property2) {
  return Object.hasOwn(object2, property2);
}
function inherits2(child, parent, members) {
  const proto = child.prototype = Object.create(parent.prototype);
  Object.defineProperty(proto, "constructor", {
    value: child,
    writable: true,
    enumerable: true,
    configurable: true
  });
  return extend2(proto, members);
}
function isDate2(_) {
  return Object.prototype.toString.call(_) === "[object Date]";
}
function isIterable2(_) {
  return _ && isFunction2(_[Symbol.iterator]);
}
function isNumber2(_) {
  return typeof _ === "number";
}
function isString2(_) {
  return typeof _ === "string";
}
function $2(x9) {
  return isArray2(x9) ? `[${x9.map((v2) => v2 === null ? "null" : $2(v2))}]` : isObject2(x9) || isString2(x9) ? (
    // Output valid JSON and JS source strings.
    // See https://github.com/judofyr/timeless/blob/master/posts/json-isnt-a-javascript-subset.md
    JSON.stringify(x9).replaceAll("\u2028", "\\u2028").replaceAll("\u2029", "\\u2029")
  ) : x9;
}
function toBoolean2(_) {
  return _ == null || _ === "" ? null : !_ || _ === "false" || _ === "0" ? false : !!_;
}
var defaultParser2 = (_) => isNumber2(_) ? _ : isDate2(_) ? _ : Date.parse(_);
function toDate2(_, parser3) {
  parser3 = parser3 || defaultParser2;
  return _ == null || _ === "" ? null : parser3(_);
}
function toString2(_) {
  return _ == null || _ === "" ? null : _ + "";
}
function visitArray2(array22, filter4, visitor) {
  if (array22) {
    if (filter4) {
      const n = array22.length;
      for (let i = 0; i < n; ++i) {
        const t = filter4(array22[i]);
        if (t)
          visitor(t, i, array22);
      }
    } else {
      array22.forEach(visitor);
    }
  }
}

// node_modules/d3-dsv/src/dsv.js
var EOL = {};
var EOF = {};
var QUOTE = 34;
var NEWLINE = 10;
var RETURN = 13;
function objectConverter(columns) {
  return new Function("d", "return {" + columns.map(function(name, i) {
    return JSON.stringify(name) + ": d[" + i + '] || ""';
  }).join(",") + "}");
}
function customConverter(columns, f) {
  var object2 = objectConverter(columns);
  return function(row, i) {
    return f(object2(row), i, columns);
  };
}
function inferColumns(rows) {
  var columnSet = /* @__PURE__ */ Object.create(null), columns = [];
  rows.forEach(function(row) {
    for (var column in row) {
      if (!(column in columnSet)) {
        columns.push(columnSet[column] = column);
      }
    }
  });
  return columns;
}
function pad2(value7, width2) {
  var s2 = value7 + "", length2 = s2.length;
  return length2 < width2 ? new Array(width2 - length2 + 1).join(0) + s2 : s2;
}
function formatYear(year) {
  return year < 0 ? "-" + pad2(-year, 6) : year > 9999 ? "+" + pad2(year, 6) : pad2(year, 4);
}
function formatDate(date2) {
  var hours = date2.getUTCHours(), minutes = date2.getUTCMinutes(), seconds2 = date2.getUTCSeconds(), milliseconds2 = date2.getUTCMilliseconds();
  return isNaN(date2) ? "Invalid Date" : formatYear(date2.getUTCFullYear(), 4) + "-" + pad2(date2.getUTCMonth() + 1, 2) + "-" + pad2(date2.getUTCDate(), 2) + (milliseconds2 ? "T" + pad2(hours, 2) + ":" + pad2(minutes, 2) + ":" + pad2(seconds2, 2) + "." + pad2(milliseconds2, 3) + "Z" : seconds2 ? "T" + pad2(hours, 2) + ":" + pad2(minutes, 2) + ":" + pad2(seconds2, 2) + "Z" : minutes || hours ? "T" + pad2(hours, 2) + ":" + pad2(minutes, 2) + "Z" : "");
}
function dsv_default(delimiter) {
  var reFormat = new RegExp('["' + delimiter + "\n\r]"), DELIMITER = delimiter.charCodeAt(0);
  function parse12(text7, f) {
    var convert, columns, rows = parseRows(text7, function(row, i) {
      if (convert)
        return convert(row, i - 1);
      columns = row, convert = f ? customConverter(row, f) : objectConverter(row);
    });
    rows.columns = columns || [];
    return rows;
  }
  function parseRows(text7, f) {
    var rows = [], N = text7.length, I = 0, n = 0, t, eof = N <= 0, eol = false;
    if (text7.charCodeAt(N - 1) === NEWLINE)
      --N;
    if (text7.charCodeAt(N - 1) === RETURN)
      --N;
    function token() {
      if (eof)
        return EOF;
      if (eol)
        return eol = false, EOL;
      var i, j = I, c5;
      if (text7.charCodeAt(j) === QUOTE) {
        while (I++ < N && text7.charCodeAt(I) !== QUOTE || text7.charCodeAt(++I) === QUOTE)
          ;
        if ((i = I) >= N)
          eof = true;
        else if ((c5 = text7.charCodeAt(I++)) === NEWLINE)
          eol = true;
        else if (c5 === RETURN) {
          eol = true;
          if (text7.charCodeAt(I) === NEWLINE)
            ++I;
        }
        return text7.slice(j + 1, i - 1).replace(/""/g, '"');
      }
      while (I < N) {
        if ((c5 = text7.charCodeAt(i = I++)) === NEWLINE)
          eol = true;
        else if (c5 === RETURN) {
          eol = true;
          if (text7.charCodeAt(I) === NEWLINE)
            ++I;
        } else if (c5 !== DELIMITER)
          continue;
        return text7.slice(j, i);
      }
      return eof = true, text7.slice(j, N);
    }
    while ((t = token()) !== EOF) {
      var row = [];
      while (t !== EOL && t !== EOF)
        row.push(t), t = token();
      if (f && (row = f(row, n++)) == null)
        continue;
      rows.push(row);
    }
    return rows;
  }
  function preformatBody(rows, columns) {
    return rows.map(function(row) {
      return columns.map(function(column) {
        return formatValue9(row[column]);
      }).join(delimiter);
    });
  }
  function format14(rows, columns) {
    if (columns == null)
      columns = inferColumns(rows);
    return [columns.map(formatValue9).join(delimiter)].concat(preformatBody(rows, columns)).join("\n");
  }
  function formatBody(rows, columns) {
    if (columns == null)
      columns = inferColumns(rows);
    return preformatBody(rows, columns).join("\n");
  }
  function formatRows(rows) {
    return rows.map(formatRow).join("\n");
  }
  function formatRow(row) {
    return row.map(formatValue9).join(delimiter);
  }
  function formatValue9(value7) {
    return value7 == null ? "" : value7 instanceof Date ? formatDate(value7) : reFormat.test(value7 += "") ? '"' + value7.replace(/"/g, '""') + '"' : value7;
  }
  return {
    parse: parse12,
    parseRows,
    format: format14,
    formatBody,
    formatRows,
    formatRow,
    formatValue: formatValue9
  };
}

// node_modules/d3-dsv/src/csv.js
var csv = dsv_default(",");
var csvParse = csv.parse;
var csvParseRows = csv.parseRows;
var csvFormat = csv.format;
var csvFormatBody = csv.formatBody;
var csvFormatRows = csv.formatRows;
var csvFormatRow = csv.formatRow;
var csvFormatValue = csv.formatValue;

// node_modules/d3-dsv/src/tsv.js
var tsv = dsv_default("	");
var tsvParse = tsv.parse;
var tsvParseRows = tsv.parseRows;
var tsvFormat = tsv.format;
var tsvFormatBody = tsv.formatBody;
var tsvFormatRows = tsv.formatRows;
var tsvFormatRow = tsv.formatRow;
var tsvFormatValue = tsv.formatValue;

// node_modules/d3-dsv/src/autoType.js
var fixtz = (/* @__PURE__ */ new Date("2019-01-01T00:00")).getHours() || (/* @__PURE__ */ new Date("2019-07-01T00:00")).getHours();

// node_modules/topojson-client/src/identity.js
function identity_default(x9) {
  return x9;
}

// node_modules/topojson-client/src/transform.js
function transform_default(transform4) {
  if (transform4 == null)
    return identity_default;
  var x07, y07, kx3 = transform4.scale[0], ky2 = transform4.scale[1], dx = transform4.translate[0], dy = transform4.translate[1];
  return function(input, i) {
    if (!i)
      x07 = y07 = 0;
    var j = 2, n = input.length, output3 = new Array(n);
    output3[0] = (x07 += input[0]) * kx3 + dx;
    output3[1] = (y07 += input[1]) * ky2 + dy;
    while (j < n)
      output3[j] = input[j], ++j;
    return output3;
  };
}

// node_modules/topojson-client/src/reverse.js
function reverse_default(array22, n) {
  var t, j = array22.length, i = j - n;
  while (i < --j)
    t = array22[i], array22[i++] = array22[j], array22[j] = t;
}

// node_modules/topojson-client/src/feature.js
function feature_default(topology, o) {
  if (typeof o === "string")
    o = topology.objects[o];
  return o.type === "GeometryCollection" ? { type: "FeatureCollection", features: o.geometries.map(function(o2) {
    return feature(topology, o2);
  }) } : feature(topology, o);
}
function feature(topology, o) {
  var id24 = o.id, bbox = o.bbox, properties = o.properties == null ? {} : o.properties, geometry = object(topology, o);
  return id24 == null && bbox == null ? { type: "Feature", properties, geometry } : bbox == null ? { type: "Feature", id: id24, properties, geometry } : { type: "Feature", id: id24, bbox, properties, geometry };
}
function object(topology, o) {
  var transformPoint = transform_default(topology.transform), arcs = topology.arcs;
  function arc8(i, points2) {
    if (points2.length)
      points2.pop();
    for (var a4 = arcs[i < 0 ? ~i : i], k3 = 0, n = a4.length; k3 < n; ++k3) {
      points2.push(transformPoint(a4[k3], k3));
    }
    if (i < 0)
      reverse_default(points2, n);
  }
  function point21(p) {
    return transformPoint(p);
  }
  function line8(arcs2) {
    var points2 = [];
    for (var i = 0, n = arcs2.length; i < n; ++i)
      arc8(arcs2[i], points2);
    if (points2.length < 2)
      points2.push(points2[0]);
    return points2;
  }
  function ring(arcs2) {
    var points2 = line8(arcs2);
    while (points2.length < 4)
      points2.push(points2[0]);
    return points2;
  }
  function polygon(arcs2) {
    return arcs2.map(ring);
  }
  function geometry(o2) {
    var type7 = o2.type, coordinates;
    switch (type7) {
      case "GeometryCollection":
        return { type: type7, geometries: o2.geometries.map(geometry) };
      case "Point":
        coordinates = point21(o2.coordinates);
        break;
      case "MultiPoint":
        coordinates = o2.coordinates.map(point21);
        break;
      case "LineString":
        coordinates = line8(o2.arcs);
        break;
      case "MultiLineString":
        coordinates = o2.arcs.map(line8);
        break;
      case "Polygon":
        coordinates = polygon(o2.arcs);
        break;
      case "MultiPolygon":
        coordinates = o2.arcs.map(polygon);
        break;
      default:
        return null;
    }
    return { type: type7, coordinates };
  }
  return geometry(o);
}

// node_modules/topojson-client/src/stitch.js
function stitch_default(topology, arcs) {
  var stitchedArcs = {}, fragmentByStart = {}, fragmentByEnd = {}, fragments = [], emptyIndex = -1;
  arcs.forEach(function(i, j) {
    var arc8 = topology.arcs[i < 0 ? ~i : i], t;
    if (arc8.length < 3 && !arc8[1][0] && !arc8[1][1]) {
      t = arcs[++emptyIndex], arcs[emptyIndex] = i, arcs[j] = t;
    }
  });
  arcs.forEach(function(i) {
    var e3 = ends(i), start = e3[0], end = e3[1], f, g;
    if (f = fragmentByEnd[start]) {
      delete fragmentByEnd[f.end];
      f.push(i);
      f.end = end;
      if (g = fragmentByStart[end]) {
        delete fragmentByStart[g.start];
        var fg = g === f ? f : f.concat(g);
        fragmentByStart[fg.start = f.start] = fragmentByEnd[fg.end = g.end] = fg;
      } else {
        fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
      }
    } else if (f = fragmentByStart[end]) {
      delete fragmentByStart[f.start];
      f.unshift(i);
      f.start = start;
      if (g = fragmentByEnd[start]) {
        delete fragmentByEnd[g.end];
        var gf = g === f ? f : g.concat(f);
        fragmentByStart[gf.start = g.start] = fragmentByEnd[gf.end = f.end] = gf;
      } else {
        fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
      }
    } else {
      f = [i];
      fragmentByStart[f.start = start] = fragmentByEnd[f.end = end] = f;
    }
  });
  function ends(i) {
    var arc8 = topology.arcs[i < 0 ? ~i : i], p02 = arc8[0], p1;
    if (topology.transform)
      p1 = [0, 0], arc8.forEach(function(dp) {
        p1[0] += dp[0], p1[1] += dp[1];
      });
    else
      p1 = arc8[arc8.length - 1];
    return i < 0 ? [p1, p02] : [p02, p1];
  }
  function flush3(fragmentByEnd2, fragmentByStart2) {
    for (var k3 in fragmentByEnd2) {
      var f = fragmentByEnd2[k3];
      delete fragmentByStart2[f.start];
      delete f.start;
      delete f.end;
      f.forEach(function(i) {
        stitchedArcs[i < 0 ? ~i : i] = 1;
      });
      fragments.push(f);
    }
  }
  flush3(fragmentByEnd, fragmentByStart);
  flush3(fragmentByStart, fragmentByEnd);
  arcs.forEach(function(i) {
    if (!stitchedArcs[i < 0 ? ~i : i])
      fragments.push([i]);
  });
  return fragments;
}

// node_modules/topojson-client/src/mesh.js
function mesh_default(topology) {
  return object(topology, meshArcs.apply(this, arguments));
}
function meshArcs(topology, object2, filter4) {
  var arcs, i, n;
  if (arguments.length > 1)
    arcs = extractArcs(topology, object2, filter4);
  else
    for (i = 0, arcs = new Array(n = topology.arcs.length); i < n; ++i)
      arcs[i] = i;
  return { type: "MultiLineString", arcs: stitch_default(topology, arcs) };
}
function extractArcs(topology, object2, filter4) {
  var arcs = [], geomsByArc = [], geom;
  function extract0(i) {
    var j = i < 0 ? ~i : i;
    (geomsByArc[j] || (geomsByArc[j] = [])).push({ i, g: geom });
  }
  function extract1(arcs2) {
    arcs2.forEach(extract0);
  }
  function extract2(arcs2) {
    arcs2.forEach(extract1);
  }
  function extract3(arcs2) {
    arcs2.forEach(extract2);
  }
  function geometry(o) {
    switch (geom = o, o.type) {
      case "GeometryCollection":
        o.geometries.forEach(geometry);
        break;
      case "LineString":
        extract1(o.arcs);
        break;
      case "MultiLineString":
      case "Polygon":
        extract2(o.arcs);
        break;
      case "MultiPolygon":
        extract3(o.arcs);
        break;
    }
  }
  geometry(object2);
  geomsByArc.forEach(filter4 == null ? function(geoms) {
    arcs.push(geoms[0].i);
  } : function(geoms) {
    if (filter4(geoms[0].g, geoms[geoms.length - 1].g))
      arcs.push(geoms[0].i);
  });
  return arcs;
}

// node_modules/d3-array/src/ascending.js
function ascending2(a4, b6) {
  return a4 == null || b6 == null ? NaN : a4 < b6 ? -1 : a4 > b6 ? 1 : a4 >= b6 ? 0 : NaN;
}

// node_modules/d3-array/src/descending.js
function descending(a4, b6) {
  return a4 == null || b6 == null ? NaN : b6 < a4 ? -1 : b6 > a4 ? 1 : b6 >= a4 ? 0 : NaN;
}

// node_modules/d3-array/src/bisector.js
function bisector(f) {
  let compare14, compare22, delta;
  if (f.length !== 2) {
    compare14 = ascending2;
    compare22 = (d, x9) => ascending2(f(d), x9);
    delta = (d, x9) => f(d) - x9;
  } else {
    compare14 = f === ascending2 || f === descending ? f : zero3;
    compare22 = f;
    delta = f;
  }
  function left(a4, x9, lo = 0, hi = a4.length) {
    if (lo < hi) {
      if (compare14(x9, x9) !== 0)
        return hi;
      do {
        const mid = lo + hi >>> 1;
        if (compare22(a4[mid], x9) < 0)
          lo = mid + 1;
        else
          hi = mid;
      } while (lo < hi);
    }
    return lo;
  }
  function right(a4, x9, lo = 0, hi = a4.length) {
    if (lo < hi) {
      if (compare14(x9, x9) !== 0)
        return hi;
      do {
        const mid = lo + hi >>> 1;
        if (compare22(a4[mid], x9) <= 0)
          lo = mid + 1;
        else
          hi = mid;
      } while (lo < hi);
    }
    return lo;
  }
  function center(a4, x9, lo = 0, hi = a4.length) {
    const i = left(a4, x9, lo, hi - 1);
    return i > lo && delta(a4[i - 1], x9) > -delta(a4[i], x9) ? i - 1 : i;
  }
  return { left, center, right };
}
function zero3() {
  return 0;
}

// node_modules/d3-array/src/number.js
function number(x9) {
  return x9 === null ? NaN : +x9;
}
function* numbers(values7, valueof) {
  if (valueof === void 0) {
    for (let value7 of values7) {
      if (value7 != null && (value7 = +value7) >= value7) {
        yield value7;
      }
    }
  } else {
    let index4 = -1;
    for (let value7 of values7) {
      if ((value7 = valueof(value7, ++index4, values7)) != null && (value7 = +value7) >= value7) {
        yield value7;
      }
    }
  }
}

// node_modules/d3-array/src/bisect.js
var ascendingBisect = bisector(ascending2);
var bisectRight = ascendingBisect.right;
var bisectLeft = ascendingBisect.left;
var bisectCenter = bisector(number).center;
var bisect_default2 = bisectRight;

// node_modules/d3-array/src/blur.js
var blur2 = Blur2(blurf);
var blurImage = Blur2(blurfImage);
function Blur2(blur3) {
  return function(data3, rx, ry = rx) {
    if (!((rx = +rx) >= 0))
      throw new RangeError("invalid rx");
    if (!((ry = +ry) >= 0))
      throw new RangeError("invalid ry");
    let { data: values7, width: width2, height: height2 } = data3;
    if (!((width2 = Math.floor(width2)) >= 0))
      throw new RangeError("invalid width");
    if (!((height2 = Math.floor(height2 !== void 0 ? height2 : values7.length / width2)) >= 0))
      throw new RangeError("invalid height");
    if (!width2 || !height2 || !rx && !ry)
      return data3;
    const blurx = rx && blur3(rx);
    const blury = ry && blur3(ry);
    const temp6 = values7.slice();
    if (blurx && blury) {
      blurh(blurx, temp6, values7, width2, height2);
      blurh(blurx, values7, temp6, width2, height2);
      blurh(blurx, temp6, values7, width2, height2);
      blurv(blury, values7, temp6, width2, height2);
      blurv(blury, temp6, values7, width2, height2);
      blurv(blury, values7, temp6, width2, height2);
    } else if (blurx) {
      blurh(blurx, values7, temp6, width2, height2);
      blurh(blurx, temp6, values7, width2, height2);
      blurh(blurx, values7, temp6, width2, height2);
    } else if (blury) {
      blurv(blury, values7, temp6, width2, height2);
      blurv(blury, temp6, values7, width2, height2);
      blurv(blury, values7, temp6, width2, height2);
    }
    return data3;
  };
}
function blurh(blur3, T, S, w8, h6) {
  for (let y9 = 0, n = w8 * h6; y9 < n; ) {
    blur3(T, S, y9, y9 += w8, 1);
  }
}
function blurv(blur3, T, S, w8, h6) {
  for (let x9 = 0, n = w8 * h6; x9 < w8; ++x9) {
    blur3(T, S, x9, x9 + n, w8);
  }
}
function blurfImage(radius2) {
  const blur3 = blurf(radius2);
  return (T, S, start, stop2, step) => {
    start <<= 2, stop2 <<= 2, step <<= 2;
    blur3(T, S, start + 0, stop2 + 0, step);
    blur3(T, S, start + 1, stop2 + 1, step);
    blur3(T, S, start + 2, stop2 + 2, step);
    blur3(T, S, start + 3, stop2 + 3, step);
  };
}
function blurf(radius2) {
  const radius0 = Math.floor(radius2);
  if (radius0 === radius2)
    return bluri(radius2);
  const t = radius2 - radius0;
  const w8 = 2 * radius2 + 1;
  return (T, S, start, stop2, step) => {
    if (!((stop2 -= step) >= start))
      return;
    let sum4 = radius0 * S[start];
    const s0 = step * radius0;
    const s1 = s0 + step;
    for (let i = start, j = start + s0; i < j; i += step) {
      sum4 += S[Math.min(stop2, i)];
    }
    for (let i = start, j = stop2; i <= j; i += step) {
      sum4 += S[Math.min(stop2, i + s0)];
      T[i] = (sum4 + t * (S[Math.max(start, i - s1)] + S[Math.min(stop2, i + s1)])) / w8;
      sum4 -= S[Math.max(start, i - s0)];
    }
  };
}
function bluri(radius2) {
  const w8 = 2 * radius2 + 1;
  return (T, S, start, stop2, step) => {
    if (!((stop2 -= step) >= start))
      return;
    let sum4 = radius2 * S[start];
    const s2 = step * radius2;
    for (let i = start, j = start + s2; i < j; i += step) {
      sum4 += S[Math.min(stop2, i)];
    }
    for (let i = start, j = stop2; i <= j; i += step) {
      sum4 += S[Math.min(stop2, i + s2)];
      T[i] = sum4 / w8;
      sum4 -= S[Math.max(start, i - s2)];
    }
  };
}

// node_modules/d3-array/src/variance.js
function variance(values7, valueof) {
  let count3 = 0;
  let delta;
  let mean2 = 0;
  let sum4 = 0;
  if (valueof === void 0) {
    for (let value7 of values7) {
      if (value7 != null && (value7 = +value7) >= value7) {
        delta = value7 - mean2;
        mean2 += delta / ++count3;
        sum4 += delta * (value7 - mean2);
      }
    }
  } else {
    let index4 = -1;
    for (let value7 of values7) {
      if ((value7 = valueof(value7, ++index4, values7)) != null && (value7 = +value7) >= value7) {
        delta = value7 - mean2;
        mean2 += delta / ++count3;
        sum4 += delta * (value7 - mean2);
      }
    }
  }
  if (count3 > 1)
    return sum4 / (count3 - 1);
}

// node_modules/d3-array/src/deviation.js
function deviation(values7, valueof) {
  const v2 = variance(values7, valueof);
  return v2 ? Math.sqrt(v2) : v2;
}

// node_modules/d3-array/src/fsum.js
var Adder = class {
  constructor() {
    this._partials = new Float64Array(32);
    this._n = 0;
  }
  add(x9) {
    const p = this._partials;
    let i = 0;
    for (let j = 0; j < this._n && j < 32; j++) {
      const y9 = p[j], hi = x9 + y9, lo = Math.abs(x9) < Math.abs(y9) ? x9 - (hi - y9) : y9 - (hi - x9);
      if (lo)
        p[i++] = lo;
      x9 = hi;
    }
    p[i] = x9;
    this._n = i + 1;
    return this;
  }
  valueOf() {
    const p = this._partials;
    let n = this._n, x9, y9, lo, hi = 0;
    if (n > 0) {
      hi = p[--n];
      while (n > 0) {
        x9 = hi;
        y9 = p[--n];
        hi = x9 + y9;
        lo = y9 - (hi - x9);
        if (lo)
          break;
      }
      if (n > 0 && (lo < 0 && p[n - 1] < 0 || lo > 0 && p[n - 1] > 0)) {
        y9 = lo * 2;
        x9 = hi + y9;
        if (y9 == x9 - hi)
          hi = x9;
      }
    }
    return hi;
  }
};

// node_modules/internmap/src/index.js
var InternMap = class extends Map {
  constructor(entries2, key4 = keyof) {
    super();
    Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: key4 } });
    if (entries2 != null)
      for (const [key5, value7] of entries2)
        this.set(key5, value7);
  }
  get(key4) {
    return super.get(intern_get(this, key4));
  }
  has(key4) {
    return super.has(intern_get(this, key4));
  }
  set(key4, value7) {
    return super.set(intern_set(this, key4), value7);
  }
  delete(key4) {
    return super.delete(intern_delete(this, key4));
  }
};
var InternSet = class extends Set {
  constructor(values7, key4 = keyof) {
    super();
    Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: key4 } });
    if (values7 != null)
      for (const value7 of values7)
        this.add(value7);
  }
  has(value7) {
    return super.has(intern_get(this, value7));
  }
  add(value7) {
    return super.add(intern_set(this, value7));
  }
  delete(value7) {
    return super.delete(intern_delete(this, value7));
  }
};
function intern_get({ _intern, _key }, value7) {
  const key4 = _key(value7);
  return _intern.has(key4) ? _intern.get(key4) : value7;
}
function intern_set({ _intern, _key }, value7) {
  const key4 = _key(value7);
  if (_intern.has(key4))
    return _intern.get(key4);
  _intern.set(key4, value7);
  return value7;
}
function intern_delete({ _intern, _key }, value7) {
  const key4 = _key(value7);
  if (_intern.has(key4)) {
    value7 = _intern.get(key4);
    _intern.delete(key4);
  }
  return value7;
}
function keyof(value7) {
  return value7 !== null && typeof value7 === "object" ? value7.valueOf() : value7;
}

// node_modules/d3-array/src/permute.js
function permute(source3, keys5) {
  return Array.from(keys5, (key4) => source3[key4]);
}

// node_modules/d3-array/src/sort.js
function compareDefined(compare10 = ascending2) {
  if (compare10 === ascending2)
    return ascendingDefined;
  if (typeof compare10 !== "function")
    throw new TypeError("compare is not a function");
  return (a4, b6) => {
    const x9 = compare10(a4, b6);
    if (x9 || x9 === 0)
      return x9;
    return (compare10(b6, b6) === 0) - (compare10(a4, a4) === 0);
  };
}
function ascendingDefined(a4, b6) {
  return (a4 == null || !(a4 >= a4)) - (b6 == null || !(b6 >= b6)) || (a4 < b6 ? -1 : a4 > b6 ? 1 : 0);
}

// node_modules/d3-array/src/array.js
var array3 = Array.prototype;
var slice = array3.slice;
var map = array3.map;

// node_modules/d3-array/src/ticks.js
var e10 = Math.sqrt(50);
var e5 = Math.sqrt(10);
var e2 = Math.sqrt(2);
function tickSpec(start, stop2, count3) {
  const step = (stop2 - start) / Math.max(0, count3), power = Math.floor(Math.log10(step)), error25 = step / Math.pow(10, power), factor = error25 >= e10 ? 10 : error25 >= e5 ? 5 : error25 >= e2 ? 2 : 1;
  let i1, i2, inc;
  if (power < 0) {
    inc = Math.pow(10, -power) / factor;
    i1 = Math.round(start * inc);
    i2 = Math.round(stop2 * inc);
    if (i1 / inc < start)
      ++i1;
    if (i2 / inc > stop2)
      --i2;
    inc = -inc;
  } else {
    inc = Math.pow(10, power) * factor;
    i1 = Math.round(start / inc);
    i2 = Math.round(stop2 / inc);
    if (i1 * inc < start)
      ++i1;
    if (i2 * inc > stop2)
      --i2;
  }
  if (i2 < i1 && 0.5 <= count3 && count3 < 2)
    return tickSpec(start, stop2, count3 * 2);
  return [i1, i2, inc];
}
function ticks(start, stop2, count3) {
  stop2 = +stop2, start = +start, count3 = +count3;
  if (!(count3 > 0))
    return [];
  if (start === stop2)
    return [start];
  const reverse4 = stop2 < start, [i1, i2, inc] = reverse4 ? tickSpec(stop2, start, count3) : tickSpec(start, stop2, count3);
  if (!(i2 >= i1))
    return [];
  const n = i2 - i1 + 1, ticks2 = new Array(n);
  if (reverse4) {
    if (inc < 0)
      for (let i = 0; i < n; ++i)
        ticks2[i] = (i2 - i) / -inc;
    else
      for (let i = 0; i < n; ++i)
        ticks2[i] = (i2 - i) * inc;
  } else {
    if (inc < 0)
      for (let i = 0; i < n; ++i)
        ticks2[i] = (i1 + i) / -inc;
    else
      for (let i = 0; i < n; ++i)
        ticks2[i] = (i1 + i) * inc;
  }
  return ticks2;
}
function tickIncrement(start, stop2, count3) {
  stop2 = +stop2, start = +start, count3 = +count3;
  return tickSpec(start, stop2, count3)[2];
}
function tickStep(start, stop2, count3) {
  stop2 = +stop2, start = +start, count3 = +count3;
  const reverse4 = stop2 < start, inc = reverse4 ? tickIncrement(stop2, start, count3) : tickIncrement(start, stop2, count3);
  return (reverse4 ? -1 : 1) * (inc < 0 ? 1 / -inc : inc);
}

// node_modules/d3-array/src/max.js
function max(values7, valueof) {
  let max5;
  if (valueof === void 0) {
    for (const value7 of values7) {
      if (value7 != null && (max5 < value7 || max5 === void 0 && value7 >= value7)) {
        max5 = value7;
      }
    }
  } else {
    let index4 = -1;
    for (let value7 of values7) {
      if ((value7 = valueof(value7, ++index4, values7)) != null && (max5 < value7 || max5 === void 0 && value7 >= value7)) {
        max5 = value7;
      }
    }
  }
  return max5;
}

// node_modules/d3-array/src/min.js
function min(values7, valueof) {
  let min5;
  if (valueof === void 0) {
    for (const value7 of values7) {
      if (value7 != null && (min5 > value7 || min5 === void 0 && value7 >= value7)) {
        min5 = value7;
      }
    }
  } else {
    let index4 = -1;
    for (let value7 of values7) {
      if ((value7 = valueof(value7, ++index4, values7)) != null && (min5 > value7 || min5 === void 0 && value7 >= value7)) {
        min5 = value7;
      }
    }
  }
  return min5;
}

// node_modules/d3-array/src/quickselect.js
function quickselect(array22, k3, left = 0, right = Infinity, compare10) {
  k3 = Math.floor(k3);
  left = Math.floor(Math.max(0, left));
  right = Math.floor(Math.min(array22.length - 1, right));
  if (!(left <= k3 && k3 <= right))
    return array22;
  compare10 = compare10 === void 0 ? ascendingDefined : compareDefined(compare10);
  while (right > left) {
    if (right - left > 600) {
      const n = right - left + 1;
      const m3 = k3 - left + 1;
      const z = Math.log(n);
      const s2 = 0.5 * Math.exp(2 * z / 3);
      const sd = 0.5 * Math.sqrt(z * s2 * (n - s2) / n) * (m3 - n / 2 < 0 ? -1 : 1);
      const newLeft = Math.max(left, Math.floor(k3 - m3 * s2 / n + sd));
      const newRight = Math.min(right, Math.floor(k3 + (n - m3) * s2 / n + sd));
      quickselect(array22, k3, newLeft, newRight, compare10);
    }
    const t = array22[k3];
    let i = left;
    let j = right;
    swap(array22, left, k3);
    if (compare10(array22[right], t) > 0)
      swap(array22, left, right);
    while (i < j) {
      swap(array22, i, j), ++i, --j;
      while (compare10(array22[i], t) < 0)
        ++i;
      while (compare10(array22[j], t) > 0)
        --j;
    }
    if (compare10(array22[left], t) === 0)
      swap(array22, left, j);
    else
      ++j, swap(array22, j, right);
    if (j <= k3)
      left = j + 1;
    if (k3 <= j)
      right = j - 1;
  }
  return array22;
}
function swap(array22, i, j) {
  const t = array22[i];
  array22[i] = array22[j];
  array22[j] = t;
}

// node_modules/d3-array/src/quantile.js
function quantile(values7, p, valueof) {
  values7 = Float64Array.from(numbers(values7, valueof));
  if (!(n = values7.length) || isNaN(p = +p))
    return;
  if (p <= 0 || n < 2)
    return min(values7);
  if (p >= 1)
    return max(values7);
  var n, i = (n - 1) * p, i0 = Math.floor(i), value0 = max(quickselect(values7, i0).subarray(0, i0 + 1)), value1 = min(values7.subarray(i0 + 1));
  return value0 + (value1 - value0) * (i - i0);
}
function quantileSorted(values7, p, valueof = number) {
  if (!(n = values7.length) || isNaN(p = +p))
    return;
  if (p <= 0 || n < 2)
    return +valueof(values7[0], 0, values7);
  if (p >= 1)
    return +valueof(values7[n - 1], n - 1, values7);
  var n, i = (n - 1) * p, i0 = Math.floor(i), value0 = +valueof(values7[i0], i0, values7), value1 = +valueof(values7[i0 + 1], i0 + 1, values7);
  return value0 + (value1 - value0) * (i - i0);
}

// node_modules/d3-array/src/mean.js
function mean(values7, valueof) {
  let count3 = 0;
  let sum4 = 0;
  if (valueof === void 0) {
    for (let value7 of values7) {
      if (value7 != null && (value7 = +value7) >= value7) {
        ++count3, sum4 += value7;
      }
    }
  } else {
    let index4 = -1;
    for (let value7 of values7) {
      if ((value7 = valueof(value7, ++index4, values7)) != null && (value7 = +value7) >= value7) {
        ++count3, sum4 += value7;
      }
    }
  }
  if (count3)
    return sum4 / count3;
}

// node_modules/d3-array/src/median.js
function median(values7, valueof) {
  return quantile(values7, 0.5, valueof);
}

// node_modules/d3-array/src/merge.js
function* flatten(arrays) {
  for (const array22 of arrays) {
    yield* array22;
  }
}
function merge2(arrays) {
  return Array.from(flatten(arrays));
}

// node_modules/d3-array/src/range.js
function range(start, stop2, step) {
  start = +start, stop2 = +stop2, step = (n = arguments.length) < 2 ? (stop2 = start, start = 0, 1) : n < 3 ? 1 : +step;
  var i = -1, n = Math.max(0, Math.ceil((stop2 - start) / step)) | 0, range7 = new Array(n);
  while (++i < n) {
    range7[i] = start + i * step;
  }
  return range7;
}

// node_modules/d3-array/src/shuffle.js
var shuffle_default = shuffler(Math.random);
function shuffler(random2) {
  return function shuffle2(array22, i0 = 0, i1 = array22.length) {
    let m3 = i1 - (i0 = +i0);
    while (m3) {
      const i = random2() * m3-- | 0, t = array22[m3 + i0];
      array22[m3 + i0] = array22[i + i0];
      array22[i + i0] = t;
    }
    return array22;
  };
}

// node_modules/d3-array/src/sum.js
function sum(values7, valueof) {
  let sum4 = 0;
  if (valueof === void 0) {
    for (let value7 of values7) {
      if (value7 = +value7) {
        sum4 += value7;
      }
    }
  } else {
    let index4 = -1;
    for (let value7 of values7) {
      if (value7 = +valueof(value7, ++index4, values7)) {
        sum4 += value7;
      }
    }
  }
  return sum4;
}

// node_modules/d3-array/src/intersection.js
function intersection(values7, ...others) {
  values7 = new InternSet(values7);
  others = others.map(set);
  out:
    for (const value7 of values7) {
      for (const other of others) {
        if (!other.has(value7)) {
          values7.delete(value7);
          continue out;
        }
      }
    }
  return values7;
}
function set(values7) {
  return values7 instanceof InternSet ? values7 : new InternSet(values7);
}

// node_modules/d3-array/src/union.js
function union(...others) {
  const set7 = new InternSet();
  for (const other of others) {
    for (const o of other) {
      set7.add(o);
    }
  }
  return set7;
}

// node_modules/d3-format/src/formatDecimal.js
function formatDecimal_default(x9) {
  return Math.abs(x9 = Math.round(x9)) >= 1e21 ? x9.toLocaleString("en").replace(/,/g, "") : x9.toString(10);
}
function formatDecimalParts(x9, p) {
  if ((i = (x9 = p ? x9.toExponential(p - 1) : x9.toExponential()).indexOf("e")) < 0)
    return null;
  var i, coefficient = x9.slice(0, i);
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x9.slice(i + 1)
  ];
}

// node_modules/d3-format/src/exponent.js
function exponent_default(x9) {
  return x9 = formatDecimalParts(Math.abs(x9)), x9 ? x9[1] : NaN;
}

// node_modules/d3-format/src/formatGroup.js
function formatGroup_default(grouping, thousands) {
  return function(value7, width2) {
    var i = value7.length, t = [], j = 0, g = grouping[0], length2 = 0;
    while (i > 0 && g > 0) {
      if (length2 + g + 1 > width2)
        g = Math.max(1, width2 - length2);
      t.push(value7.substring(i -= g, i + g));
      if ((length2 += g + 1) > width2)
        break;
      g = grouping[j = (j + 1) % grouping.length];
    }
    return t.reverse().join(thousands);
  };
}

// node_modules/d3-format/src/formatNumerals.js
function formatNumerals_default(numerals) {
  return function(value7) {
    return value7.replace(/[0-9]/g, function(i) {
      return numerals[+i];
    });
  };
}

// node_modules/d3-format/src/formatSpecifier.js
var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function formatSpecifier(specifier) {
  if (!(match2 = re.exec(specifier)))
    throw new Error("invalid format: " + specifier);
  var match2;
  return new FormatSpecifier({
    fill: match2[1],
    align: match2[2],
    sign: match2[3],
    symbol: match2[4],
    zero: match2[5],
    width: match2[6],
    comma: match2[7],
    precision: match2[8] && match2[8].slice(1),
    trim: match2[9],
    type: match2[10]
  });
}
formatSpecifier.prototype = FormatSpecifier.prototype;
function FormatSpecifier(specifier) {
  this.fill = specifier.fill === void 0 ? " " : specifier.fill + "";
  this.align = specifier.align === void 0 ? ">" : specifier.align + "";
  this.sign = specifier.sign === void 0 ? "-" : specifier.sign + "";
  this.symbol = specifier.symbol === void 0 ? "" : specifier.symbol + "";
  this.zero = !!specifier.zero;
  this.width = specifier.width === void 0 ? void 0 : +specifier.width;
  this.comma = !!specifier.comma;
  this.precision = specifier.precision === void 0 ? void 0 : +specifier.precision;
  this.trim = !!specifier.trim;
  this.type = specifier.type === void 0 ? "" : specifier.type + "";
}
FormatSpecifier.prototype.toString = function() {
  return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};

// node_modules/d3-format/src/formatTrim.js
function formatTrim_default(s2) {
  out:
    for (var n = s2.length, i = 1, i0 = -1, i1; i < n; ++i) {
      switch (s2[i]) {
        case ".":
          i0 = i1 = i;
          break;
        case "0":
          if (i0 === 0)
            i0 = i;
          i1 = i;
          break;
        default:
          if (!+s2[i])
            break out;
          if (i0 > 0)
            i0 = 0;
          break;
      }
    }
  return i0 > 0 ? s2.slice(0, i0) + s2.slice(i1 + 1) : s2;
}

// node_modules/d3-format/src/formatPrefixAuto.js
var prefixExponent;
function formatPrefixAuto_default(x9, p) {
  var d = formatDecimalParts(x9, p);
  if (!d)
    return x9 + "";
  var coefficient = d[0], exponent = d[1], i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1, n = coefficient.length;
  return i === n ? coefficient : i > n ? coefficient + new Array(i - n + 1).join("0") : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i) : "0." + new Array(1 - i).join("0") + formatDecimalParts(x9, Math.max(0, p + i - 1))[0];
}

// node_modules/d3-format/src/formatRounded.js
function formatRounded_default(x9, p) {
  var d = formatDecimalParts(x9, p);
  if (!d)
    return x9 + "";
  var coefficient = d[0], exponent = d[1];
  return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1) : coefficient + new Array(exponent - coefficient.length + 2).join("0");
}

// node_modules/d3-format/src/formatTypes.js
var formatTypes_default = {
  "%": (x9, p) => (x9 * 100).toFixed(p),
  "b": (x9) => Math.round(x9).toString(2),
  "c": (x9) => x9 + "",
  "d": formatDecimal_default,
  "e": (x9, p) => x9.toExponential(p),
  "f": (x9, p) => x9.toFixed(p),
  "g": (x9, p) => x9.toPrecision(p),
  "o": (x9) => Math.round(x9).toString(8),
  "p": (x9, p) => formatRounded_default(x9 * 100, p),
  "r": formatRounded_default,
  "s": formatPrefixAuto_default,
  "X": (x9) => Math.round(x9).toString(16).toUpperCase(),
  "x": (x9) => Math.round(x9).toString(16)
};

// node_modules/d3-format/src/identity.js
function identity_default2(x9) {
  return x9;
}

// node_modules/d3-format/src/locale.js
var map3 = Array.prototype.map;
var prefixes = ["y", "z", "a", "f", "p", "n", "µ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
function locale_default(locale5) {
  var group7 = locale5.grouping === void 0 || locale5.thousands === void 0 ? identity_default2 : formatGroup_default(map3.call(locale5.grouping, Number), locale5.thousands + ""), currencyPrefix = locale5.currency === void 0 ? "" : locale5.currency[0] + "", currencySuffix = locale5.currency === void 0 ? "" : locale5.currency[1] + "", decimal = locale5.decimal === void 0 ? "." : locale5.decimal + "", numerals = locale5.numerals === void 0 ? identity_default2 : formatNumerals_default(map3.call(locale5.numerals, String)), percent = locale5.percent === void 0 ? "%" : locale5.percent + "", minus = locale5.minus === void 0 ? "−" : locale5.minus + "", nan = locale5.nan === void 0 ? "NaN" : locale5.nan + "";
  function newFormat(specifier) {
    specifier = formatSpecifier(specifier);
    var fill6 = specifier.fill, align2 = specifier.align, sign4 = specifier.sign, symbol6 = specifier.symbol, zero28 = specifier.zero, width2 = specifier.width, comma = specifier.comma, precision = specifier.precision, trim = specifier.trim, type7 = specifier.type;
    if (type7 === "n")
      comma = true, type7 = "g";
    else if (!formatTypes_default[type7])
      precision === void 0 && (precision = 12), trim = true, type7 = "g";
    if (zero28 || fill6 === "0" && align2 === "=")
      zero28 = true, fill6 = "0", align2 = "=";
    var prefix = symbol6 === "$" ? currencyPrefix : symbol6 === "#" && /[boxX]/.test(type7) ? "0" + type7.toLowerCase() : "", suffix = symbol6 === "$" ? currencySuffix : /[%p]/.test(type7) ? percent : "";
    var formatType = formatTypes_default[type7], maybeSuffix = /[defgprs%]/.test(type7);
    precision = precision === void 0 ? 6 : /[gprs]/.test(type7) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));
    function format14(value7) {
      var valuePrefix = prefix, valueSuffix = suffix, i, n, c5;
      if (type7 === "c") {
        valueSuffix = formatType(value7) + valueSuffix;
        value7 = "";
      } else {
        value7 = +value7;
        var valueNegative = value7 < 0 || 1 / value7 < 0;
        value7 = isNaN(value7) ? nan : formatType(Math.abs(value7), precision);
        if (trim)
          value7 = formatTrim_default(value7);
        if (valueNegative && +value7 === 0 && sign4 !== "+")
          valueNegative = false;
        valuePrefix = (valueNegative ? sign4 === "(" ? sign4 : minus : sign4 === "-" || sign4 === "(" ? "" : sign4) + valuePrefix;
        valueSuffix = (type7 === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign4 === "(" ? ")" : "");
        if (maybeSuffix) {
          i = -1, n = value7.length;
          while (++i < n) {
            if (c5 = value7.charCodeAt(i), 48 > c5 || c5 > 57) {
              valueSuffix = (c5 === 46 ? decimal + value7.slice(i + 1) : value7.slice(i)) + valueSuffix;
              value7 = value7.slice(0, i);
              break;
            }
          }
        }
      }
      if (comma && !zero28)
        value7 = group7(value7, Infinity);
      var length2 = valuePrefix.length + value7.length + valueSuffix.length, padding3 = length2 < width2 ? new Array(width2 - length2 + 1).join(fill6) : "";
      if (comma && zero28)
        value7 = group7(padding3 + value7, padding3.length ? width2 - valueSuffix.length : Infinity), padding3 = "";
      switch (align2) {
        case "<":
          value7 = valuePrefix + value7 + valueSuffix + padding3;
          break;
        case "=":
          value7 = valuePrefix + padding3 + value7 + valueSuffix;
          break;
        case "^":
          value7 = padding3.slice(0, length2 = padding3.length >> 1) + valuePrefix + value7 + valueSuffix + padding3.slice(length2);
          break;
        default:
          value7 = padding3 + valuePrefix + value7 + valueSuffix;
          break;
      }
      return numerals(value7);
    }
    format14.toString = function() {
      return specifier + "";
    };
    return format14;
  }
  function formatPrefix2(specifier, value7) {
    var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)), e3 = Math.max(-8, Math.min(8, Math.floor(exponent_default(value7) / 3))) * 3, k3 = Math.pow(10, -e3), prefix = prefixes[8 + e3 / 3];
    return function(value8) {
      return f(k3 * value8) + prefix;
    };
  }
  return {
    format: newFormat,
    formatPrefix: formatPrefix2
  };
}

// node_modules/d3-format/src/defaultLocale.js
var locale;
var format;
var formatPrefix;
defaultLocale({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});
function defaultLocale(definition3) {
  locale = locale_default(definition3);
  format = locale.format;
  formatPrefix = locale.formatPrefix;
  return locale;
}

// node_modules/d3-format/src/precisionFixed.js
function precisionFixed_default(step) {
  return Math.max(0, -exponent_default(Math.abs(step)));
}

// node_modules/d3-format/src/precisionPrefix.js
function precisionPrefix_default(step, value7) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent_default(value7) / 3))) * 3 - exponent_default(Math.abs(step)));
}

// node_modules/d3-format/src/precisionRound.js
function precisionRound_default(step, max5) {
  step = Math.abs(step), max5 = Math.abs(max5) - step;
  return Math.max(0, exponent_default(max5) - exponent_default(step)) + 1;
}

// node_modules/d3-time/src/interval.js
var t0 = /* @__PURE__ */ new Date();
var t1 = /* @__PURE__ */ new Date();
function timeInterval(floori, offseti, count3, field25) {
  function interval3(date2) {
    return floori(date2 = arguments.length === 0 ? /* @__PURE__ */ new Date() : /* @__PURE__ */ new Date(+date2)), date2;
  }
  interval3.floor = (date2) => {
    return floori(date2 = /* @__PURE__ */ new Date(+date2)), date2;
  };
  interval3.ceil = (date2) => {
    return floori(date2 = new Date(date2 - 1)), offseti(date2, 1), floori(date2), date2;
  };
  interval3.round = (date2) => {
    const d0 = interval3(date2), d1 = interval3.ceil(date2);
    return date2 - d0 < d1 - date2 ? d0 : d1;
  };
  interval3.offset = (date2, step) => {
    return offseti(date2 = /* @__PURE__ */ new Date(+date2), step == null ? 1 : Math.floor(step)), date2;
  };
  interval3.range = (start, stop2, step) => {
    const range7 = [];
    start = interval3.ceil(start);
    step = step == null ? 1 : Math.floor(step);
    if (!(start < stop2) || !(step > 0))
      return range7;
    let previous;
    do
      range7.push(previous = /* @__PURE__ */ new Date(+start)), offseti(start, step), floori(start);
    while (previous < start && start < stop2);
    return range7;
  };
  interval3.filter = (test2) => {
    return timeInterval((date2) => {
      if (date2 >= date2)
        while (floori(date2), !test2(date2))
          date2.setTime(date2 - 1);
    }, (date2, step) => {
      if (date2 >= date2) {
        if (step < 0)
          while (++step <= 0) {
            while (offseti(date2, -1), !test2(date2)) {
            }
          }
        else
          while (--step >= 0) {
            while (offseti(date2, 1), !test2(date2)) {
            }
          }
      }
    });
  };
  if (count3) {
    interval3.count = (start, end) => {
      t0.setTime(+start), t1.setTime(+end);
      floori(t0), floori(t1);
      return Math.floor(count3(t0, t1));
    };
    interval3.every = (step) => {
      step = Math.floor(step);
      return !isFinite(step) || !(step > 0) ? null : !(step > 1) ? interval3 : interval3.filter(field25 ? (d) => field25(d) % step === 0 : (d) => interval3.count(0, d) % step === 0);
    };
  }
  return interval3;
}

// node_modules/d3-time/src/millisecond.js
var millisecond = timeInterval(() => {
}, (date2, step) => {
  date2.setTime(+date2 + step);
}, (start, end) => {
  return end - start;
});
millisecond.every = (k3) => {
  k3 = Math.floor(k3);
  if (!isFinite(k3) || !(k3 > 0))
    return null;
  if (!(k3 > 1))
    return millisecond;
  return timeInterval((date2) => {
    date2.setTime(Math.floor(date2 / k3) * k3);
  }, (date2, step) => {
    date2.setTime(+date2 + step * k3);
  }, (start, end) => {
    return (end - start) / k3;
  });
};
var milliseconds = millisecond.range;

// node_modules/d3-time/src/duration.js
var durationSecond = 1e3;
var durationMinute = durationSecond * 60;
var durationHour = durationMinute * 60;
var durationDay = durationHour * 24;
var durationWeek = durationDay * 7;
var durationMonth = durationDay * 30;
var durationYear = durationDay * 365;

// node_modules/d3-time/src/second.js
var second = timeInterval((date2) => {
  date2.setTime(date2 - date2.getMilliseconds());
}, (date2, step) => {
  date2.setTime(+date2 + step * durationSecond);
}, (start, end) => {
  return (end - start) / durationSecond;
}, (date2) => {
  return date2.getUTCSeconds();
});
var seconds = second.range;

// node_modules/d3-time/src/minute.js
var timeMinute = timeInterval((date2) => {
  date2.setTime(date2 - date2.getMilliseconds() - date2.getSeconds() * durationSecond);
}, (date2, step) => {
  date2.setTime(+date2 + step * durationMinute);
}, (start, end) => {
  return (end - start) / durationMinute;
}, (date2) => {
  return date2.getMinutes();
});
var timeMinutes = timeMinute.range;
var utcMinute = timeInterval((date2) => {
  date2.setUTCSeconds(0, 0);
}, (date2, step) => {
  date2.setTime(+date2 + step * durationMinute);
}, (start, end) => {
  return (end - start) / durationMinute;
}, (date2) => {
  return date2.getUTCMinutes();
});
var utcMinutes = utcMinute.range;

// node_modules/d3-time/src/hour.js
var timeHour = timeInterval((date2) => {
  date2.setTime(date2 - date2.getMilliseconds() - date2.getSeconds() * durationSecond - date2.getMinutes() * durationMinute);
}, (date2, step) => {
  date2.setTime(+date2 + step * durationHour);
}, (start, end) => {
  return (end - start) / durationHour;
}, (date2) => {
  return date2.getHours();
});
var timeHours = timeHour.range;
var utcHour = timeInterval((date2) => {
  date2.setUTCMinutes(0, 0, 0);
}, (date2, step) => {
  date2.setTime(+date2 + step * durationHour);
}, (start, end) => {
  return (end - start) / durationHour;
}, (date2) => {
  return date2.getUTCHours();
});
var utcHours = utcHour.range;

// node_modules/d3-time/src/day.js
var timeDay = timeInterval(
  (date2) => date2.setHours(0, 0, 0, 0),
  (date2, step) => date2.setDate(date2.getDate() + step),
  (start, end) => (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationDay,
  (date2) => date2.getDate() - 1
);
var timeDays = timeDay.range;
var utcDay = timeInterval((date2) => {
  date2.setUTCHours(0, 0, 0, 0);
}, (date2, step) => {
  date2.setUTCDate(date2.getUTCDate() + step);
}, (start, end) => {
  return (end - start) / durationDay;
}, (date2) => {
  return date2.getUTCDate() - 1;
});
var utcDays = utcDay.range;
var unixDay = timeInterval((date2) => {
  date2.setUTCHours(0, 0, 0, 0);
}, (date2, step) => {
  date2.setUTCDate(date2.getUTCDate() + step);
}, (start, end) => {
  return (end - start) / durationDay;
}, (date2) => {
  return Math.floor(date2 / durationDay);
});
var unixDays = unixDay.range;

// node_modules/d3-time/src/week.js
function timeWeekday(i) {
  return timeInterval((date2) => {
    date2.setDate(date2.getDate() - (date2.getDay() + 7 - i) % 7);
    date2.setHours(0, 0, 0, 0);
  }, (date2, step) => {
    date2.setDate(date2.getDate() + step * 7);
  }, (start, end) => {
    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationWeek;
  });
}
var timeSunday = timeWeekday(0);
var timeMonday = timeWeekday(1);
var timeTuesday = timeWeekday(2);
var timeWednesday = timeWeekday(3);
var timeThursday = timeWeekday(4);
var timeFriday = timeWeekday(5);
var timeSaturday = timeWeekday(6);
var timeSundays = timeSunday.range;
var timeMondays = timeMonday.range;
var timeTuesdays = timeTuesday.range;
var timeWednesdays = timeWednesday.range;
var timeThursdays = timeThursday.range;
var timeFridays = timeFriday.range;
var timeSaturdays = timeSaturday.range;
function utcWeekday(i) {
  return timeInterval((date2) => {
    date2.setUTCDate(date2.getUTCDate() - (date2.getUTCDay() + 7 - i) % 7);
    date2.setUTCHours(0, 0, 0, 0);
  }, (date2, step) => {
    date2.setUTCDate(date2.getUTCDate() + step * 7);
  }, (start, end) => {
    return (end - start) / durationWeek;
  });
}
var utcSunday = utcWeekday(0);
var utcMonday = utcWeekday(1);
var utcTuesday = utcWeekday(2);
var utcWednesday = utcWeekday(3);
var utcThursday = utcWeekday(4);
var utcFriday = utcWeekday(5);
var utcSaturday = utcWeekday(6);
var utcSundays = utcSunday.range;
var utcMondays = utcMonday.range;
var utcTuesdays = utcTuesday.range;
var utcWednesdays = utcWednesday.range;
var utcThursdays = utcThursday.range;
var utcFridays = utcFriday.range;
var utcSaturdays = utcSaturday.range;

// node_modules/d3-time/src/month.js
var timeMonth = timeInterval((date2) => {
  date2.setDate(1);
  date2.setHours(0, 0, 0, 0);
}, (date2, step) => {
  date2.setMonth(date2.getMonth() + step);
}, (start, end) => {
  return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
}, (date2) => {
  return date2.getMonth();
});
var timeMonths = timeMonth.range;
var utcMonth = timeInterval((date2) => {
  date2.setUTCDate(1);
  date2.setUTCHours(0, 0, 0, 0);
}, (date2, step) => {
  date2.setUTCMonth(date2.getUTCMonth() + step);
}, (start, end) => {
  return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
}, (date2) => {
  return date2.getUTCMonth();
});
var utcMonths = utcMonth.range;

// node_modules/d3-time/src/year.js
var timeYear = timeInterval((date2) => {
  date2.setMonth(0, 1);
  date2.setHours(0, 0, 0, 0);
}, (date2, step) => {
  date2.setFullYear(date2.getFullYear() + step);
}, (start, end) => {
  return end.getFullYear() - start.getFullYear();
}, (date2) => {
  return date2.getFullYear();
});
timeYear.every = (k3) => {
  return !isFinite(k3 = Math.floor(k3)) || !(k3 > 0) ? null : timeInterval((date2) => {
    date2.setFullYear(Math.floor(date2.getFullYear() / k3) * k3);
    date2.setMonth(0, 1);
    date2.setHours(0, 0, 0, 0);
  }, (date2, step) => {
    date2.setFullYear(date2.getFullYear() + step * k3);
  });
};
var timeYears = timeYear.range;
var utcYear = timeInterval((date2) => {
  date2.setUTCMonth(0, 1);
  date2.setUTCHours(0, 0, 0, 0);
}, (date2, step) => {
  date2.setUTCFullYear(date2.getUTCFullYear() + step);
}, (start, end) => {
  return end.getUTCFullYear() - start.getUTCFullYear();
}, (date2) => {
  return date2.getUTCFullYear();
});
utcYear.every = (k3) => {
  return !isFinite(k3 = Math.floor(k3)) || !(k3 > 0) ? null : timeInterval((date2) => {
    date2.setUTCFullYear(Math.floor(date2.getUTCFullYear() / k3) * k3);
    date2.setUTCMonth(0, 1);
    date2.setUTCHours(0, 0, 0, 0);
  }, (date2, step) => {
    date2.setUTCFullYear(date2.getUTCFullYear() + step * k3);
  });
};
var utcYears = utcYear.range;

// node_modules/d3-time/src/ticks.js
function ticker(year, month, week3, day, hour, minute) {
  const tickIntervals = [
    [second, 1, durationSecond],
    [second, 5, 5 * durationSecond],
    [second, 15, 15 * durationSecond],
    [second, 30, 30 * durationSecond],
    [minute, 1, durationMinute],
    [minute, 5, 5 * durationMinute],
    [minute, 15, 15 * durationMinute],
    [minute, 30, 30 * durationMinute],
    [hour, 1, durationHour],
    [hour, 3, 3 * durationHour],
    [hour, 6, 6 * durationHour],
    [hour, 12, 12 * durationHour],
    [day, 1, durationDay],
    [day, 2, 2 * durationDay],
    [week3, 1, durationWeek],
    [month, 1, durationMonth],
    [month, 3, 3 * durationMonth],
    [year, 1, durationYear]
  ];
  function ticks2(start, stop2, count3) {
    const reverse4 = stop2 < start;
    if (reverse4)
      [start, stop2] = [stop2, start];
    const interval3 = count3 && typeof count3.range === "function" ? count3 : tickInterval(start, stop2, count3);
    const ticks3 = interval3 ? interval3.range(start, +stop2 + 1) : [];
    return reverse4 ? ticks3.reverse() : ticks3;
  }
  function tickInterval(start, stop2, count3) {
    const target2 = Math.abs(stop2 - start) / count3;
    const i = bisector(([, , step2]) => step2).right(tickIntervals, target2);
    if (i === tickIntervals.length)
      return year.every(tickStep(start / durationYear, stop2 / durationYear, count3));
    if (i === 0)
      return millisecond.every(Math.max(tickStep(start, stop2, count3), 1));
    const [t, step] = tickIntervals[target2 / tickIntervals[i - 1][2] < tickIntervals[i][2] / target2 ? i - 1 : i];
    return t.every(step);
  }
  return [ticks2, tickInterval];
}
var [utcTicks, utcTickInterval] = ticker(utcYear, utcMonth, utcSunday, unixDay, utcHour, utcMinute);
var [timeTicks, timeTickInterval] = ticker(timeYear, timeMonth, timeSunday, timeDay, timeHour, timeMinute);

// node_modules/vega-dataflow/node_modules/vega-time/build/vega-time.js
var YEAR = "year";
var QUARTER = "quarter";
var MONTH = "month";
var WEEK = "week";
var DATE = "date";
var DAY = "day";
var DAYOFYEAR = "dayofyear";
var HOURS = "hours";
var MINUTES = "minutes";
var SECONDS = "seconds";
var MILLISECONDS = "milliseconds";
var TIME_UNITS = [YEAR, QUARTER, MONTH, WEEK, DATE, DAY, DAYOFYEAR, HOURS, MINUTES, SECONDS, MILLISECONDS];
var UNITS = TIME_UNITS.reduce((o, u4, i) => (o[u4] = 1 + i, o), {});
var defaultSpecifiers = {
  [YEAR]: "%Y ",
  [QUARTER]: "Q%q ",
  [MONTH]: "%b ",
  [DATE]: "%d ",
  [WEEK]: "W%U ",
  [DAY]: "%a ",
  [DAYOFYEAR]: "%j ",
  [HOURS]: "%H:00",
  [MINUTES]: "00:%M",
  [SECONDS]: ":%S",
  [MILLISECONDS]: ".%L",
  [`${YEAR}-${MONTH}`]: "%Y-%m ",
  [`${YEAR}-${MONTH}-${DATE}`]: "%Y-%m-%d ",
  [`${HOURS}-${MINUTES}`]: "%H:%M"
};
var t02 = /* @__PURE__ */ new Date();
function localYear(y9) {
  t02.setFullYear(y9);
  t02.setMonth(0);
  t02.setDate(1);
  t02.setHours(0, 0, 0, 0);
  return t02;
}
function localDayOfYear(d) {
  return timeDay.count(localYear(d.getFullYear()) - 1, d);
}
function localWeekNum(d) {
  return timeSunday.count(localYear(d.getFullYear()) - 1, d);
}
function localFirst(y9) {
  return localYear(y9).getDay();
}
function utcDayOfYear(d) {
  const y9 = Date.UTC(d.getUTCFullYear(), 0, 1);
  return utcDay.count(y9 - 1, d);
}
function utcWeekNum(d) {
  const y9 = Date.UTC(d.getUTCFullYear(), 0, 1);
  return utcSunday.count(y9 - 1, d);
}
function utcFirst(y9) {
  t02.setTime(Date.UTC(y9, 0, 1));
  return t02.getUTCDay();
}
function weekday(week3, day, firstDay) {
  return day + week3 * 7 - (firstDay + 6) % 7;
}
var localGet = {
  [YEAR]: (d) => d.getFullYear(),
  [QUARTER]: (d) => Math.floor(d.getMonth() / 3),
  [MONTH]: (d) => d.getMonth(),
  [DATE]: (d) => d.getDate(),
  [HOURS]: (d) => d.getHours(),
  [MINUTES]: (d) => d.getMinutes(),
  [SECONDS]: (d) => d.getSeconds(),
  [MILLISECONDS]: (d) => d.getMilliseconds(),
  [DAYOFYEAR]: (d) => localDayOfYear(d),
  [WEEK]: (d) => localWeekNum(d),
  [WEEK + DAY]: (d, y9) => weekday(localWeekNum(d), d.getDay(), localFirst(y9)),
  [DAY]: (d, y9) => weekday(1, d.getDay(), localFirst(y9))
};
var localInv = {
  [QUARTER]: (q) => 3 * q,
  [WEEK]: (w8, y9) => weekday(w8, 0, localFirst(y9))
};
var utcGet = {
  [YEAR]: (d) => d.getUTCFullYear(),
  [QUARTER]: (d) => Math.floor(d.getUTCMonth() / 3),
  [MONTH]: (d) => d.getUTCMonth(),
  [DATE]: (d) => d.getUTCDate(),
  [HOURS]: (d) => d.getUTCHours(),
  [MINUTES]: (d) => d.getUTCMinutes(),
  [SECONDS]: (d) => d.getUTCSeconds(),
  [MILLISECONDS]: (d) => d.getUTCMilliseconds(),
  [DAYOFYEAR]: (d) => utcDayOfYear(d),
  [WEEK]: (d) => utcWeekNum(d),
  [DAY]: (d, y9) => weekday(1, d.getUTCDay(), utcFirst(y9)),
  [WEEK + DAY]: (d, y9) => weekday(utcWeekNum(d), d.getUTCDay(), utcFirst(y9))
};
var utcInv = {
  [QUARTER]: (q) => 3 * q,
  [WEEK]: (w8, y9) => weekday(w8, 0, utcFirst(y9))
};
var timeIntervals = {
  [YEAR]: timeYear,
  [QUARTER]: timeMonth.every(3),
  [MONTH]: timeMonth,
  [WEEK]: timeSunday,
  [DATE]: timeDay,
  [DAY]: timeDay,
  [DAYOFYEAR]: timeDay,
  [HOURS]: timeHour,
  [MINUTES]: timeMinute,
  [SECONDS]: second,
  [MILLISECONDS]: millisecond
};
var utcIntervals = {
  [YEAR]: utcYear,
  [QUARTER]: utcMonth.every(3),
  [MONTH]: utcMonth,
  [WEEK]: utcSunday,
  [DATE]: utcDay,
  [DAY]: utcDay,
  [DAYOFYEAR]: utcDay,
  [HOURS]: utcHour,
  [MINUTES]: utcMinute,
  [SECONDS]: second,
  [MILLISECONDS]: millisecond
};
function timeInterval2(unit2) {
  return timeIntervals[unit2];
}
function utcInterval(unit2) {
  return utcIntervals[unit2];
}
var durationSecond2 = 1e3;
var durationMinute2 = durationSecond2 * 60;
var durationHour2 = durationMinute2 * 60;
var durationDay2 = durationHour2 * 24;
var durationWeek2 = durationDay2 * 7;
var durationMonth2 = durationDay2 * 30;
var durationYear2 = durationDay2 * 365;
var Milli = [YEAR, MONTH, DATE, HOURS, MINUTES, SECONDS, MILLISECONDS];
var Seconds = Milli.slice(0, -1);
var Minutes = Seconds.slice(0, -1);
var Hours = Minutes.slice(0, -1);
var Day = Hours.slice(0, -1);
var Week = [YEAR, WEEK];
var Month = [YEAR, MONTH];
var Year = [YEAR];
var intervals = [[Seconds, 1, durationSecond2], [Seconds, 5, 5 * durationSecond2], [Seconds, 15, 15 * durationSecond2], [Seconds, 30, 30 * durationSecond2], [Minutes, 1, durationMinute2], [Minutes, 5, 5 * durationMinute2], [Minutes, 15, 15 * durationMinute2], [Minutes, 30, 30 * durationMinute2], [Hours, 1, durationHour2], [Hours, 3, 3 * durationHour2], [Hours, 6, 6 * durationHour2], [Hours, 12, 12 * durationHour2], [Day, 1, durationDay2], [Week, 1, durationWeek2], [Month, 1, durationMonth2], [Month, 3, 3 * durationMonth2], [Year, 1, durationYear2]];

// node_modules/d3-time-format/src/locale.js
function localDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date2 = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
    date2.setFullYear(d.y);
    return date2;
  }
  return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
}
function utcDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date2 = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
    date2.setUTCFullYear(d.y);
    return date2;
  }
  return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
}
function newDate(y9, m3, d) {
  return { y: y9, m: m3, d, H: 0, M: 0, S: 0, L: 0 };
}
function formatLocale(locale5) {
  var locale_dateTime = locale5.dateTime, locale_date = locale5.date, locale_time = locale5.time, locale_periods = locale5.periods, locale_weekdays = locale5.days, locale_shortWeekdays = locale5.shortDays, locale_months = locale5.months, locale_shortMonths = locale5.shortMonths;
  var periodRe = formatRe(locale_periods), periodLookup = formatLookup(locale_periods), weekdayRe = formatRe(locale_weekdays), weekdayLookup = formatLookup(locale_weekdays), shortWeekdayRe = formatRe(locale_shortWeekdays), shortWeekdayLookup = formatLookup(locale_shortWeekdays), monthRe = formatRe(locale_months), monthLookup = formatLookup(locale_months), shortMonthRe = formatRe(locale_shortMonths), shortMonthLookup = formatLookup(locale_shortMonths);
  var formats12 = {
    "a": formatShortWeekday,
    "A": formatWeekday,
    "b": formatShortMonth,
    "B": formatMonth,
    "c": null,
    "d": formatDayOfMonth,
    "e": formatDayOfMonth,
    "f": formatMicroseconds,
    "g": formatYearISO,
    "G": formatFullYearISO,
    "H": formatHour24,
    "I": formatHour12,
    "j": formatDayOfYear,
    "L": formatMilliseconds,
    "m": formatMonthNumber,
    "M": formatMinutes,
    "p": formatPeriod,
    "q": formatQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatSeconds,
    "u": formatWeekdayNumberMonday,
    "U": formatWeekNumberSunday,
    "V": formatWeekNumberISO,
    "w": formatWeekdayNumberSunday,
    "W": formatWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatYear2,
    "Y": formatFullYear,
    "Z": formatZone,
    "%": formatLiteralPercent
  };
  var utcFormats = {
    "a": formatUTCShortWeekday,
    "A": formatUTCWeekday,
    "b": formatUTCShortMonth,
    "B": formatUTCMonth,
    "c": null,
    "d": formatUTCDayOfMonth,
    "e": formatUTCDayOfMonth,
    "f": formatUTCMicroseconds,
    "g": formatUTCYearISO,
    "G": formatUTCFullYearISO,
    "H": formatUTCHour24,
    "I": formatUTCHour12,
    "j": formatUTCDayOfYear,
    "L": formatUTCMilliseconds,
    "m": formatUTCMonthNumber,
    "M": formatUTCMinutes,
    "p": formatUTCPeriod,
    "q": formatUTCQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatUTCSeconds,
    "u": formatUTCWeekdayNumberMonday,
    "U": formatUTCWeekNumberSunday,
    "V": formatUTCWeekNumberISO,
    "w": formatUTCWeekdayNumberSunday,
    "W": formatUTCWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatUTCYear,
    "Y": formatUTCFullYear,
    "Z": formatUTCZone,
    "%": formatLiteralPercent
  };
  var parses = {
    "a": parseShortWeekday,
    "A": parseWeekday,
    "b": parseShortMonth,
    "B": parseMonth,
    "c": parseLocaleDateTime,
    "d": parseDayOfMonth,
    "e": parseDayOfMonth,
    "f": parseMicroseconds,
    "g": parseYear,
    "G": parseFullYear,
    "H": parseHour24,
    "I": parseHour24,
    "j": parseDayOfYear,
    "L": parseMilliseconds,
    "m": parseMonthNumber,
    "M": parseMinutes,
    "p": parsePeriod,
    "q": parseQuarter,
    "Q": parseUnixTimestamp,
    "s": parseUnixTimestampSeconds,
    "S": parseSeconds,
    "u": parseWeekdayNumberMonday,
    "U": parseWeekNumberSunday,
    "V": parseWeekNumberISO,
    "w": parseWeekdayNumberSunday,
    "W": parseWeekNumberMonday,
    "x": parseLocaleDate,
    "X": parseLocaleTime,
    "y": parseYear,
    "Y": parseFullYear,
    "Z": parseZone,
    "%": parseLiteralPercent
  };
  formats12.x = newFormat(locale_date, formats12);
  formats12.X = newFormat(locale_time, formats12);
  formats12.c = newFormat(locale_dateTime, formats12);
  utcFormats.x = newFormat(locale_date, utcFormats);
  utcFormats.X = newFormat(locale_time, utcFormats);
  utcFormats.c = newFormat(locale_dateTime, utcFormats);
  function newFormat(specifier, formats13) {
    return function(date2) {
      var string = [], i = -1, j = 0, n = specifier.length, c5, pad5, format14;
      if (!(date2 instanceof Date))
        date2 = /* @__PURE__ */ new Date(+date2);
      while (++i < n) {
        if (specifier.charCodeAt(i) === 37) {
          string.push(specifier.slice(j, i));
          if ((pad5 = pads[c5 = specifier.charAt(++i)]) != null)
            c5 = specifier.charAt(++i);
          else
            pad5 = c5 === "e" ? " " : "0";
          if (format14 = formats13[c5])
            c5 = format14(date2, pad5);
          string.push(c5);
          j = i + 1;
        }
      }
      string.push(specifier.slice(j, i));
      return string.join("");
    };
  }
  function newParse(specifier, Z) {
    return function(string) {
      var d = newDate(1900, void 0, 1), i = parseSpecifier(d, specifier, string += "", 0), week3, day;
      if (i != string.length)
        return null;
      if ("Q" in d)
        return new Date(d.Q);
      if ("s" in d)
        return new Date(d.s * 1e3 + ("L" in d ? d.L : 0));
      if (Z && !("Z" in d))
        d.Z = 0;
      if ("p" in d)
        d.H = d.H % 12 + d.p * 12;
      if (d.m === void 0)
        d.m = "q" in d ? d.q : 0;
      if ("V" in d) {
        if (d.V < 1 || d.V > 53)
          return null;
        if (!("w" in d))
          d.w = 1;
        if ("Z" in d) {
          week3 = utcDate(newDate(d.y, 0, 1)), day = week3.getUTCDay();
          week3 = day > 4 || day === 0 ? utcMonday.ceil(week3) : utcMonday(week3);
          week3 = utcDay.offset(week3, (d.V - 1) * 7);
          d.y = week3.getUTCFullYear();
          d.m = week3.getUTCMonth();
          d.d = week3.getUTCDate() + (d.w + 6) % 7;
        } else {
          week3 = localDate(newDate(d.y, 0, 1)), day = week3.getDay();
          week3 = day > 4 || day === 0 ? timeMonday.ceil(week3) : timeMonday(week3);
          week3 = timeDay.offset(week3, (d.V - 1) * 7);
          d.y = week3.getFullYear();
          d.m = week3.getMonth();
          d.d = week3.getDate() + (d.w + 6) % 7;
        }
      } else if ("W" in d || "U" in d) {
        if (!("w" in d))
          d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
        day = "Z" in d ? utcDate(newDate(d.y, 0, 1)).getUTCDay() : localDate(newDate(d.y, 0, 1)).getDay();
        d.m = 0;
        d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day + 5) % 7 : d.w + d.U * 7 - (day + 6) % 7;
      }
      if ("Z" in d) {
        d.H += d.Z / 100 | 0;
        d.M += d.Z % 100;
        return utcDate(d);
      }
      return localDate(d);
    };
  }
  function parseSpecifier(d, specifier, string, j) {
    var i = 0, n = specifier.length, m3 = string.length, c5, parse12;
    while (i < n) {
      if (j >= m3)
        return -1;
      c5 = specifier.charCodeAt(i++);
      if (c5 === 37) {
        c5 = specifier.charAt(i++);
        parse12 = parses[c5 in pads ? specifier.charAt(i++) : c5];
        if (!parse12 || (j = parse12(d, string, j)) < 0)
          return -1;
      } else if (c5 != string.charCodeAt(j++)) {
        return -1;
      }
    }
    return j;
  }
  function parsePeriod(d, string, i) {
    var n = periodRe.exec(string.slice(i));
    return n ? (d.p = periodLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseShortWeekday(d, string, i) {
    var n = shortWeekdayRe.exec(string.slice(i));
    return n ? (d.w = shortWeekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseWeekday(d, string, i) {
    var n = weekdayRe.exec(string.slice(i));
    return n ? (d.w = weekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseShortMonth(d, string, i) {
    var n = shortMonthRe.exec(string.slice(i));
    return n ? (d.m = shortMonthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseMonth(d, string, i) {
    var n = monthRe.exec(string.slice(i));
    return n ? (d.m = monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseLocaleDateTime(d, string, i) {
    return parseSpecifier(d, locale_dateTime, string, i);
  }
  function parseLocaleDate(d, string, i) {
    return parseSpecifier(d, locale_date, string, i);
  }
  function parseLocaleTime(d, string, i) {
    return parseSpecifier(d, locale_time, string, i);
  }
  function formatShortWeekday(d) {
    return locale_shortWeekdays[d.getDay()];
  }
  function formatWeekday(d) {
    return locale_weekdays[d.getDay()];
  }
  function formatShortMonth(d) {
    return locale_shortMonths[d.getMonth()];
  }
  function formatMonth(d) {
    return locale_months[d.getMonth()];
  }
  function formatPeriod(d) {
    return locale_periods[+(d.getHours() >= 12)];
  }
  function formatQuarter(d) {
    return 1 + ~~(d.getMonth() / 3);
  }
  function formatUTCShortWeekday(d) {
    return locale_shortWeekdays[d.getUTCDay()];
  }
  function formatUTCWeekday(d) {
    return locale_weekdays[d.getUTCDay()];
  }
  function formatUTCShortMonth(d) {
    return locale_shortMonths[d.getUTCMonth()];
  }
  function formatUTCMonth(d) {
    return locale_months[d.getUTCMonth()];
  }
  function formatUTCPeriod(d) {
    return locale_periods[+(d.getUTCHours() >= 12)];
  }
  function formatUTCQuarter(d) {
    return 1 + ~~(d.getUTCMonth() / 3);
  }
  return {
    format: function(specifier) {
      var f = newFormat(specifier += "", formats12);
      f.toString = function() {
        return specifier;
      };
      return f;
    },
    parse: function(specifier) {
      var p = newParse(specifier += "", false);
      p.toString = function() {
        return specifier;
      };
      return p;
    },
    utcFormat: function(specifier) {
      var f = newFormat(specifier += "", utcFormats);
      f.toString = function() {
        return specifier;
      };
      return f;
    },
    utcParse: function(specifier) {
      var p = newParse(specifier += "", true);
      p.toString = function() {
        return specifier;
      };
      return p;
    }
  };
}
var pads = { "-": "", "_": " ", "0": "0" };
var numberRe = /^\s*\d+/;
var percentRe = /^%/;
var requoteRe = /[\\^$*+?|[\]().{}]/g;
function pad3(value7, fill6, width2) {
  var sign4 = value7 < 0 ? "-" : "", string = (sign4 ? -value7 : value7) + "", length2 = string.length;
  return sign4 + (length2 < width2 ? new Array(width2 - length2 + 1).join(fill6) + string : string);
}
function requote(s2) {
  return s2.replace(requoteRe, "\\$&");
}
function formatRe(names) {
  return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
}
function formatLookup(names) {
  return new Map(names.map((name, i) => [name.toLowerCase(), i]));
}
function parseWeekdayNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.w = +n[0], i + n[0].length) : -1;
}
function parseWeekdayNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.u = +n[0], i + n[0].length) : -1;
}
function parseWeekNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.U = +n[0], i + n[0].length) : -1;
}
function parseWeekNumberISO(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.V = +n[0], i + n[0].length) : -1;
}
function parseWeekNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.W = +n[0], i + n[0].length) : -1;
}
function parseFullYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 4));
  return n ? (d.y = +n[0], i + n[0].length) : -1;
}
function parseYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2e3), i + n[0].length) : -1;
}
function parseZone(d, string, i) {
  var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
  return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
}
function parseQuarter(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.q = n[0] * 3 - 3, i + n[0].length) : -1;
}
function parseMonthNumber(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
}
function parseDayOfMonth(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.d = +n[0], i + n[0].length) : -1;
}
function parseDayOfYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
}
function parseHour24(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.H = +n[0], i + n[0].length) : -1;
}
function parseMinutes(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.M = +n[0], i + n[0].length) : -1;
}
function parseSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.S = +n[0], i + n[0].length) : -1;
}
function parseMilliseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.L = +n[0], i + n[0].length) : -1;
}
function parseMicroseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 6));
  return n ? (d.L = Math.floor(n[0] / 1e3), i + n[0].length) : -1;
}
function parseLiteralPercent(d, string, i) {
  var n = percentRe.exec(string.slice(i, i + 1));
  return n ? i + n[0].length : -1;
}
function parseUnixTimestamp(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.Q = +n[0], i + n[0].length) : -1;
}
function parseUnixTimestampSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.s = +n[0], i + n[0].length) : -1;
}
function formatDayOfMonth(d, p) {
  return pad3(d.getDate(), p, 2);
}
function formatHour24(d, p) {
  return pad3(d.getHours(), p, 2);
}
function formatHour12(d, p) {
  return pad3(d.getHours() % 12 || 12, p, 2);
}
function formatDayOfYear(d, p) {
  return pad3(1 + timeDay.count(timeYear(d), d), p, 3);
}
function formatMilliseconds(d, p) {
  return pad3(d.getMilliseconds(), p, 3);
}
function formatMicroseconds(d, p) {
  return formatMilliseconds(d, p) + "000";
}
function formatMonthNumber(d, p) {
  return pad3(d.getMonth() + 1, p, 2);
}
function formatMinutes(d, p) {
  return pad3(d.getMinutes(), p, 2);
}
function formatSeconds(d, p) {
  return pad3(d.getSeconds(), p, 2);
}
function formatWeekdayNumberMonday(d) {
  var day = d.getDay();
  return day === 0 ? 7 : day;
}
function formatWeekNumberSunday(d, p) {
  return pad3(timeSunday.count(timeYear(d) - 1, d), p, 2);
}
function dISO(d) {
  var day = d.getDay();
  return day >= 4 || day === 0 ? timeThursday(d) : timeThursday.ceil(d);
}
function formatWeekNumberISO(d, p) {
  d = dISO(d);
  return pad3(timeThursday.count(timeYear(d), d) + (timeYear(d).getDay() === 4), p, 2);
}
function formatWeekdayNumberSunday(d) {
  return d.getDay();
}
function formatWeekNumberMonday(d, p) {
  return pad3(timeMonday.count(timeYear(d) - 1, d), p, 2);
}
function formatYear2(d, p) {
  return pad3(d.getFullYear() % 100, p, 2);
}
function formatYearISO(d, p) {
  d = dISO(d);
  return pad3(d.getFullYear() % 100, p, 2);
}
function formatFullYear(d, p) {
  return pad3(d.getFullYear() % 1e4, p, 4);
}
function formatFullYearISO(d, p) {
  var day = d.getDay();
  d = day >= 4 || day === 0 ? timeThursday(d) : timeThursday.ceil(d);
  return pad3(d.getFullYear() % 1e4, p, 4);
}
function formatZone(d) {
  var z = d.getTimezoneOffset();
  return (z > 0 ? "-" : (z *= -1, "+")) + pad3(z / 60 | 0, "0", 2) + pad3(z % 60, "0", 2);
}
function formatUTCDayOfMonth(d, p) {
  return pad3(d.getUTCDate(), p, 2);
}
function formatUTCHour24(d, p) {
  return pad3(d.getUTCHours(), p, 2);
}
function formatUTCHour12(d, p) {
  return pad3(d.getUTCHours() % 12 || 12, p, 2);
}
function formatUTCDayOfYear(d, p) {
  return pad3(1 + utcDay.count(utcYear(d), d), p, 3);
}
function formatUTCMilliseconds(d, p) {
  return pad3(d.getUTCMilliseconds(), p, 3);
}
function formatUTCMicroseconds(d, p) {
  return formatUTCMilliseconds(d, p) + "000";
}
function formatUTCMonthNumber(d, p) {
  return pad3(d.getUTCMonth() + 1, p, 2);
}
function formatUTCMinutes(d, p) {
  return pad3(d.getUTCMinutes(), p, 2);
}
function formatUTCSeconds(d, p) {
  return pad3(d.getUTCSeconds(), p, 2);
}
function formatUTCWeekdayNumberMonday(d) {
  var dow = d.getUTCDay();
  return dow === 0 ? 7 : dow;
}
function formatUTCWeekNumberSunday(d, p) {
  return pad3(utcSunday.count(utcYear(d) - 1, d), p, 2);
}
function UTCdISO(d) {
  var day = d.getUTCDay();
  return day >= 4 || day === 0 ? utcThursday(d) : utcThursday.ceil(d);
}
function formatUTCWeekNumberISO(d, p) {
  d = UTCdISO(d);
  return pad3(utcThursday.count(utcYear(d), d) + (utcYear(d).getUTCDay() === 4), p, 2);
}
function formatUTCWeekdayNumberSunday(d) {
  return d.getUTCDay();
}
function formatUTCWeekNumberMonday(d, p) {
  return pad3(utcMonday.count(utcYear(d) - 1, d), p, 2);
}
function formatUTCYear(d, p) {
  return pad3(d.getUTCFullYear() % 100, p, 2);
}
function formatUTCYearISO(d, p) {
  d = UTCdISO(d);
  return pad3(d.getUTCFullYear() % 100, p, 2);
}
function formatUTCFullYear(d, p) {
  return pad3(d.getUTCFullYear() % 1e4, p, 4);
}
function formatUTCFullYearISO(d, p) {
  var day = d.getUTCDay();
  d = day >= 4 || day === 0 ? utcThursday(d) : utcThursday.ceil(d);
  return pad3(d.getUTCFullYear() % 1e4, p, 4);
}
function formatUTCZone() {
  return "+0000";
}
function formatLiteralPercent() {
  return "%";
}
function formatUnixTimestamp(d) {
  return +d;
}
function formatUnixTimestampSeconds(d) {
  return Math.floor(+d / 1e3);
}

// node_modules/d3-time-format/src/defaultLocale.js
var locale2;
var timeFormat;
var timeParse;
var utcFormat;
var utcParse;
defaultLocale2({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});
function defaultLocale2(definition3) {
  locale2 = formatLocale(definition3);
  timeFormat = locale2.format;
  timeParse = locale2.parse;
  utcFormat = locale2.utcFormat;
  utcParse = locale2.utcParse;
  return locale2;
}

// node_modules/d3-time-format/src/isoFormat.js
var isoSpecifier = "%Y-%m-%dT%H:%M:%S.%LZ";
function formatIsoNative(date2) {
  return date2.toISOString();
}
var formatIso = Date.prototype.toISOString ? formatIsoNative : utcFormat(isoSpecifier);

// node_modules/d3-time-format/src/isoParse.js
function parseIsoNative(string) {
  var date2 = new Date(string);
  return isNaN(date2) ? null : date2;
}
var parseIso = +/* @__PURE__ */ new Date("2000-01-01T00:00:00.000Z") ? parseIsoNative : utcParse(isoSpecifier);

// node_modules/vega-dataflow/node_modules/vega-format/build/vega-format.js
function memoize(method10) {
  const cache2 = {};
  return (spec) => cache2[spec] || (cache2[spec] = method10(spec));
}
function trimZeroes(numberFormat2, decimalChar) {
  return (x9) => {
    const str = numberFormat2(x9), dec = str.indexOf(decimalChar);
    if (dec < 0)
      return str;
    let idx = rightmostDigit(str, dec);
    const end = idx < str.length ? str.slice(idx) : "";
    while (--idx > dec)
      if (str[idx] !== "0") {
        ++idx;
        break;
      }
    return str.slice(0, idx) + end;
  };
}
function rightmostDigit(str, dec) {
  let i = str.lastIndexOf("e"), c5;
  if (i > 0)
    return i;
  for (i = str.length; --i > dec; ) {
    c5 = str.charCodeAt(i);
    if (c5 >= 48 && c5 <= 57)
      return i + 1;
  }
}
function numberLocale(locale5) {
  const format14 = memoize(locale5.format), formatPrefix2 = locale5.formatPrefix;
  return {
    format: format14,
    formatPrefix: formatPrefix2,
    formatFloat(spec) {
      const s2 = formatSpecifier(spec || ",");
      if (s2.precision == null) {
        s2.precision = 12;
        switch (s2.type) {
          case "%":
            s2.precision -= 2;
            break;
          case "e":
            s2.precision -= 1;
            break;
        }
        return trimZeroes(
          format14(s2),
          // number format
          format14(".1f")(1)[1]
          // decimal point character
        );
      } else {
        return format14(s2);
      }
    },
    formatSpan(start, stop2, count3, specifier) {
      specifier = formatSpecifier(specifier == null ? ",f" : specifier);
      const step = tickStep(start, stop2, count3), value7 = Math.max(Math.abs(start), Math.abs(stop2));
      let precision;
      if (specifier.precision == null) {
        switch (specifier.type) {
          case "s": {
            if (!isNaN(precision = precisionPrefix_default(step, value7))) {
              specifier.precision = precision;
            }
            return formatPrefix2(specifier, value7);
          }
          case "":
          case "e":
          case "g":
          case "p":
          case "r": {
            if (!isNaN(precision = precisionRound_default(step, value7))) {
              specifier.precision = precision - (specifier.type === "e");
            }
            break;
          }
          case "f":
          case "%": {
            if (!isNaN(precision = precisionFixed_default(step))) {
              specifier.precision = precision - (specifier.type === "%") * 2;
            }
            break;
          }
        }
      }
      return format14(specifier);
    }
  };
}
var defaultNumberLocale;
resetNumberFormatDefaultLocale();
function resetNumberFormatDefaultLocale() {
  return defaultNumberLocale = numberLocale({
    format,
    formatPrefix
  });
}
function numberFormatLocale(definition3) {
  return numberLocale(locale_default(definition3));
}
function numberFormatDefaultLocale(definition3) {
  return arguments.length ? defaultNumberLocale = numberFormatLocale(definition3) : defaultNumberLocale;
}
function timeMultiFormat(format14, interval3, spec) {
  spec = spec || {};
  if (!isObject2(spec)) {
    error2(`Invalid time multi-format specifier: ${spec}`);
  }
  const second2 = interval3(SECONDS), minute = interval3(MINUTES), hour = interval3(HOURS), day = interval3(DATE), week3 = interval3(WEEK), month = interval3(MONTH), quarter3 = interval3(QUARTER), year = interval3(YEAR), L = format14(spec[MILLISECONDS] || ".%L"), S = format14(spec[SECONDS] || ":%S"), M2 = format14(spec[MINUTES] || "%I:%M"), H = format14(spec[HOURS] || "%I %p"), d = format14(spec[DATE] || spec[DAY] || "%a %d"), w8 = format14(spec[WEEK] || "%b %d"), m3 = format14(spec[MONTH] || "%B"), q = format14(spec[QUARTER] || "%B"), y9 = format14(spec[YEAR] || "%Y");
  return (date2) => (second2(date2) < date2 ? L : minute(date2) < date2 ? S : hour(date2) < date2 ? M2 : day(date2) < date2 ? H : month(date2) < date2 ? week3(date2) < date2 ? d : w8 : year(date2) < date2 ? quarter3(date2) < date2 ? m3 : q : y9)(date2);
}
function timeLocale(locale5) {
  const timeFormat4 = memoize(locale5.format), utcFormat3 = memoize(locale5.utcFormat);
  return {
    timeFormat: (spec) => isString2(spec) ? timeFormat4(spec) : timeMultiFormat(timeFormat4, timeInterval2, spec),
    utcFormat: (spec) => isString2(spec) ? utcFormat3(spec) : timeMultiFormat(utcFormat3, utcInterval, spec),
    timeParse: memoize(locale5.parse),
    utcParse: memoize(locale5.utcParse)
  };
}
var defaultTimeLocale;
resetTimeFormatDefaultLocale();
function resetTimeFormatDefaultLocale() {
  return defaultTimeLocale = timeLocale({
    format: timeFormat,
    parse: timeParse,
    utcFormat,
    utcParse
  });
}
function timeFormatLocale(definition3) {
  return timeLocale(formatLocale(definition3));
}
function timeFormatDefaultLocale(definition3) {
  return arguments.length ? defaultTimeLocale = timeFormatLocale(definition3) : defaultTimeLocale;
}
var createLocale = (number12, time3) => extend2({}, number12, time3);
function defaultLocale3(numberSpec, timeSpec) {
  const args = arguments.length;
  if (args && args !== 2) {
    error2("defaultLocale expects either zero or two arguments.");
  }
  return args ? createLocale(numberFormatDefaultLocale(numberSpec), timeFormatDefaultLocale(timeSpec)) : createLocale(numberFormatDefaultLocale(), timeFormatDefaultLocale());
}

// node_modules/vega-dataflow/node_modules/vega-loader/build/vega-loader.browser.js
var protocol_re = /^(data:|([A-Za-z]+:)?\/\/)/;
var allowed_re = /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp|file|data):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i;
var whitespace_re = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205f\u3000]/g;
var fileProtocol = "file://";
function loaderFactory(fs) {
  return (options) => ({
    options: options || {},
    sanitize,
    load,
    fileAccess: false,
    file: fileLoader(),
    http: httpLoader
  });
}
async function load(uri, options) {
  const opt = await this.sanitize(uri, options), url = opt.href;
  return opt.localFile ? this.file(url) : this.http(url, options == null ? void 0 : options.http);
}
async function sanitize(uri, options) {
  options = extend2({}, this.options, options);
  const fileAccess = this.fileAccess, result = {
    href: null
  };
  let isFile, loadFile, base;
  const isAllowed = allowed_re.test(uri.replace(whitespace_re, ""));
  if (uri == null || typeof uri !== "string" || !isAllowed) {
    error2("Sanitize failure, invalid URI: " + $2(uri));
  }
  const hasProtocol = protocol_re.test(uri);
  if ((base = options.baseURL) && !hasProtocol) {
    if (!uri.startsWith("/") && !base.endsWith("/")) {
      uri = "/" + uri;
    }
    uri = base + uri;
  }
  loadFile = (isFile = uri.startsWith(fileProtocol)) || options.mode === "file" || options.mode !== "http" && !hasProtocol && fileAccess;
  if (isFile) {
    uri = uri.slice(fileProtocol.length);
  } else if (uri.startsWith("//")) {
    if (options.defaultProtocol === "file") {
      uri = uri.slice(2);
      loadFile = true;
    } else {
      uri = (options.defaultProtocol || "http") + ":" + uri;
    }
  }
  Object.defineProperty(result, "localFile", {
    value: !!loadFile
  });
  result.href = uri;
  if (options.target) {
    result.target = options.target + "";
  }
  if (options.rel) {
    result.rel = options.rel + "";
  }
  if (options.context === "image" && options.crossOrigin) {
    result.crossOrigin = options.crossOrigin + "";
  }
  return result;
}
function fileLoader(fs) {
  return fileReject;
}
async function fileReject() {
  error2("No file system access.");
}
async function httpLoader(url, options) {
  const opt = extend2({}, this.options.http, options), type7 = options && options.response, response = await fetch(url, opt);
  return !response.ok ? error2(response.status + "" + response.statusText) : isFunction2(response[type7]) ? response[type7]() : response.text();
}
var isValid = (_) => _ != null && _ === _;
var isBoolean2 = (_) => _ === "true" || _ === "false" || _ === true || _ === false;
var isDate3 = (_) => !Number.isNaN(Date.parse(_));
var isNumber3 = (_) => !Number.isNaN(+_) && !(_ instanceof Date);
var isInteger = (_) => isNumber3(_) && Number.isInteger(+_);
var typeParsers = {
  boolean: toBoolean2,
  integer: toNumber2,
  number: toNumber2,
  date: toDate2,
  string: toString2,
  unknown: identity2
};
var typeTests = [isBoolean2, isInteger, isNumber3, isDate3];
var typeList = ["boolean", "integer", "number", "date"];
function inferType(values7, field25) {
  if (!values7 || !values7.length)
    return "unknown";
  const n = values7.length, m3 = typeTests.length, a4 = typeTests.map((_, i) => i + 1);
  for (let i = 0, t = 0, j, value7; i < n; ++i) {
    value7 = field25 ? values7[i][field25] : values7[i];
    for (j = 0; j < m3; ++j) {
      if (a4[j] && isValid(value7) && !typeTests[j](value7)) {
        a4[j] = 0;
        ++t;
        if (t === typeTests.length)
          return "string";
      }
    }
  }
  return typeList[a4.reduce((u4, v2) => u4 === 0 ? v2 : u4, 0) - 1];
}
function inferTypes(data3, fields) {
  return fields.reduce((types, field25) => {
    types[field25] = inferType(data3, field25);
    return types;
  }, {});
}
function delimitedFormat(delimiter) {
  const parse12 = function(data3, format14) {
    const delim = {
      delimiter
    };
    return dsv(data3, format14 ? extend2(format14, delim) : delim);
  };
  parse12.responseType = "text";
  return parse12;
}
function dsv(data3, format14) {
  if (format14.header) {
    data3 = format14.header.map($2).join(format14.delimiter) + "\n" + data3;
  }
  return dsv_default(format14.delimiter).parse(data3 + "");
}
dsv.responseType = "text";
function isBuffer(_) {
  return typeof Buffer === "function" && isFunction2(Buffer.isBuffer) ? Buffer.isBuffer(_) : false;
}
function json(data3, format14) {
  const prop = format14 && format14.property ? field2(format14.property) : identity2;
  return isObject2(data3) && !isBuffer(data3) ? parseJSON(prop(data3), format14) : prop(JSON.parse(data3));
}
json.responseType = "json";
function parseJSON(data3, format14) {
  if (!isArray2(data3) && isIterable2(data3)) {
    data3 = [...data3];
  }
  return format14 && format14.copy ? JSON.parse(JSON.stringify(data3)) : data3;
}
var filters = {
  interior: (a4, b6) => a4 !== b6,
  exterior: (a4, b6) => a4 === b6
};
function topojson(data3, format14) {
  let method10, object2, property2, filter4;
  data3 = json(data3, format14);
  if (format14 && format14.feature) {
    method10 = feature_default;
    property2 = format14.feature;
  } else if (format14 && format14.mesh) {
    method10 = mesh_default;
    property2 = format14.mesh;
    filter4 = filters[format14.filter];
  } else {
    error2("Missing TopoJSON feature or mesh parameter.");
  }
  object2 = (object2 = data3.objects[property2]) ? method10(data3, object2, filter4) : error2("Invalid TopoJSON object: " + property2);
  return object2 && object2.features || [object2];
}
topojson.responseType = "json";
var format2 = {
  dsv,
  csv: delimitedFormat(","),
  tsv: delimitedFormat("	"),
  json,
  topojson
};
function formats(name, reader) {
  if (arguments.length > 1) {
    format2[name] = reader;
    return this;
  } else {
    return has2(format2, name) ? format2[name] : null;
  }
}
function responseType(type7) {
  const f = formats(type7);
  return f && f.responseType || "text";
}
function read(data3, schema, timeParser, utcParser) {
  schema = schema || {};
  const reader = formats(schema.type || "json");
  if (!reader)
    error2("Unknown data format type: " + schema.type);
  data3 = reader(data3, schema);
  if (schema.parse)
    parse(data3, schema.parse, timeParser, utcParser);
  if (has2(data3, "columns"))
    delete data3.columns;
  return data3;
}
function parse(data3, types, timeParser, utcParser) {
  if (!data3.length)
    return;
  const locale5 = timeFormatDefaultLocale();
  timeParser = timeParser || locale5.timeParse;
  utcParser = utcParser || locale5.utcParse;
  let fields = data3.columns || Object.keys(data3[0]), datum2, field25, i, j, n, m3;
  if (types === "auto")
    types = inferTypes(data3, fields);
  fields = Object.keys(types);
  const parsers = fields.map((field26) => {
    const type7 = types[field26];
    let parts, pattern;
    if (type7 && (type7.startsWith("date:") || type7.startsWith("utc:"))) {
      parts = type7.split(/:(.+)?/, 2);
      pattern = parts[1];
      if (pattern[0] === "'" && pattern[pattern.length - 1] === "'" || pattern[0] === '"' && pattern[pattern.length - 1] === '"') {
        pattern = pattern.slice(1, -1);
      }
      const parse12 = parts[0] === "utc" ? utcParser : timeParser;
      return parse12(pattern);
    }
    if (!typeParsers[type7]) {
      throw Error("Illegal format pattern: " + field26 + ":" + type7);
    }
    return typeParsers[type7];
  });
  for (i = 0, n = data3.length, m3 = fields.length; i < n; ++i) {
    datum2 = data3[i];
    for (j = 0; j < m3; ++j) {
      field25 = fields[j];
      datum2[field25] = parsers[j](datum2[field25]);
    }
  }
}
var loader = loaderFactory();

// node_modules/vega-dataflow/build/vega-dataflow.js
function UniqueList(idFunc) {
  const $11 = idFunc || identity2, list = [], ids = {};
  list.add = (_) => {
    const id24 = $11(_);
    if (!ids[id24]) {
      ids[id24] = 1;
      list.push(_);
    }
    return list;
  };
  list.remove = (_) => {
    const id24 = $11(_);
    if (ids[id24]) {
      ids[id24] = 0;
      const idx = list.indexOf(_);
      if (idx >= 0)
        list.splice(idx, 1);
    }
    return list;
  };
  return list;
}
async function asyncCallback(df, callback) {
  try {
    await callback(df);
  } catch (err) {
    df.error(err);
  }
}
var TUPLE_ID_KEY = Symbol("vega_id");
var TUPLE_ID = 1;
function isTuple(t) {
  return !!(t && tupleid(t));
}
function tupleid(t) {
  return t[TUPLE_ID_KEY];
}
function setid(t, id24) {
  t[TUPLE_ID_KEY] = id24;
  return t;
}
function ingest$1(datum2) {
  const t = datum2 === Object(datum2) ? datum2 : {
    data: datum2
  };
  return tupleid(t) ? t : setid(t, TUPLE_ID++);
}
function derive(t) {
  return rederive(t, ingest$1({}));
}
function rederive(t, d) {
  for (const k3 in t)
    d[k3] = t[k3];
  return d;
}
function replace(t, d) {
  return setid(d, tupleid(t));
}
function stableCompare(cmp, f) {
  return !cmp ? null : f ? (a4, b6) => cmp(a4, b6) || tupleid(f(a4)) - tupleid(f(b6)) : (a4, b6) => cmp(a4, b6) || tupleid(a4) - tupleid(b6);
}
function isChangeSet(v2) {
  return v2 && v2.constructor === changeset;
}
function changeset() {
  const add10 = [], rem2 = [], mod = [], remp = [], modp = [];
  let clean = null, reflow2 = false;
  return {
    constructor: changeset,
    insert(t) {
      const d = array2(t), n = d.length;
      for (let i = 0; i < n; ++i)
        add10.push(d[i]);
      return this;
    },
    remove(t) {
      const a4 = isFunction2(t) ? remp : rem2, d = array2(t), n = d.length;
      for (let i = 0; i < n; ++i)
        a4.push(d[i]);
      return this;
    },
    modify(t, field25, value7) {
      const m3 = {
        field: field25,
        value: constant2(value7)
      };
      if (isFunction2(t)) {
        m3.filter = t;
        modp.push(m3);
      } else {
        m3.tuple = t;
        mod.push(m3);
      }
      return this;
    },
    encode(t, set7) {
      if (isFunction2(t))
        modp.push({
          filter: t,
          field: set7
        });
      else
        mod.push({
          tuple: t,
          field: set7
        });
      return this;
    },
    clean(value7) {
      clean = value7;
      return this;
    },
    reflow() {
      reflow2 = true;
      return this;
    },
    pulse(pulse2, tuples) {
      const cur = {}, out = {};
      let i, n, m3, f, t, id24;
      for (i = 0, n = tuples.length; i < n; ++i) {
        cur[tupleid(tuples[i])] = 1;
      }
      for (i = 0, n = rem2.length; i < n; ++i) {
        t = rem2[i];
        cur[tupleid(t)] = -1;
      }
      for (i = 0, n = remp.length; i < n; ++i) {
        f = remp[i];
        tuples.forEach((t4) => {
          if (f(t4))
            cur[tupleid(t4)] = -1;
        });
      }
      for (i = 0, n = add10.length; i < n; ++i) {
        t = add10[i];
        id24 = tupleid(t);
        if (cur[id24]) {
          cur[id24] = 1;
        } else {
          pulse2.add.push(ingest$1(add10[i]));
        }
      }
      for (i = 0, n = tuples.length; i < n; ++i) {
        t = tuples[i];
        if (cur[tupleid(t)] < 0)
          pulse2.rem.push(t);
      }
      function modify2(t4, f2, v2) {
        if (v2) {
          t4[f2] = v2(t4);
        } else {
          pulse2.encode = f2;
        }
        if (!reflow2)
          out[tupleid(t4)] = t4;
      }
      for (i = 0, n = mod.length; i < n; ++i) {
        m3 = mod[i];
        t = m3.tuple;
        f = m3.field;
        id24 = cur[tupleid(t)];
        if (id24 > 0) {
          modify2(t, f, m3.value);
          pulse2.modifies(f);
        }
      }
      for (i = 0, n = modp.length; i < n; ++i) {
        m3 = modp[i];
        f = m3.filter;
        tuples.forEach((t4) => {
          if (f(t4) && cur[tupleid(t4)] > 0) {
            modify2(t4, m3.field, m3.value);
          }
        });
        pulse2.modifies(m3.field);
      }
      if (reflow2) {
        pulse2.mod = rem2.length || remp.length ? tuples.filter((t4) => cur[tupleid(t4)] > 0) : tuples.slice();
      } else {
        for (id24 in out)
          pulse2.mod.push(out[id24]);
      }
      if (clean || clean == null && (rem2.length || remp.length)) {
        pulse2.clean(true);
      }
      return pulse2;
    }
  };
}
var CACHE = "_:mod:_";
function Parameters() {
  Object.defineProperty(this, CACHE, {
    writable: true,
    value: {}
  });
}
Parameters.prototype = {
  /**
   * Set a parameter value. If the parameter value changes, the parameter
   * will be recorded as modified.
   * @param {string} name - The parameter name.
   * @param {number} index - The index into an array-value parameter. Ignored if
   *   the argument is undefined, null or less than zero.
   * @param {*} value - The parameter value to set.
   * @param {boolean} [force=false] - If true, records the parameter as modified
   *   even if the value is unchanged.
   * @return {Parameters} - This parameter object.
   */
  set(name, index4, value7, force) {
    const o = this, v2 = o[name], mod = o[CACHE];
    if (index4 != null && index4 >= 0) {
      if (v2[index4] !== value7 || force) {
        v2[index4] = value7;
        mod[index4 + ":" + name] = -1;
        mod[name] = -1;
      }
    } else if (v2 !== value7 || force) {
      o[name] = value7;
      mod[name] = isArray2(value7) ? 1 + value7.length : -1;
    }
    return o;
  },
  /**
   * Tests if one or more parameters has been modified. If invoked with no
   * arguments, returns true if any parameter value has changed. If the first
   * argument is array, returns trues if any parameter name in the array has
   * changed. Otherwise, tests if the given name and optional array index has
   * changed.
   * @param {string} name - The parameter name to test.
   * @param {number} [index=undefined] - The parameter array index to test.
   * @return {boolean} - Returns true if a queried parameter was modified.
   */
  modified(name, index4) {
    const mod = this[CACHE];
    if (!arguments.length) {
      for (const k3 in mod) {
        if (mod[k3])
          return true;
      }
      return false;
    } else if (isArray2(name)) {
      for (let k3 = 0; k3 < name.length; ++k3) {
        if (mod[name[k3]])
          return true;
      }
      return false;
    }
    return index4 != null && index4 >= 0 ? index4 + 1 < mod[name] || !!mod[index4 + ":" + name] : !!mod[name];
  },
  /**
   * Clears the modification records. After calling this method,
   * all parameters are considered unmodified.
   */
  clear() {
    this[CACHE] = {};
    return this;
  }
};
var OP_ID = 0;
var PULSE = "pulse";
var NO_PARAMS = new Parameters();
var SKIP$1 = 1;
var MODIFIED = 2;
function Operator(init2, update3, params2, react) {
  this.id = ++OP_ID;
  this.value = init2;
  this.stamp = -1;
  this.rank = -1;
  this.qrank = -1;
  this.flags = 0;
  if (update3) {
    this._update = update3;
  }
  if (params2)
    this.parameters(params2, react);
}
function flag(bit) {
  return function(state) {
    const f = this.flags;
    if (arguments.length === 0)
      return !!(f & bit);
    this.flags = state ? f | bit : f & ~bit;
    return this;
  };
}
Operator.prototype = {
  /**
   * Returns a list of target operators dependent on this operator.
   * If this list does not exist, it is created and then returned.
   * @return {UniqueList}
   */
  targets() {
    return this._targets || (this._targets = UniqueList(id2));
  },
  /**
   * Sets the value of this operator.
   * @param {*} value - the value to set.
   * @return {Number} Returns 1 if the operator value has changed
   *   according to strict equality, returns 0 otherwise.
   */
  set(value7) {
    if (this.value !== value7) {
      this.value = value7;
      return 1;
    } else {
      return 0;
    }
  },
  /**
   * Indicates that operator evaluation should be skipped on the next pulse.
   * This operator will still propagate incoming pulses, but its update function
   * will not be invoked. The skip flag is reset after every pulse, so calling
   * this method will affect processing of the next pulse only.
   */
  skip: flag(SKIP$1),
  /**
   * Indicates that this operator's value has been modified on its most recent
   * pulse. Normally modification is checked via strict equality; however, in
   * some cases it is more efficient to update the internal state of an object.
   * In those cases, the modified flag can be used to trigger propagation. Once
   * set, the modification flag persists across pulses until unset. The flag can
   * be used with the last timestamp to test if a modification is recent.
   */
  modified: flag(MODIFIED),
  /**
   * Sets the parameters for this operator. The parameter values are analyzed for
   * operator instances. If found, this operator will be added as a dependency
   * of the parameterizing operator. Operator values are dynamically marshalled
   * from each operator parameter prior to evaluation. If a parameter value is
   * an array, the array will also be searched for Operator instances. However,
   * the search does not recurse into sub-arrays or object properties.
   * @param {object} params - A hash of operator parameters.
   * @param {boolean} [react=true] - A flag indicating if this operator should
   *   automatically update (react) when parameter values change. In other words,
   *   this flag determines if the operator registers itself as a listener on
   *   any upstream operators included in the parameters.
   * @param {boolean} [initonly=false] - A flag indicating if this operator
   *   should calculate an update only upon its initial evaluation, then
   *   deregister dependencies and suppress all future update invocations.
   * @return {Operator[]} - An array of upstream dependencies.
   */
  parameters(params2, react, initonly) {
    react = react !== false;
    const argval = this._argval = this._argval || new Parameters(), argops = this._argops = this._argops || [], deps = [];
    let name, value7, n, i;
    const add10 = (name2, index4, value8) => {
      if (value8 instanceof Operator) {
        if (value8 !== this) {
          if (react)
            value8.targets().add(this);
          deps.push(value8);
        }
        argops.push({
          op: value8,
          name: name2,
          index: index4
        });
      } else {
        argval.set(name2, index4, value8);
      }
    };
    for (name in params2) {
      value7 = params2[name];
      if (name === PULSE) {
        array2(value7).forEach((op) => {
          if (!(op instanceof Operator)) {
            error2("Pulse parameters must be operator instances.");
          } else if (op !== this) {
            op.targets().add(this);
            deps.push(op);
          }
        });
        this.source = value7;
      } else if (isArray2(value7)) {
        argval.set(name, -1, Array(n = value7.length));
        for (i = 0; i < n; ++i)
          add10(name, i, value7[i]);
      } else {
        add10(name, -1, value7);
      }
    }
    this.marshall().clear();
    if (initonly)
      argops.initonly = true;
    return deps;
  },
  /**
   * Internal method for marshalling parameter values.
   * Visits each operator dependency to pull the latest value.
   * @return {Parameters} A Parameters object to pass to the update function.
   */
  marshall(stamp) {
    const argval = this._argval || NO_PARAMS, argops = this._argops;
    let item, i, op, mod;
    if (argops) {
      const n = argops.length;
      for (i = 0; i < n; ++i) {
        item = argops[i];
        op = item.op;
        mod = op.modified() && op.stamp === stamp;
        argval.set(item.name, item.index, op.value, mod);
      }
      if (argops.initonly) {
        for (i = 0; i < n; ++i) {
          item = argops[i];
          item.op.targets().remove(this);
        }
        this._argops = null;
        this._update = null;
      }
    }
    return argval;
  },
  /**
   * Detach this operator from the dataflow.
   * Unregisters listeners on upstream dependencies.
   */
  detach() {
    const argops = this._argops;
    let i, n, item, op;
    if (argops) {
      for (i = 0, n = argops.length; i < n; ++i) {
        item = argops[i];
        op = item.op;
        if (op._targets) {
          op._targets.remove(this);
        }
      }
    }
    this.pulse = null;
    this.source = null;
  },
  /**
   * Delegate method to perform operator processing.
   * Subclasses can override this method to perform custom processing.
   * By default, it marshalls parameters and calls the update function
   * if that function is defined. If the update function does not
   * change the operator value then StopPropagation is returned.
   * If no update function is defined, this method does nothing.
   * @param {Pulse} pulse - the current dataflow pulse.
   * @return The output pulse or StopPropagation. A falsy return value
   *   (including undefined) will let the input pulse pass through.
   */
  evaluate(pulse2) {
    const update3 = this._update;
    if (update3) {
      const params2 = this.marshall(pulse2.stamp), v2 = update3.call(this, params2, pulse2);
      params2.clear();
      if (v2 !== this.value) {
        this.value = v2;
      } else if (!this.modified()) {
        return pulse2.StopPropagation;
      }
    }
  },
  /**
   * Run this operator for the current pulse. If this operator has already
   * been run at (or after) the pulse timestamp, returns StopPropagation.
   * Internally, this method calls {@link evaluate} to perform processing.
   * If {@link evaluate} returns a falsy value, the input pulse is returned.
   * This method should NOT be overridden, instead overrride {@link evaluate}.
   * @param {Pulse} pulse - the current dataflow pulse.
   * @return the output pulse for this operator (or StopPropagation)
   */
  run(pulse2) {
    if (pulse2.stamp < this.stamp)
      return pulse2.StopPropagation;
    let rv;
    if (this.skip()) {
      this.skip(false);
      rv = 0;
    } else {
      rv = this.evaluate(pulse2);
    }
    return this.pulse = rv || pulse2;
  }
};
function add(init2, update3, params2, react) {
  let shift = 1, op;
  if (init2 instanceof Operator) {
    op = init2;
  } else if (init2 && init2.prototype instanceof Operator) {
    op = new init2();
  } else if (isFunction2(init2)) {
    op = new Operator(null, init2);
  } else {
    shift = 0;
    op = new Operator(init2, update3);
  }
  this.rank(op);
  if (shift) {
    react = params2;
    params2 = update3;
  }
  if (params2)
    this.connect(op, op.parameters(params2, react));
  this.touch(op);
  return op;
}
function connect(target2, sources) {
  const targetRank = target2.rank, n = sources.length;
  for (let i = 0; i < n; ++i) {
    if (targetRank < sources[i].rank) {
      this.rerank(target2);
      return;
    }
  }
}
var STREAM_ID = 0;
function EventStream(filter4, apply11, receive) {
  this.id = ++STREAM_ID;
  this.value = null;
  if (receive)
    this.receive = receive;
  if (filter4)
    this._filter = filter4;
  if (apply11)
    this._apply = apply11;
}
function stream(filter4, apply11, receive) {
  return new EventStream(filter4, apply11, receive);
}
EventStream.prototype = {
  _filter: truthy2,
  _apply: identity2,
  targets() {
    return this._targets || (this._targets = UniqueList(id2));
  },
  consume(_) {
    if (!arguments.length)
      return !!this._consume;
    this._consume = !!_;
    return this;
  },
  receive(evt) {
    if (this._filter(evt)) {
      const val = this.value = this._apply(evt), trg = this._targets, n = trg ? trg.length : 0;
      for (let i = 0; i < n; ++i)
        trg[i].receive(val);
      if (this._consume) {
        evt.preventDefault();
        evt.stopPropagation();
      }
    }
  },
  filter(filter4) {
    const s2 = stream(filter4);
    this.targets().add(s2);
    return s2;
  },
  apply(apply11) {
    const s2 = stream(null, apply11);
    this.targets().add(s2);
    return s2;
  },
  merge() {
    const s2 = stream();
    this.targets().add(s2);
    for (let i = 0, n = arguments.length; i < n; ++i) {
      arguments[i].targets().add(s2);
    }
    return s2;
  },
  throttle(pause) {
    let t = -1;
    return this.filter(() => {
      const now2 = Date.now();
      if (now2 - t > pause) {
        t = now2;
        return 1;
      } else {
        return 0;
      }
    });
  },
  debounce(delay) {
    const s2 = stream();
    this.targets().add(stream(null, null, debounce2(delay, (e3) => {
      const df = e3.dataflow;
      s2.receive(e3);
      if (df && df.run)
        df.run();
    })));
    return s2;
  },
  between(a4, b6) {
    let active = false;
    a4.targets().add(stream(null, null, () => active = true));
    b6.targets().add(stream(null, null, () => active = false));
    return this.filter(() => active);
  },
  detach() {
    this._filter = truthy2;
    this._targets = null;
  }
};
function events(source3, type7, filter4, apply11) {
  const df = this, s2 = stream(filter4, apply11), send = function(e3) {
    e3.dataflow = df;
    try {
      s2.receive(e3);
    } catch (error25) {
      df.error(error25);
    } finally {
      df.run();
    }
  };
  let sources;
  if (typeof source3 === "string" && typeof document !== "undefined") {
    sources = document.querySelectorAll(source3);
  } else {
    sources = array2(source3);
  }
  const n = sources.length;
  for (let i = 0; i < n; ++i) {
    sources[i].addEventListener(type7, send);
  }
  return s2;
}
function parse2(data3, format14) {
  const locale5 = this.locale();
  return read(data3, format14, locale5.timeParse, locale5.utcParse);
}
function ingest(target2, data3, format14) {
  data3 = this.parse(data3, format14);
  return this.pulse(target2, this.changeset().insert(data3));
}
async function request(url, format14) {
  const df = this;
  let status = 0, data3;
  try {
    data3 = await df.loader().load(url, {
      context: "dataflow",
      response: responseType(format14 && format14.type)
    });
    try {
      data3 = df.parse(data3, format14);
    } catch (err) {
      status = -2;
      df.warn("Data ingestion failed", url, err);
    }
  } catch (err) {
    status = -1;
    df.warn("Loading failed", url, err);
  }
  return {
    data: data3,
    status
  };
}
async function preload(target2, url, format14) {
  const df = this, pending = df._pending || loadPending(df);
  pending.requests += 1;
  const res = await df.request(url, format14);
  df.pulse(target2, df.changeset().remove(truthy2).insert(res.data || []));
  pending.done();
  return res;
}
function loadPending(df) {
  let accept;
  const pending = new Promise((a4) => accept = a4);
  pending.requests = 0;
  pending.done = () => {
    if (--pending.requests === 0) {
      df._pending = null;
      accept(df);
    }
  };
  return df._pending = pending;
}
var SKIP = {
  skip: true
};
function on(source3, target2, update3, params2, options) {
  const fn = source3 instanceof Operator ? onOperator : onStream;
  fn(this, source3, target2, update3, params2, options);
  return this;
}
function onStream(df, stream2, target2, update3, params2, options) {
  const opt = extend2({}, options, SKIP);
  let func, op;
  if (!isFunction2(target2))
    target2 = constant2(target2);
  if (update3 === void 0) {
    func = (e3) => df.touch(target2(e3));
  } else if (isFunction2(update3)) {
    op = new Operator(null, update3, params2, false);
    func = (e3) => {
      op.evaluate(e3);
      const t = target2(e3), v2 = op.value;
      isChangeSet(v2) ? df.pulse(t, v2, options) : df.update(t, v2, opt);
    };
  } else {
    func = (e3) => df.update(target2(e3), update3, opt);
  }
  stream2.apply(func);
}
function onOperator(df, source3, target2, update3, params2, options) {
  if (update3 === void 0) {
    source3.targets().add(target2);
  } else {
    const opt = options || {}, op = new Operator(null, updater(target2, update3), params2, false);
    op.modified(opt.force);
    op.rank = source3.rank;
    source3.targets().add(op);
    if (target2) {
      op.skip(true);
      op.value = target2.value;
      op.targets().add(target2);
      df.connect(target2, [op]);
    }
  }
}
function updater(target2, update3) {
  update3 = isFunction2(update3) ? update3 : constant2(update3);
  return target2 ? function(_, pulse2) {
    const value7 = update3(_, pulse2);
    if (!target2.skip()) {
      target2.skip(value7 !== this.value).value = value7;
    }
    return value7;
  } : update3;
}
function rank2(op) {
  op.rank = ++this._rank;
}
function rerank(op) {
  const queue = [op];
  let cur, list, i;
  while (queue.length) {
    this.rank(cur = queue.pop());
    if (list = cur._targets) {
      for (i = list.length; --i >= 0; ) {
        queue.push(cur = list[i]);
        if (cur === op)
          error2("Cycle detected in dataflow graph.");
      }
    }
  }
}
var StopPropagation = {};
var ADD = 1 << 0;
var REM = 1 << 1;
var MOD = 1 << 2;
var ADD_REM = ADD | REM;
var ADD_MOD = ADD | MOD;
var ALL = ADD | REM | MOD;
var REFLOW = 1 << 3;
var SOURCE = 1 << 4;
var NO_SOURCE = 1 << 5;
var NO_FIELDS = 1 << 6;
function Pulse(dataflow, stamp, encode2) {
  this.dataflow = dataflow;
  this.stamp = stamp == null ? -1 : stamp;
  this.add = [];
  this.rem = [];
  this.mod = [];
  this.fields = null;
  this.encode = encode2 || null;
}
function materialize(data3, filter4) {
  const out = [];
  visitArray2(data3, filter4, (_) => out.push(_));
  return out;
}
function filter2(pulse2, flags) {
  const map13 = {};
  pulse2.visit(flags, (t) => {
    map13[tupleid(t)] = 1;
  });
  return (t) => map13[tupleid(t)] ? null : t;
}
function addFilter(a4, b6) {
  return a4 ? (t, i) => a4(t, i) && b6(t, i) : b6;
}
Pulse.prototype = {
  /**
   * Sentinel value indicating pulse propagation should stop.
   */
  StopPropagation,
  /**
   * Boolean flag indicating ADD (added) tuples.
   */
  ADD,
  /**
   * Boolean flag indicating REM (removed) tuples.
   */
  REM,
  /**
   * Boolean flag indicating MOD (modified) tuples.
   */
  MOD,
  /**
   * Boolean flag indicating ADD (added) and REM (removed) tuples.
   */
  ADD_REM,
  /**
   * Boolean flag indicating ADD (added) and MOD (modified) tuples.
   */
  ADD_MOD,
  /**
   * Boolean flag indicating ADD, REM and MOD tuples.
   */
  ALL,
  /**
   * Boolean flag indicating all tuples in a data source
   * except for the ADD, REM and MOD tuples.
   */
  REFLOW,
  /**
   * Boolean flag indicating a 'pass-through' to a
   * backing data source, ignoring ADD, REM and MOD tuples.
   */
  SOURCE,
  /**
   * Boolean flag indicating that source data should be
   * suppressed when creating a forked pulse.
   */
  NO_SOURCE,
  /**
   * Boolean flag indicating that field modifications should be
   * suppressed when creating a forked pulse.
   */
  NO_FIELDS,
  /**
   * Creates a new pulse based on the values of this pulse.
   * The dataflow, time stamp and field modification values are copied over.
   * By default, new empty ADD, REM and MOD arrays are created.
   * @param {number} flags - Integer of boolean flags indicating which (if any)
   *   tuple arrays should be copied to the new pulse. The supported flag values
   *   are ADD, REM and MOD. Array references are copied directly: new array
   *   instances are not created.
   * @return {Pulse} - The forked pulse instance.
   * @see init
   */
  fork(flags) {
    return new Pulse(this.dataflow).init(this, flags);
  },
  /**
   * Creates a copy of this pulse with new materialized array
   * instances for the ADD, REM, MOD, and SOURCE arrays.
   * The dataflow, time stamp and field modification values are copied over.
   * @return {Pulse} - The cloned pulse instance.
   * @see init
   */
  clone() {
    const p = this.fork(ALL);
    p.add = p.add.slice();
    p.rem = p.rem.slice();
    p.mod = p.mod.slice();
    if (p.source)
      p.source = p.source.slice();
    return p.materialize(ALL | SOURCE);
  },
  /**
   * Returns a pulse that adds all tuples from a backing source. This is
   * useful for cases where operators are added to a dataflow after an
   * upstream data pipeline has already been processed, ensuring that
   * new operators can observe all tuples within a stream.
   * @return {Pulse} - A pulse instance with all source tuples included
   *   in the add array. If the current pulse already has all source
   *   tuples in its add array, it is returned directly. If the current
   *   pulse does not have a backing source, it is returned directly.
   */
  addAll() {
    let p = this;
    const reuse = !p.source || p.add === p.rem || !p.rem.length && p.source.length === p.add.length;
    if (reuse) {
      return p;
    } else {
      p = new Pulse(this.dataflow).init(this);
      p.add = p.source;
      p.rem = [];
      return p;
    }
  },
  /**
   * Initialize this pulse based on the values of another pulse. This method
   * is used internally by {@link fork} to initialize a new forked tuple.
   * The dataflow, time stamp and field modification values are copied over.
   * By default, new empty ADD, REM and MOD arrays are created.
   * @param {Pulse} src - The source pulse to copy from.
   * @param {number} flags - Integer of boolean flags indicating which (if any)
   *   tuple arrays should be copied to the new pulse. The supported flag values
   *   are ADD, REM and MOD. Array references are copied directly: new array
   *   instances are not created. By default, source data arrays are copied
   *   to the new pulse. Use the NO_SOURCE flag to enforce a null source.
   * @return {Pulse} - Returns this Pulse instance.
   */
  init(src, flags) {
    const p = this;
    p.stamp = src.stamp;
    p.encode = src.encode;
    if (src.fields && !(flags & NO_FIELDS)) {
      p.fields = src.fields;
    }
    if (flags & ADD) {
      p.addF = src.addF;
      p.add = src.add;
    } else {
      p.addF = null;
      p.add = [];
    }
    if (flags & REM) {
      p.remF = src.remF;
      p.rem = src.rem;
    } else {
      p.remF = null;
      p.rem = [];
    }
    if (flags & MOD) {
      p.modF = src.modF;
      p.mod = src.mod;
    } else {
      p.modF = null;
      p.mod = [];
    }
    if (flags & NO_SOURCE) {
      p.srcF = null;
      p.source = null;
    } else {
      p.srcF = src.srcF;
      p.source = src.source;
      if (src.cleans)
        p.cleans = src.cleans;
    }
    return p;
  },
  /**
   * Schedules a function to run after pulse propagation completes.
   * @param {function} func - The function to run.
   */
  runAfter(func) {
    this.dataflow.runAfter(func);
  },
  /**
   * Indicates if tuples have been added, removed or modified.
   * @param {number} [flags] - The tuple types (ADD, REM or MOD) to query.
   *   Defaults to ALL, returning true if any tuple type has changed.
   * @return {boolean} - Returns true if one or more queried tuple types have
   *   changed, false otherwise.
   */
  changed(flags) {
    const f = flags || ALL;
    return f & ADD && this.add.length || f & REM && this.rem.length || f & MOD && this.mod.length;
  },
  /**
   * Forces a "reflow" of tuple values, such that all tuples in the backing
   * source are added to the MOD set, unless already present in the ADD set.
   * @param {boolean} [fork=false] - If true, returns a forked copy of this
   *   pulse, and invokes reflow on that derived pulse.
   * @return {Pulse} - The reflowed pulse instance.
   */
  reflow(fork) {
    if (fork)
      return this.fork(ALL).reflow();
    const len = this.add.length, src = this.source && this.source.length;
    if (src && src !== len) {
      this.mod = this.source;
      if (len)
        this.filter(MOD, filter2(this, ADD));
    }
    return this;
  },
  /**
   * Get/set metadata to pulse requesting garbage collection
   * to reclaim currently unused resources.
   */
  clean(value7) {
    if (arguments.length) {
      this.cleans = !!value7;
      return this;
    } else {
      return this.cleans;
    }
  },
  /**
   * Marks one or more data field names as modified to assist dependency
   * tracking and incremental processing by transform operators.
   * @param {string|Array<string>} _ - The field(s) to mark as modified.
   * @return {Pulse} - This pulse instance.
   */
  modifies(_) {
    const hash2 = this.fields || (this.fields = {});
    if (isArray2(_)) {
      _.forEach((f) => hash2[f] = true);
    } else {
      hash2[_] = true;
    }
    return this;
  },
  /**
   * Checks if one or more data fields have been modified during this pulse
   * propagation timestamp.
   * @param {string|Array<string>} _ - The field(s) to check for modified.
   * @param {boolean} nomod - If true, will check the modified flag even if
   *   no mod tuples exist. If false (default), mod tuples must be present.
   * @return {boolean} - Returns true if any of the provided fields has been
   *   marked as modified, false otherwise.
   */
  modified(_, nomod) {
    const fields = this.fields;
    return !((nomod || this.mod.length) && fields) ? false : !arguments.length ? !!fields : isArray2(_) ? _.some((f) => fields[f]) : fields[_];
  },
  /**
   * Adds a filter function to one more tuple sets. Filters are applied to
   * backing tuple arrays, to determine the actual set of tuples considered
   * added, removed or modified. They can be used to delay materialization of
   * a tuple set in order to avoid expensive array copies. In addition, the
   * filter functions can serve as value transformers: unlike standard predicate
   * function (which return boolean values), Pulse filters should return the
   * actual tuple value to process. If a tuple set is already filtered, the
   * new filter function will be appended into a conjuntive ('and') query.
   * @param {number} flags - Flags indicating the tuple set(s) to filter.
   * @param {function(*):object} filter - Filter function that will be applied
   *   to the tuple set array, and should return a data tuple if the value
   *   should be included in the tuple set, and falsy (or null) otherwise.
   * @return {Pulse} - Returns this pulse instance.
   */
  filter(flags, filter4) {
    const p = this;
    if (flags & ADD)
      p.addF = addFilter(p.addF, filter4);
    if (flags & REM)
      p.remF = addFilter(p.remF, filter4);
    if (flags & MOD)
      p.modF = addFilter(p.modF, filter4);
    if (flags & SOURCE)
      p.srcF = addFilter(p.srcF, filter4);
    return p;
  },
  /**
   * Materialize one or more tuple sets in this pulse. If the tuple set(s) have
   * a registered filter function, it will be applied and the tuple set(s) will
   * be replaced with materialized tuple arrays.
   * @param {number} flags - Flags indicating the tuple set(s) to materialize.
   * @return {Pulse} - Returns this pulse instance.
   */
  materialize(flags) {
    flags = flags || ALL;
    const p = this;
    if (flags & ADD && p.addF) {
      p.add = materialize(p.add, p.addF);
      p.addF = null;
    }
    if (flags & REM && p.remF) {
      p.rem = materialize(p.rem, p.remF);
      p.remF = null;
    }
    if (flags & MOD && p.modF) {
      p.mod = materialize(p.mod, p.modF);
      p.modF = null;
    }
    if (flags & SOURCE && p.srcF) {
      p.source = p.source.filter(p.srcF);
      p.srcF = null;
    }
    return p;
  },
  /**
   * Visit one or more tuple sets in this pulse.
   * @param {number} flags - Flags indicating the tuple set(s) to visit.
   *   Legal values are ADD, REM, MOD and SOURCE (if a backing data source
   *   has been set).
   * @param {function(object):*} - Visitor function invoked per-tuple.
   * @return {Pulse} - Returns this pulse instance.
   */
  visit(flags, visitor) {
    const p = this, v2 = visitor;
    if (flags & SOURCE) {
      visitArray2(p.source, p.srcF, v2);
      return p;
    }
    if (flags & ADD)
      visitArray2(p.add, p.addF, v2);
    if (flags & REM)
      visitArray2(p.rem, p.remF, v2);
    if (flags & MOD)
      visitArray2(p.mod, p.modF, v2);
    const src = p.source;
    if (flags & REFLOW && src) {
      const sum4 = p.add.length + p.mod.length;
      if (sum4 === src.length)
        ;
      else if (sum4) {
        visitArray2(src, filter2(p, ADD_MOD), v2);
      } else {
        visitArray2(src, p.srcF, v2);
      }
    }
    return p;
  }
};
function MultiPulse(dataflow, stamp, pulses, encode2) {
  const p = this;
  let c5 = 0;
  this.dataflow = dataflow;
  this.stamp = stamp;
  this.fields = null;
  this.encode = encode2 || null;
  this.pulses = pulses;
  for (const pulse2 of pulses) {
    if (pulse2.stamp !== stamp)
      continue;
    if (pulse2.fields) {
      const hash2 = p.fields || (p.fields = {});
      for (const f in pulse2.fields) {
        hash2[f] = 1;
      }
    }
    if (pulse2.changed(p.ADD))
      c5 |= p.ADD;
    if (pulse2.changed(p.REM))
      c5 |= p.REM;
    if (pulse2.changed(p.MOD))
      c5 |= p.MOD;
  }
  this.changes = c5;
}
inherits2(MultiPulse, Pulse, {
  /**
   * Creates a new pulse based on the values of this pulse.
   * The dataflow, time stamp and field modification values are copied over.
   * @return {Pulse}
   */
  fork(flags) {
    const p = new Pulse(this.dataflow).init(this, flags & this.NO_FIELDS);
    if (flags !== void 0) {
      if (flags & p.ADD)
        this.visit(p.ADD, (t) => p.add.push(t));
      if (flags & p.REM)
        this.visit(p.REM, (t) => p.rem.push(t));
      if (flags & p.MOD)
        this.visit(p.MOD, (t) => p.mod.push(t));
    }
    return p;
  },
  changed(flags) {
    return this.changes & flags;
  },
  modified(_) {
    const p = this, fields = p.fields;
    return !(fields && p.changes & p.MOD) ? 0 : isArray2(_) ? _.some((f) => fields[f]) : fields[_];
  },
  filter() {
    error2("MultiPulse does not support filtering.");
  },
  materialize() {
    error2("MultiPulse does not support materialization.");
  },
  visit(flags, visitor) {
    const p = this, pulses = p.pulses, n = pulses.length;
    let i = 0;
    if (flags & p.SOURCE) {
      for (; i < n; ++i) {
        pulses[i].visit(flags, visitor);
      }
    } else {
      for (; i < n; ++i) {
        if (pulses[i].stamp === p.stamp) {
          pulses[i].visit(flags, visitor);
        }
      }
    }
    return p;
  }
});
async function evaluate(encode2, prerun, postrun) {
  const df = this, async = [];
  if (df._pulse)
    return reentrant(df);
  if (df._pending)
    await df._pending;
  if (prerun)
    await asyncCallback(df, prerun);
  if (!df._touched.length) {
    df.debug("Dataflow invoked, but nothing to do.");
    return df;
  }
  const stamp = ++df._clock;
  df._pulse = new Pulse(df, stamp, encode2);
  df._touched.forEach((op2) => df._enqueue(op2, true));
  df._touched = UniqueList(id2);
  let count3 = 0, op, next, error25;
  try {
    while (df._heap.size() > 0) {
      op = df._heap.pop();
      if (op.rank !== op.qrank) {
        df._enqueue(op, true);
        continue;
      }
      next = op.run(df._getPulse(op, encode2));
      if (next.then) {
        next = await next;
      } else if (next.async) {
        async.push(next.async);
        next = StopPropagation;
      }
      if (next !== StopPropagation) {
        if (op._targets)
          op._targets.forEach((op2) => df._enqueue(op2));
      }
      ++count3;
    }
  } catch (err) {
    df._heap.clear();
    error25 = err;
  }
  df._input = {};
  df._pulse = null;
  df.debug(`Pulse ${stamp}: ${count3} operators`);
  if (error25) {
    df._postrun = [];
    df.error(error25);
  }
  if (df._postrun.length) {
    const pr = df._postrun.sort((a4, b6) => b6.priority - a4.priority);
    df._postrun = [];
    for (let i = 0; i < pr.length; ++i) {
      await asyncCallback(df, pr[i].callback);
    }
  }
  if (postrun)
    await asyncCallback(df, postrun);
  if (async.length) {
    Promise.all(async).then((cb) => df.runAsync(null, () => {
      cb.forEach((f) => {
        try {
          f(df);
        } catch (err) {
          df.error(err);
        }
      });
    }));
  }
  return df;
}
async function runAsync(encode2, prerun, postrun) {
  while (this._running)
    await this._running;
  const clear2 = () => this._running = null;
  (this._running = this.evaluate(encode2, prerun, postrun)).then(clear2, clear2);
  return this._running;
}
function run(encode2, prerun, postrun) {
  return this._pulse ? reentrant(this) : (this.evaluate(encode2, prerun, postrun), this);
}
function runAfter(callback, enqueue2, priority) {
  if (this._pulse || enqueue2) {
    this._postrun.push({
      priority: priority || 0,
      callback
    });
  } else {
    try {
      callback(this);
    } catch (err) {
      this.error(err);
    }
  }
}
function reentrant(df) {
  df.error("Dataflow already running. Use runAsync() to chain invocations.");
  return df;
}
function enqueue(op, force) {
  const q = op.stamp < this._clock;
  if (q)
    op.stamp = this._clock;
  if (q || force) {
    op.qrank = op.rank;
    this._heap.push(op);
  }
}
function getPulse(op, encode2) {
  const s2 = op.source, stamp = this._clock;
  return s2 && isArray2(s2) ? new MultiPulse(this, stamp, s2.map((_) => _.pulse), encode2) : this._input[op.id] || singlePulse(this._pulse, s2 && s2.pulse);
}
function singlePulse(p, s2) {
  if (s2 && s2.stamp === p.stamp) {
    return s2;
  }
  p = p.fork();
  if (s2 && s2 !== StopPropagation) {
    p.source = s2.source;
  }
  return p;
}
var NO_OPT = {
  skip: false,
  force: false
};
function touch(op, options) {
  const opt = options || NO_OPT;
  if (this._pulse) {
    this._enqueue(op);
  } else {
    this._touched.add(op);
  }
  if (opt.skip)
    op.skip(true);
  return this;
}
function update(op, value7, options) {
  const opt = options || NO_OPT;
  if (op.set(value7) || opt.force) {
    this.touch(op, opt);
  }
  return this;
}
function pulse(op, changeset2, options) {
  this.touch(op, options || NO_OPT);
  const p = new Pulse(this, this._clock + (this._pulse ? 0 : 1)), t = op.pulse && op.pulse.source || [];
  p.target = op;
  this._input[op.id] = changeset2.pulse(p, t);
  return this;
}
function Heap(cmp) {
  let nodes = [];
  return {
    clear: () => nodes = [],
    size: () => nodes.length,
    peek: () => nodes[0],
    push: (x9) => {
      nodes.push(x9);
      return siftdown(nodes, 0, nodes.length - 1, cmp);
    },
    pop: () => {
      const last = nodes.pop();
      let item;
      if (nodes.length) {
        item = nodes[0];
        nodes[0] = last;
        siftup(nodes, 0, cmp);
      } else {
        item = last;
      }
      return item;
    }
  };
}
function siftdown(array22, start, idx, cmp) {
  let parent, pidx;
  const item = array22[idx];
  while (idx > start) {
    pidx = idx - 1 >> 1;
    parent = array22[pidx];
    if (cmp(item, parent) < 0) {
      array22[idx] = parent;
      idx = pidx;
      continue;
    }
    break;
  }
  return array22[idx] = item;
}
function siftup(array22, idx, cmp) {
  const start = idx, end = array22.length, item = array22[idx];
  let cidx = (idx << 1) + 1, ridx;
  while (cidx < end) {
    ridx = cidx + 1;
    if (ridx < end && cmp(array22[cidx], array22[ridx]) >= 0) {
      cidx = ridx;
    }
    array22[idx] = array22[cidx];
    idx = cidx;
    cidx = (idx << 1) + 1;
  }
  array22[idx] = item;
  return siftdown(array22, start, idx, cmp);
}
function Dataflow() {
  this.logger(logger2());
  this.logLevel(Error$12);
  this._clock = 0;
  this._rank = 0;
  this._locale = defaultLocale3();
  try {
    this._loader = loader();
  } catch (e3) {
  }
  this._touched = UniqueList(id2);
  this._input = {};
  this._pulse = null;
  this._heap = Heap((a4, b6) => a4.qrank - b6.qrank);
  this._postrun = [];
}
function logMethod(method10) {
  return function() {
    return this._log[method10].apply(this, arguments);
  };
}
Dataflow.prototype = {
  /**
   * The current timestamp of this dataflow. This value reflects the
   * timestamp of the previous dataflow run. The dataflow is initialized
   * with a stamp value of 0. The initial run of the dataflow will have
   * a timestap of 1, and so on. This value will match the
   * {@link Pulse.stamp} property.
   * @return {number} - The current timestamp value.
   */
  stamp() {
    return this._clock;
  },
  /**
   * Gets or sets the loader instance to use for data file loading. A
   * loader object must provide a "load" method for loading files and a
   * "sanitize" method for checking URL/filename validity. Both methods
   * should accept a URI and options hash as arguments, and return a Promise
   * that resolves to the loaded file contents (load) or a hash containing
   * sanitized URI data with the sanitized url assigned to the "href" property
   * (sanitize).
   * @param {object} _ - The loader instance to use.
   * @return {object|Dataflow} - If no arguments are provided, returns
   *   the current loader instance. Otherwise returns this Dataflow instance.
   */
  loader(_) {
    if (arguments.length) {
      this._loader = _;
      return this;
    } else {
      return this._loader;
    }
  },
  /**
   * Gets or sets the locale instance to use for formatting and parsing
   * string values. The locale object should be provided by the
   * vega-format library, and include methods such as format, timeFormat,
   * utcFormat, timeParse, and utcParse.
   * @param {object} _ - The locale instance to use.
   * @return {object|Dataflow} - If no arguments are provided, returns
   *   the current locale instance. Otherwise returns this Dataflow instance.
   */
  locale(_) {
    if (arguments.length) {
      this._locale = _;
      return this;
    } else {
      return this._locale;
    }
  },
  /**
   * Get or set the logger instance used to log messages. If no arguments are
   * provided, returns the current logger instance. Otherwise, sets the logger
   * and return this Dataflow instance. Provided loggers must support the full
   * API of logger objects generated by the vega-util logger method. Note that
   * by default the log level of the new logger will be used; use the logLevel
   * method to adjust the log level as needed.
   */
  logger(logger4) {
    if (arguments.length) {
      this._log = logger4;
      return this;
    } else {
      return this._log;
    }
  },
  /**
   * Logs an error message. By default, logged messages are written to console
   * output. The message will only be logged if the current log level is high
   * enough to permit error messages.
   */
  error: logMethod("error"),
  /**
   * Logs a warning message. By default, logged messages are written to console
   * output. The message will only be logged if the current log level is high
   * enough to permit warning messages.
   */
  warn: logMethod("warn"),
  /**
   * Logs a information message. By default, logged messages are written to
   * console output. The message will only be logged if the current log level is
   * high enough to permit information messages.
   */
  info: logMethod("info"),
  /**
   * Logs a debug message. By default, logged messages are written to console
   * output. The message will only be logged if the current log level is high
   * enough to permit debug messages.
   */
  debug: logMethod("debug"),
  /**
   * Get or set the current log level. If an argument is provided, it
   * will be used as the new log level.
   * @param {number} [level] - Should be one of None, Warn, Info
   * @return {number} - The current log level.
   */
  logLevel: logMethod("level"),
  /**
   * Empty entry threshold for garbage cleaning. Map data structures will
   * perform cleaning once the number of empty entries exceeds this value.
   */
  cleanThreshold: 1e4,
  // OPERATOR REGISTRATION
  add,
  connect,
  rank: rank2,
  rerank,
  // OPERATOR UPDATES
  pulse,
  touch,
  update,
  changeset,
  // DATA LOADING
  ingest,
  parse: parse2,
  preload,
  request,
  // EVENT HANDLING
  events,
  on,
  // PULSE PROPAGATION
  evaluate,
  run,
  runAsync,
  runAfter,
  _enqueue: enqueue,
  _getPulse: getPulse
};
function Transform(init2, params2) {
  Operator.call(this, init2, null, params2);
}
inherits2(Transform, Operator, {
  /**
   * Overrides {@link Operator.evaluate} for transform operators.
   * Internally, this method calls {@link evaluate} to perform processing.
   * If {@link evaluate} returns a falsy value, the input pulse is returned.
   * This method should NOT be overridden, instead overrride {@link evaluate}.
   * @param {Pulse} pulse - the current dataflow pulse.
   * @return the output pulse for this operator (or StopPropagation)
   */
  run(pulse2) {
    if (pulse2.stamp < this.stamp)
      return pulse2.StopPropagation;
    let rv;
    if (this.skip()) {
      this.skip(false);
    } else {
      rv = this.evaluate(pulse2);
    }
    rv = rv || pulse2;
    if (rv.then) {
      rv = rv.then((_) => this.pulse = _);
    } else if (rv !== pulse2.StopPropagation) {
      this.pulse = rv;
    }
    return rv;
  },
  /**
   * Overrides {@link Operator.evaluate} for transform operators.
   * Marshalls parameter values and then invokes {@link transform}.
   * @param {Pulse} pulse - the current dataflow pulse.
   * @return {Pulse} The output pulse (or StopPropagation). A falsy return
       value (including undefined) will let the input pulse pass through.
  */
  evaluate(pulse2) {
    const params2 = this.marshall(pulse2.stamp), out = this.transform(params2, pulse2);
    params2.clear();
    return out;
  },
  /**
   * Process incoming pulses.
   * Subclasses should override this method to implement transforms.
   * @param {Parameters} _ - The operator parameter values.
   * @param {Pulse} pulse - The current dataflow pulse.
   * @return {Pulse} The output pulse (or StopPropagation). A falsy return
   *   value (including undefined) will let the input pulse pass through.
   */
  transform() {
  }
});
var transforms = {};
function definition(type7) {
  const t = transform(type7);
  return t && t.Definition || null;
}
function transform(type7) {
  type7 = type7 && type7.toLowerCase();
  return has2(transforms, type7) ? transforms[type7] : null;
}

// node_modules/vega-transforms/build/vega-transforms.js
var vega_transforms_exports = {};
__export(vega_transforms_exports, {
  aggregate: () => Aggregate,
  bin: () => Bin,
  collect: () => Collect,
  compare: () => Compare,
  countpattern: () => CountPattern,
  cross: () => Cross,
  density: () => Density,
  dotbin: () => DotBin,
  expression: () => Expression,
  extent: () => Extent,
  facet: () => Facet,
  field: () => Field,
  filter: () => Filter,
  flatten: () => Flatten,
  fold: () => Fold,
  formula: () => Formula,
  generate: () => Generate,
  impute: () => Impute,
  joinaggregate: () => JoinAggregate,
  kde: () => KDE,
  key: () => Key,
  load: () => Load,
  lookup: () => Lookup,
  multiextent: () => MultiExtent,
  multivalues: () => MultiValues,
  params: () => Params,
  pivot: () => Pivot,
  prefacet: () => PreFacet,
  project: () => Project,
  proxy: () => Proxy,
  quantile: () => Quantile,
  relay: () => Relay,
  sample: () => Sample,
  sequence: () => Sequence,
  sieve: () => Sieve,
  subflow: () => Subflow,
  timeunit: () => TimeUnit,
  tupleindex: () => TupleIndex,
  values: () => Values,
  window: () => Window
});

// node_modules/vega-transforms/node_modules/vega-util/build/vega-util.js
function accessor3(fn, fields, name) {
  fn.fields = fields || [];
  fn.fname = name;
  return fn;
}
function accessorName2(fn) {
  return fn == null ? null : fn.fname;
}
function accessorFields2(fn) {
  return fn == null ? null : fn.fields;
}
function getter3(path7) {
  return path7.length === 1 ? get13(path7[0]) : getN3(path7);
}
var get13 = (field25) => function(obj) {
  return obj[field25];
};
var getN3 = (path7) => {
  const len = path7.length;
  return function(obj) {
    for (let i = 0; i < len; ++i) {
      obj = obj[path7[i]];
    }
    return obj;
  };
};
function error3(message) {
  throw Error(message);
}
function splitAccessPath3(p) {
  const path7 = [], n = p.length;
  let q = null, b6 = 0, s2 = "", i, j, c5;
  p = p + "";
  function push() {
    path7.push(s2 + p.substring(i, j));
    s2 = "";
    i = j + 1;
  }
  for (i = j = 0; j < n; ++j) {
    c5 = p[j];
    if (c5 === "\\") {
      s2 += p.substring(i, j++);
      i = j;
    } else if (c5 === q) {
      push();
      q = null;
      b6 = -1;
    } else if (q) {
      continue;
    } else if (i === b6 && c5 === '"') {
      i = j + 1;
      q = c5;
    } else if (i === b6 && c5 === "'") {
      i = j + 1;
      q = c5;
    } else if (c5 === "." && !b6) {
      if (j > i) {
        push();
      } else {
        i = j + 1;
      }
    } else if (c5 === "[") {
      if (j > i)
        push();
      b6 = i = j + 1;
    } else if (c5 === "]") {
      if (!b6)
        error3("Access path missing open bracket: " + p);
      if (b6 > 0)
        push();
      b6 = 0;
      i = j + 1;
    }
  }
  if (b6)
    error3("Access path missing closing bracket: " + p);
  if (q)
    error3("Access path missing closing quote: " + p);
  if (j > i) {
    j++;
    push();
  }
  return path7;
}
function field3(field25, name, opt) {
  const path7 = splitAccessPath3(field25);
  field25 = path7.length === 1 ? path7[0] : field25;
  return accessor3((opt && opt.get || getter3)(path7), [field25], name || field25);
}
var id3 = field3("id");
var identity4 = accessor3((_) => _, [], "identity");
var zero4 = accessor3(() => 0, [], "zero");
var one3 = accessor3(() => 1, [], "one");
var truthy3 = accessor3(() => true, [], "true");
var falsy3 = accessor3(() => false, [], "false");
var DisallowedObjectProperties3 = /* @__PURE__ */ new Set([...Object.getOwnPropertyNames(Object.prototype).filter((name) => typeof Object.prototype[name] === "function"), "__proto__"]);
var isArray3 = Array.isArray;
function peek3(array22) {
  return array22[array22.length - 1];
}
function toNumber3(_) {
  return _ == null || _ === "" ? null : +_;
}
function array4(_) {
  return _ != null ? isArray3(_) ? _ : [_] : [];
}
function isFunction3(_) {
  return typeof _ === "function";
}
var DESCENDING2 = "descending";
function compare2(fields, orders, opt) {
  opt = opt || {};
  orders = array4(orders) || [];
  const ord = [], get23 = [], fmap = {}, gen = opt.comparator || comparator2;
  array4(fields).forEach((f, i) => {
    if (f == null)
      return;
    ord.push(orders[i] === DESCENDING2 ? -1 : 1);
    get23.push(f = isFunction3(f) ? f : field3(f, null, opt));
    (accessorFields2(f) || []).forEach((_) => fmap[_] = 1);
  });
  return get23.length === 0 ? null : accessor3(gen(get23, ord), Object.keys(fmap));
}
var ascending3 = (u4, v2) => (u4 < v2 || u4 == null) && v2 != null ? -1 : (u4 > v2 || v2 == null) && u4 != null ? 1 : (v2 = v2 instanceof Date ? +v2 : v2, u4 = u4 instanceof Date ? +u4 : u4) !== u4 && v2 === v2 ? -1 : v2 !== v2 && u4 === u4 ? 1 : 0;
var comparator2 = (fields, orders) => fields.length === 1 ? compare12(fields[0], orders[0]) : compareN2(fields, orders, fields.length);
var compare12 = (field25, order) => function(a4, b6) {
  return ascending3(field25(a4), field25(b6)) * order;
};
var compareN2 = (fields, orders, n) => {
  orders.push(0);
  return function(a4, b6) {
    let f, c5 = 0, i = -1;
    while (c5 === 0 && ++i < n) {
      f = fields[i];
      c5 = ascending3(f(a4), f(b6));
    }
    return c5 * orders[i];
  };
};
function constant4(_) {
  return isFunction3(_) ? _ : () => _;
}
function extend3(_) {
  for (let x9, k3, i = 1, len = arguments.length; i < len; ++i) {
    x9 = arguments[i];
    for (k3 in x9) {
      _[k3] = x9[k3];
    }
  }
  return _;
}
function extent3(array22, f) {
  let i = 0, n, v2, min5, max5;
  if (array22 && (n = array22.length)) {
    if (f == null) {
      for (v2 = array22[i]; i < n && (v2 == null || v2 !== v2); v2 = array22[++i])
        ;
      min5 = max5 = v2;
      for (; i < n; ++i) {
        v2 = array22[i];
        if (v2 != null) {
          if (v2 < min5)
            min5 = v2;
          if (v2 > max5)
            max5 = v2;
        }
      }
    } else {
      for (v2 = f(array22[i]); i < n && (v2 == null || v2 !== v2); v2 = f(array22[++i]))
        ;
      min5 = max5 = v2;
      for (; i < n; ++i) {
        v2 = f(array22[i]);
        if (v2 != null) {
          if (v2 < min5)
            min5 = v2;
          if (v2 > max5)
            max5 = v2;
        }
      }
    }
  }
  return [min5, max5];
}
function extentIndex2(array22, f) {
  const n = array22.length;
  let i = -1, a4, b6, c5, u4, v2;
  if (f == null) {
    while (++i < n) {
      b6 = array22[i];
      if (b6 != null && b6 >= b6) {
        a4 = c5 = b6;
        break;
      }
    }
    if (i === n)
      return [-1, -1];
    u4 = v2 = i;
    while (++i < n) {
      b6 = array22[i];
      if (b6 != null) {
        if (a4 > b6) {
          a4 = b6;
          u4 = i;
        }
        if (c5 < b6) {
          c5 = b6;
          v2 = i;
        }
      }
    }
  } else {
    while (++i < n) {
      b6 = f(array22[i], i, array22);
      if (b6 != null && b6 >= b6) {
        a4 = c5 = b6;
        break;
      }
    }
    if (i === n)
      return [-1, -1];
    u4 = v2 = i;
    while (++i < n) {
      b6 = f(array22[i], i, array22);
      if (b6 != null) {
        if (a4 > b6) {
          a4 = b6;
          u4 = i;
        }
        if (c5 < b6) {
          c5 = b6;
          v2 = i;
        }
      }
    }
  }
  return [u4, v2];
}
function has3(object2, property2) {
  return Object.hasOwn(object2, property2);
}
var NULL2 = {};
function fastmap2(input) {
  let obj = {}, test2;
  function has$1(key4) {
    return has3(obj, key4) && obj[key4] !== NULL2;
  }
  const map13 = {
    size: 0,
    empty: 0,
    object: obj,
    has: has$1,
    get(key4) {
      return has$1(key4) ? obj[key4] : void 0;
    },
    set(key4, value7) {
      if (!has$1(key4)) {
        ++map13.size;
        if (obj[key4] === NULL2)
          --map13.empty;
      }
      obj[key4] = value7;
      return this;
    },
    delete(key4) {
      if (has$1(key4)) {
        --map13.size;
        ++map13.empty;
        obj[key4] = NULL2;
      }
      return this;
    },
    clear() {
      map13.size = map13.empty = 0;
      map13.object = obj = {};
    },
    test(_) {
      if (arguments.length) {
        test2 = _;
        return map13;
      } else {
        return test2;
      }
    },
    clean() {
      const next = {};
      let size = 0;
      for (const key4 in obj) {
        const value7 = obj[key4];
        if (value7 !== NULL2 && (!test2 || !test2(value7))) {
          next[key4] = value7;
          ++size;
        }
      }
      map13.size = size;
      map13.empty = 0;
      map13.object = obj = next;
    }
  };
  if (input)
    Object.keys(input).forEach((key4) => {
      map13.set(key4, input[key4]);
    });
  return map13;
}
function inherits3(child, parent, members) {
  const proto = child.prototype = Object.create(parent.prototype);
  Object.defineProperty(proto, "constructor", {
    value: child,
    writable: true,
    enumerable: true,
    configurable: true
  });
  return extend3(proto, members);
}
function key2(fields, flat, opt) {
  if (fields) {
    fields = flat ? array4(fields).map((f) => f.replace(/\\(.)/g, "$1")) : array4(fields);
  }
  const len = fields && fields.length, gen = opt && opt.get || getter3, map13 = (f) => gen(flat ? [f] : splitAccessPath3(f));
  let fn;
  if (!len) {
    fn = function() {
      return "";
    };
  } else if (len === 1) {
    const get23 = map13(fields[0]);
    fn = function(_) {
      return "" + get23(_);
    };
  } else {
    const get23 = fields.map(map13);
    fn = function(_) {
      let s2 = "" + get23[0](_), i = 0;
      while (++i < len)
        s2 += "|" + get23[i](_);
      return s2;
    };
  }
  return accessor3(fn, fields, "key");
}
function merge3(compare10, array0, array1, output3) {
  const n0 = array0.length, n1 = array1.length;
  if (!n1)
    return array0;
  if (!n0)
    return array1;
  const merged = output3 || new array0.constructor(n0 + n1);
  let i0 = 0, i1 = 0, i = 0;
  for (; i0 < n0 && i1 < n1; ++i) {
    merged[i] = compare10(array0[i0], array1[i1]) > 0 ? array1[i1++] : array0[i0++];
  }
  for (; i0 < n0; ++i0, ++i) {
    merged[i] = array0[i0];
  }
  for (; i1 < n1; ++i1, ++i) {
    merged[i] = array1[i1];
  }
  return merged;
}
function span3(array22) {
  return array22 && peek3(array22) - array22[0] || 0;
}
function toSet3(_) {
  const s2 = {}, n = _.length;
  for (let i = 0; i < n; ++i)
    s2[_[i]] = true;
  return s2;
}

// node_modules/vega-statistics/build/vega-statistics.js
function* numbers2(values7, valueof) {
  if (valueof == null) {
    for (let value7 of values7) {
      if (value7 != null && value7 !== "" && (value7 = +value7) >= value7) {
        yield value7;
      }
    }
  } else {
    let index4 = -1;
    for (let value7 of values7) {
      value7 = valueof(value7, ++index4, values7);
      if (value7 != null && value7 !== "" && (value7 = +value7) >= value7) {
        yield value7;
      }
    }
  }
}
function quantiles(array22, p, f) {
  const values7 = Float64Array.from(numbers2(array22, f));
  values7.sort(ascending2);
  return p.map((_) => quantileSorted(values7, _));
}
function quartiles(array22, f) {
  return quantiles(array22, [0.25, 0.5, 0.75], f);
}
function estimateBandwidth(array22, f) {
  const n = array22.length, d = deviation(array22, f), q = quartiles(array22, f), h6 = (q[2] - q[0]) / 1.34, v2 = Math.min(d, h6) || d || Math.abs(q[0]) || 1;
  return 1.06 * v2 * Math.pow(n, -0.2);
}
function bin2(_) {
  const maxb = _.maxbins || 20, base = _.base || 10, logb = Math.log(base), div = _.divide || [5, 2];
  let min5 = _.extent[0], max5 = _.extent[1], step, level, minstep, v2, i, n;
  const span12 = _.span || max5 - min5 || Math.abs(min5) || 1;
  if (_.step) {
    step = _.step;
  } else if (_.steps) {
    v2 = span12 / maxb;
    for (i = 0, n = _.steps.length; i < n && _.steps[i] < v2; ++i)
      ;
    step = _.steps[Math.max(0, i - 1)];
  } else {
    level = Math.ceil(Math.log(maxb) / logb);
    minstep = _.minstep || 0;
    step = Math.max(minstep, Math.pow(base, Math.round(Math.log(span12) / logb) - level));
    while (Math.ceil(span12 / step) > maxb) {
      step *= base;
    }
    for (i = 0, n = div.length; i < n; ++i) {
      v2 = step / div[i];
      if (v2 >= minstep && span12 / v2 <= maxb)
        step = v2;
    }
  }
  v2 = Math.log(step);
  const precision = v2 >= 0 ? 0 : ~~(-v2 / logb) + 1, eps = Math.pow(base, -precision - 1);
  if (_.nice || _.nice === void 0) {
    v2 = Math.floor(min5 / step + eps) * step;
    min5 = min5 < v2 ? v2 - step : v2;
    max5 = Math.ceil(max5 / step) * step;
  }
  return {
    start: min5,
    stop: max5 === min5 ? min5 + step : max5,
    step
  };
}
var random = Math.random;
function setRandom(r) {
  random = r;
}
function bootstrapCI(array22, samples, alpha, f) {
  if (!array22.length)
    return [void 0, void 0];
  const values7 = Float64Array.from(numbers2(array22, f)), n = values7.length, m3 = samples;
  let a4, i, j, mu;
  for (j = 0, mu = Array(m3); j < m3; ++j) {
    for (a4 = 0, i = 0; i < n; ++i) {
      a4 += values7[~~(random() * n)];
    }
    mu[j] = a4 / n;
  }
  mu.sort(ascending2);
  return [quantile(mu, alpha / 2), quantile(mu, 1 - alpha / 2)];
}
function dotbin(array22, step, smooth, f) {
  f = f || ((_) => _);
  const n = array22.length, v2 = new Float64Array(n);
  let i = 0, j = 1, a4 = f(array22[0]), b6 = a4, w8 = a4 + step, x9;
  for (; j < n; ++j) {
    x9 = f(array22[j]);
    if (x9 >= w8) {
      b6 = (a4 + b6) / 2;
      for (; i < j; ++i)
        v2[i] = b6;
      w8 = x9 + step;
      a4 = x9;
    }
    b6 = x9;
  }
  b6 = (a4 + b6) / 2;
  for (; i < j; ++i)
    v2[i] = b6;
  return smooth ? smoothing(v2, step + step / 4) : v2;
}
function smoothing(v2, thresh) {
  const n = v2.length;
  let a4 = 0, b6 = 1, c5, d;
  while (v2[a4] === v2[b6])
    ++b6;
  while (b6 < n) {
    c5 = b6 + 1;
    while (v2[b6] === v2[c5])
      ++c5;
    if (v2[b6] - v2[b6 - 1] < thresh) {
      d = b6 + (a4 + c5 - b6 - b6 >> 1);
      while (d < b6)
        v2[d++] = v2[b6];
      while (d > b6)
        v2[d--] = v2[a4];
    }
    a4 = b6;
    b6 = c5;
  }
  return v2;
}
function lcg(seed) {
  return function() {
    seed = (1103515245 * seed + 12345) % 2147483647;
    return seed / 2147483647;
  };
}
function integer(min5, max5) {
  if (max5 == null) {
    max5 = min5;
    min5 = 0;
  }
  let a4, b6, d;
  const dist2 = {
    min(_) {
      if (arguments.length) {
        a4 = _ || 0;
        d = b6 - a4;
        return dist2;
      } else {
        return a4;
      }
    },
    max(_) {
      if (arguments.length) {
        b6 = _ || 0;
        d = b6 - a4;
        return dist2;
      } else {
        return b6;
      }
    },
    sample() {
      return a4 + Math.floor(d * random());
    },
    pdf(x9) {
      return x9 === Math.floor(x9) && x9 >= a4 && x9 < b6 ? 1 / d : 0;
    },
    cdf(x9) {
      const v2 = Math.floor(x9);
      return v2 < a4 ? 0 : v2 >= b6 ? 1 : (v2 - a4 + 1) / d;
    },
    icdf(p) {
      return p >= 0 && p <= 1 ? a4 - 1 + Math.floor(p * d) : NaN;
    }
  };
  return dist2.min(min5).max(max5);
}
var SQRT2PI = Math.sqrt(2 * Math.PI);
var SQRT2 = Math.SQRT2;
var nextSample = NaN;
function sampleNormal(mean2, stdev) {
  mean2 = mean2 || 0;
  stdev = stdev == null ? 1 : stdev;
  let x9 = 0, y9 = 0, rds, c5;
  if (nextSample === nextSample) {
    x9 = nextSample;
    nextSample = NaN;
  } else {
    do {
      x9 = random() * 2 - 1;
      y9 = random() * 2 - 1;
      rds = x9 * x9 + y9 * y9;
    } while (rds === 0 || rds > 1);
    c5 = Math.sqrt(-2 * Math.log(rds) / rds);
    x9 *= c5;
    nextSample = y9 * c5;
  }
  return mean2 + x9 * stdev;
}
function densityNormal(value7, mean2, stdev) {
  stdev = stdev == null ? 1 : stdev;
  const z = (value7 - (mean2 || 0)) / stdev;
  return Math.exp(-0.5 * z * z) / (stdev * SQRT2PI);
}
function cumulativeNormal(value7, mean2, stdev) {
  mean2 = mean2 || 0;
  stdev = stdev == null ? 1 : stdev;
  const z = (value7 - mean2) / stdev, Z = Math.abs(z);
  let cd2;
  if (Z > 37) {
    cd2 = 0;
  } else {
    const exp7 = Math.exp(-Z * Z / 2);
    let sum4;
    if (Z < 7.07106781186547) {
      sum4 = 0.0352624965998911 * Z + 0.700383064443688;
      sum4 = sum4 * Z + 6.37396220353165;
      sum4 = sum4 * Z + 33.912866078383;
      sum4 = sum4 * Z + 112.079291497871;
      sum4 = sum4 * Z + 221.213596169931;
      sum4 = sum4 * Z + 220.206867912376;
      cd2 = exp7 * sum4;
      sum4 = 0.0883883476483184 * Z + 1.75566716318264;
      sum4 = sum4 * Z + 16.064177579207;
      sum4 = sum4 * Z + 86.7807322029461;
      sum4 = sum4 * Z + 296.564248779674;
      sum4 = sum4 * Z + 637.333633378831;
      sum4 = sum4 * Z + 793.826512519948;
      sum4 = sum4 * Z + 440.413735824752;
      cd2 = cd2 / sum4;
    } else {
      sum4 = Z + 0.65;
      sum4 = Z + 4 / sum4;
      sum4 = Z + 3 / sum4;
      sum4 = Z + 2 / sum4;
      sum4 = Z + 1 / sum4;
      cd2 = exp7 / sum4 / 2.506628274631;
    }
  }
  return z > 0 ? 1 - cd2 : cd2;
}
function quantileNormal(p, mean2, stdev) {
  if (p < 0 || p > 1)
    return NaN;
  return (mean2 || 0) + (stdev == null ? 1 : stdev) * SQRT2 * erfinv(2 * p - 1);
}
function erfinv(x9) {
  let w8 = -Math.log((1 - x9) * (1 + x9)), p;
  if (w8 < 6.25) {
    w8 -= 3.125;
    p = -364441206401782e-35;
    p = -16850591381820166e-35 + p * w8;
    p = 128584807152564e-32 + p * w8;
    p = 11157877678025181e-33 + p * w8;
    p = -1333171662854621e-31 + p * w8;
    p = 20972767875968562e-33 + p * w8;
    p = 6637638134358324e-30 + p * w8;
    p = -4054566272975207e-29 + p * w8;
    p = -8151934197605472e-29 + p * w8;
    p = 26335093153082323e-28 + p * w8;
    p = -12975133253453532e-27 + p * w8;
    p = -5415412054294628e-26 + p * w8;
    p = 10512122733215323e-25 + p * w8;
    p = -4112633980346984e-24 + p * w8;
    p = -29070369957882005e-24 + p * w8;
    p = 42347877827932404e-23 + p * w8;
    p = -13654692000834679e-22 + p * w8;
    p = -13882523362786469e-21 + p * w8;
    p = 18673420803405714e-20 + p * w8;
    p = -740702534166267e-18 + p * w8;
    p = -0.006033670871430149 + p * w8;
    p = 0.24015818242558962 + p * w8;
    p = 1.6536545626831027 + p * w8;
  } else if (w8 < 16) {
    w8 = Math.sqrt(w8) - 3.25;
    p = 22137376921775787e-25;
    p = 9075656193888539e-23 + p * w8;
    p = -27517406297064545e-23 + p * w8;
    p = 18239629214389228e-24 + p * w8;
    p = 15027403968909828e-22 + p * w8;
    p = -4013867526981546e-21 + p * w8;
    p = 29234449089955446e-22 + p * w8;
    p = 12475304481671779e-21 + p * w8;
    p = -47318229009055734e-21 + p * w8;
    p = 6828485145957318e-20 + p * w8;
    p = 24031110387097894e-21 + p * w8;
    p = -3550375203628475e-19 + p * w8;
    p = 9532893797373805e-19 + p * w8;
    p = -0.0016882755560235047 + p * w8;
    p = 0.002491442096107851 + p * w8;
    p = -0.003751208507569241 + p * w8;
    p = 0.005370914553590064 + p * w8;
    p = 1.0052589676941592 + p * w8;
    p = 3.0838856104922208 + p * w8;
  } else if (Number.isFinite(w8)) {
    w8 = Math.sqrt(w8) - 5;
    p = -27109920616438573e-27;
    p = -2555641816996525e-25 + p * w8;
    p = 15076572693500548e-25 + p * w8;
    p = -3789465440126737e-24 + p * w8;
    p = 761570120807834e-23 + p * w8;
    p = -1496002662714924e-23 + p * w8;
    p = 2914795345090108e-23 + p * w8;
    p = -6771199775845234e-23 + p * w8;
    p = 22900482228026655e-23 + p * w8;
    p = -99298272942317e-20 + p * w8;
    p = 4526062597223154e-21 + p * w8;
    p = -1968177810553167e-20 + p * w8;
    p = 7599527703001776e-20 + p * w8;
    p = -21503011930044477e-20 + p * w8;
    p = -13871931833623122e-20 + p * w8;
    p = 1.0103004648645344 + p * w8;
    p = 4.849906401408584 + p * w8;
  } else {
    p = Infinity;
  }
  return p * x9;
}
function gaussian(mean2, stdev) {
  let mu, sigma;
  const dist2 = {
    mean(_) {
      if (arguments.length) {
        mu = _ || 0;
        return dist2;
      } else {
        return mu;
      }
    },
    stdev(_) {
      if (arguments.length) {
        sigma = _ == null ? 1 : _;
        return dist2;
      } else {
        return sigma;
      }
    },
    sample: () => sampleNormal(mu, sigma),
    pdf: (value7) => densityNormal(value7, mu, sigma),
    cdf: (value7) => cumulativeNormal(value7, mu, sigma),
    icdf: (p) => quantileNormal(p, mu, sigma)
  };
  return dist2.mean(mean2).stdev(stdev);
}
function kde(support, bandwidth2) {
  const kernel = gaussian();
  let n = 0;
  const dist2 = {
    data(_) {
      if (arguments.length) {
        support = _;
        n = _ ? _.length : 0;
        return dist2.bandwidth(bandwidth2);
      } else {
        return support;
      }
    },
    bandwidth(_) {
      if (!arguments.length)
        return bandwidth2;
      bandwidth2 = _;
      if (!bandwidth2 && support)
        bandwidth2 = estimateBandwidth(support);
      return dist2;
    },
    sample() {
      return support[~~(random() * n)] + bandwidth2 * kernel.sample();
    },
    pdf(x9) {
      let y9 = 0, i = 0;
      for (; i < n; ++i) {
        y9 += kernel.pdf((x9 - support[i]) / bandwidth2);
      }
      return y9 / bandwidth2 / n;
    },
    cdf(x9) {
      let y9 = 0, i = 0;
      for (; i < n; ++i) {
        y9 += kernel.cdf((x9 - support[i]) / bandwidth2);
      }
      return y9 / n;
    },
    icdf() {
      throw Error("KDE icdf not supported.");
    }
  };
  return dist2.data(support);
}
function sampleLogNormal(mean2, stdev) {
  mean2 = mean2 || 0;
  stdev = stdev == null ? 1 : stdev;
  return Math.exp(mean2 + sampleNormal() * stdev);
}
function densityLogNormal(value7, mean2, stdev) {
  if (value7 <= 0)
    return 0;
  mean2 = mean2 || 0;
  stdev = stdev == null ? 1 : stdev;
  const z = (Math.log(value7) - mean2) / stdev;
  return Math.exp(-0.5 * z * z) / (stdev * SQRT2PI * value7);
}
function cumulativeLogNormal(value7, mean2, stdev) {
  return cumulativeNormal(Math.log(value7), mean2, stdev);
}
function quantileLogNormal(p, mean2, stdev) {
  return Math.exp(quantileNormal(p, mean2, stdev));
}
function lognormal(mean2, stdev) {
  let mu, sigma;
  const dist2 = {
    mean(_) {
      if (arguments.length) {
        mu = _ || 0;
        return dist2;
      } else {
        return mu;
      }
    },
    stdev(_) {
      if (arguments.length) {
        sigma = _ == null ? 1 : _;
        return dist2;
      } else {
        return sigma;
      }
    },
    sample: () => sampleLogNormal(mu, sigma),
    pdf: (value7) => densityLogNormal(value7, mu, sigma),
    cdf: (value7) => cumulativeLogNormal(value7, mu, sigma),
    icdf: (p) => quantileLogNormal(p, mu, sigma)
  };
  return dist2.mean(mean2).stdev(stdev);
}
function mixture(dists, weights) {
  let m3 = 0, w8;
  function normalize4(x9) {
    const w9 = [];
    let sum4 = 0, i;
    for (i = 0; i < m3; ++i) {
      sum4 += w9[i] = x9[i] == null ? 1 : +x9[i];
    }
    for (i = 0; i < m3; ++i) {
      w9[i] /= sum4;
    }
    return w9;
  }
  const dist2 = {
    weights(_) {
      if (arguments.length) {
        w8 = normalize4(weights = _ || []);
        return dist2;
      }
      return weights;
    },
    distributions(_) {
      if (arguments.length) {
        if (_) {
          m3 = _.length;
          dists = _;
        } else {
          m3 = 0;
          dists = [];
        }
        return dist2.weights(weights);
      }
      return dists;
    },
    sample() {
      const r = random();
      let d = dists[m3 - 1], v2 = w8[0], i = 0;
      for (; i < m3 - 1; v2 += w8[++i]) {
        if (r < v2) {
          d = dists[i];
          break;
        }
      }
      return d.sample();
    },
    pdf(x9) {
      let p = 0, i = 0;
      for (; i < m3; ++i) {
        p += w8[i] * dists[i].pdf(x9);
      }
      return p;
    },
    cdf(x9) {
      let p = 0, i = 0;
      for (; i < m3; ++i) {
        p += w8[i] * dists[i].cdf(x9);
      }
      return p;
    },
    icdf() {
      throw Error("Mixture icdf not supported.");
    }
  };
  return dist2.distributions(dists).weights(weights);
}
function sampleUniform(min5, max5) {
  if (max5 == null) {
    max5 = min5 == null ? 1 : min5;
    min5 = 0;
  }
  return min5 + (max5 - min5) * random();
}
function densityUniform(value7, min5, max5) {
  if (max5 == null) {
    max5 = min5 == null ? 1 : min5;
    min5 = 0;
  }
  return value7 >= min5 && value7 <= max5 ? 1 / (max5 - min5) : 0;
}
function cumulativeUniform(value7, min5, max5) {
  if (max5 == null) {
    max5 = min5 == null ? 1 : min5;
    min5 = 0;
  }
  return value7 < min5 ? 0 : value7 > max5 ? 1 : (value7 - min5) / (max5 - min5);
}
function quantileUniform(p, min5, max5) {
  if (max5 == null) {
    max5 = min5 == null ? 1 : min5;
    min5 = 0;
  }
  return p >= 0 && p <= 1 ? min5 + p * (max5 - min5) : NaN;
}
function uniform(min5, max5) {
  let a4, b6;
  const dist2 = {
    min(_) {
      if (arguments.length) {
        a4 = _ || 0;
        return dist2;
      } else {
        return a4;
      }
    },
    max(_) {
      if (arguments.length) {
        b6 = _ == null ? 1 : _;
        return dist2;
      } else {
        return b6;
      }
    },
    sample: () => sampleUniform(a4, b6),
    pdf: (value7) => densityUniform(value7, a4, b6),
    cdf: (value7) => cumulativeUniform(value7, a4, b6),
    icdf: (p) => quantileUniform(p, a4, b6)
  };
  if (max5 == null) {
    max5 = min5 == null ? 1 : min5;
    min5 = 0;
  }
  return dist2.min(min5).max(max5);
}
function constant5(data3, x9, y9) {
  let mean2 = 0, n = 0;
  for (const d of data3) {
    const val = y9(d);
    if (x9(d) == null || val == null || isNaN(val))
      continue;
    mean2 += (val - mean2) / ++n;
  }
  return {
    coef: [mean2],
    predict: () => mean2,
    rSquared: 0
  };
}
function ols(uX, uY, uXY, uX2) {
  const delta = uX2 - uX * uX, slope = Math.abs(delta) < 1e-24 ? 0 : (uXY - uX * uY) / delta, intercept = uY - slope * uX;
  return [intercept, slope];
}
function points(data3, x9, y9, sort4) {
  data3 = data3.filter((d2) => {
    let u4 = x9(d2), v2 = y9(d2);
    return u4 != null && (u4 = +u4) >= u4 && v2 != null && (v2 = +v2) >= v2;
  });
  if (sort4) {
    data3.sort((a4, b6) => x9(a4) - x9(b6));
  }
  const n = data3.length, X4 = new Float64Array(n), Y4 = new Float64Array(n);
  let i = 0, ux = 0, uy = 0, xv, yv, d;
  for (d of data3) {
    X4[i] = xv = +x9(d);
    Y4[i] = yv = +y9(d);
    ++i;
    ux += (xv - ux) / i;
    uy += (yv - uy) / i;
  }
  for (i = 0; i < n; ++i) {
    X4[i] -= ux;
    Y4[i] -= uy;
  }
  return [X4, Y4, ux, uy];
}
function visitPoints(data3, x9, y9, callback) {
  let i = -1, u4, v2;
  for (const d of data3) {
    u4 = x9(d);
    v2 = y9(d);
    if (u4 != null && (u4 = +u4) >= u4 && v2 != null && (v2 = +v2) >= v2) {
      callback(u4, v2, ++i);
    }
  }
}
function rSquared(data3, x9, y9, uY, predict) {
  let SSE = 0, SST = 0;
  visitPoints(data3, x9, y9, (dx, dy) => {
    const sse = dy - predict(dx), sst = dy - uY;
    SSE += sse * sse;
    SST += sst * sst;
  });
  return 1 - SSE / SST;
}
function linear(data3, x9, y9) {
  let X4 = 0, Y4 = 0, XY = 0, X24 = 0, n = 0;
  visitPoints(data3, x9, y9, (dx, dy) => {
    ++n;
    X4 += (dx - X4) / n;
    Y4 += (dy - Y4) / n;
    XY += (dx * dy - XY) / n;
    X24 += (dx * dx - X24) / n;
  });
  const coef = ols(X4, Y4, XY, X24), predict = (x10) => coef[0] + coef[1] * x10;
  return {
    coef,
    predict,
    rSquared: rSquared(data3, x9, y9, Y4, predict)
  };
}
function log2(data3, x9, y9) {
  let X4 = 0, Y4 = 0, XY = 0, X24 = 0, n = 0;
  visitPoints(data3, x9, y9, (dx, dy) => {
    ++n;
    dx = Math.log(dx);
    X4 += (dx - X4) / n;
    Y4 += (dy - Y4) / n;
    XY += (dx * dy - XY) / n;
    X24 += (dx * dx - X24) / n;
  });
  const coef = ols(X4, Y4, XY, X24), predict = (x10) => coef[0] + coef[1] * Math.log(x10);
  return {
    coef,
    predict,
    rSquared: rSquared(data3, x9, y9, Y4, predict)
  };
}
function exp2(data3, x9, y9) {
  const [xv, yv, ux, uy] = points(data3, x9, y9);
  let YL = 0, XY = 0, XYL = 0, X2Y = 0, n = 0, dx, ly6, xy;
  visitPoints(data3, x9, y9, (_, dy) => {
    dx = xv[n++];
    ly6 = Math.log(dy);
    xy = dx * dy;
    YL += (dy * ly6 - YL) / n;
    XY += (xy - XY) / n;
    XYL += (xy * ly6 - XYL) / n;
    X2Y += (dx * xy - X2Y) / n;
  });
  const [c0, c1] = ols(XY / uy, YL / uy, XYL / uy, X2Y / uy), predict = (x10) => Math.exp(c0 + c1 * (x10 - ux));
  return {
    coef: [Math.exp(c0 - c1 * ux), c1],
    predict,
    rSquared: rSquared(data3, x9, y9, uy, predict)
  };
}
function pow2(data3, x9, y9) {
  let X4 = 0, Y4 = 0, XY = 0, X24 = 0, YS = 0, n = 0;
  visitPoints(data3, x9, y9, (dx, dy) => {
    const lx6 = Math.log(dx), ly6 = Math.log(dy);
    ++n;
    X4 += (lx6 - X4) / n;
    Y4 += (ly6 - Y4) / n;
    XY += (lx6 * ly6 - XY) / n;
    X24 += (lx6 * lx6 - X24) / n;
    YS += (dy - YS) / n;
  });
  const coef = ols(X4, Y4, XY, X24), predict = (x10) => coef[0] * Math.pow(x10, coef[1]);
  coef[0] = Math.exp(coef[0]);
  return {
    coef,
    predict,
    rSquared: rSquared(data3, x9, y9, YS, predict)
  };
}
function quad(data3, x9, y9) {
  const [xv, yv, ux, uy] = points(data3, x9, y9), n = xv.length;
  let X24 = 0, X32 = 0, X4 = 0, XY = 0, X2Y = 0, i, dx, dy, x22;
  for (i = 0; i < n; ) {
    dx = xv[i];
    dy = yv[i++];
    x22 = dx * dx;
    X24 += (x22 - X24) / i;
    X32 += (x22 * dx - X32) / i;
    X4 += (x22 * x22 - X4) / i;
    XY += (dx * dy - XY) / i;
    X2Y += (x22 * dy - X2Y) / i;
  }
  const X2X2 = X4 - X24 * X24, d = X24 * X2X2 - X32 * X32, a4 = (X2Y * X24 - XY * X32) / d, b6 = (XY * X2X2 - X2Y * X32) / d, c5 = -a4 * X24, predict = (x10) => {
    x10 = x10 - ux;
    return a4 * x10 * x10 + b6 * x10 + c5 + uy;
  };
  return {
    coef: [c5 - b6 * ux + a4 * ux * ux + uy, b6 - 2 * a4 * ux, a4],
    predict,
    rSquared: rSquared(data3, x9, y9, uy, predict)
  };
}
function poly(data3, x9, y9, order) {
  if (order === 0)
    return constant5(data3, x9, y9);
  if (order === 1)
    return linear(data3, x9, y9);
  if (order === 2)
    return quad(data3, x9, y9);
  const [xv, yv, ux, uy] = points(data3, x9, y9), n = xv.length, lhs = [], rhs = [], k3 = order + 1;
  let i, j, l, v2, c5;
  for (i = 0; i < k3; ++i) {
    for (l = 0, v2 = 0; l < n; ++l) {
      v2 += Math.pow(xv[l], i) * yv[l];
    }
    lhs.push(v2);
    c5 = new Float64Array(k3);
    for (j = 0; j < k3; ++j) {
      for (l = 0, v2 = 0; l < n; ++l) {
        v2 += Math.pow(xv[l], i + j);
      }
      c5[j] = v2;
    }
    rhs.push(c5);
  }
  rhs.push(lhs);
  const coef = gaussianElimination(rhs), predict = (x10) => {
    x10 -= ux;
    let y10 = uy + coef[0] + coef[1] * x10 + coef[2] * x10 * x10;
    for (i = 3; i < k3; ++i)
      y10 += coef[i] * Math.pow(x10, i);
    return y10;
  };
  return {
    coef: uncenter(k3, coef, -ux, uy),
    predict,
    rSquared: rSquared(data3, x9, y9, uy, predict)
  };
}
function uncenter(k3, a4, x9, y9) {
  const z = Array(k3);
  let i, j, v2, c5;
  for (i = 0; i < k3; ++i)
    z[i] = 0;
  for (i = k3 - 1; i >= 0; --i) {
    v2 = a4[i];
    c5 = 1;
    z[i] += v2;
    for (j = 1; j <= i; ++j) {
      c5 *= (i + 1 - j) / j;
      z[i - j] += v2 * Math.pow(x9, j) * c5;
    }
  }
  z[0] += y9;
  return z;
}
function gaussianElimination(matrix) {
  const n = matrix.length - 1, coef = [];
  let i, j, k3, r, t;
  for (i = 0; i < n; ++i) {
    r = i;
    for (j = i + 1; j < n; ++j) {
      if (Math.abs(matrix[i][j]) > Math.abs(matrix[i][r])) {
        r = j;
      }
    }
    for (k3 = i; k3 < n + 1; ++k3) {
      t = matrix[k3][i];
      matrix[k3][i] = matrix[k3][r];
      matrix[k3][r] = t;
    }
    for (j = i + 1; j < n; ++j) {
      for (k3 = n; k3 >= i; k3--) {
        matrix[k3][j] -= matrix[k3][i] * matrix[i][j] / matrix[i][i];
      }
    }
  }
  for (j = n - 1; j >= 0; --j) {
    t = 0;
    for (k3 = j + 1; k3 < n; ++k3) {
      t += matrix[k3][j] * coef[k3];
    }
    coef[j] = (matrix[n][j] - t) / matrix[j][j];
  }
  return coef;
}
var maxiters = 2;
var epsilon = 1e-12;
function loess(data3, x9, y9, bandwidth2) {
  const [xv, yv, ux, uy] = points(data3, x9, y9, true), n = xv.length, bw = Math.max(2, ~~(bandwidth2 * n)), yhat = new Float64Array(n), residuals = new Float64Array(n), robustWeights = new Float64Array(n).fill(1);
  for (let iter = -1; ++iter <= maxiters; ) {
    const interval3 = [0, bw - 1];
    for (let i = 0; i < n; ++i) {
      const dx = xv[i], i0 = interval3[0], i1 = interval3[1], edge = dx - xv[i0] > xv[i1] - dx ? i0 : i1;
      let W = 0, X4 = 0, Y4 = 0, XY = 0, X24 = 0;
      const denom = 1 / Math.abs(xv[edge] - dx || 1);
      for (let k3 = i0; k3 <= i1; ++k3) {
        const xk = xv[k3], yk = yv[k3], w8 = tricube(Math.abs(dx - xk) * denom) * robustWeights[k3], xkw = xk * w8;
        W += w8;
        X4 += xkw;
        Y4 += yk * w8;
        XY += yk * xkw;
        X24 += xk * xkw;
      }
      const [a4, b6] = ols(X4 / W, Y4 / W, XY / W, X24 / W);
      yhat[i] = a4 + b6 * dx;
      residuals[i] = Math.abs(yv[i] - yhat[i]);
      updateInterval(xv, i + 1, interval3);
    }
    if (iter === maxiters) {
      break;
    }
    const medianResidual = median(residuals);
    if (Math.abs(medianResidual) < epsilon)
      break;
    for (let i = 0, arg, w8; i < n; ++i) {
      arg = residuals[i] / (6 * medianResidual);
      robustWeights[i] = arg >= 1 ? epsilon : (w8 = 1 - arg * arg) * w8;
    }
  }
  return output(xv, yhat, ux, uy);
}
function tricube(x9) {
  return (x9 = 1 - x9 * x9 * x9) * x9 * x9;
}
function updateInterval(xv, i, interval3) {
  const val = xv[i];
  let left = interval3[0], right = interval3[1] + 1;
  if (right >= xv.length)
    return;
  while (i > left && xv[right] - val <= val - xv[left]) {
    interval3[0] = ++left;
    interval3[1] = right;
    ++right;
  }
}
function output(xv, yhat, ux, uy) {
  const n = xv.length, out = [];
  let i = 0, cnt = 0, prev = [], v2;
  for (; i < n; ++i) {
    v2 = xv[i] + ux;
    if (prev[0] === v2) {
      prev[1] += (yhat[i] - prev[1]) / ++cnt;
    } else {
      cnt = 0;
      prev[1] += uy;
      prev = [v2, yhat[i]];
      out.push(prev);
    }
  }
  prev[1] += uy;
  return out;
}
var MIN_RADIANS = 0.5 * Math.PI / 180;
function sampleCurve(f, extent8, minSteps, maxSteps) {
  minSteps = minSteps || 25;
  maxSteps = Math.max(minSteps, maxSteps || 200);
  const point21 = (x9) => [x9, f(x9)], minX = extent8[0], maxX = extent8[1], span12 = maxX - minX, stop2 = span12 / maxSteps, prev = [point21(minX)], next = [];
  if (minSteps === maxSteps) {
    for (let i = 1; i < maxSteps; ++i) {
      prev.push(point21(minX + i / minSteps * span12));
    }
    prev.push(point21(maxX));
    return prev;
  } else {
    next.push(point21(maxX));
    for (let i = minSteps; --i > 0; ) {
      next.push(point21(minX + i / minSteps * span12));
    }
  }
  let p02 = prev[0];
  let p1 = next[next.length - 1];
  const sx = 1 / span12;
  const sy = scaleY(p02[1], next);
  while (p1) {
    const pm = point21((p02[0] + p1[0]) / 2);
    const dx = pm[0] - p02[0] >= stop2;
    if (dx && angleDelta(p02, pm, p1, sx, sy) > MIN_RADIANS) {
      next.push(pm);
    } else {
      p02 = p1;
      prev.push(p1);
      next.pop();
    }
    p1 = next[next.length - 1];
  }
  return prev;
}
function scaleY(init2, points2) {
  let ymin = init2;
  let ymax = init2;
  const n = points2.length;
  for (let i = 0; i < n; ++i) {
    const y9 = points2[i][1];
    if (y9 < ymin)
      ymin = y9;
    if (y9 > ymax)
      ymax = y9;
  }
  return 1 / (ymax - ymin);
}
function angleDelta(p, q, r, sx, sy) {
  const a0 = Math.atan2(sy * (r[1] - p[1]), sx * (r[0] - p[0])), a1 = Math.atan2(sy * (q[1] - p[1]), sx * (q[0] - p[0]));
  return Math.abs(a0 - a1);
}

// node_modules/vega-transforms/node_modules/vega-time/build/vega-time.js
var YEAR2 = "year";
var QUARTER2 = "quarter";
var MONTH2 = "month";
var WEEK2 = "week";
var DATE2 = "date";
var DAY2 = "day";
var DAYOFYEAR2 = "dayofyear";
var HOURS2 = "hours";
var MINUTES2 = "minutes";
var SECONDS2 = "seconds";
var MILLISECONDS2 = "milliseconds";
var TIME_UNITS2 = [YEAR2, QUARTER2, MONTH2, WEEK2, DATE2, DAY2, DAYOFYEAR2, HOURS2, MINUTES2, SECONDS2, MILLISECONDS2];
var UNITS2 = TIME_UNITS2.reduce((o, u4, i) => (o[u4] = 1 + i, o), {});
function timeUnits(units) {
  const u4 = array4(units).slice(), m3 = {};
  if (!u4.length)
    error3("Missing time unit.");
  u4.forEach((unit2) => {
    if (has3(UNITS2, unit2)) {
      m3[unit2] = 1;
    } else {
      error3(`Invalid time unit: ${unit2}.`);
    }
  });
  const numTypes = (m3[WEEK2] || m3[DAY2] ? 1 : 0) + (m3[QUARTER2] || m3[MONTH2] || m3[DATE2] ? 1 : 0) + (m3[DAYOFYEAR2] ? 1 : 0);
  if (numTypes > 1) {
    error3(`Incompatible time units: ${units}`);
  }
  u4.sort((a4, b6) => UNITS2[a4] - UNITS2[b6]);
  return u4;
}
var defaultSpecifiers2 = {
  [YEAR2]: "%Y ",
  [QUARTER2]: "Q%q ",
  [MONTH2]: "%b ",
  [DATE2]: "%d ",
  [WEEK2]: "W%U ",
  [DAY2]: "%a ",
  [DAYOFYEAR2]: "%j ",
  [HOURS2]: "%H:00",
  [MINUTES2]: "00:%M",
  [SECONDS2]: ":%S",
  [MILLISECONDS2]: ".%L",
  [`${YEAR2}-${MONTH2}`]: "%Y-%m ",
  [`${YEAR2}-${MONTH2}-${DATE2}`]: "%Y-%m-%d ",
  [`${HOURS2}-${MINUTES2}`]: "%H:%M"
};
var t03 = /* @__PURE__ */ new Date();
function localYear2(y9) {
  t03.setFullYear(y9);
  t03.setMonth(0);
  t03.setDate(1);
  t03.setHours(0, 0, 0, 0);
  return t03;
}
function localDayOfYear2(d) {
  return timeDay.count(localYear2(d.getFullYear()) - 1, d);
}
function localWeekNum2(d) {
  return timeSunday.count(localYear2(d.getFullYear()) - 1, d);
}
function localFirst2(y9) {
  return localYear2(y9).getDay();
}
function localDate2(y9, m3, d, H, M2, S, L) {
  if (0 <= y9 && y9 < 100) {
    const date2 = new Date(-1, m3, d, H, M2, S, L);
    date2.setFullYear(y9);
    return date2;
  }
  return new Date(y9, m3, d, H, M2, S, L);
}
function utcDayOfYear2(d) {
  const y9 = Date.UTC(d.getUTCFullYear(), 0, 1);
  return utcDay.count(y9 - 1, d);
}
function utcWeekNum2(d) {
  const y9 = Date.UTC(d.getUTCFullYear(), 0, 1);
  return utcSunday.count(y9 - 1, d);
}
function utcFirst2(y9) {
  t03.setTime(Date.UTC(y9, 0, 1));
  return t03.getUTCDay();
}
function utcDate2(y9, m3, d, H, M2, S, L) {
  if (0 <= y9 && y9 < 100) {
    const date2 = new Date(Date.UTC(-1, m3, d, H, M2, S, L));
    date2.setUTCFullYear(d.y);
    return date2;
  }
  return new Date(Date.UTC(y9, m3, d, H, M2, S, L));
}
function floor(units, step, get23, inv, newDate2) {
  const s2 = step || 1, b6 = peek3(units), _ = (unit2, p, key4) => {
    key4 = key4 || unit2;
    return getUnit(get23[key4], inv[key4], unit2 === b6 && s2, p);
  };
  const t = /* @__PURE__ */ new Date(), u4 = toSet3(units), y9 = u4[YEAR2] ? _(YEAR2) : constant4(2012), m3 = u4[MONTH2] ? _(MONTH2) : u4[QUARTER2] ? _(QUARTER2) : zero4, d = u4[WEEK2] && u4[DAY2] ? _(DAY2, 1, WEEK2 + DAY2) : u4[WEEK2] ? _(WEEK2, 1) : u4[DAY2] ? _(DAY2, 1) : u4[DATE2] ? _(DATE2, 1) : u4[DAYOFYEAR2] ? _(DAYOFYEAR2, 1) : one3, H = u4[HOURS2] ? _(HOURS2) : zero4, M2 = u4[MINUTES2] ? _(MINUTES2) : zero4, S = u4[SECONDS2] ? _(SECONDS2) : zero4, L = u4[MILLISECONDS2] ? _(MILLISECONDS2) : zero4;
  return function(v2) {
    t.setTime(+v2);
    const year = y9(t);
    return newDate2(year, m3(t), d(t, year), H(t), M2(t), S(t), L(t));
  };
}
function getUnit(f, inv, step, phase) {
  const u4 = step <= 1 ? f : phase ? (d, y9) => phase + step * Math.floor((f(d, y9) - phase) / step) : (d, y9) => step * Math.floor(f(d, y9) / step);
  return inv ? (d, y9) => inv(u4(d, y9), y9) : u4;
}
function weekday2(week3, day, firstDay) {
  return day + week3 * 7 - (firstDay + 6) % 7;
}
var localGet2 = {
  [YEAR2]: (d) => d.getFullYear(),
  [QUARTER2]: (d) => Math.floor(d.getMonth() / 3),
  [MONTH2]: (d) => d.getMonth(),
  [DATE2]: (d) => d.getDate(),
  [HOURS2]: (d) => d.getHours(),
  [MINUTES2]: (d) => d.getMinutes(),
  [SECONDS2]: (d) => d.getSeconds(),
  [MILLISECONDS2]: (d) => d.getMilliseconds(),
  [DAYOFYEAR2]: (d) => localDayOfYear2(d),
  [WEEK2]: (d) => localWeekNum2(d),
  [WEEK2 + DAY2]: (d, y9) => weekday2(localWeekNum2(d), d.getDay(), localFirst2(y9)),
  [DAY2]: (d, y9) => weekday2(1, d.getDay(), localFirst2(y9))
};
var localInv2 = {
  [QUARTER2]: (q) => 3 * q,
  [WEEK2]: (w8, y9) => weekday2(w8, 0, localFirst2(y9))
};
function timeFloor(units, step) {
  return floor(units, step || 1, localGet2, localInv2, localDate2);
}
var utcGet2 = {
  [YEAR2]: (d) => d.getUTCFullYear(),
  [QUARTER2]: (d) => Math.floor(d.getUTCMonth() / 3),
  [MONTH2]: (d) => d.getUTCMonth(),
  [DATE2]: (d) => d.getUTCDate(),
  [HOURS2]: (d) => d.getUTCHours(),
  [MINUTES2]: (d) => d.getUTCMinutes(),
  [SECONDS2]: (d) => d.getUTCSeconds(),
  [MILLISECONDS2]: (d) => d.getUTCMilliseconds(),
  [DAYOFYEAR2]: (d) => utcDayOfYear2(d),
  [WEEK2]: (d) => utcWeekNum2(d),
  [DAY2]: (d, y9) => weekday2(1, d.getUTCDay(), utcFirst2(y9)),
  [WEEK2 + DAY2]: (d, y9) => weekday2(utcWeekNum2(d), d.getUTCDay(), utcFirst2(y9))
};
var utcInv2 = {
  [QUARTER2]: (q) => 3 * q,
  [WEEK2]: (w8, y9) => weekday2(w8, 0, utcFirst2(y9))
};
function utcFloor(units, step) {
  return floor(units, step || 1, utcGet2, utcInv2, utcDate2);
}
var timeIntervals2 = {
  [YEAR2]: timeYear,
  [QUARTER2]: timeMonth.every(3),
  [MONTH2]: timeMonth,
  [WEEK2]: timeSunday,
  [DATE2]: timeDay,
  [DAY2]: timeDay,
  [DAYOFYEAR2]: timeDay,
  [HOURS2]: timeHour,
  [MINUTES2]: timeMinute,
  [SECONDS2]: second,
  [MILLISECONDS2]: millisecond
};
var utcIntervals2 = {
  [YEAR2]: utcYear,
  [QUARTER2]: utcMonth.every(3),
  [MONTH2]: utcMonth,
  [WEEK2]: utcSunday,
  [DATE2]: utcDay,
  [DAY2]: utcDay,
  [DAYOFYEAR2]: utcDay,
  [HOURS2]: utcHour,
  [MINUTES2]: utcMinute,
  [SECONDS2]: second,
  [MILLISECONDS2]: millisecond
};
function timeInterval3(unit2) {
  return timeIntervals2[unit2];
}
function utcInterval2(unit2) {
  return utcIntervals2[unit2];
}
var durationSecond3 = 1e3;
var durationMinute3 = durationSecond3 * 60;
var durationHour3 = durationMinute3 * 60;
var durationDay3 = durationHour3 * 24;
var durationWeek3 = durationDay3 * 7;
var durationMonth3 = durationDay3 * 30;
var durationYear3 = durationDay3 * 365;
var Milli2 = [YEAR2, MONTH2, DATE2, HOURS2, MINUTES2, SECONDS2, MILLISECONDS2];
var Seconds2 = Milli2.slice(0, -1);
var Minutes2 = Seconds2.slice(0, -1);
var Hours2 = Minutes2.slice(0, -1);
var Day2 = Hours2.slice(0, -1);
var Week2 = [YEAR2, WEEK2];
var Month2 = [YEAR2, MONTH2];
var Year2 = [YEAR2];
var intervals2 = [[Seconds2, 1, durationSecond3], [Seconds2, 5, 5 * durationSecond3], [Seconds2, 15, 15 * durationSecond3], [Seconds2, 30, 30 * durationSecond3], [Minutes2, 1, durationMinute3], [Minutes2, 5, 5 * durationMinute3], [Minutes2, 15, 15 * durationMinute3], [Minutes2, 30, 30 * durationMinute3], [Hours2, 1, durationHour3], [Hours2, 3, 3 * durationHour3], [Hours2, 6, 6 * durationHour3], [Hours2, 12, 12 * durationHour3], [Day2, 1, durationDay3], [Week2, 1, durationWeek3], [Month2, 1, durationMonth3], [Month2, 3, 3 * durationMonth3], [Year2, 1, durationYear3]];
function bin3(opt) {
  const ext = opt.extent, max5 = opt.maxbins || 40, target2 = Math.abs(span3(ext)) / max5;
  let i = bisector((i2) => i2[2]).right(intervals2, target2), units, step;
  if (i === intervals2.length) {
    units = Year2, step = tickStep(ext[0] / durationYear3, ext[1] / durationYear3, max5);
  } else if (i) {
    i = intervals2[target2 / intervals2[i - 1][2] < intervals2[i][2] / target2 ? i - 1 : i];
    units = i[0];
    step = i[1];
  } else {
    units = Milli2;
    step = Math.max(tickStep(ext[0], ext[1], max5), 1);
  }
  return {
    units,
    step
  };
}

// node_modules/vega-transforms/build/vega-transforms.js
function multikey(f) {
  return (x9) => {
    const n = f.length;
    let i = 1, k3 = String(f[0](x9));
    for (; i < n; ++i) {
      k3 += "|" + f[i](x9);
    }
    return k3;
  };
}
function groupkey(fields) {
  return !fields || !fields.length ? function() {
    return "";
  } : fields.length === 1 ? fields[0] : multikey(fields);
}
function measureName(op, field25, as) {
  return as || op + (!field25 ? "" : "_" + field25);
}
var noop = () => {
};
var base_op = {
  init: noop,
  add: noop,
  rem: noop,
  idx: 0
};
var AggregateOps = {
  values: {
    init: (m3) => m3.cell.store = true,
    value: (m3) => m3.cell.data.values(),
    idx: -1
  },
  count: {
    value: (m3) => m3.cell.num
  },
  __count__: {
    value: (m3) => m3.missing + m3.valid
  },
  missing: {
    value: (m3) => m3.missing
  },
  valid: {
    value: (m3) => m3.valid
  },
  sum: {
    init: (m3) => m3.sum = 0,
    value: (m3) => m3.valid ? m3.sum : void 0,
    add: (m3, v2) => m3.sum += +v2,
    rem: (m3, v2) => m3.sum -= v2
  },
  product: {
    init: (m3) => m3.product = 1,
    value: (m3) => m3.valid ? m3.product : void 0,
    add: (m3, v2) => m3.product *= v2,
    rem: (m3, v2) => m3.product /= v2
  },
  mean: {
    init: (m3) => m3.mean = 0,
    value: (m3) => m3.valid ? m3.mean : void 0,
    add: (m3, v2) => (m3.mean_d = v2 - m3.mean, m3.mean += m3.mean_d / m3.valid),
    rem: (m3, v2) => (m3.mean_d = v2 - m3.mean, m3.mean -= m3.valid ? m3.mean_d / m3.valid : m3.mean)
  },
  average: {
    value: (m3) => m3.valid ? m3.mean : void 0,
    req: ["mean"],
    idx: 1
  },
  variance: {
    init: (m3) => m3.dev = 0,
    value: (m3) => m3.valid > 1 ? m3.dev / (m3.valid - 1) : void 0,
    add: (m3, v2) => m3.dev += m3.mean_d * (v2 - m3.mean),
    rem: (m3, v2) => m3.dev -= m3.mean_d * (v2 - m3.mean),
    req: ["mean"],
    idx: 1
  },
  variancep: {
    value: (m3) => m3.valid > 1 ? m3.dev / m3.valid : void 0,
    req: ["variance"],
    idx: 2
  },
  stdev: {
    value: (m3) => m3.valid > 1 ? Math.sqrt(m3.dev / (m3.valid - 1)) : void 0,
    req: ["variance"],
    idx: 2
  },
  stdevp: {
    value: (m3) => m3.valid > 1 ? Math.sqrt(m3.dev / m3.valid) : void 0,
    req: ["variance"],
    idx: 2
  },
  stderr: {
    value: (m3) => m3.valid > 1 ? Math.sqrt(m3.dev / (m3.valid * (m3.valid - 1))) : void 0,
    req: ["variance"],
    idx: 2
  },
  distinct: {
    value: (m3) => m3.cell.data.distinct(m3.get),
    req: ["values"],
    idx: 3
  },
  ci0: {
    value: (m3) => m3.cell.data.ci0(m3.get),
    req: ["values"],
    idx: 3
  },
  ci1: {
    value: (m3) => m3.cell.data.ci1(m3.get),
    req: ["values"],
    idx: 3
  },
  median: {
    value: (m3) => m3.cell.data.q2(m3.get),
    req: ["values"],
    idx: 3
  },
  q1: {
    value: (m3) => m3.cell.data.q1(m3.get),
    req: ["values"],
    idx: 3
  },
  q3: {
    value: (m3) => m3.cell.data.q3(m3.get),
    req: ["values"],
    idx: 3
  },
  min: {
    init: (m3) => m3.min = void 0,
    value: (m3) => m3.min = Number.isNaN(m3.min) ? m3.cell.data.min(m3.get) : m3.min,
    add: (m3, v2) => {
      if (v2 < m3.min || m3.min === void 0)
        m3.min = v2;
    },
    rem: (m3, v2) => {
      if (v2 <= m3.min)
        m3.min = NaN;
    },
    req: ["values"],
    idx: 4
  },
  max: {
    init: (m3) => m3.max = void 0,
    value: (m3) => m3.max = Number.isNaN(m3.max) ? m3.cell.data.max(m3.get) : m3.max,
    add: (m3, v2) => {
      if (v2 > m3.max || m3.max === void 0)
        m3.max = v2;
    },
    rem: (m3, v2) => {
      if (v2 >= m3.max)
        m3.max = NaN;
    },
    req: ["values"],
    idx: 4
  },
  argmin: {
    init: (m3) => m3.argmin = void 0,
    value: (m3) => m3.argmin || m3.cell.data.argmin(m3.get),
    add: (m3, v2, t) => {
      if (v2 < m3.min)
        m3.argmin = t;
    },
    rem: (m3, v2) => {
      if (v2 <= m3.min)
        m3.argmin = void 0;
    },
    req: ["min", "values"],
    idx: 3
  },
  argmax: {
    init: (m3) => m3.argmax = void 0,
    value: (m3) => m3.argmax || m3.cell.data.argmax(m3.get),
    add: (m3, v2, t) => {
      if (v2 > m3.max)
        m3.argmax = t;
    },
    rem: (m3, v2) => {
      if (v2 >= m3.max)
        m3.argmax = void 0;
    },
    req: ["max", "values"],
    idx: 3
  },
  exponential: {
    init: (m3, r) => {
      m3.exp = 0;
      m3.exp_r = r;
    },
    value: (m3) => m3.valid ? m3.exp * (1 - m3.exp_r) / (1 - m3.exp_r ** m3.valid) : void 0,
    add: (m3, v2) => m3.exp = m3.exp_r * m3.exp + v2,
    rem: (m3, v2) => m3.exp = (m3.exp - v2 / m3.exp_r ** (m3.valid - 1)) / m3.exp_r
  },
  exponentialb: {
    value: (m3) => m3.valid ? m3.exp * (1 - m3.exp_r) : void 0,
    req: ["exponential"],
    idx: 1
  }
};
var ValidAggregateOps = Object.keys(AggregateOps).filter((d) => d !== "__count__");
function measure(key4, value7) {
  return (out, aggregate_param) => extend3({
    name: key4,
    aggregate_param,
    out: out || key4
  }, base_op, value7);
}
[...ValidAggregateOps, "__count__"].forEach((key4) => {
  AggregateOps[key4] = measure(key4, AggregateOps[key4]);
});
function createMeasure(op, param2, name) {
  return AggregateOps[op](name, param2);
}
function compareIndex(a4, b6) {
  return a4.idx - b6.idx;
}
function resolve(agg) {
  const map13 = {};
  agg.forEach((a4) => map13[a4.name] = a4);
  const getreqs = (a4) => {
    if (!a4.req)
      return;
    a4.req.forEach((key4) => {
      if (!map13[key4])
        getreqs(map13[key4] = AggregateOps[key4]());
    });
  };
  agg.forEach(getreqs);
  return Object.values(map13).sort(compareIndex);
}
function init() {
  this.valid = 0;
  this.missing = 0;
  this._ops.forEach((op) => op.aggregate_param == null ? op.init(this) : op.init(this, op.aggregate_param));
}
function add2(v2, t) {
  if (v2 == null || v2 === "") {
    ++this.missing;
    return;
  }
  if (v2 !== v2)
    return;
  ++this.valid;
  this._ops.forEach((op) => op.add(this, v2, t));
}
function rem(v2, t) {
  if (v2 == null || v2 === "") {
    --this.missing;
    return;
  }
  if (v2 !== v2)
    return;
  --this.valid;
  this._ops.forEach((op) => op.rem(this, v2, t));
}
function set2(t) {
  this._out.forEach((op) => t[op.out] = op.value(this));
  return t;
}
function compileMeasures(agg, field25) {
  const get23 = field25 || identity4, ops2 = resolve(agg), out = agg.slice().sort(compareIndex);
  function ctr(cell2) {
    this._ops = ops2;
    this._out = out;
    this.cell = cell2;
    this.init();
  }
  ctr.prototype.init = init;
  ctr.prototype.add = add2;
  ctr.prototype.rem = rem;
  ctr.prototype.set = set2;
  ctr.prototype.get = get23;
  ctr.fields = agg.map((op) => op.out);
  return ctr;
}
function TupleStore(key4) {
  this._key = key4 ? field3(key4) : tupleid;
  this.reset();
}
var prototype$1 = TupleStore.prototype;
prototype$1.reset = function() {
  this._add = [];
  this._rem = [];
  this._ext = null;
  this._get = null;
  this._q = null;
};
prototype$1.add = function(v2) {
  this._add.push(v2);
};
prototype$1.rem = function(v2) {
  this._rem.push(v2);
};
prototype$1.values = function() {
  this._get = null;
  if (this._rem.length === 0)
    return this._add;
  const a4 = this._add, r = this._rem, k3 = this._key, n = a4.length, m3 = r.length, x9 = Array(n - m3), map13 = {};
  let i, j, v2;
  for (i = 0; i < m3; ++i) {
    map13[k3(r[i])] = 1;
  }
  for (i = 0, j = 0; i < n; ++i) {
    if (map13[k3(v2 = a4[i])]) {
      map13[k3(v2)] = 0;
    } else {
      x9[j++] = v2;
    }
  }
  this._rem = [];
  return this._add = x9;
};
prototype$1.distinct = function(get23) {
  const v2 = this.values(), map13 = {};
  let n = v2.length, count3 = 0, s2;
  while (--n >= 0) {
    s2 = get23(v2[n]) + "";
    if (!has3(map13, s2)) {
      map13[s2] = 1;
      ++count3;
    }
  }
  return count3;
};
prototype$1.extent = function(get23) {
  if (this._get !== get23 || !this._ext) {
    const v2 = this.values(), i = extentIndex2(v2, get23);
    this._ext = [v2[i[0]], v2[i[1]]];
    this._get = get23;
  }
  return this._ext;
};
prototype$1.argmin = function(get23) {
  return this.extent(get23)[0] || {};
};
prototype$1.argmax = function(get23) {
  return this.extent(get23)[1] || {};
};
prototype$1.min = function(get23) {
  const m3 = this.extent(get23)[0];
  return m3 != null ? get23(m3) : void 0;
};
prototype$1.max = function(get23) {
  const m3 = this.extent(get23)[1];
  return m3 != null ? get23(m3) : void 0;
};
prototype$1.quartile = function(get23) {
  if (this._get !== get23 || !this._q) {
    this._q = quartiles(this.values(), get23);
    this._get = get23;
  }
  return this._q;
};
prototype$1.q1 = function(get23) {
  return this.quartile(get23)[0];
};
prototype$1.q2 = function(get23) {
  return this.quartile(get23)[1];
};
prototype$1.q3 = function(get23) {
  return this.quartile(get23)[2];
};
prototype$1.ci = function(get23) {
  if (this._get !== get23 || !this._ci) {
    this._ci = bootstrapCI(this.values(), 1e3, 0.05, get23);
    this._get = get23;
  }
  return this._ci;
};
prototype$1.ci0 = function(get23) {
  return this.ci(get23)[0];
};
prototype$1.ci1 = function(get23) {
  return this.ci(get23)[1];
};
function Aggregate(params2) {
  Transform.call(this, null, params2);
  this._adds = [];
  this._mods = [];
  this._alen = 0;
  this._mlen = 0;
  this._drop = true;
  this._cross = false;
  this._dims = [];
  this._dnames = [];
  this._measures = [];
  this._countOnly = false;
  this._counts = null;
  this._prev = null;
  this._inputs = null;
  this._outputs = null;
}
Aggregate.Definition = {
  "type": "Aggregate",
  "metadata": {
    "generates": true,
    "changes": true
  },
  "params": [{
    "name": "groupby",
    "type": "field",
    "array": true
  }, {
    "name": "ops",
    "type": "enum",
    "array": true,
    "values": ValidAggregateOps
  }, {
    "name": "aggregate_params",
    "type": "number",
    "null": true,
    "array": true
  }, {
    "name": "fields",
    "type": "field",
    "null": true,
    "array": true
  }, {
    "name": "as",
    "type": "string",
    "null": true,
    "array": true
  }, {
    "name": "drop",
    "type": "boolean",
    "default": true
  }, {
    "name": "cross",
    "type": "boolean",
    "default": false
  }, {
    "name": "key",
    "type": "field"
  }]
};
inherits3(Aggregate, Transform, {
  transform(_, pulse2) {
    const aggr = this, out = pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS), mod = _.modified();
    aggr.stamp = out.stamp;
    if (aggr.value && (mod || pulse2.modified(aggr._inputs, true))) {
      aggr._prev = aggr.value;
      aggr.value = mod ? aggr.init(_) : /* @__PURE__ */ Object.create(null);
      pulse2.visit(pulse2.SOURCE, (t) => aggr.add(t));
    } else {
      aggr.value = aggr.value || aggr.init(_);
      pulse2.visit(pulse2.REM, (t) => aggr.rem(t));
      pulse2.visit(pulse2.ADD, (t) => aggr.add(t));
    }
    out.modifies(aggr._outputs);
    aggr._drop = _.drop !== false;
    if (_.cross && aggr._dims.length > 1) {
      aggr._drop = false;
      aggr.cross();
    }
    if (pulse2.clean() && aggr._drop) {
      out.clean(true).runAfter(() => this.clean());
    }
    return aggr.changes(out);
  },
  cross() {
    const aggr = this, curr = aggr.value, dims = aggr._dnames, vals2 = dims.map(() => ({})), n = dims.length;
    function collect2(cells) {
      let key4, i, t, v2;
      for (key4 in cells) {
        t = cells[key4].tuple;
        for (i = 0; i < n; ++i) {
          vals2[i][v2 = t[dims[i]]] = v2;
        }
      }
    }
    collect2(aggr._prev);
    collect2(curr);
    function generate3(base, tuple, index4) {
      const name = dims[index4], v2 = vals2[index4++];
      for (const k3 in v2) {
        const key4 = base ? base + "|" + k3 : k3;
        tuple[name] = v2[k3];
        if (index4 < n)
          generate3(key4, tuple, index4);
        else if (!curr[key4])
          aggr.cell(key4, tuple);
      }
    }
    generate3("", {}, 0);
  },
  init(_) {
    const inputs = this._inputs = [], outputs = this._outputs = [], inputMap = {};
    function inputVisit(get23) {
      const fields2 = array4(accessorFields2(get23)), n2 = fields2.length;
      let i2 = 0, f;
      for (; i2 < n2; ++i2) {
        if (!inputMap[f = fields2[i2]]) {
          inputMap[f] = 1;
          inputs.push(f);
        }
      }
    }
    this._dims = array4(_.groupby);
    this._dnames = this._dims.map((d) => {
      const dname = accessorName2(d);
      inputVisit(d);
      outputs.push(dname);
      return dname;
    });
    this.cellkey = _.key ? _.key : groupkey(this._dims);
    this._countOnly = true;
    this._counts = [];
    this._measures = [];
    const fields = _.fields || [null], ops2 = _.ops || ["count"], aggregate_params = _.aggregate_params || [null], as = _.as || [], n = fields.length, map13 = {};
    let field25, op, aggregate_param, m3, mname, outname, i;
    if (n !== ops2.length) {
      error3("Unmatched number of fields and aggregate ops.");
    }
    for (i = 0; i < n; ++i) {
      field25 = fields[i];
      op = ops2[i];
      aggregate_param = aggregate_params[i] || null;
      if (field25 == null && op !== "count") {
        error3("Null aggregate field specified.");
      }
      mname = accessorName2(field25);
      outname = measureName(op, mname, as[i]);
      outputs.push(outname);
      if (op === "count") {
        this._counts.push(outname);
        continue;
      }
      m3 = map13[mname];
      if (!m3) {
        inputVisit(field25);
        m3 = map13[mname] = [];
        m3.field = field25;
        this._measures.push(m3);
      }
      if (op !== "count")
        this._countOnly = false;
      m3.push(createMeasure(op, aggregate_param, outname));
    }
    this._measures = this._measures.map((m4) => compileMeasures(m4, m4.field));
    return /* @__PURE__ */ Object.create(null);
  },
  // -- Cell Management -----
  cellkey: groupkey(),
  cell(key4, t) {
    let cell2 = this.value[key4];
    if (!cell2) {
      cell2 = this.value[key4] = this.newcell(key4, t);
      this._adds[this._alen++] = cell2;
    } else if (cell2.num === 0 && this._drop && cell2.stamp < this.stamp) {
      cell2.stamp = this.stamp;
      this._adds[this._alen++] = cell2;
    } else if (cell2.stamp < this.stamp) {
      cell2.stamp = this.stamp;
      this._mods[this._mlen++] = cell2;
    }
    return cell2;
  },
  newcell(key4, t) {
    const cell2 = {
      key: key4,
      num: 0,
      agg: null,
      tuple: this.newtuple(t, this._prev && this._prev[key4]),
      stamp: this.stamp,
      store: false
    };
    if (!this._countOnly) {
      const measures = this._measures, n = measures.length;
      cell2.agg = Array(n);
      for (let i = 0; i < n; ++i) {
        cell2.agg[i] = new measures[i](cell2);
      }
    }
    if (cell2.store) {
      cell2.data = new TupleStore();
    }
    return cell2;
  },
  newtuple(t, p) {
    const names = this._dnames, dims = this._dims, n = dims.length, x9 = {};
    for (let i = 0; i < n; ++i) {
      x9[names[i]] = dims[i](t);
    }
    return p ? replace(p.tuple, x9) : ingest$1(x9);
  },
  clean() {
    const cells = this.value;
    for (const key4 in cells) {
      if (cells[key4].num === 0) {
        delete cells[key4];
      }
    }
  },
  // -- Process Tuples -----
  add(t) {
    const key4 = this.cellkey(t), cell2 = this.cell(key4, t);
    cell2.num += 1;
    if (this._countOnly)
      return;
    if (cell2.store)
      cell2.data.add(t);
    const agg = cell2.agg;
    for (let i = 0, n = agg.length; i < n; ++i) {
      agg[i].add(agg[i].get(t), t);
    }
  },
  rem(t) {
    const key4 = this.cellkey(t), cell2 = this.cell(key4, t);
    cell2.num -= 1;
    if (this._countOnly)
      return;
    if (cell2.store)
      cell2.data.rem(t);
    const agg = cell2.agg;
    for (let i = 0, n = agg.length; i < n; ++i) {
      agg[i].rem(agg[i].get(t), t);
    }
  },
  celltuple(cell2) {
    const tuple = cell2.tuple, counts = this._counts;
    if (cell2.store) {
      cell2.data.values();
    }
    for (let i = 0, n = counts.length; i < n; ++i) {
      tuple[counts[i]] = cell2.num;
    }
    if (!this._countOnly) {
      const agg = cell2.agg;
      for (let i = 0, n = agg.length; i < n; ++i) {
        agg[i].set(tuple);
      }
    }
    return tuple;
  },
  changes(out) {
    const adds = this._adds, mods = this._mods, prev = this._prev, drop = this._drop, add10 = out.add, rem2 = out.rem, mod = out.mod;
    let cell2, key4, i, n;
    if (prev)
      for (key4 in prev) {
        cell2 = prev[key4];
        if (!drop || cell2.num)
          rem2.push(cell2.tuple);
      }
    for (i = 0, n = this._alen; i < n; ++i) {
      add10.push(this.celltuple(adds[i]));
      adds[i] = null;
    }
    for (i = 0, n = this._mlen; i < n; ++i) {
      cell2 = mods[i];
      (cell2.num === 0 && drop ? rem2 : mod).push(this.celltuple(cell2));
      mods[i] = null;
    }
    this._alen = this._mlen = 0;
    this._prev = null;
    return out;
  }
});
var EPSILON$1 = 1e-14;
function Bin(params2) {
  Transform.call(this, null, params2);
}
Bin.Definition = {
  "type": "Bin",
  "metadata": {
    "modifies": true
  },
  "params": [{
    "name": "field",
    "type": "field",
    "required": true
  }, {
    "name": "interval",
    "type": "boolean",
    "default": true
  }, {
    "name": "anchor",
    "type": "number"
  }, {
    "name": "maxbins",
    "type": "number",
    "default": 20
  }, {
    "name": "base",
    "type": "number",
    "default": 10
  }, {
    "name": "divide",
    "type": "number",
    "array": true,
    "default": [5, 2]
  }, {
    "name": "extent",
    "type": "number",
    "array": true,
    "length": 2,
    "required": true
  }, {
    "name": "span",
    "type": "number"
  }, {
    "name": "step",
    "type": "number"
  }, {
    "name": "steps",
    "type": "number",
    "array": true
  }, {
    "name": "minstep",
    "type": "number",
    "default": 0
  }, {
    "name": "nice",
    "type": "boolean",
    "default": true
  }, {
    "name": "name",
    "type": "string"
  }, {
    "name": "as",
    "type": "string",
    "array": true,
    "length": 2,
    "default": ["bin0", "bin1"]
  }]
};
inherits3(Bin, Transform, {
  transform(_, pulse2) {
    const band11 = _.interval !== false, bins2 = this._bins(_), start = bins2.start, step = bins2.step, as = _.as || ["bin0", "bin1"], b0 = as[0], b1 = as[1];
    let flag2;
    if (_.modified()) {
      pulse2 = pulse2.reflow(true);
      flag2 = pulse2.SOURCE;
    } else {
      flag2 = pulse2.modified(accessorFields2(_.field)) ? pulse2.ADD_MOD : pulse2.ADD;
    }
    pulse2.visit(flag2, band11 ? (t) => {
      const v2 = bins2(t);
      t[b0] = v2;
      t[b1] = v2 == null ? null : start + step * (1 + (v2 - start) / step);
    } : (t) => t[b0] = bins2(t));
    return pulse2.modifies(band11 ? as : b0);
  },
  _bins(_) {
    if (this.value && !_.modified()) {
      return this.value;
    }
    const field25 = _.field, bins2 = bin2(_), step = bins2.step;
    let start = bins2.start, stop2 = start + Math.ceil((bins2.stop - start) / step) * step, a4, d;
    if ((a4 = _.anchor) != null) {
      d = a4 - (start + step * Math.floor((a4 - start) / step));
      start += d;
      stop2 += d;
    }
    const f = function(t) {
      let v2 = toNumber3(field25(t));
      return v2 == null ? null : v2 < start ? -Infinity : v2 > stop2 ? Infinity : (v2 = Math.max(start, Math.min(v2, stop2 - step)), start + step * Math.floor(EPSILON$1 + (v2 - start) / step));
    };
    f.start = start;
    f.stop = bins2.stop;
    f.step = step;
    return this.value = accessor3(f, accessorFields2(field25), _.name || "bin_" + accessorName2(field25));
  }
});
function SortedList(idFunc, source3, input) {
  const $11 = idFunc;
  let data3 = source3 || [], add10 = input || [], rem2 = {}, cnt = 0;
  return {
    add: (t) => add10.push(t),
    remove: (t) => rem2[$11(t)] = ++cnt,
    size: () => data3.length,
    data: (compare10, resort) => {
      if (cnt) {
        data3 = data3.filter((t) => !rem2[$11(t)]);
        rem2 = {};
        cnt = 0;
      }
      if (resort && compare10) {
        data3.sort(compare10);
      }
      if (add10.length) {
        data3 = compare10 ? merge3(compare10, data3, add10.sort(compare10)) : data3.concat(add10);
        add10 = [];
      }
      return data3;
    }
  };
}
function Collect(params2) {
  Transform.call(this, [], params2);
}
Collect.Definition = {
  "type": "Collect",
  "metadata": {
    "source": true
  },
  "params": [{
    "name": "sort",
    "type": "compare"
  }]
};
inherits3(Collect, Transform, {
  transform(_, pulse2) {
    const out = pulse2.fork(pulse2.ALL), list = SortedList(tupleid, this.value, out.materialize(out.ADD).add), sort4 = _.sort, mod = pulse2.changed() || sort4 && (_.modified("sort") || pulse2.modified(sort4.fields));
    out.visit(out.REM, list.remove);
    this.modified(mod);
    this.value = out.source = list.data(stableCompare(sort4), mod);
    if (pulse2.source && pulse2.source.root) {
      this.value.root = pulse2.source.root;
    }
    return out;
  }
});
function Compare(params2) {
  Operator.call(this, null, update$5, params2);
}
inherits3(Compare, Operator);
function update$5(_) {
  return this.value && !_.modified() ? this.value : compare2(_.fields, _.orders);
}
function CountPattern(params2) {
  Transform.call(this, null, params2);
}
CountPattern.Definition = {
  "type": "CountPattern",
  "metadata": {
    "generates": true,
    "changes": true
  },
  "params": [{
    "name": "field",
    "type": "field",
    "required": true
  }, {
    "name": "case",
    "type": "enum",
    "values": ["upper", "lower", "mixed"],
    "default": "mixed"
  }, {
    "name": "pattern",
    "type": "string",
    "default": '[\\w"]+'
  }, {
    "name": "stopwords",
    "type": "string",
    "default": ""
  }, {
    "name": "as",
    "type": "string",
    "array": true,
    "length": 2,
    "default": ["text", "count"]
  }]
};
function tokenize(text7, tcase, match2) {
  switch (tcase) {
    case "upper":
      text7 = text7.toUpperCase();
      break;
    case "lower":
      text7 = text7.toLowerCase();
      break;
  }
  return text7.match(match2);
}
inherits3(CountPattern, Transform, {
  transform(_, pulse2) {
    const process2 = (update3) => (tuple) => {
      var tokens = tokenize(get23(tuple), _.case, match2) || [], t;
      for (var i = 0, n = tokens.length; i < n; ++i) {
        if (!stop2.test(t = tokens[i]))
          update3(t);
      }
    };
    const init2 = this._parameterCheck(_, pulse2), counts = this._counts, match2 = this._match, stop2 = this._stop, get23 = _.field, as = _.as || ["text", "count"], add10 = process2((t) => counts[t] = 1 + (counts[t] || 0)), rem2 = process2((t) => counts[t] -= 1);
    if (init2) {
      pulse2.visit(pulse2.SOURCE, add10);
    } else {
      pulse2.visit(pulse2.ADD, add10);
      pulse2.visit(pulse2.REM, rem2);
    }
    return this._finish(pulse2, as);
  },
  _parameterCheck(_, pulse2) {
    let init2 = false;
    if (_.modified("stopwords") || !this._stop) {
      this._stop = new RegExp("^" + (_.stopwords || "") + "$", "i");
      init2 = true;
    }
    if (_.modified("pattern") || !this._match) {
      this._match = new RegExp(_.pattern || "[\\w']+", "g");
      init2 = true;
    }
    if (_.modified("field") || pulse2.modified(_.field.fields)) {
      init2 = true;
    }
    if (init2)
      this._counts = {};
    return init2;
  },
  _finish(pulse2, as) {
    const counts = this._counts, tuples = this._tuples || (this._tuples = {}), text7 = as[0], count3 = as[1], out = pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS);
    let w8, t, c5;
    for (w8 in counts) {
      t = tuples[w8];
      c5 = counts[w8] || 0;
      if (!t && c5) {
        tuples[w8] = t = ingest$1({});
        t[text7] = w8;
        t[count3] = c5;
        out.add.push(t);
      } else if (c5 === 0) {
        if (t)
          out.rem.push(t);
        counts[w8] = null;
        tuples[w8] = null;
      } else if (t[count3] !== c5) {
        t[count3] = c5;
        out.mod.push(t);
      }
    }
    return out.modifies(as);
  }
});
function Cross(params2) {
  Transform.call(this, null, params2);
}
Cross.Definition = {
  "type": "Cross",
  "metadata": {
    "generates": true
  },
  "params": [{
    "name": "filter",
    "type": "expr"
  }, {
    "name": "as",
    "type": "string",
    "array": true,
    "length": 2,
    "default": ["a", "b"]
  }]
};
inherits3(Cross, Transform, {
  transform(_, pulse2) {
    const out = pulse2.fork(pulse2.NO_SOURCE), as = _.as || ["a", "b"], a4 = as[0], b6 = as[1], reset3 = !this.value || pulse2.changed(pulse2.ADD_REM) || _.modified("as") || _.modified("filter");
    let data3 = this.value;
    if (reset3) {
      if (data3)
        out.rem = data3;
      data3 = pulse2.materialize(pulse2.SOURCE).source;
      out.add = this.value = cross2(data3, a4, b6, _.filter || truthy3);
    } else {
      out.mod = data3;
    }
    out.source = this.value;
    return out.modifies(as);
  }
});
function cross2(input, a4, b6, filter4) {
  var data3 = [], t = {}, n = input.length, i = 0, j, left;
  for (; i < n; ++i) {
    t[a4] = left = input[i];
    for (j = 0; j < n; ++j) {
      t[b6] = input[j];
      if (filter4(t)) {
        data3.push(ingest$1(t));
        t = {};
        t[a4] = left;
      }
    }
  }
  return data3;
}
var Distributions = {
  kde,
  mixture,
  normal: gaussian,
  lognormal,
  uniform
};
var DISTRIBUTIONS = "distributions";
var FUNCTION = "function";
var FIELD = "field";
function parse3(def6, data3) {
  const func = def6[FUNCTION];
  if (!has3(Distributions, func)) {
    error3("Unknown distribution function: " + func);
  }
  const d = Distributions[func]();
  for (const name in def6) {
    if (name === FIELD) {
      d.data((def6.from || data3()).map(def6[name]));
    } else if (name === DISTRIBUTIONS) {
      d[name](def6[name].map((_) => parse3(_, data3)));
    } else if (typeof d[name] === FUNCTION) {
      d[name](def6[name]);
    }
  }
  return d;
}
function Density(params2) {
  Transform.call(this, null, params2);
}
var distributions = [{
  "key": {
    "function": "normal"
  },
  "params": [{
    "name": "mean",
    "type": "number",
    "default": 0
  }, {
    "name": "stdev",
    "type": "number",
    "default": 1
  }]
}, {
  "key": {
    "function": "lognormal"
  },
  "params": [{
    "name": "mean",
    "type": "number",
    "default": 0
  }, {
    "name": "stdev",
    "type": "number",
    "default": 1
  }]
}, {
  "key": {
    "function": "uniform"
  },
  "params": [{
    "name": "min",
    "type": "number",
    "default": 0
  }, {
    "name": "max",
    "type": "number",
    "default": 1
  }]
}, {
  "key": {
    "function": "kde"
  },
  "params": [{
    "name": "field",
    "type": "field",
    "required": true
  }, {
    "name": "from",
    "type": "data"
  }, {
    "name": "bandwidth",
    "type": "number",
    "default": 0
  }]
}];
var mixture2 = {
  "key": {
    "function": "mixture"
  },
  "params": [{
    "name": "distributions",
    "type": "param",
    "array": true,
    "params": distributions
  }, {
    "name": "weights",
    "type": "number",
    "array": true
  }]
};
Density.Definition = {
  "type": "Density",
  "metadata": {
    "generates": true
  },
  "params": [{
    "name": "extent",
    "type": "number",
    "array": true,
    "length": 2
  }, {
    "name": "steps",
    "type": "number"
  }, {
    "name": "minsteps",
    "type": "number",
    "default": 25
  }, {
    "name": "maxsteps",
    "type": "number",
    "default": 200
  }, {
    "name": "method",
    "type": "string",
    "default": "pdf",
    "values": ["pdf", "cdf"]
  }, {
    "name": "distribution",
    "type": "param",
    "params": distributions.concat(mixture2)
  }, {
    "name": "as",
    "type": "string",
    "array": true,
    "default": ["value", "density"]
  }]
};
inherits3(Density, Transform, {
  transform(_, pulse2) {
    const out = pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS);
    if (!this.value || pulse2.changed() || _.modified()) {
      const dist2 = parse3(_.distribution, source(pulse2)), minsteps = _.steps || _.minsteps || 25, maxsteps = _.steps || _.maxsteps || 200;
      let method10 = _.method || "pdf";
      if (method10 !== "pdf" && method10 !== "cdf") {
        error3("Invalid density method: " + method10);
      }
      if (!_.extent && !dist2.data) {
        error3("Missing density extent parameter.");
      }
      method10 = dist2[method10];
      const as = _.as || ["value", "density"], domain3 = _.extent || extent3(dist2.data()), values7 = sampleCurve(method10, domain3, minsteps, maxsteps).map((v2) => {
        const tuple = {};
        tuple[as[0]] = v2[0];
        tuple[as[1]] = v2[1];
        return ingest$1(tuple);
      });
      if (this.value)
        out.rem = this.value;
      this.value = out.add = out.source = values7;
    }
    return out;
  }
});
function source(pulse2) {
  return () => pulse2.materialize(pulse2.SOURCE).source;
}
function fieldNames(fields, as) {
  if (!fields)
    return null;
  return fields.map((f, i) => as[i] || accessorName2(f));
}
function partition$1(data3, groupby, field25) {
  const groups2 = [], get23 = (f) => f(t);
  let map13, i, n, t, k3, g;
  if (groupby == null) {
    groups2.push(data3.map(field25));
  } else {
    for (map13 = {}, i = 0, n = data3.length; i < n; ++i) {
      t = data3[i];
      k3 = groupby.map(get23);
      g = map13[k3];
      if (!g) {
        map13[k3] = g = [];
        g.dims = k3;
        groups2.push(g);
      }
      g.push(field25(t));
    }
  }
  return groups2;
}
var Output = "bin";
function DotBin(params2) {
  Transform.call(this, null, params2);
}
DotBin.Definition = {
  "type": "DotBin",
  "metadata": {
    "modifies": true
  },
  "params": [{
    "name": "field",
    "type": "field",
    "required": true
  }, {
    "name": "groupby",
    "type": "field",
    "array": true
  }, {
    "name": "step",
    "type": "number"
  }, {
    "name": "smooth",
    "type": "boolean",
    "default": false
  }, {
    "name": "as",
    "type": "string",
    "default": Output
  }]
};
var autostep = (data3, field25) => span3(extent3(data3, field25)) / 30;
inherits3(DotBin, Transform, {
  transform(_, pulse2) {
    if (this.value && !(_.modified() || pulse2.changed())) {
      return pulse2;
    }
    const source3 = pulse2.materialize(pulse2.SOURCE).source, groups2 = partition$1(pulse2.source, _.groupby, identity4), smooth = _.smooth || false, field25 = _.field, step = _.step || autostep(source3, field25), sort4 = stableCompare((a4, b6) => field25(a4) - field25(b6)), as = _.as || Output, n = groups2.length;
    let min5 = Infinity, max5 = -Infinity, i = 0, j;
    for (; i < n; ++i) {
      const g = groups2[i].sort(sort4);
      j = -1;
      for (const v2 of dotbin(g, step, smooth, field25)) {
        if (v2 < min5)
          min5 = v2;
        if (v2 > max5)
          max5 = v2;
        g[++j][as] = v2;
      }
    }
    this.value = {
      start: min5,
      stop: max5,
      step
    };
    return pulse2.reflow(true).modifies(as);
  }
});
function Expression(params2) {
  Operator.call(this, null, update$4, params2);
  this.modified(true);
}
inherits3(Expression, Operator);
function update$4(_) {
  const expr2 = _.expr;
  return this.value && !_.modified("expr") ? this.value : accessor3((datum2) => expr2(datum2, _), accessorFields2(expr2), accessorName2(expr2));
}
function Extent(params2) {
  Transform.call(this, [void 0, void 0], params2);
}
Extent.Definition = {
  "type": "Extent",
  "metadata": {},
  "params": [{
    "name": "field",
    "type": "field",
    "required": true
  }]
};
inherits3(Extent, Transform, {
  transform(_, pulse2) {
    const extent8 = this.value, field25 = _.field, mod = pulse2.changed() || pulse2.modified(field25.fields) || _.modified("field");
    let min5 = extent8[0], max5 = extent8[1];
    if (mod || min5 == null) {
      min5 = Infinity;
      max5 = -Infinity;
    }
    pulse2.visit(mod ? pulse2.SOURCE : pulse2.ADD, (t) => {
      const v2 = toNumber3(field25(t));
      if (v2 != null) {
        if (v2 < min5)
          min5 = v2;
        if (v2 > max5)
          max5 = v2;
      }
    });
    if (!Number.isFinite(min5) || !Number.isFinite(max5)) {
      let name = accessorName2(field25);
      if (name)
        name = ` for field "${name}"`;
      pulse2.dataflow.warn(`Infinite extent${name}: [${min5}, ${max5}]`);
      min5 = max5 = void 0;
    }
    this.value = [min5, max5];
  }
});
function Subflow(pulse2, parent) {
  Operator.call(this, pulse2);
  this.parent = parent;
  this.count = 0;
}
inherits3(Subflow, Operator, {
  /**
   * Routes pulses from this subflow to a target transform.
   * @param {Transform} target - A transform that receives the subflow of tuples.
   */
  connect(target2) {
    this.detachSubflow = target2.detachSubflow;
    this.targets().add(target2);
    return target2.source = this;
  },
  /**
   * Add an 'add' tuple to the subflow pulse.
   * @param {Tuple} t - The tuple being added.
   */
  add(t) {
    this.count += 1;
    this.value.add.push(t);
  },
  /**
   * Add a 'rem' tuple to the subflow pulse.
   * @param {Tuple} t - The tuple being removed.
   */
  rem(t) {
    this.count -= 1;
    this.value.rem.push(t);
  },
  /**
   * Add a 'mod' tuple to the subflow pulse.
   * @param {Tuple} t - The tuple being modified.
   */
  mod(t) {
    this.value.mod.push(t);
  },
  /**
   * Re-initialize this operator's pulse value.
   * @param {Pulse} pulse - The pulse to copy from.
   * @see Pulse.init
   */
  init(pulse2) {
    this.value.init(pulse2, pulse2.NO_SOURCE);
  },
  /**
   * Evaluate this operator. This method overrides the
   * default behavior to simply return the contained pulse value.
   * @return {Pulse}
   */
  evaluate() {
    return this.value;
  }
});
function Facet(params2) {
  Transform.call(this, {}, params2);
  this._keys = fastmap2();
  const a4 = this._targets = [];
  a4.active = 0;
  a4.forEach = (f) => {
    for (let i = 0, n = a4.active; i < n; ++i) {
      f(a4[i], i, a4);
    }
  };
}
inherits3(Facet, Transform, {
  activate(flow) {
    this._targets[this._targets.active++] = flow;
  },
  // parent argument provided by PreFacet subclass
  subflow(key4, flow, pulse2, parent) {
    const flows = this.value;
    let sf = has3(flows, key4) && flows[key4], df, p;
    if (!sf) {
      p = parent || (p = this._group[key4]) && p.tuple;
      df = pulse2.dataflow;
      sf = new Subflow(pulse2.fork(pulse2.NO_SOURCE), this);
      df.add(sf).connect(flow(df, key4, p));
      flows[key4] = sf;
      this.activate(sf);
    } else if (sf.value.stamp < pulse2.stamp) {
      sf.init(pulse2);
      this.activate(sf);
    }
    return sf;
  },
  clean() {
    const flows = this.value;
    let detached = 0;
    for (const key4 in flows) {
      if (flows[key4].count === 0) {
        const detach = flows[key4].detachSubflow;
        if (detach)
          detach();
        delete flows[key4];
        ++detached;
      }
    }
    if (detached) {
      const active = this._targets.filter((sf) => sf && sf.count > 0);
      this.initTargets(active);
    }
  },
  initTargets(act) {
    const a4 = this._targets, n = a4.length, m3 = act ? act.length : 0;
    let i = 0;
    for (; i < m3; ++i) {
      a4[i] = act[i];
    }
    for (; i < n && a4[i] != null; ++i) {
      a4[i] = null;
    }
    a4.active = m3;
  },
  transform(_, pulse2) {
    const df = pulse2.dataflow, key4 = _.key, flow = _.subflow, cache2 = this._keys, rekey = _.modified("key"), subflow = (key5) => this.subflow(key5, flow, pulse2);
    this._group = _.group || {};
    this.initTargets();
    pulse2.visit(pulse2.REM, (t) => {
      const id24 = tupleid(t), k3 = cache2.get(id24);
      if (k3 !== void 0) {
        cache2.delete(id24);
        subflow(k3).rem(t);
      }
    });
    pulse2.visit(pulse2.ADD, (t) => {
      const k3 = key4(t);
      cache2.set(tupleid(t), k3);
      subflow(k3).add(t);
    });
    if (rekey || pulse2.modified(key4.fields)) {
      pulse2.visit(pulse2.MOD, (t) => {
        const id24 = tupleid(t), k0 = cache2.get(id24), k1 = key4(t);
        if (k0 === k1) {
          subflow(k1).mod(t);
        } else {
          cache2.set(id24, k1);
          subflow(k0).rem(t);
          subflow(k1).add(t);
        }
      });
    } else if (pulse2.changed(pulse2.MOD)) {
      pulse2.visit(pulse2.MOD, (t) => {
        subflow(cache2.get(tupleid(t))).mod(t);
      });
    }
    if (rekey) {
      pulse2.visit(pulse2.REFLOW, (t) => {
        const id24 = tupleid(t), k0 = cache2.get(id24), k1 = key4(t);
        if (k0 !== k1) {
          cache2.set(id24, k1);
          subflow(k0).rem(t);
          subflow(k1).add(t);
        }
      });
    }
    if (pulse2.clean()) {
      df.runAfter(() => {
        this.clean();
        cache2.clean();
      });
    } else if (cache2.empty > df.cleanThreshold) {
      df.runAfter(cache2.clean);
    }
    return pulse2;
  }
});
function Field(params2) {
  Operator.call(this, null, update$3, params2);
}
inherits3(Field, Operator);
function update$3(_) {
  return this.value && !_.modified() ? this.value : isArray3(_.name) ? array4(_.name).map((f) => field3(f)) : field3(_.name, _.as);
}
function Filter(params2) {
  Transform.call(this, fastmap2(), params2);
}
Filter.Definition = {
  "type": "Filter",
  "metadata": {
    "changes": true
  },
  "params": [{
    "name": "expr",
    "type": "expr",
    "required": true
  }]
};
inherits3(Filter, Transform, {
  transform(_, pulse2) {
    const df = pulse2.dataflow, cache2 = this.value, output3 = pulse2.fork(), add10 = output3.add, rem2 = output3.rem, mod = output3.mod, test2 = _.expr;
    let isMod = true;
    pulse2.visit(pulse2.REM, (t) => {
      const id24 = tupleid(t);
      if (!cache2.has(id24))
        rem2.push(t);
      else
        cache2.delete(id24);
    });
    pulse2.visit(pulse2.ADD, (t) => {
      if (test2(t, _))
        add10.push(t);
      else
        cache2.set(tupleid(t), 1);
    });
    function revisit(t) {
      const id24 = tupleid(t), b6 = test2(t, _), s2 = cache2.get(id24);
      if (b6 && s2) {
        cache2.delete(id24);
        add10.push(t);
      } else if (!b6 && !s2) {
        cache2.set(id24, 1);
        rem2.push(t);
      } else if (isMod && b6 && !s2) {
        mod.push(t);
      }
    }
    pulse2.visit(pulse2.MOD, revisit);
    if (_.modified()) {
      isMod = false;
      pulse2.visit(pulse2.REFLOW, revisit);
    }
    if (cache2.empty > df.cleanThreshold)
      df.runAfter(cache2.clean);
    return output3;
  }
});
function Flatten(params2) {
  Transform.call(this, [], params2);
}
Flatten.Definition = {
  "type": "Flatten",
  "metadata": {
    "generates": true
  },
  "params": [{
    "name": "fields",
    "type": "field",
    "array": true,
    "required": true
  }, {
    "name": "index",
    "type": "string"
  }, {
    "name": "as",
    "type": "string",
    "array": true
  }]
};
inherits3(Flatten, Transform, {
  transform(_, pulse2) {
    const out = pulse2.fork(pulse2.NO_SOURCE), fields = _.fields, as = fieldNames(fields, _.as || []), index4 = _.index || null, m3 = as.length;
    out.rem = this.value;
    pulse2.visit(pulse2.SOURCE, (t) => {
      const arrays = fields.map((f) => f(t)), maxlen = arrays.reduce((l, a4) => Math.max(l, a4.length), 0);
      let i = 0, j, d, v2;
      for (; i < maxlen; ++i) {
        d = derive(t);
        for (j = 0; j < m3; ++j) {
          d[as[j]] = (v2 = arrays[j][i]) == null ? null : v2;
        }
        if (index4) {
          d[index4] = i;
        }
        out.add.push(d);
      }
    });
    this.value = out.source = out.add;
    if (index4)
      out.modifies(index4);
    return out.modifies(as);
  }
});
function Fold(params2) {
  Transform.call(this, [], params2);
}
Fold.Definition = {
  "type": "Fold",
  "metadata": {
    "generates": true
  },
  "params": [{
    "name": "fields",
    "type": "field",
    "array": true,
    "required": true
  }, {
    "name": "as",
    "type": "string",
    "array": true,
    "length": 2,
    "default": ["key", "value"]
  }]
};
inherits3(Fold, Transform, {
  transform(_, pulse2) {
    const out = pulse2.fork(pulse2.NO_SOURCE), fields = _.fields, fnames = fields.map(accessorName2), as = _.as || ["key", "value"], k3 = as[0], v2 = as[1], n = fields.length;
    out.rem = this.value;
    pulse2.visit(pulse2.SOURCE, (t) => {
      for (let i = 0, d; i < n; ++i) {
        d = derive(t);
        d[k3] = fnames[i];
        d[v2] = fields[i](t);
        out.add.push(d);
      }
    });
    this.value = out.source = out.add;
    return out.modifies(as);
  }
});
function Formula(params2) {
  Transform.call(this, null, params2);
}
Formula.Definition = {
  "type": "Formula",
  "metadata": {
    "modifies": true
  },
  "params": [{
    "name": "expr",
    "type": "expr",
    "required": true
  }, {
    "name": "as",
    "type": "string",
    "required": true
  }, {
    "name": "initonly",
    "type": "boolean"
  }]
};
inherits3(Formula, Transform, {
  transform(_, pulse2) {
    const func = _.expr, as = _.as, mod = _.modified(), flag2 = _.initonly ? pulse2.ADD : mod ? pulse2.SOURCE : pulse2.modified(func.fields) || pulse2.modified(as) ? pulse2.ADD_MOD : pulse2.ADD;
    if (mod) {
      pulse2 = pulse2.materialize().reflow(true);
    }
    if (!_.initonly) {
      pulse2.modifies(as);
    }
    return pulse2.visit(flag2, (t) => t[as] = func(t, _));
  }
});
function Generate(params2) {
  Transform.call(this, [], params2);
}
inherits3(Generate, Transform, {
  transform(_, pulse2) {
    const out = pulse2.fork(pulse2.ALL), gen = _.generator;
    let data3 = this.value, num = _.size - data3.length, add10, rem2, t;
    if (num > 0) {
      for (add10 = []; --num >= 0; ) {
        add10.push(t = ingest$1(gen(_)));
        data3.push(t);
      }
      out.add = out.add.length ? out.materialize(out.ADD).add.concat(add10) : add10;
    } else {
      rem2 = data3.slice(0, -num);
      out.rem = out.rem.length ? out.materialize(out.REM).rem.concat(rem2) : rem2;
      data3 = data3.slice(-num);
    }
    out.source = this.value = data3;
    return out;
  }
});
var Methods = {
  value: "value",
  median,
  mean,
  min,
  max
};
var Empty = [];
function Impute(params2) {
  Transform.call(this, [], params2);
}
Impute.Definition = {
  "type": "Impute",
  "metadata": {
    "changes": true
  },
  "params": [{
    "name": "field",
    "type": "field",
    "required": true
  }, {
    "name": "key",
    "type": "field",
    "required": true
  }, {
    "name": "keyvals",
    "array": true
  }, {
    "name": "groupby",
    "type": "field",
    "array": true
  }, {
    "name": "method",
    "type": "enum",
    "default": "value",
    "values": ["value", "mean", "median", "max", "min"]
  }, {
    "name": "value",
    "default": 0
  }]
};
function getValue(_) {
  var m3 = _.method || Methods.value, v2;
  if (Methods[m3] == null) {
    error3("Unrecognized imputation method: " + m3);
  } else if (m3 === Methods.value) {
    v2 = _.value !== void 0 ? _.value : 0;
    return () => v2;
  } else {
    return Methods[m3];
  }
}
function getField(_) {
  const f = _.field;
  return (t) => t ? f(t) : NaN;
}
inherits3(Impute, Transform, {
  transform(_, pulse2) {
    var out = pulse2.fork(pulse2.ALL), impute = getValue(_), field25 = getField(_), fName = accessorName2(_.field), kName = accessorName2(_.key), gNames = (_.groupby || []).map(accessorName2), groups2 = partition(pulse2.source, _.groupby, _.key, _.keyvals), curr = [], prev = this.value, m3 = groups2.domain.length, group7, value7, gVals, kVal, g, i, j, l, n, t;
    for (g = 0, l = groups2.length; g < l; ++g) {
      group7 = groups2[g];
      gVals = group7.values;
      value7 = NaN;
      for (j = 0; j < m3; ++j) {
        if (group7[j] != null)
          continue;
        kVal = groups2.domain[j];
        t = {
          _impute: true
        };
        for (i = 0, n = gVals.length; i < n; ++i)
          t[gNames[i]] = gVals[i];
        t[kName] = kVal;
        t[fName] = Number.isNaN(value7) ? value7 = impute(group7, field25) : value7;
        curr.push(ingest$1(t));
      }
    }
    if (curr.length)
      out.add = out.materialize(out.ADD).add.concat(curr);
    if (prev.length)
      out.rem = out.materialize(out.REM).rem.concat(prev);
    this.value = curr;
    return out;
  }
});
function partition(data3, groupby, key4, keyvals) {
  var get23 = (f) => f(t), groups2 = [], domain3 = keyvals ? keyvals.slice() : [], kMap = {}, gMap = {}, gVals, gKey, group7, i, j, k3, n, t;
  domain3.forEach((k4, i2) => kMap[k4] = i2 + 1);
  for (i = 0, n = data3.length; i < n; ++i) {
    t = data3[i];
    k3 = key4(t);
    j = kMap[k3] || (kMap[k3] = domain3.push(k3));
    gKey = (gVals = groupby ? groupby.map(get23) : Empty) + "";
    if (!(group7 = gMap[gKey])) {
      group7 = gMap[gKey] = [];
      groups2.push(group7);
      group7.values = gVals;
    }
    group7[j - 1] = t;
  }
  groups2.domain = domain3;
  return groups2;
}
function JoinAggregate(params2) {
  Aggregate.call(this, params2);
}
JoinAggregate.Definition = {
  "type": "JoinAggregate",
  "metadata": {
    "modifies": true
  },
  "params": [{
    "name": "groupby",
    "type": "field",
    "array": true
  }, {
    "name": "fields",
    "type": "field",
    "null": true,
    "array": true
  }, {
    "name": "ops",
    "type": "enum",
    "array": true,
    "values": ValidAggregateOps
  }, {
    "name": "as",
    "type": "string",
    "null": true,
    "array": true
  }, {
    "name": "key",
    "type": "field"
  }]
};
inherits3(JoinAggregate, Aggregate, {
  transform(_, pulse2) {
    const aggr = this, mod = _.modified();
    let cells;
    if (aggr.value && (mod || pulse2.modified(aggr._inputs, true))) {
      cells = aggr.value = mod ? aggr.init(_) : {};
      pulse2.visit(pulse2.SOURCE, (t) => aggr.add(t));
    } else {
      cells = aggr.value = aggr.value || this.init(_);
      pulse2.visit(pulse2.REM, (t) => aggr.rem(t));
      pulse2.visit(pulse2.ADD, (t) => aggr.add(t));
    }
    aggr.changes();
    pulse2.visit(pulse2.SOURCE, (t) => {
      extend3(t, cells[aggr.cellkey(t)].tuple);
    });
    return pulse2.reflow(mod).modifies(this._outputs);
  },
  changes() {
    const adds = this._adds, mods = this._mods;
    let i, n;
    for (i = 0, n = this._alen; i < n; ++i) {
      this.celltuple(adds[i]);
      adds[i] = null;
    }
    for (i = 0, n = this._mlen; i < n; ++i) {
      this.celltuple(mods[i]);
      mods[i] = null;
    }
    this._alen = this._mlen = 0;
  }
});
function KDE(params2) {
  Transform.call(this, null, params2);
}
KDE.Definition = {
  "type": "KDE",
  "metadata": {
    "generates": true
  },
  "params": [{
    "name": "groupby",
    "type": "field",
    "array": true
  }, {
    "name": "field",
    "type": "field",
    "required": true
  }, {
    "name": "cumulative",
    "type": "boolean",
    "default": false
  }, {
    "name": "counts",
    "type": "boolean",
    "default": false
  }, {
    "name": "bandwidth",
    "type": "number",
    "default": 0
  }, {
    "name": "extent",
    "type": "number",
    "array": true,
    "length": 2
  }, {
    "name": "resolve",
    "type": "enum",
    "values": ["shared", "independent"],
    "default": "independent"
  }, {
    "name": "steps",
    "type": "number"
  }, {
    "name": "minsteps",
    "type": "number",
    "default": 25
  }, {
    "name": "maxsteps",
    "type": "number",
    "default": 200
  }, {
    "name": "as",
    "type": "string",
    "array": true,
    "default": ["value", "density"]
  }]
};
inherits3(KDE, Transform, {
  transform(_, pulse2) {
    const out = pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS);
    if (!this.value || pulse2.changed() || _.modified()) {
      const source3 = pulse2.materialize(pulse2.SOURCE).source, groups2 = partition$1(source3, _.groupby, _.field), names = (_.groupby || []).map(accessorName2), bandwidth2 = _.bandwidth, method10 = _.cumulative ? "cdf" : "pdf", as = _.as || ["value", "density"], values7 = [];
      let domain3 = _.extent, minsteps = _.steps || _.minsteps || 25, maxsteps = _.steps || _.maxsteps || 200;
      if (method10 !== "pdf" && method10 !== "cdf") {
        error3("Invalid density method: " + method10);
      }
      if (_.resolve === "shared") {
        if (!domain3)
          domain3 = extent3(source3, _.field);
        minsteps = maxsteps = _.steps || maxsteps;
      }
      groups2.forEach((g) => {
        const density = kde(g, bandwidth2)[method10], scale19 = _.counts ? g.length : 1, local = domain3 || extent3(g);
        sampleCurve(density, local, minsteps, maxsteps).forEach((v2) => {
          const t = {};
          for (let i = 0; i < names.length; ++i) {
            t[names[i]] = g.dims[i];
          }
          t[as[0]] = v2[0];
          t[as[1]] = v2[1] * scale19;
          values7.push(ingest$1(t));
        });
      });
      if (this.value)
        out.rem = this.value;
      this.value = out.add = out.source = values7;
    }
    return out;
  }
});
function Key(params2) {
  Operator.call(this, null, update$2, params2);
}
inherits3(Key, Operator);
function update$2(_) {
  return this.value && !_.modified() ? this.value : key2(_.fields, _.flat);
}
function Load(params2) {
  Transform.call(this, [], params2);
  this._pending = null;
}
inherits3(Load, Transform, {
  transform(_, pulse2) {
    const df = pulse2.dataflow;
    if (this._pending) {
      return output2(this, pulse2, this._pending);
    }
    if (stop(_))
      return pulse2.StopPropagation;
    if (_.values) {
      return output2(this, pulse2, df.parse(_.values, _.format));
    } else if (_.async) {
      const p = df.request(_.url, _.format).then((res) => {
        this._pending = array4(res.data);
        return (df2) => df2.touch(this);
      });
      return {
        async: p
      };
    } else {
      return df.request(_.url, _.format).then((res) => output2(this, pulse2, array4(res.data)));
    }
  }
});
function stop(_) {
  return _.modified("async") && !(_.modified("values") || _.modified("url") || _.modified("format"));
}
function output2(op, pulse2, data3) {
  data3.forEach(ingest$1);
  const out = pulse2.fork(pulse2.NO_FIELDS & pulse2.NO_SOURCE);
  out.rem = op.value;
  op.value = out.source = out.add = data3;
  op._pending = null;
  if (out.rem.length)
    out.clean(true);
  return out;
}
function Lookup(params2) {
  Transform.call(this, {}, params2);
}
Lookup.Definition = {
  "type": "Lookup",
  "metadata": {
    "modifies": true
  },
  "params": [{
    "name": "index",
    "type": "index",
    "params": [{
      "name": "from",
      "type": "data",
      "required": true
    }, {
      "name": "key",
      "type": "field",
      "required": true
    }]
  }, {
    "name": "values",
    "type": "field",
    "array": true
  }, {
    "name": "fields",
    "type": "field",
    "array": true,
    "required": true
  }, {
    "name": "as",
    "type": "string",
    "array": true
  }, {
    "name": "default",
    "default": null
  }]
};
inherits3(Lookup, Transform, {
  transform(_, pulse2) {
    const keys5 = _.fields, index4 = _.index, values7 = _.values, defaultValue = _.default == null ? null : _.default, reset3 = _.modified(), n = keys5.length;
    let flag2 = reset3 ? pulse2.SOURCE : pulse2.ADD, out = pulse2, as = _.as, set7, m3, mods;
    if (values7) {
      m3 = values7.length;
      if (n > 1 && !as) {
        error3('Multi-field lookup requires explicit "as" parameter.');
      }
      if (as && as.length !== n * m3) {
        error3('The "as" parameter has too few output field names.');
      }
      as = as || values7.map(accessorName2);
      set7 = function(t) {
        for (var i = 0, k3 = 0, j, v2; i < n; ++i) {
          v2 = index4.get(keys5[i](t));
          if (v2 == null)
            for (j = 0; j < m3; ++j, ++k3)
              t[as[k3]] = defaultValue;
          else
            for (j = 0; j < m3; ++j, ++k3)
              t[as[k3]] = values7[j](v2);
        }
      };
    } else {
      if (!as) {
        error3("Missing output field names.");
      }
      set7 = function(t) {
        for (var i = 0, v2; i < n; ++i) {
          v2 = index4.get(keys5[i](t));
          t[as[i]] = v2 == null ? defaultValue : v2;
        }
      };
    }
    if (reset3) {
      out = pulse2.reflow(true);
    } else {
      mods = keys5.some((k3) => pulse2.modified(k3.fields));
      flag2 |= mods ? pulse2.MOD : 0;
    }
    pulse2.visit(flag2, set7);
    return out.modifies(as);
  }
});
function MultiExtent(params2) {
  Operator.call(this, null, update$1, params2);
}
inherits3(MultiExtent, Operator);
function update$1(_) {
  if (this.value && !_.modified()) {
    return this.value;
  }
  const ext = _.extents, n = ext.length;
  let min5 = Infinity, max5 = -Infinity, i, e3;
  for (i = 0; i < n; ++i) {
    e3 = ext[i];
    if (e3[0] < min5)
      min5 = e3[0];
    if (e3[1] > max5)
      max5 = e3[1];
  }
  return [min5, max5];
}
function MultiValues(params2) {
  Operator.call(this, null, update2, params2);
}
inherits3(MultiValues, Operator);
function update2(_) {
  return this.value && !_.modified() ? this.value : _.values.reduce((data3, _2) => data3.concat(_2), []);
}
function Params(params2) {
  Transform.call(this, null, params2);
}
inherits3(Params, Transform, {
  transform(_, pulse2) {
    this.modified(_.modified());
    this.value = _;
    return pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS);
  }
});
function Pivot(params2) {
  Aggregate.call(this, params2);
}
Pivot.Definition = {
  "type": "Pivot",
  "metadata": {
    "generates": true,
    "changes": true
  },
  "params": [{
    "name": "groupby",
    "type": "field",
    "array": true
  }, {
    "name": "field",
    "type": "field",
    "required": true
  }, {
    "name": "value",
    "type": "field",
    "required": true
  }, {
    "name": "op",
    "type": "enum",
    "values": ValidAggregateOps,
    "default": "sum"
  }, {
    "name": "limit",
    "type": "number",
    "default": 0
  }, {
    "name": "key",
    "type": "field"
  }]
};
inherits3(Pivot, Aggregate, {
  _transform: Aggregate.prototype.transform,
  transform(_, pulse2) {
    return this._transform(aggregateParams(_, pulse2), pulse2);
  }
});
function aggregateParams(_, pulse2) {
  const key4 = _.field, value7 = _.value, op = (_.op === "count" ? "__count__" : _.op) || "sum", fields = accessorFields2(key4).concat(accessorFields2(value7)), keys5 = pivotKeys(key4, _.limit || 0, pulse2);
  if (pulse2.changed())
    _.set("__pivot__", null, null, true);
  return {
    key: _.key,
    groupby: _.groupby,
    ops: keys5.map(() => op),
    fields: keys5.map((k3) => get(k3, key4, value7, fields)),
    as: keys5.map((k3) => k3 + ""),
    modified: _.modified.bind(_)
  };
}
function get(k3, key4, value7, fields) {
  return accessor3((d) => key4(d) === k3 ? value7(d) : NaN, fields, k3 + "");
}
function pivotKeys(key4, limit, pulse2) {
  const map13 = {}, list = [];
  pulse2.visit(pulse2.SOURCE, (t) => {
    const k3 = key4(t);
    if (!map13[k3]) {
      map13[k3] = 1;
      list.push(k3);
    }
  });
  list.sort(ascending3);
  return limit ? list.slice(0, limit) : list;
}
function PreFacet(params2) {
  Facet.call(this, params2);
}
inherits3(PreFacet, Facet, {
  transform(_, pulse2) {
    const flow = _.subflow, field25 = _.field, subflow = (t) => this.subflow(tupleid(t), flow, pulse2, t);
    if (_.modified("field") || field25 && pulse2.modified(accessorFields2(field25))) {
      error3("PreFacet does not support field modification.");
    }
    this.initTargets();
    if (field25) {
      pulse2.visit(pulse2.MOD, (t) => {
        const sf = subflow(t);
        field25(t).forEach((_2) => sf.mod(_2));
      });
      pulse2.visit(pulse2.ADD, (t) => {
        const sf = subflow(t);
        field25(t).forEach((_2) => sf.add(ingest$1(_2)));
      });
      pulse2.visit(pulse2.REM, (t) => {
        const sf = subflow(t);
        field25(t).forEach((_2) => sf.rem(_2));
      });
    } else {
      pulse2.visit(pulse2.MOD, (t) => subflow(t).mod(t));
      pulse2.visit(pulse2.ADD, (t) => subflow(t).add(t));
      pulse2.visit(pulse2.REM, (t) => subflow(t).rem(t));
    }
    if (pulse2.clean()) {
      pulse2.runAfter(() => this.clean());
    }
    return pulse2;
  }
});
function Project(params2) {
  Transform.call(this, null, params2);
}
Project.Definition = {
  "type": "Project",
  "metadata": {
    "generates": true,
    "changes": true
  },
  "params": [{
    "name": "fields",
    "type": "field",
    "array": true
  }, {
    "name": "as",
    "type": "string",
    "null": true,
    "array": true
  }]
};
inherits3(Project, Transform, {
  transform(_, pulse2) {
    const out = pulse2.fork(pulse2.NO_SOURCE), fields = _.fields, as = fieldNames(_.fields, _.as || []), derive2 = fields ? (s2, t) => project(s2, t, fields, as) : rederive;
    let lut;
    if (this.value) {
      lut = this.value;
    } else {
      pulse2 = pulse2.addAll();
      lut = this.value = {};
    }
    pulse2.visit(pulse2.REM, (t) => {
      const id24 = tupleid(t);
      out.rem.push(lut[id24]);
      lut[id24] = null;
    });
    pulse2.visit(pulse2.ADD, (t) => {
      const dt = derive2(t, ingest$1({}));
      lut[tupleid(t)] = dt;
      out.add.push(dt);
    });
    pulse2.visit(pulse2.MOD, (t) => {
      out.mod.push(derive2(t, lut[tupleid(t)]));
    });
    return out;
  }
});
function project(s2, t, fields, as) {
  for (let i = 0, n = fields.length; i < n; ++i) {
    t[as[i]] = fields[i](s2);
  }
  return t;
}
function Proxy(params2) {
  Transform.call(this, null, params2);
}
inherits3(Proxy, Transform, {
  transform(_, pulse2) {
    this.value = _.value;
    return _.modified("value") ? pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS) : pulse2.StopPropagation;
  }
});
function Quantile(params2) {
  Transform.call(this, null, params2);
}
Quantile.Definition = {
  "type": "Quantile",
  "metadata": {
    "generates": true,
    "changes": true
  },
  "params": [{
    "name": "groupby",
    "type": "field",
    "array": true
  }, {
    "name": "field",
    "type": "field",
    "required": true
  }, {
    "name": "probs",
    "type": "number",
    "array": true
  }, {
    "name": "step",
    "type": "number",
    "default": 0.01
  }, {
    "name": "as",
    "type": "string",
    "array": true,
    "default": ["prob", "value"]
  }]
};
var EPSILON = 1e-14;
inherits3(Quantile, Transform, {
  transform(_, pulse2) {
    const out = pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS), as = _.as || ["prob", "value"];
    if (this.value && !_.modified() && !pulse2.changed()) {
      out.source = this.value;
      return out;
    }
    const source3 = pulse2.materialize(pulse2.SOURCE).source, groups2 = partition$1(source3, _.groupby, _.field), names = (_.groupby || []).map(accessorName2), values7 = [], step = _.step || 0.01, p = _.probs || range(step / 2, 1 - EPSILON, step), n = p.length;
    groups2.forEach((g) => {
      const q = quantiles(g, p);
      for (let i = 0; i < n; ++i) {
        const t = {};
        for (let i2 = 0; i2 < names.length; ++i2) {
          t[names[i2]] = g.dims[i2];
        }
        t[as[0]] = p[i];
        t[as[1]] = q[i];
        values7.push(ingest$1(t));
      }
    });
    if (this.value)
      out.rem = this.value;
    this.value = out.add = out.source = values7;
    return out;
  }
});
function Relay(params2) {
  Transform.call(this, null, params2);
}
inherits3(Relay, Transform, {
  transform(_, pulse2) {
    let out, lut;
    if (this.value) {
      lut = this.value;
    } else {
      out = pulse2 = pulse2.addAll();
      lut = this.value = {};
    }
    if (_.derive) {
      out = pulse2.fork(pulse2.NO_SOURCE);
      pulse2.visit(pulse2.REM, (t) => {
        const id24 = tupleid(t);
        out.rem.push(lut[id24]);
        lut[id24] = null;
      });
      pulse2.visit(pulse2.ADD, (t) => {
        const dt = derive(t);
        lut[tupleid(t)] = dt;
        out.add.push(dt);
      });
      pulse2.visit(pulse2.MOD, (t) => {
        const dt = lut[tupleid(t)];
        for (const k3 in t) {
          dt[k3] = t[k3];
          out.modifies(k3);
        }
        out.mod.push(dt);
      });
    }
    return out;
  }
});
function Sample(params2) {
  Transform.call(this, [], params2);
  this.count = 0;
}
Sample.Definition = {
  "type": "Sample",
  "metadata": {},
  "params": [{
    "name": "size",
    "type": "number",
    "default": 1e3
  }]
};
inherits3(Sample, Transform, {
  transform(_, pulse2) {
    const out = pulse2.fork(pulse2.NO_SOURCE), mod = _.modified("size"), num = _.size, map13 = this.value.reduce((m3, t) => (m3[tupleid(t)] = 1, m3), {});
    let res = this.value, cnt = this.count, cap = 0;
    function update3(t) {
      let p, idx;
      if (res.length < num) {
        res.push(t);
      } else {
        idx = ~~((cnt + 1) * random());
        if (idx < res.length && idx >= cap) {
          p = res[idx];
          if (map13[tupleid(p)])
            out.rem.push(p);
          res[idx] = t;
        }
      }
      ++cnt;
    }
    if (pulse2.rem.length) {
      pulse2.visit(pulse2.REM, (t) => {
        const id24 = tupleid(t);
        if (map13[id24]) {
          map13[id24] = -1;
          out.rem.push(t);
        }
        --cnt;
      });
      res = res.filter((t) => map13[tupleid(t)] !== -1);
    }
    if ((pulse2.rem.length || mod) && res.length < num && pulse2.source) {
      cap = cnt = res.length;
      pulse2.visit(pulse2.SOURCE, (t) => {
        if (!map13[tupleid(t)])
          update3(t);
      });
      cap = -1;
    }
    if (mod && res.length > num) {
      const n = res.length - num;
      for (let i = 0; i < n; ++i) {
        map13[tupleid(res[i])] = -1;
        out.rem.push(res[i]);
      }
      res = res.slice(n);
    }
    if (pulse2.mod.length) {
      pulse2.visit(pulse2.MOD, (t) => {
        if (map13[tupleid(t)])
          out.mod.push(t);
      });
    }
    if (pulse2.add.length) {
      pulse2.visit(pulse2.ADD, update3);
    }
    if (pulse2.add.length || cap < 0) {
      out.add = res.filter((t) => !map13[tupleid(t)]);
    }
    this.count = cnt;
    this.value = out.source = res;
    return out;
  }
});
function Sequence(params2) {
  Transform.call(this, null, params2);
}
Sequence.Definition = {
  "type": "Sequence",
  "metadata": {
    "generates": true,
    "changes": true
  },
  "params": [{
    "name": "start",
    "type": "number",
    "required": true
  }, {
    "name": "stop",
    "type": "number",
    "required": true
  }, {
    "name": "step",
    "type": "number",
    "default": 1
  }, {
    "name": "as",
    "type": "string",
    "default": "data"
  }]
};
inherits3(Sequence, Transform, {
  transform(_, pulse2) {
    if (this.value && !_.modified())
      return;
    const out = pulse2.materialize().fork(pulse2.MOD), as = _.as || "data";
    out.rem = this.value ? pulse2.rem.concat(this.value) : pulse2.rem;
    this.value = range(_.start, _.stop, _.step || 1).map((v2) => {
      const t = {};
      t[as] = v2;
      return ingest$1(t);
    });
    out.add = pulse2.add.concat(this.value);
    return out;
  }
});
function Sieve(params2) {
  Transform.call(this, null, params2);
  this.modified(true);
}
inherits3(Sieve, Transform, {
  transform(_, pulse2) {
    this.value = pulse2.source;
    return pulse2.changed() ? pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS) : pulse2.StopPropagation;
  }
});
function TimeUnit(params2) {
  Transform.call(this, null, params2);
}
var OUTPUT = ["unit0", "unit1"];
TimeUnit.Definition = {
  "type": "TimeUnit",
  "metadata": {
    "modifies": true
  },
  "params": [{
    "name": "field",
    "type": "field",
    "required": true
  }, {
    "name": "interval",
    "type": "boolean",
    "default": true
  }, {
    "name": "units",
    "type": "enum",
    "values": TIME_UNITS2,
    "array": true
  }, {
    "name": "step",
    "type": "number",
    "default": 1
  }, {
    "name": "maxbins",
    "type": "number",
    "default": 40
  }, {
    "name": "extent",
    "type": "date",
    "array": true
  }, {
    "name": "timezone",
    "type": "enum",
    "default": "local",
    "values": ["local", "utc"]
  }, {
    "name": "as",
    "type": "string",
    "array": true,
    "length": 2,
    "default": OUTPUT
  }]
};
inherits3(TimeUnit, Transform, {
  transform(_, pulse2) {
    const field25 = _.field, band11 = _.interval !== false, utc = _.timezone === "utc", floor4 = this._floor(_, pulse2), offset9 = (utc ? utcInterval2 : timeInterval3)(floor4.unit).offset, as = _.as || OUTPUT, u0 = as[0], u1 = as[1], step = floor4.step;
    let min5 = floor4.start || Infinity, max5 = floor4.stop || -Infinity, flag2 = pulse2.ADD;
    if (_.modified() || pulse2.changed(pulse2.REM) || pulse2.modified(accessorFields2(field25))) {
      pulse2 = pulse2.reflow(true);
      flag2 = pulse2.SOURCE;
      min5 = Infinity;
      max5 = -Infinity;
    }
    pulse2.visit(flag2, (t) => {
      const v2 = field25(t);
      let a4, b6;
      if (v2 == null) {
        t[u0] = null;
        if (band11)
          t[u1] = null;
      } else {
        t[u0] = a4 = b6 = floor4(v2);
        if (band11)
          t[u1] = b6 = offset9(a4, step);
        if (a4 < min5)
          min5 = a4;
        if (b6 > max5)
          max5 = b6;
      }
    });
    floor4.start = min5;
    floor4.stop = max5;
    return pulse2.modifies(band11 ? as : u0);
  },
  _floor(_, pulse2) {
    const utc = _.timezone === "utc";
    const {
      units,
      step
    } = _.units ? {
      units: _.units,
      step: _.step || 1
    } : bin3({
      extent: _.extent || extent3(pulse2.materialize(pulse2.SOURCE).source, _.field),
      maxbins: _.maxbins
    });
    const tunits = timeUnits(units), prev = this.value || {}, floor4 = (utc ? utcFloor : timeFloor)(tunits, step);
    floor4.unit = peek3(tunits);
    floor4.units = tunits;
    floor4.step = step;
    floor4.start = prev.start;
    floor4.stop = prev.stop;
    return this.value = floor4;
  }
});
function TupleIndex(params2) {
  Transform.call(this, fastmap2(), params2);
}
inherits3(TupleIndex, Transform, {
  transform(_, pulse2) {
    const df = pulse2.dataflow, field25 = _.field, index4 = this.value, set7 = (t) => index4.set(field25(t), t);
    let mod = true;
    if (_.modified("field") || pulse2.modified(field25.fields)) {
      index4.clear();
      pulse2.visit(pulse2.SOURCE, set7);
    } else if (pulse2.changed()) {
      pulse2.visit(pulse2.REM, (t) => index4.delete(field25(t)));
      pulse2.visit(pulse2.ADD, set7);
    } else {
      mod = false;
    }
    this.modified(mod);
    if (index4.empty > df.cleanThreshold)
      df.runAfter(index4.clean);
    return pulse2.fork();
  }
});
function Values(params2) {
  Transform.call(this, null, params2);
}
inherits3(Values, Transform, {
  transform(_, pulse2) {
    const run2 = !this.value || _.modified("field") || _.modified("sort") || pulse2.changed() || _.sort && pulse2.modified(_.sort.fields);
    if (run2) {
      this.value = (_.sort ? pulse2.source.slice().sort(stableCompare(_.sort)) : pulse2.source).map(_.field);
    }
  }
});
function WindowOp(op, field25, param2, as) {
  const fn = WindowOps[op](field25, param2);
  return {
    init: fn.init || zero4,
    update: function(w8, t) {
      t[as] = fn.next(w8);
    }
  };
}
var WindowOps = {
  row_number: function() {
    return {
      next: (w8) => w8.index + 1
    };
  },
  rank: function() {
    let rank3;
    return {
      init: () => rank3 = 1,
      next: (w8) => {
        const i = w8.index, data3 = w8.data;
        return i && w8.compare(data3[i - 1], data3[i]) ? rank3 = i + 1 : rank3;
      }
    };
  },
  dense_rank: function() {
    let drank;
    return {
      init: () => drank = 1,
      next: (w8) => {
        const i = w8.index, d = w8.data;
        return i && w8.compare(d[i - 1], d[i]) ? ++drank : drank;
      }
    };
  },
  percent_rank: function() {
    const rank3 = WindowOps.rank(), next = rank3.next;
    return {
      init: rank3.init,
      next: (w8) => (next(w8) - 1) / (w8.data.length - 1)
    };
  },
  cume_dist: function() {
    let cume;
    return {
      init: () => cume = 0,
      next: (w8) => {
        const d = w8.data, c5 = w8.compare;
        let i = w8.index;
        if (cume < i) {
          while (i + 1 < d.length && !c5(d[i], d[i + 1]))
            ++i;
          cume = i;
        }
        return (1 + cume) / d.length;
      }
    };
  },
  ntile: function(field25, num) {
    num = +num;
    if (!(num > 0))
      error3("ntile num must be greater than zero.");
    const cume = WindowOps.cume_dist(), next = cume.next;
    return {
      init: cume.init,
      next: (w8) => Math.ceil(num * next(w8))
    };
  },
  lag: function(field25, offset9) {
    offset9 = +offset9 || 1;
    return {
      next: (w8) => {
        const i = w8.index - offset9;
        return i >= 0 ? field25(w8.data[i]) : null;
      }
    };
  },
  lead: function(field25, offset9) {
    offset9 = +offset9 || 1;
    return {
      next: (w8) => {
        const i = w8.index + offset9, d = w8.data;
        return i < d.length ? field25(d[i]) : null;
      }
    };
  },
  first_value: function(field25) {
    return {
      next: (w8) => field25(w8.data[w8.i0])
    };
  },
  last_value: function(field25) {
    return {
      next: (w8) => field25(w8.data[w8.i1 - 1])
    };
  },
  nth_value: function(field25, nth) {
    nth = +nth;
    if (!(nth > 0))
      error3("nth_value nth must be greater than zero.");
    return {
      next: (w8) => {
        const i = w8.i0 + (nth - 1);
        return i < w8.i1 ? field25(w8.data[i]) : null;
      }
    };
  },
  prev_value: function(field25) {
    let prev;
    return {
      init: () => prev = null,
      next: (w8) => {
        const v2 = field25(w8.data[w8.index]);
        return v2 != null ? prev = v2 : prev;
      }
    };
  },
  next_value: function(field25) {
    let v2, i;
    return {
      init: () => (v2 = null, i = -1),
      next: (w8) => {
        const d = w8.data;
        return w8.index <= i ? v2 : (i = find(field25, d, w8.index)) < 0 ? (i = d.length, v2 = null) : v2 = field25(d[i]);
      }
    };
  }
};
function find(field25, data3, index4) {
  for (let n = data3.length; index4 < n; ++index4) {
    const v2 = field25(data3[index4]);
    if (v2 != null)
      return index4;
  }
  return -1;
}
var ValidWindowOps = Object.keys(WindowOps);
function WindowState(_) {
  const ops2 = array4(_.ops), fields = array4(_.fields), params2 = array4(_.params), aggregate_params = array4(_.aggregate_params), as = array4(_.as), outputs = this.outputs = [], windows = this.windows = [], inputs = {}, map13 = {}, counts = [], measures = [];
  let countOnly = true;
  function visitInputs(f) {
    array4(accessorFields2(f)).forEach((_2) => inputs[_2] = 1);
  }
  visitInputs(_.sort);
  ops2.forEach((op, i) => {
    const field25 = fields[i], param2 = params2[i], aggregate_param = aggregate_params[i] || null, mname = accessorName2(field25), name = measureName(op, mname, as[i]);
    visitInputs(field25);
    outputs.push(name);
    if (has3(WindowOps, op)) {
      windows.push(WindowOp(op, field25, param2, name));
    } else {
      if (field25 == null && op !== "count") {
        error3("Null aggregate field specified.");
      }
      if (op === "count") {
        counts.push(name);
        return;
      }
      countOnly = false;
      let m3 = map13[mname];
      if (!m3) {
        m3 = map13[mname] = [];
        m3.field = field25;
        measures.push(m3);
      }
      m3.push(createMeasure(op, aggregate_param, name));
    }
  });
  if (counts.length || measures.length) {
    this.cell = cell(measures, counts, countOnly);
  }
  this.inputs = Object.keys(inputs);
}
var prototype = WindowState.prototype;
prototype.init = function() {
  this.windows.forEach((_) => _.init());
  if (this.cell)
    this.cell.init();
};
prototype.update = function(w8, t) {
  const cell2 = this.cell, wind = this.windows, data3 = w8.data, m3 = wind && wind.length;
  let j;
  if (cell2) {
    for (j = w8.p0; j < w8.i0; ++j)
      cell2.rem(data3[j]);
    for (j = w8.p1; j < w8.i1; ++j)
      cell2.add(data3[j]);
    cell2.set(t);
  }
  for (j = 0; j < m3; ++j)
    wind[j].update(w8, t);
};
function cell(measures, counts, countOnly) {
  measures = measures.map((m3) => compileMeasures(m3, m3.field));
  const cell2 = {
    num: 0,
    agg: null,
    store: false,
    count: counts
  };
  if (!countOnly) {
    var n = measures.length, a4 = cell2.agg = Array(n), i = 0;
    for (; i < n; ++i)
      a4[i] = new measures[i](cell2);
  }
  if (cell2.store) {
    var store = cell2.data = new TupleStore();
  }
  cell2.add = function(t) {
    cell2.num += 1;
    if (countOnly)
      return;
    if (store)
      store.add(t);
    for (let i2 = 0; i2 < n; ++i2) {
      a4[i2].add(a4[i2].get(t), t);
    }
  };
  cell2.rem = function(t) {
    cell2.num -= 1;
    if (countOnly)
      return;
    if (store)
      store.rem(t);
    for (let i2 = 0; i2 < n; ++i2) {
      a4[i2].rem(a4[i2].get(t), t);
    }
  };
  cell2.set = function(t) {
    let i2, n2;
    if (store)
      store.values();
    for (i2 = 0, n2 = counts.length; i2 < n2; ++i2)
      t[counts[i2]] = cell2.num;
    if (!countOnly)
      for (i2 = 0, n2 = a4.length; i2 < n2; ++i2)
        a4[i2].set(t);
  };
  cell2.init = function() {
    cell2.num = 0;
    if (store)
      store.reset();
    for (let i2 = 0; i2 < n; ++i2)
      a4[i2].init();
  };
  return cell2;
}
function Window(params2) {
  Transform.call(this, {}, params2);
  this._mlen = 0;
  this._mods = [];
}
Window.Definition = {
  "type": "Window",
  "metadata": {
    "modifies": true
  },
  "params": [{
    "name": "sort",
    "type": "compare"
  }, {
    "name": "groupby",
    "type": "field",
    "array": true
  }, {
    "name": "ops",
    "type": "enum",
    "array": true,
    "values": ValidWindowOps.concat(ValidAggregateOps)
  }, {
    "name": "params",
    "type": "number",
    "null": true,
    "array": true
  }, {
    "name": "aggregate_params",
    "type": "number",
    "null": true,
    "array": true
  }, {
    "name": "fields",
    "type": "field",
    "null": true,
    "array": true
  }, {
    "name": "as",
    "type": "string",
    "null": true,
    "array": true
  }, {
    "name": "frame",
    "type": "number",
    "null": true,
    "array": true,
    "length": 2,
    "default": [null, 0]
  }, {
    "name": "ignorePeers",
    "type": "boolean",
    "default": false
  }]
};
inherits3(Window, Transform, {
  transform(_, pulse2) {
    this.stamp = pulse2.stamp;
    const mod = _.modified(), cmp = stableCompare(_.sort), key4 = groupkey(_.groupby), group7 = (t) => this.group(key4(t));
    let state = this.state;
    if (!state || mod) {
      state = this.state = new WindowState(_);
    }
    if (mod || pulse2.modified(state.inputs)) {
      this.value = {};
      pulse2.visit(pulse2.SOURCE, (t) => group7(t).add(t));
    } else {
      pulse2.visit(pulse2.REM, (t) => group7(t).remove(t));
      pulse2.visit(pulse2.ADD, (t) => group7(t).add(t));
    }
    for (let i = 0, n = this._mlen; i < n; ++i) {
      processPartition(this._mods[i], state, cmp, _);
    }
    this._mlen = 0;
    this._mods = [];
    return pulse2.reflow(mod).modifies(state.outputs);
  },
  group(key4) {
    let group7 = this.value[key4];
    if (!group7) {
      group7 = this.value[key4] = SortedList(tupleid);
      group7.stamp = -1;
    }
    if (group7.stamp < this.stamp) {
      group7.stamp = this.stamp;
      this._mods[this._mlen++] = group7;
    }
    return group7;
  }
});
function processPartition(list, state, cmp, _) {
  const sort4 = _.sort, range7 = sort4 && !_.ignorePeers, frame2 = _.frame || [null, 0], data3 = list.data(cmp), n = data3.length, b6 = range7 ? bisector(sort4) : null, w8 = {
    i0: 0,
    i1: 0,
    p0: 0,
    p1: 0,
    index: 0,
    data: data3,
    compare: sort4 || constant4(-1)
  };
  state.init();
  for (let i = 0; i < n; ++i) {
    setWindow(w8, frame2, i, n);
    if (range7)
      adjustRange(w8, b6);
    state.update(w8, data3[i]);
  }
}
function setWindow(w8, f, i, n) {
  w8.p0 = w8.i0;
  w8.p1 = w8.i1;
  w8.i0 = f[0] == null ? 0 : Math.max(0, i - Math.abs(f[0]));
  w8.i1 = f[1] == null ? n : Math.min(n, i + Math.abs(f[1]) + 1);
  w8.index = i;
}
function adjustRange(w8, bisect2) {
  const r0 = w8.i0, r1 = w8.i1 - 1, c5 = w8.compare, d = w8.data, n = d.length - 1;
  if (r0 > 0 && !c5(d[r0], d[r0 - 1]))
    w8.i0 = bisect2.left(d, d[r0]);
  if (r1 < n && !c5(d[r1], d[r1 + 1]))
    w8.i1 = bisect2.right(d, d[r1]);
}

// node_modules/vega-view-transforms/build/vega-view-transforms.js
var vega_view_transforms_exports = {};
__export(vega_view_transforms_exports, {
  bound: () => Bound,
  identifier: () => Identifier,
  mark: () => Mark,
  overlap: () => Overlap,
  render: () => Render,
  viewlayout: () => ViewLayout
});

// node_modules/vega-view-transforms/node_modules/vega-util/build/vega-util.js
function accessor4(fn, fields, name) {
  fn.fields = fields || [];
  fn.fname = name;
  return fn;
}
function getter4(path7) {
  return path7.length === 1 ? get14(path7[0]) : getN4(path7);
}
var get14 = (field25) => function(obj) {
  return obj[field25];
};
var getN4 = (path7) => {
  const len = path7.length;
  return function(obj) {
    for (let i = 0; i < len; ++i) {
      obj = obj[path7[i]];
    }
    return obj;
  };
};
function error4(message) {
  throw Error(message);
}
function splitAccessPath4(p) {
  const path7 = [], n = p.length;
  let q = null, b6 = 0, s2 = "", i, j, c5;
  p = p + "";
  function push() {
    path7.push(s2 + p.substring(i, j));
    s2 = "";
    i = j + 1;
  }
  for (i = j = 0; j < n; ++j) {
    c5 = p[j];
    if (c5 === "\\") {
      s2 += p.substring(i, j++);
      i = j;
    } else if (c5 === q) {
      push();
      q = null;
      b6 = -1;
    } else if (q) {
      continue;
    } else if (i === b6 && c5 === '"') {
      i = j + 1;
      q = c5;
    } else if (i === b6 && c5 === "'") {
      i = j + 1;
      q = c5;
    } else if (c5 === "." && !b6) {
      if (j > i) {
        push();
      } else {
        i = j + 1;
      }
    } else if (c5 === "[") {
      if (j > i)
        push();
      b6 = i = j + 1;
    } else if (c5 === "]") {
      if (!b6)
        error4("Access path missing open bracket: " + p);
      if (b6 > 0)
        push();
      b6 = 0;
      i = j + 1;
    }
  }
  if (b6)
    error4("Access path missing closing bracket: " + p);
  if (q)
    error4("Access path missing closing quote: " + p);
  if (j > i) {
    j++;
    push();
  }
  return path7;
}
function field4(field25, name, opt) {
  const path7 = splitAccessPath4(field25);
  field25 = path7.length === 1 ? path7[0] : field25;
  return accessor4((opt && opt.get || getter4)(path7), [field25], name || field25);
}
var id4 = field4("id");
var identity5 = accessor4((_) => _, [], "identity");
var zero5 = accessor4(() => 0, [], "zero");
var one4 = accessor4(() => 1, [], "one");
var truthy4 = accessor4(() => true, [], "true");
var falsy4 = accessor4(() => false, [], "false");
var DisallowedObjectProperties4 = /* @__PURE__ */ new Set([...Object.getOwnPropertyNames(Object.prototype).filter((name) => typeof Object.prototype[name] === "function"), "__proto__"]);
var isArray4 = Array.isArray;
function isObject3(_) {
  return _ === Object(_);
}
function peek4(array22) {
  return array22[array22.length - 1];
}
function toNumber4(_) {
  return _ == null || _ === "" ? null : +_;
}
function array5(_) {
  return _ != null ? isArray4(_) ? _ : [_] : [];
}
function isFunction4(_) {
  return typeof _ === "function";
}
function extend4(_) {
  for (let x9, k3, i = 1, len = arguments.length; i < len; ++i) {
    x9 = arguments[i];
    for (k3 in x9) {
      _[k3] = x9[k3];
    }
  }
  return _;
}
function has4(object2, property2) {
  return Object.hasOwn(object2, property2);
}
function inherits4(child, parent, members) {
  const proto = child.prototype = Object.create(parent.prototype);
  Object.defineProperty(proto, "constructor", {
    value: child,
    writable: true,
    enumerable: true,
    configurable: true
  });
  return extend4(proto, members);
}
function isIterable3(_) {
  return _ && isFunction4(_[Symbol.iterator]);
}
function isString3(_) {
  return typeof _ === "string";
}
var DEFAULT_MAX_SIZE2 = 1e4;
function lruCache2(maxsize) {
  maxsize = +maxsize || DEFAULT_MAX_SIZE2;
  let curr, prev, size;
  const clear2 = () => {
    curr = {};
    prev = {};
    size = 0;
  };
  const update3 = (key4, value7) => {
    if (++size > maxsize) {
      prev = curr;
      curr = {};
      size = 1;
    }
    return curr[key4] = value7;
  };
  clear2();
  return {
    clear: clear2,
    has: (key4) => has4(curr, key4) || has4(prev, key4),
    get: (key4) => has4(curr, key4) ? curr[key4] : has4(prev, key4) ? update3(key4, prev[key4]) : void 0,
    set: (key4, value7) => has4(curr, key4) ? curr[key4] = value7 : update3(key4, value7)
  };
}
function $3(x9) {
  return isArray4(x9) ? `[${x9.map((v2) => v2 === null ? "null" : $3(v2))}]` : isObject3(x9) || isString3(x9) ? (
    // Output valid JSON and JS source strings.
    // See https://github.com/judofyr/timeless/blob/master/posts/json-isnt-a-javascript-subset.md
    JSON.stringify(x9).replaceAll("\u2028", "\\u2028").replaceAll("\u2029", "\\u2029")
  ) : x9;
}
function toSet4(_) {
  const s2 = {}, n = _.length;
  for (let i = 0; i < n; ++i)
    s2[_[i]] = true;
  return s2;
}

// node_modules/d3-shape/src/constant.js
function constant_default(x9) {
  return function constant15() {
    return x9;
  };
}

// node_modules/d3-shape/src/math.js
var abs = Math.abs;
var atan2 = Math.atan2;
var cos = Math.cos;
var max2 = Math.max;
var min2 = Math.min;
var sin = Math.sin;
var sqrt = Math.sqrt;
var epsilon2 = 1e-12;
var pi = Math.PI;
var halfPi = pi / 2;
var tau = 2 * pi;
function acos(x9) {
  return x9 > 1 ? 0 : x9 < -1 ? pi : Math.acos(x9);
}
function asin(x9) {
  return x9 >= 1 ? halfPi : x9 <= -1 ? -halfPi : Math.asin(x9);
}

// node_modules/d3-path/src/path.js
var pi2 = Math.PI;
var tau2 = 2 * pi2;
var epsilon3 = 1e-6;
var tauEpsilon = tau2 - epsilon3;
function append(strings) {
  this._ += strings[0];
  for (let i = 1, n = strings.length; i < n; ++i) {
    this._ += arguments[i] + strings[i];
  }
}
function appendRound(digits) {
  let d = Math.floor(digits);
  if (!(d >= 0))
    throw new Error(`invalid digits: ${digits}`);
  if (d > 15)
    return append;
  const k3 = 10 ** d;
  return function(strings) {
    this._ += strings[0];
    for (let i = 1, n = strings.length; i < n; ++i) {
      this._ += Math.round(arguments[i] * k3) / k3 + strings[i];
    }
  };
}
var Path = class {
  constructor(digits) {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null;
    this._ = "";
    this._append = digits == null ? append : appendRound(digits);
  }
  moveTo(x9, y9) {
    this._append`M${this._x0 = this._x1 = +x9},${this._y0 = this._y1 = +y9}`;
  }
  closePath() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._append`Z`;
    }
  }
  lineTo(x9, y9) {
    this._append`L${this._x1 = +x9},${this._y1 = +y9}`;
  }
  quadraticCurveTo(x13, y13, x9, y9) {
    this._append`Q${+x13},${+y13},${this._x1 = +x9},${this._y1 = +y9}`;
  }
  bezierCurveTo(x13, y13, x22, y22, x9, y9) {
    this._append`C${+x13},${+y13},${+x22},${+y22},${this._x1 = +x9},${this._y1 = +y9}`;
  }
  arcTo(x13, y13, x22, y22, r) {
    x13 = +x13, y13 = +y13, x22 = +x22, y22 = +y22, r = +r;
    if (r < 0)
      throw new Error(`negative radius: ${r}`);
    let x07 = this._x1, y07 = this._y1, x21 = x22 - x13, y21 = y22 - y13, x01 = x07 - x13, y01 = y07 - y13, l01_2 = x01 * x01 + y01 * y01;
    if (this._x1 === null) {
      this._append`M${this._x1 = x13},${this._y1 = y13}`;
    } else if (!(l01_2 > epsilon3))
      ;
    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon3) || !r) {
      this._append`L${this._x1 = x13},${this._y1 = y13}`;
    } else {
      let x20 = x22 - x07, y20 = y22 - y07, l21_2 = x21 * x21 + y21 * y21, l20_2 = x20 * x20 + y20 * y20, l21 = Math.sqrt(l21_2), l01 = Math.sqrt(l01_2), l = r * Math.tan((pi2 - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2), t01 = l / l01, t21 = l / l21;
      if (Math.abs(t01 - 1) > epsilon3) {
        this._append`L${x13 + t01 * x01},${y13 + t01 * y01}`;
      }
      this._append`A${r},${r},0,0,${+(y01 * x20 > x01 * y20)},${this._x1 = x13 + t21 * x21},${this._y1 = y13 + t21 * y21}`;
    }
  }
  arc(x9, y9, r, a0, a1, ccw) {
    x9 = +x9, y9 = +y9, r = +r, ccw = !!ccw;
    if (r < 0)
      throw new Error(`negative radius: ${r}`);
    let dx = r * Math.cos(a0), dy = r * Math.sin(a0), x07 = x9 + dx, y07 = y9 + dy, cw2 = 1 ^ ccw, da2 = ccw ? a0 - a1 : a1 - a0;
    if (this._x1 === null) {
      this._append`M${x07},${y07}`;
    } else if (Math.abs(this._x1 - x07) > epsilon3 || Math.abs(this._y1 - y07) > epsilon3) {
      this._append`L${x07},${y07}`;
    }
    if (!r)
      return;
    if (da2 < 0)
      da2 = da2 % tau2 + tau2;
    if (da2 > tauEpsilon) {
      this._append`A${r},${r},0,1,${cw2},${x9 - dx},${y9 - dy}A${r},${r},0,1,${cw2},${this._x1 = x07},${this._y1 = y07}`;
    } else if (da2 > epsilon3) {
      this._append`A${r},${r},0,${+(da2 >= pi2)},${cw2},${this._x1 = x9 + r * Math.cos(a1)},${this._y1 = y9 + r * Math.sin(a1)}`;
    }
  }
  rect(x9, y9, w8, h6) {
    this._append`M${this._x0 = this._x1 = +x9},${this._y0 = this._y1 = +y9}h${w8 = +w8}v${+h6}h${-w8}Z`;
  }
  toString() {
    return this._;
  }
};
function path() {
  return new Path();
}
path.prototype = Path.prototype;

// node_modules/d3-shape/src/path.js
function withPath(shape6) {
  let digits = 3;
  shape6.digits = function(_) {
    if (!arguments.length)
      return digits;
    if (_ == null) {
      digits = null;
    } else {
      const d = Math.floor(_);
      if (!(d >= 0))
        throw new RangeError(`invalid digits: ${_}`);
      digits = d;
    }
    return shape6;
  };
  return () => new Path(digits);
}

// node_modules/d3-shape/src/arc.js
function arcInnerRadius(d) {
  return d.innerRadius;
}
function arcOuterRadius(d) {
  return d.outerRadius;
}
function arcStartAngle(d) {
  return d.startAngle;
}
function arcEndAngle(d) {
  return d.endAngle;
}
function arcPadAngle(d) {
  return d && d.padAngle;
}
function intersect(x07, y07, x13, y13, x22, y22, x32, y32) {
  var x10 = x13 - x07, y10 = y13 - y07, x322 = x32 - x22, y322 = y32 - y22, t = y322 * x10 - x322 * y10;
  if (t * t < epsilon2)
    return;
  t = (x322 * (y07 - y22) - y322 * (x07 - x22)) / t;
  return [x07 + t * x10, y07 + t * y10];
}
function cornerTangents(x07, y07, x13, y13, r1, rc, cw2) {
  var x01 = x07 - x13, y01 = y07 - y13, lo = (cw2 ? rc : -rc) / sqrt(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x11 = x07 + ox, y11 = y07 + oy, x10 = x13 + ox, y10 = y13 + oy, x004 = (x11 + x10) / 2, y004 = (y11 + y10) / 2, dx = x10 - x11, dy = y10 - y11, d2 = dx * dx + dy * dy, r = r1 - rc, D3 = x11 * y10 - x10 * y11, d = (dy < 0 ? -1 : 1) * sqrt(max2(0, r * r * d2 - D3 * D3)), cx0 = (D3 * dy - dx * d) / d2, cy0 = (-D3 * dx - dy * d) / d2, cx1 = (D3 * dy + dx * d) / d2, cy1 = (-D3 * dx + dy * d) / d2, dx0 = cx0 - x004, dy0 = cy0 - y004, dx1 = cx1 - x004, dy1 = cy1 - y004;
  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1)
    cx0 = cx1, cy0 = cy1;
  return {
    cx: cx0,
    cy: cy0,
    x01: -ox,
    y01: -oy,
    x11: cx0 * (r1 / r - 1),
    y11: cy0 * (r1 / r - 1)
  };
}
function arc_default() {
  var innerRadius = arcInnerRadius, outerRadius = arcOuterRadius, cornerRadius = constant_default(0), padRadius = null, startAngle = arcStartAngle, endAngle = arcEndAngle, padAngle = arcPadAngle, context7 = null, path7 = withPath(arc8);
  function arc8() {
    var buffer, r, r0 = +innerRadius.apply(this, arguments), r1 = +outerRadius.apply(this, arguments), a0 = startAngle.apply(this, arguments) - halfPi, a1 = endAngle.apply(this, arguments) - halfPi, da2 = abs(a1 - a0), cw2 = a1 > a0;
    if (!context7)
      context7 = buffer = path7();
    if (r1 < r0)
      r = r1, r1 = r0, r0 = r;
    if (!(r1 > epsilon2))
      context7.moveTo(0, 0);
    else if (da2 > tau - epsilon2) {
      context7.moveTo(r1 * cos(a0), r1 * sin(a0));
      context7.arc(0, 0, r1, a0, a1, !cw2);
      if (r0 > epsilon2) {
        context7.moveTo(r0 * cos(a1), r0 * sin(a1));
        context7.arc(0, 0, r0, a1, a0, cw2);
      }
    } else {
      var a01 = a0, a11 = a1, a00 = a0, a10 = a1, da0 = da2, da1 = da2, ap = padAngle.apply(this, arguments) / 2, rp = ap > epsilon2 && (padRadius ? +padRadius.apply(this, arguments) : sqrt(r0 * r0 + r1 * r1)), rc = min2(abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments)), rc0 = rc, rc1 = rc, t014, t13;
      if (rp > epsilon2) {
        var p02 = asin(rp / r0 * sin(ap)), p1 = asin(rp / r1 * sin(ap));
        if ((da0 -= p02 * 2) > epsilon2)
          p02 *= cw2 ? 1 : -1, a00 += p02, a10 -= p02;
        else
          da0 = 0, a00 = a10 = (a0 + a1) / 2;
        if ((da1 -= p1 * 2) > epsilon2)
          p1 *= cw2 ? 1 : -1, a01 += p1, a11 -= p1;
        else
          da1 = 0, a01 = a11 = (a0 + a1) / 2;
      }
      var x01 = r1 * cos(a01), y01 = r1 * sin(a01), x10 = r0 * cos(a10), y10 = r0 * sin(a10);
      if (rc > epsilon2) {
        var x11 = r1 * cos(a11), y11 = r1 * sin(a11), x004 = r0 * cos(a00), y004 = r0 * sin(a00), oc;
        if (da2 < pi) {
          if (oc = intersect(x01, y01, x004, y004, x11, y11, x10, y10)) {
            var ax = x01 - oc[0], ay = y01 - oc[1], bx = x11 - oc[0], by = y11 - oc[1], kc = 1 / sin(acos((ax * bx + ay * by) / (sqrt(ax * ax + ay * ay) * sqrt(bx * bx + by * by))) / 2), lc = sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
            rc0 = min2(rc, (r0 - lc) / (kc - 1));
            rc1 = min2(rc, (r1 - lc) / (kc + 1));
          } else {
            rc0 = rc1 = 0;
          }
        }
      }
      if (!(da1 > epsilon2))
        context7.moveTo(x01, y01);
      else if (rc1 > epsilon2) {
        t014 = cornerTangents(x004, y004, x01, y01, r1, rc1, cw2);
        t13 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw2);
        context7.moveTo(t014.cx + t014.x01, t014.cy + t014.y01);
        if (rc1 < rc)
          context7.arc(t014.cx, t014.cy, rc1, atan2(t014.y01, t014.x01), atan2(t13.y01, t13.x01), !cw2);
        else {
          context7.arc(t014.cx, t014.cy, rc1, atan2(t014.y01, t014.x01), atan2(t014.y11, t014.x11), !cw2);
          context7.arc(0, 0, r1, atan2(t014.cy + t014.y11, t014.cx + t014.x11), atan2(t13.cy + t13.y11, t13.cx + t13.x11), !cw2);
          context7.arc(t13.cx, t13.cy, rc1, atan2(t13.y11, t13.x11), atan2(t13.y01, t13.x01), !cw2);
        }
      } else
        context7.moveTo(x01, y01), context7.arc(0, 0, r1, a01, a11, !cw2);
      if (!(r0 > epsilon2) || !(da0 > epsilon2))
        context7.lineTo(x10, y10);
      else if (rc0 > epsilon2) {
        t014 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw2);
        t13 = cornerTangents(x01, y01, x004, y004, r0, -rc0, cw2);
        context7.lineTo(t014.cx + t014.x01, t014.cy + t014.y01);
        if (rc0 < rc)
          context7.arc(t014.cx, t014.cy, rc0, atan2(t014.y01, t014.x01), atan2(t13.y01, t13.x01), !cw2);
        else {
          context7.arc(t014.cx, t014.cy, rc0, atan2(t014.y01, t014.x01), atan2(t014.y11, t014.x11), !cw2);
          context7.arc(0, 0, r0, atan2(t014.cy + t014.y11, t014.cx + t014.x11), atan2(t13.cy + t13.y11, t13.cx + t13.x11), cw2);
          context7.arc(t13.cx, t13.cy, rc0, atan2(t13.y11, t13.x11), atan2(t13.y01, t13.x01), !cw2);
        }
      } else
        context7.arc(0, 0, r0, a10, a00, cw2);
    }
    context7.closePath();
    if (buffer)
      return context7 = null, buffer + "" || null;
  }
  arc8.centroid = function() {
    var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2, a4 = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi / 2;
    return [cos(a4) * r, sin(a4) * r];
  };
  arc8.innerRadius = function(_) {
    return arguments.length ? (innerRadius = typeof _ === "function" ? _ : constant_default(+_), arc8) : innerRadius;
  };
  arc8.outerRadius = function(_) {
    return arguments.length ? (outerRadius = typeof _ === "function" ? _ : constant_default(+_), arc8) : outerRadius;
  };
  arc8.cornerRadius = function(_) {
    return arguments.length ? (cornerRadius = typeof _ === "function" ? _ : constant_default(+_), arc8) : cornerRadius;
  };
  arc8.padRadius = function(_) {
    return arguments.length ? (padRadius = _ == null ? null : typeof _ === "function" ? _ : constant_default(+_), arc8) : padRadius;
  };
  arc8.startAngle = function(_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant_default(+_), arc8) : startAngle;
  };
  arc8.endAngle = function(_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant_default(+_), arc8) : endAngle;
  };
  arc8.padAngle = function(_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant_default(+_), arc8) : padAngle;
  };
  arc8.context = function(_) {
    return arguments.length ? (context7 = _ == null ? null : _, arc8) : context7;
  };
  return arc8;
}

// node_modules/d3-shape/src/array.js
var slice2 = Array.prototype.slice;
function array_default(x9) {
  return typeof x9 === "object" && "length" in x9 ? x9 : Array.from(x9);
}

// node_modules/d3-shape/src/curve/linear.js
function Linear(context7) {
  this._context = context7;
}
Linear.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x9, y9) {
    x9 = +x9, y9 = +y9;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x9, y9) : this._context.moveTo(x9, y9);
        break;
      case 1:
        this._point = 2;
      default:
        this._context.lineTo(x9, y9);
        break;
    }
  }
};
function linear_default(context7) {
  return new Linear(context7);
}

// node_modules/d3-shape/src/point.js
function x(p) {
  return p[0];
}
function y(p) {
  return p[1];
}

// node_modules/d3-shape/src/line.js
function line_default(x9, y9) {
  var defined2 = constant_default(true), context7 = null, curve2 = linear_default, output3 = null, path7 = withPath(line8);
  x9 = typeof x9 === "function" ? x9 : x9 === void 0 ? x : constant_default(x9);
  y9 = typeof y9 === "function" ? y9 : y9 === void 0 ? y : constant_default(y9);
  function line8(data3) {
    var i, n = (data3 = array_default(data3)).length, d, defined0 = false, buffer;
    if (context7 == null)
      output3 = curve2(buffer = path7());
    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined2(d = data3[i], i, data3)) === defined0) {
        if (defined0 = !defined0)
          output3.lineStart();
        else
          output3.lineEnd();
      }
      if (defined0)
        output3.point(+x9(d, i, data3), +y9(d, i, data3));
    }
    if (buffer)
      return output3 = null, buffer + "" || null;
  }
  line8.x = function(_) {
    return arguments.length ? (x9 = typeof _ === "function" ? _ : constant_default(+_), line8) : x9;
  };
  line8.y = function(_) {
    return arguments.length ? (y9 = typeof _ === "function" ? _ : constant_default(+_), line8) : y9;
  };
  line8.defined = function(_) {
    return arguments.length ? (defined2 = typeof _ === "function" ? _ : constant_default(!!_), line8) : defined2;
  };
  line8.curve = function(_) {
    return arguments.length ? (curve2 = _, context7 != null && (output3 = curve2(context7)), line8) : curve2;
  };
  line8.context = function(_) {
    return arguments.length ? (_ == null ? context7 = output3 = null : output3 = curve2(context7 = _), line8) : context7;
  };
  return line8;
}

// node_modules/d3-shape/src/area.js
function area_default(x07, y07, y13) {
  var x13 = null, defined2 = constant_default(true), context7 = null, curve2 = linear_default, output3 = null, path7 = withPath(area8);
  x07 = typeof x07 === "function" ? x07 : x07 === void 0 ? x : constant_default(+x07);
  y07 = typeof y07 === "function" ? y07 : y07 === void 0 ? constant_default(0) : constant_default(+y07);
  y13 = typeof y13 === "function" ? y13 : y13 === void 0 ? y : constant_default(+y13);
  function area8(data3) {
    var i, j, k3, n = (data3 = array_default(data3)).length, d, defined0 = false, buffer, x0z = new Array(n), y0z = new Array(n);
    if (context7 == null)
      output3 = curve2(buffer = path7());
    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined2(d = data3[i], i, data3)) === defined0) {
        if (defined0 = !defined0) {
          j = i;
          output3.areaStart();
          output3.lineStart();
        } else {
          output3.lineEnd();
          output3.lineStart();
          for (k3 = i - 1; k3 >= j; --k3) {
            output3.point(x0z[k3], y0z[k3]);
          }
          output3.lineEnd();
          output3.areaEnd();
        }
      }
      if (defined0) {
        x0z[i] = +x07(d, i, data3), y0z[i] = +y07(d, i, data3);
        output3.point(x13 ? +x13(d, i, data3) : x0z[i], y13 ? +y13(d, i, data3) : y0z[i]);
      }
    }
    if (buffer)
      return output3 = null, buffer + "" || null;
  }
  function arealine() {
    return line_default().defined(defined2).curve(curve2).context(context7);
  }
  area8.x = function(_) {
    return arguments.length ? (x07 = typeof _ === "function" ? _ : constant_default(+_), x13 = null, area8) : x07;
  };
  area8.x0 = function(_) {
    return arguments.length ? (x07 = typeof _ === "function" ? _ : constant_default(+_), area8) : x07;
  };
  area8.x1 = function(_) {
    return arguments.length ? (x13 = _ == null ? null : typeof _ === "function" ? _ : constant_default(+_), area8) : x13;
  };
  area8.y = function(_) {
    return arguments.length ? (y07 = typeof _ === "function" ? _ : constant_default(+_), y13 = null, area8) : y07;
  };
  area8.y0 = function(_) {
    return arguments.length ? (y07 = typeof _ === "function" ? _ : constant_default(+_), area8) : y07;
  };
  area8.y1 = function(_) {
    return arguments.length ? (y13 = _ == null ? null : typeof _ === "function" ? _ : constant_default(+_), area8) : y13;
  };
  area8.lineX0 = area8.lineY0 = function() {
    return arealine().x(x07).y(y07);
  };
  area8.lineY1 = function() {
    return arealine().x(x07).y(y13);
  };
  area8.lineX1 = function() {
    return arealine().x(x13).y(y07);
  };
  area8.defined = function(_) {
    return arguments.length ? (defined2 = typeof _ === "function" ? _ : constant_default(!!_), area8) : defined2;
  };
  area8.curve = function(_) {
    return arguments.length ? (curve2 = _, context7 != null && (output3 = curve2(context7)), area8) : curve2;
  };
  area8.context = function(_) {
    return arguments.length ? (_ == null ? context7 = output3 = null : output3 = curve2(context7 = _), area8) : context7;
  };
  return area8;
}

// node_modules/d3-shape/src/curve/radial.js
var curveRadialLinear = curveRadial(linear_default);
function Radial(curve2) {
  this._curve = curve2;
}
Radial.prototype = {
  areaStart: function() {
    this._curve.areaStart();
  },
  areaEnd: function() {
    this._curve.areaEnd();
  },
  lineStart: function() {
    this._curve.lineStart();
  },
  lineEnd: function() {
    this._curve.lineEnd();
  },
  point: function(a4, r) {
    this._curve.point(r * Math.sin(a4), r * -Math.cos(a4));
  }
};
function curveRadial(curve2) {
  function radial2(context7) {
    return new Radial(curve2(context7));
  }
  radial2._curve = curve2;
  return radial2;
}

// node_modules/d3-shape/src/symbol/asterisk.js
var sqrt3 = sqrt(3);

// node_modules/d3-shape/src/symbol/circle.js
var circle_default = {
  draw(context7, size) {
    const r = sqrt(size / pi);
    context7.moveTo(r, 0);
    context7.arc(0, 0, r, 0, tau);
  }
};

// node_modules/d3-shape/src/symbol/diamond.js
var tan30 = sqrt(1 / 3);
var tan30_2 = tan30 * 2;

// node_modules/d3-shape/src/symbol/star.js
var kr = sin(pi / 10) / sin(7 * pi / 10);
var kx = sin(tau / 10) * kr;
var ky = -cos(tau / 10) * kr;

// node_modules/d3-shape/src/symbol/triangle.js
var sqrt32 = sqrt(3);

// node_modules/d3-shape/src/symbol/triangle2.js
var sqrt33 = sqrt(3);

// node_modules/d3-shape/src/symbol/wye.js
var s = sqrt(3) / 2;
var k = 1 / sqrt(12);
var a = (k / 2 + 1) * 3;

// node_modules/d3-shape/src/symbol.js
function Symbol2(type7, size) {
  let context7 = null, path7 = withPath(symbol6);
  type7 = typeof type7 === "function" ? type7 : constant_default(type7 || circle_default);
  size = typeof size === "function" ? size : constant_default(size === void 0 ? 64 : +size);
  function symbol6() {
    let buffer;
    if (!context7)
      context7 = buffer = path7();
    type7.apply(this, arguments).draw(context7, +size.apply(this, arguments));
    if (buffer)
      return context7 = null, buffer + "" || null;
  }
  symbol6.type = function(_) {
    return arguments.length ? (type7 = typeof _ === "function" ? _ : constant_default(_), symbol6) : type7;
  };
  symbol6.size = function(_) {
    return arguments.length ? (size = typeof _ === "function" ? _ : constant_default(+_), symbol6) : size;
  };
  symbol6.context = function(_) {
    return arguments.length ? (context7 = _ == null ? null : _, symbol6) : context7;
  };
  return symbol6;
}

// node_modules/d3-shape/src/noop.js
function noop_default() {
}

// node_modules/d3-shape/src/curve/basis.js
function point(that, x9, y9) {
  that._context.bezierCurveTo(
    (2 * that._x0 + that._x1) / 3,
    (2 * that._y0 + that._y1) / 3,
    (that._x0 + 2 * that._x1) / 3,
    (that._y0 + 2 * that._y1) / 3,
    (that._x0 + 4 * that._x1 + x9) / 6,
    (that._y0 + 4 * that._y1 + y9) / 6
  );
}
function Basis(context7) {
  this._context = context7;
}
Basis.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 3:
        point(this, this._x1, this._y1);
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x9, y9) {
    x9 = +x9, y9 = +y9;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x9, y9) : this._context.moveTo(x9, y9);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
      default:
        point(this, x9, y9);
        break;
    }
    this._x0 = this._x1, this._x1 = x9;
    this._y0 = this._y1, this._y1 = y9;
  }
};
function basis_default(context7) {
  return new Basis(context7);
}

// node_modules/d3-shape/src/curve/basisClosed.js
function BasisClosed(context7) {
  this._context = context7;
}
BasisClosed.prototype = {
  areaStart: noop_default,
  areaEnd: noop_default,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x2, this._y2);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
        this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x2, this._y2);
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        break;
      }
    }
  },
  point: function(x9, y9) {
    x9 = +x9, y9 = +y9;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._x2 = x9, this._y2 = y9;
        break;
      case 1:
        this._point = 2;
        this._x3 = x9, this._y3 = y9;
        break;
      case 2:
        this._point = 3;
        this._x4 = x9, this._y4 = y9;
        this._context.moveTo((this._x0 + 4 * this._x1 + x9) / 6, (this._y0 + 4 * this._y1 + y9) / 6);
        break;
      default:
        point(this, x9, y9);
        break;
    }
    this._x0 = this._x1, this._x1 = x9;
    this._y0 = this._y1, this._y1 = y9;
  }
};
function basisClosed_default(context7) {
  return new BasisClosed(context7);
}

// node_modules/d3-shape/src/curve/basisOpen.js
function BasisOpen(context7) {
  this._context = context7;
}
BasisOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 3)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x9, y9) {
    x9 = +x9, y9 = +y9;
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        var x07 = (this._x0 + 4 * this._x1 + x9) / 6, y07 = (this._y0 + 4 * this._y1 + y9) / 6;
        this._line ? this._context.lineTo(x07, y07) : this._context.moveTo(x07, y07);
        break;
      case 3:
        this._point = 4;
      default:
        point(this, x9, y9);
        break;
    }
    this._x0 = this._x1, this._x1 = x9;
    this._y0 = this._y1, this._y1 = y9;
  }
};
function basisOpen_default(context7) {
  return new BasisOpen(context7);
}

// node_modules/d3-shape/src/curve/bundle.js
function Bundle(context7, beta) {
  this._basis = new Basis(context7);
  this._beta = beta;
}
Bundle.prototype = {
  lineStart: function() {
    this._x = [];
    this._y = [];
    this._basis.lineStart();
  },
  lineEnd: function() {
    var x9 = this._x, y9 = this._y, j = x9.length - 1;
    if (j > 0) {
      var x07 = x9[0], y07 = y9[0], dx = x9[j] - x07, dy = y9[j] - y07, i = -1, t;
      while (++i <= j) {
        t = i / j;
        this._basis.point(
          this._beta * x9[i] + (1 - this._beta) * (x07 + t * dx),
          this._beta * y9[i] + (1 - this._beta) * (y07 + t * dy)
        );
      }
    }
    this._x = this._y = null;
    this._basis.lineEnd();
  },
  point: function(x9, y9) {
    this._x.push(+x9);
    this._y.push(+y9);
  }
};
var bundle_default = function custom(beta) {
  function bundle6(context7) {
    return beta === 1 ? new Basis(context7) : new Bundle(context7, beta);
  }
  bundle6.beta = function(beta2) {
    return custom(+beta2);
  };
  return bundle6;
}(0.85);

// node_modules/d3-shape/src/curve/cardinal.js
function point2(that, x9, y9) {
  that._context.bezierCurveTo(
    that._x1 + that._k * (that._x2 - that._x0),
    that._y1 + that._k * (that._y2 - that._y0),
    that._x2 + that._k * (that._x1 - x9),
    that._y2 + that._k * (that._y1 - y9),
    that._x2,
    that._y2
  );
}
function Cardinal(context7, tension) {
  this._context = context7;
  this._k = (1 - tension) / 6;
}
Cardinal.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        point2(this, this._x1, this._y1);
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x9, y9) {
    x9 = +x9, y9 = +y9;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x9, y9) : this._context.moveTo(x9, y9);
        break;
      case 1:
        this._point = 2;
        this._x1 = x9, this._y1 = y9;
        break;
      case 2:
        this._point = 3;
      default:
        point2(this, x9, y9);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x9;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y9;
  }
};
var cardinal_default = function custom2(tension) {
  function cardinal(context7) {
    return new Cardinal(context7, tension);
  }
  cardinal.tension = function(tension2) {
    return custom2(+tension2);
  };
  return cardinal;
}(0);

// node_modules/d3-shape/src/curve/cardinalClosed.js
function CardinalClosed(context7, tension) {
  this._context = context7;
  this._k = (1 - tension) / 6;
}
CardinalClosed.prototype = {
  areaStart: noop_default,
  areaEnd: noop_default,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x9, y9) {
    x9 = +x9, y9 = +y9;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._x3 = x9, this._y3 = y9;
        break;
      case 1:
        this._point = 2;
        this._context.moveTo(this._x4 = x9, this._y4 = y9);
        break;
      case 2:
        this._point = 3;
        this._x5 = x9, this._y5 = y9;
        break;
      default:
        point2(this, x9, y9);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x9;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y9;
  }
};
var cardinalClosed_default = function custom3(tension) {
  function cardinal(context7) {
    return new CardinalClosed(context7, tension);
  }
  cardinal.tension = function(tension2) {
    return custom3(+tension2);
  };
  return cardinal;
}(0);

// node_modules/d3-shape/src/curve/cardinalOpen.js
function CardinalOpen(context7, tension) {
  this._context = context7;
  this._k = (1 - tension) / 6;
}
CardinalOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 3)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x9, y9) {
    x9 = +x9, y9 = +y9;
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      default:
        point2(this, x9, y9);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x9;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y9;
  }
};
var cardinalOpen_default = function custom4(tension) {
  function cardinal(context7) {
    return new CardinalOpen(context7, tension);
  }
  cardinal.tension = function(tension2) {
    return custom4(+tension2);
  };
  return cardinal;
}(0);

// node_modules/d3-shape/src/curve/catmullRom.js
function point3(that, x9, y9) {
  var x13 = that._x1, y13 = that._y1, x22 = that._x2, y22 = that._y2;
  if (that._l01_a > epsilon2) {
    var a4 = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a, n = 3 * that._l01_a * (that._l01_a + that._l12_a);
    x13 = (x13 * a4 - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;
    y13 = (y13 * a4 - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;
  }
  if (that._l23_a > epsilon2) {
    var b6 = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a, m3 = 3 * that._l23_a * (that._l23_a + that._l12_a);
    x22 = (x22 * b6 + that._x1 * that._l23_2a - x9 * that._l12_2a) / m3;
    y22 = (y22 * b6 + that._y1 * that._l23_2a - y9 * that._l12_2a) / m3;
  }
  that._context.bezierCurveTo(x13, y13, x22, y22, that._x2, that._y2);
}
function CatmullRom(context7, alpha) {
  this._context = context7;
  this._alpha = alpha;
}
CatmullRom.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        this.point(this._x2, this._y2);
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x9, y9) {
    x9 = +x9, y9 = +y9;
    if (this._point) {
      var x23 = this._x2 - x9, y23 = this._y2 - y9;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x9, y9) : this._context.moveTo(x9, y9);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
      default:
        point3(this, x9, y9);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x9;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y9;
  }
};
var catmullRom_default = function custom5(alpha) {
  function catmullRom(context7) {
    return alpha ? new CatmullRom(context7, alpha) : new Cardinal(context7, 0);
  }
  catmullRom.alpha = function(alpha2) {
    return custom5(+alpha2);
  };
  return catmullRom;
}(0.5);

// node_modules/d3-shape/src/curve/catmullRomClosed.js
function CatmullRomClosed(context7, alpha) {
  this._context = context7;
  this._alpha = alpha;
}
CatmullRomClosed.prototype = {
  areaStart: noop_default,
  areaEnd: noop_default,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x9, y9) {
    x9 = +x9, y9 = +y9;
    if (this._point) {
      var x23 = this._x2 - x9, y23 = this._y2 - y9;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        this._x3 = x9, this._y3 = y9;
        break;
      case 1:
        this._point = 2;
        this._context.moveTo(this._x4 = x9, this._y4 = y9);
        break;
      case 2:
        this._point = 3;
        this._x5 = x9, this._y5 = y9;
        break;
      default:
        point3(this, x9, y9);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x9;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y9;
  }
};
var catmullRomClosed_default = function custom6(alpha) {
  function catmullRom(context7) {
    return alpha ? new CatmullRomClosed(context7, alpha) : new CardinalClosed(context7, 0);
  }
  catmullRom.alpha = function(alpha2) {
    return custom6(+alpha2);
  };
  return catmullRom;
}(0.5);

// node_modules/d3-shape/src/curve/catmullRomOpen.js
function CatmullRomOpen(context7, alpha) {
  this._context = context7;
  this._alpha = alpha;
}
CatmullRomOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 3)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x9, y9) {
    x9 = +x9, y9 = +y9;
    if (this._point) {
      var x23 = this._x2 - x9, y23 = this._y2 - y9;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      default:
        point3(this, x9, y9);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x9;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y9;
  }
};
var catmullRomOpen_default = function custom7(alpha) {
  function catmullRom(context7) {
    return alpha ? new CatmullRomOpen(context7, alpha) : new CardinalOpen(context7, 0);
  }
  catmullRom.alpha = function(alpha2) {
    return custom7(+alpha2);
  };
  return catmullRom;
}(0.5);

// node_modules/d3-shape/src/curve/linearClosed.js
function LinearClosed(context7) {
  this._context = context7;
}
LinearClosed.prototype = {
  areaStart: noop_default,
  areaEnd: noop_default,
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._point)
      this._context.closePath();
  },
  point: function(x9, y9) {
    x9 = +x9, y9 = +y9;
    if (this._point)
      this._context.lineTo(x9, y9);
    else
      this._point = 1, this._context.moveTo(x9, y9);
  }
};
function linearClosed_default(context7) {
  return new LinearClosed(context7);
}

// node_modules/d3-shape/src/curve/monotone.js
function sign(x9) {
  return x9 < 0 ? -1 : 1;
}
function slope3(that, x22, y22) {
  var h0 = that._x1 - that._x0, h1 = x22 - that._x1, s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0), s1 = (y22 - that._y1) / (h1 || h0 < 0 && -0), p = (s0 * h1 + s1 * h0) / (h0 + h1);
  return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
}
function slope2(that, t) {
  var h6 = that._x1 - that._x0;
  return h6 ? (3 * (that._y1 - that._y0) / h6 - t) / 2 : t;
}
function point4(that, t014, t13) {
  var x07 = that._x0, y07 = that._y0, x13 = that._x1, y13 = that._y1, dx = (x13 - x07) / 3;
  that._context.bezierCurveTo(x07 + dx, y07 + dx * t014, x13 - dx, y13 - dx * t13, x13, y13);
}
function MonotoneX(context7) {
  this._context = context7;
}
MonotoneX.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
      case 3:
        point4(this, this._t0, slope2(this, this._t0));
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x9, y9) {
    var t13 = NaN;
    x9 = +x9, y9 = +y9;
    if (x9 === this._x1 && y9 === this._y1)
      return;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x9, y9) : this._context.moveTo(x9, y9);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        point4(this, slope2(this, t13 = slope3(this, x9, y9)), t13);
        break;
      default:
        point4(this, this._t0, t13 = slope3(this, x9, y9));
        break;
    }
    this._x0 = this._x1, this._x1 = x9;
    this._y0 = this._y1, this._y1 = y9;
    this._t0 = t13;
  }
};
function MonotoneY(context7) {
  this._context = new ReflectContext(context7);
}
(MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x9, y9) {
  MonotoneX.prototype.point.call(this, y9, x9);
};
function ReflectContext(context7) {
  this._context = context7;
}
ReflectContext.prototype = {
  moveTo: function(x9, y9) {
    this._context.moveTo(y9, x9);
  },
  closePath: function() {
    this._context.closePath();
  },
  lineTo: function(x9, y9) {
    this._context.lineTo(y9, x9);
  },
  bezierCurveTo: function(x13, y13, x22, y22, x9, y9) {
    this._context.bezierCurveTo(y13, x13, y22, x22, y9, x9);
  }
};
function monotoneX(context7) {
  return new MonotoneX(context7);
}
function monotoneY(context7) {
  return new MonotoneY(context7);
}

// node_modules/d3-shape/src/curve/natural.js
function Natural(context7) {
  this._context = context7;
}
Natural.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = [];
    this._y = [];
  },
  lineEnd: function() {
    var x9 = this._x, y9 = this._y, n = x9.length;
    if (n) {
      this._line ? this._context.lineTo(x9[0], y9[0]) : this._context.moveTo(x9[0], y9[0]);
      if (n === 2) {
        this._context.lineTo(x9[1], y9[1]);
      } else {
        var px6 = controlPoints(x9), py6 = controlPoints(y9);
        for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {
          this._context.bezierCurveTo(px6[0][i0], py6[0][i0], px6[1][i0], py6[1][i0], x9[i1], y9[i1]);
        }
      }
    }
    if (this._line || this._line !== 0 && n === 1)
      this._context.closePath();
    this._line = 1 - this._line;
    this._x = this._y = null;
  },
  point: function(x9, y9) {
    this._x.push(+x9);
    this._y.push(+y9);
  }
};
function controlPoints(x9) {
  var i, n = x9.length - 1, m3, a4 = new Array(n), b6 = new Array(n), r = new Array(n);
  a4[0] = 0, b6[0] = 2, r[0] = x9[0] + 2 * x9[1];
  for (i = 1; i < n - 1; ++i)
    a4[i] = 1, b6[i] = 4, r[i] = 4 * x9[i] + 2 * x9[i + 1];
  a4[n - 1] = 2, b6[n - 1] = 7, r[n - 1] = 8 * x9[n - 1] + x9[n];
  for (i = 1; i < n; ++i)
    m3 = a4[i] / b6[i - 1], b6[i] -= m3, r[i] -= m3 * r[i - 1];
  a4[n - 1] = r[n - 1] / b6[n - 1];
  for (i = n - 2; i >= 0; --i)
    a4[i] = (r[i] - a4[i + 1]) / b6[i];
  b6[n - 1] = (x9[n] + a4[n - 1]) / 2;
  for (i = 0; i < n - 1; ++i)
    b6[i] = 2 * x9[i + 1] - a4[i + 1];
  return [a4, b6];
}
function natural_default(context7) {
  return new Natural(context7);
}

// node_modules/d3-shape/src/curve/step.js
function Step(context7, t) {
  this._context = context7;
  this._t = t;
}
Step.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = this._y = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (0 < this._t && this._t < 1 && this._point === 2)
      this._context.lineTo(this._x, this._y);
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    if (this._line >= 0)
      this._t = 1 - this._t, this._line = 1 - this._line;
  },
  point: function(x9, y9) {
    x9 = +x9, y9 = +y9;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x9, y9) : this._context.moveTo(x9, y9);
        break;
      case 1:
        this._point = 2;
      default: {
        if (this._t <= 0) {
          this._context.lineTo(this._x, y9);
          this._context.lineTo(x9, y9);
        } else {
          var x13 = this._x * (1 - this._t) + x9 * this._t;
          this._context.lineTo(x13, this._y);
          this._context.lineTo(x13, y9);
        }
        break;
      }
    }
    this._x = x9, this._y = y9;
  }
};
function step_default(context7) {
  return new Step(context7, 0.5);
}
function stepBefore(context7) {
  return new Step(context7, 0);
}
function stepAfter(context7) {
  return new Step(context7, 1);
}

// node_modules/vega-view-transforms/node_modules/vega-canvas/build/vega-canvas.browser.js
function domCanvas(w8, h6) {
  if (typeof document !== "undefined" && document.createElement) {
    const c5 = document.createElement("canvas");
    if (c5 && c5.getContext) {
      c5.width = w8;
      c5.height = h6;
      return c5;
    }
  }
  return null;
}
var domImage = () => typeof Image !== "undefined" ? Image : null;

// node_modules/vega-view-transforms/node_modules/vega-time/build/vega-time.js
var YEAR3 = "year";
var QUARTER3 = "quarter";
var MONTH3 = "month";
var WEEK3 = "week";
var DATE3 = "date";
var DAY3 = "day";
var DAYOFYEAR3 = "dayofyear";
var HOURS3 = "hours";
var MINUTES3 = "minutes";
var SECONDS3 = "seconds";
var MILLISECONDS3 = "milliseconds";
var TIME_UNITS3 = [YEAR3, QUARTER3, MONTH3, WEEK3, DATE3, DAY3, DAYOFYEAR3, HOURS3, MINUTES3, SECONDS3, MILLISECONDS3];
var UNITS3 = TIME_UNITS3.reduce((o, u4, i) => (o[u4] = 1 + i, o), {});
var defaultSpecifiers3 = {
  [YEAR3]: "%Y ",
  [QUARTER3]: "Q%q ",
  [MONTH3]: "%b ",
  [DATE3]: "%d ",
  [WEEK3]: "W%U ",
  [DAY3]: "%a ",
  [DAYOFYEAR3]: "%j ",
  [HOURS3]: "%H:00",
  [MINUTES3]: "00:%M",
  [SECONDS3]: ":%S",
  [MILLISECONDS3]: ".%L",
  [`${YEAR3}-${MONTH3}`]: "%Y-%m ",
  [`${YEAR3}-${MONTH3}-${DATE3}`]: "%Y-%m-%d ",
  [`${HOURS3}-${MINUTES3}`]: "%H:%M"
};
var t04 = /* @__PURE__ */ new Date();
function localYear3(y9) {
  t04.setFullYear(y9);
  t04.setMonth(0);
  t04.setDate(1);
  t04.setHours(0, 0, 0, 0);
  return t04;
}
function localDayOfYear3(d) {
  return timeDay.count(localYear3(d.getFullYear()) - 1, d);
}
function localWeekNum3(d) {
  return timeSunday.count(localYear3(d.getFullYear()) - 1, d);
}
function localFirst3(y9) {
  return localYear3(y9).getDay();
}
function utcDayOfYear3(d) {
  const y9 = Date.UTC(d.getUTCFullYear(), 0, 1);
  return utcDay.count(y9 - 1, d);
}
function utcWeekNum3(d) {
  const y9 = Date.UTC(d.getUTCFullYear(), 0, 1);
  return utcSunday.count(y9 - 1, d);
}
function utcFirst3(y9) {
  t04.setTime(Date.UTC(y9, 0, 1));
  return t04.getUTCDay();
}
function weekday3(week3, day, firstDay) {
  return day + week3 * 7 - (firstDay + 6) % 7;
}
var localGet3 = {
  [YEAR3]: (d) => d.getFullYear(),
  [QUARTER3]: (d) => Math.floor(d.getMonth() / 3),
  [MONTH3]: (d) => d.getMonth(),
  [DATE3]: (d) => d.getDate(),
  [HOURS3]: (d) => d.getHours(),
  [MINUTES3]: (d) => d.getMinutes(),
  [SECONDS3]: (d) => d.getSeconds(),
  [MILLISECONDS3]: (d) => d.getMilliseconds(),
  [DAYOFYEAR3]: (d) => localDayOfYear3(d),
  [WEEK3]: (d) => localWeekNum3(d),
  [WEEK3 + DAY3]: (d, y9) => weekday3(localWeekNum3(d), d.getDay(), localFirst3(y9)),
  [DAY3]: (d, y9) => weekday3(1, d.getDay(), localFirst3(y9))
};
var localInv3 = {
  [QUARTER3]: (q) => 3 * q,
  [WEEK3]: (w8, y9) => weekday3(w8, 0, localFirst3(y9))
};
var utcGet3 = {
  [YEAR3]: (d) => d.getUTCFullYear(),
  [QUARTER3]: (d) => Math.floor(d.getUTCMonth() / 3),
  [MONTH3]: (d) => d.getUTCMonth(),
  [DATE3]: (d) => d.getUTCDate(),
  [HOURS3]: (d) => d.getUTCHours(),
  [MINUTES3]: (d) => d.getUTCMinutes(),
  [SECONDS3]: (d) => d.getUTCSeconds(),
  [MILLISECONDS3]: (d) => d.getUTCMilliseconds(),
  [DAYOFYEAR3]: (d) => utcDayOfYear3(d),
  [WEEK3]: (d) => utcWeekNum3(d),
  [DAY3]: (d, y9) => weekday3(1, d.getUTCDay(), utcFirst3(y9)),
  [WEEK3 + DAY3]: (d, y9) => weekday3(utcWeekNum3(d), d.getUTCDay(), utcFirst3(y9))
};
var utcInv3 = {
  [QUARTER3]: (q) => 3 * q,
  [WEEK3]: (w8, y9) => weekday3(w8, 0, utcFirst3(y9))
};
var timeIntervals3 = {
  [YEAR3]: timeYear,
  [QUARTER3]: timeMonth.every(3),
  [MONTH3]: timeMonth,
  [WEEK3]: timeSunday,
  [DATE3]: timeDay,
  [DAY3]: timeDay,
  [DAYOFYEAR3]: timeDay,
  [HOURS3]: timeHour,
  [MINUTES3]: timeMinute,
  [SECONDS3]: second,
  [MILLISECONDS3]: millisecond
};
var utcIntervals3 = {
  [YEAR3]: utcYear,
  [QUARTER3]: utcMonth.every(3),
  [MONTH3]: utcMonth,
  [WEEK3]: utcSunday,
  [DATE3]: utcDay,
  [DAY3]: utcDay,
  [DAYOFYEAR3]: utcDay,
  [HOURS3]: utcHour,
  [MINUTES3]: utcMinute,
  [SECONDS3]: second,
  [MILLISECONDS3]: millisecond
};
function timeInterval4(unit2) {
  return timeIntervals3[unit2];
}
function utcInterval3(unit2) {
  return utcIntervals3[unit2];
}
var durationSecond4 = 1e3;
var durationMinute4 = durationSecond4 * 60;
var durationHour4 = durationMinute4 * 60;
var durationDay4 = durationHour4 * 24;
var durationWeek4 = durationDay4 * 7;
var durationMonth4 = durationDay4 * 30;
var durationYear4 = durationDay4 * 365;
var Milli3 = [YEAR3, MONTH3, DATE3, HOURS3, MINUTES3, SECONDS3, MILLISECONDS3];
var Seconds3 = Milli3.slice(0, -1);
var Minutes3 = Seconds3.slice(0, -1);
var Hours3 = Minutes3.slice(0, -1);
var Day3 = Hours3.slice(0, -1);
var Week3 = [YEAR3, WEEK3];
var Month3 = [YEAR3, MONTH3];
var Year3 = [YEAR3];
var intervals3 = [[Seconds3, 1, durationSecond4], [Seconds3, 5, 5 * durationSecond4], [Seconds3, 15, 15 * durationSecond4], [Seconds3, 30, 30 * durationSecond4], [Minutes3, 1, durationMinute4], [Minutes3, 5, 5 * durationMinute4], [Minutes3, 15, 15 * durationMinute4], [Minutes3, 30, 30 * durationMinute4], [Hours3, 1, durationHour4], [Hours3, 3, 3 * durationHour4], [Hours3, 6, 6 * durationHour4], [Hours3, 12, 12 * durationHour4], [Day3, 1, durationDay4], [Week3, 1, durationWeek4], [Month3, 1, durationMonth4], [Month3, 3, 3 * durationMonth4], [Year3, 1, durationYear4]];

// node_modules/vega-view-transforms/node_modules/vega-format/build/vega-format.js
function memoize2(method10) {
  const cache2 = {};
  return (spec) => cache2[spec] || (cache2[spec] = method10(spec));
}
function trimZeroes2(numberFormat2, decimalChar) {
  return (x9) => {
    const str = numberFormat2(x9), dec = str.indexOf(decimalChar);
    if (dec < 0)
      return str;
    let idx = rightmostDigit2(str, dec);
    const end = idx < str.length ? str.slice(idx) : "";
    while (--idx > dec)
      if (str[idx] !== "0") {
        ++idx;
        break;
      }
    return str.slice(0, idx) + end;
  };
}
function rightmostDigit2(str, dec) {
  let i = str.lastIndexOf("e"), c5;
  if (i > 0)
    return i;
  for (i = str.length; --i > dec; ) {
    c5 = str.charCodeAt(i);
    if (c5 >= 48 && c5 <= 57)
      return i + 1;
  }
}
function numberLocale2(locale5) {
  const format14 = memoize2(locale5.format), formatPrefix2 = locale5.formatPrefix;
  return {
    format: format14,
    formatPrefix: formatPrefix2,
    formatFloat(spec) {
      const s2 = formatSpecifier(spec || ",");
      if (s2.precision == null) {
        s2.precision = 12;
        switch (s2.type) {
          case "%":
            s2.precision -= 2;
            break;
          case "e":
            s2.precision -= 1;
            break;
        }
        return trimZeroes2(
          format14(s2),
          // number format
          format14(".1f")(1)[1]
          // decimal point character
        );
      } else {
        return format14(s2);
      }
    },
    formatSpan(start, stop2, count3, specifier) {
      specifier = formatSpecifier(specifier == null ? ",f" : specifier);
      const step = tickStep(start, stop2, count3), value7 = Math.max(Math.abs(start), Math.abs(stop2));
      let precision;
      if (specifier.precision == null) {
        switch (specifier.type) {
          case "s": {
            if (!isNaN(precision = precisionPrefix_default(step, value7))) {
              specifier.precision = precision;
            }
            return formatPrefix2(specifier, value7);
          }
          case "":
          case "e":
          case "g":
          case "p":
          case "r": {
            if (!isNaN(precision = precisionRound_default(step, value7))) {
              specifier.precision = precision - (specifier.type === "e");
            }
            break;
          }
          case "f":
          case "%": {
            if (!isNaN(precision = precisionFixed_default(step))) {
              specifier.precision = precision - (specifier.type === "%") * 2;
            }
            break;
          }
        }
      }
      return format14(specifier);
    }
  };
}
var defaultNumberLocale2;
resetNumberFormatDefaultLocale2();
function resetNumberFormatDefaultLocale2() {
  return defaultNumberLocale2 = numberLocale2({
    format,
    formatPrefix
  });
}
function timeMultiFormat2(format14, interval3, spec) {
  spec = spec || {};
  if (!isObject3(spec)) {
    error4(`Invalid time multi-format specifier: ${spec}`);
  }
  const second2 = interval3(SECONDS3), minute = interval3(MINUTES3), hour = interval3(HOURS3), day = interval3(DATE3), week3 = interval3(WEEK3), month = interval3(MONTH3), quarter3 = interval3(QUARTER3), year = interval3(YEAR3), L = format14(spec[MILLISECONDS3] || ".%L"), S = format14(spec[SECONDS3] || ":%S"), M2 = format14(spec[MINUTES3] || "%I:%M"), H = format14(spec[HOURS3] || "%I %p"), d = format14(spec[DATE3] || spec[DAY3] || "%a %d"), w8 = format14(spec[WEEK3] || "%b %d"), m3 = format14(spec[MONTH3] || "%B"), q = format14(spec[QUARTER3] || "%B"), y9 = format14(spec[YEAR3] || "%Y");
  return (date2) => (second2(date2) < date2 ? L : minute(date2) < date2 ? S : hour(date2) < date2 ? M2 : day(date2) < date2 ? H : month(date2) < date2 ? week3(date2) < date2 ? d : w8 : year(date2) < date2 ? quarter3(date2) < date2 ? m3 : q : y9)(date2);
}
function timeLocale2(locale5) {
  const timeFormat4 = memoize2(locale5.format), utcFormat3 = memoize2(locale5.utcFormat);
  return {
    timeFormat: (spec) => isString3(spec) ? timeFormat4(spec) : timeMultiFormat2(timeFormat4, timeInterval4, spec),
    utcFormat: (spec) => isString3(spec) ? utcFormat3(spec) : timeMultiFormat2(utcFormat3, utcInterval3, spec),
    timeParse: memoize2(locale5.parse),
    utcParse: memoize2(locale5.utcParse)
  };
}
var defaultTimeLocale2;
resetTimeFormatDefaultLocale2();
function resetTimeFormatDefaultLocale2() {
  return defaultTimeLocale2 = timeLocale2({
    format: timeFormat,
    parse: timeParse,
    utcFormat,
    utcParse
  });
}

// node_modules/vega-view-transforms/node_modules/vega-loader/build/vega-loader.browser.js
var protocol_re2 = /^(data:|([A-Za-z]+:)?\/\/)/;
var allowed_re2 = /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp|file|data):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i;
var whitespace_re2 = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205f\u3000]/g;
var fileProtocol2 = "file://";
function loaderFactory2(fs) {
  return (options) => ({
    options: options || {},
    sanitize: sanitize2,
    load: load2,
    fileAccess: false,
    file: fileLoader2(),
    http: httpLoader2
  });
}
async function load2(uri, options) {
  const opt = await this.sanitize(uri, options), url = opt.href;
  return opt.localFile ? this.file(url) : this.http(url, options == null ? void 0 : options.http);
}
async function sanitize2(uri, options) {
  options = extend4({}, this.options, options);
  const fileAccess = this.fileAccess, result = {
    href: null
  };
  let isFile, loadFile, base;
  const isAllowed = allowed_re2.test(uri.replace(whitespace_re2, ""));
  if (uri == null || typeof uri !== "string" || !isAllowed) {
    error4("Sanitize failure, invalid URI: " + $3(uri));
  }
  const hasProtocol = protocol_re2.test(uri);
  if ((base = options.baseURL) && !hasProtocol) {
    if (!uri.startsWith("/") && !base.endsWith("/")) {
      uri = "/" + uri;
    }
    uri = base + uri;
  }
  loadFile = (isFile = uri.startsWith(fileProtocol2)) || options.mode === "file" || options.mode !== "http" && !hasProtocol && fileAccess;
  if (isFile) {
    uri = uri.slice(fileProtocol2.length);
  } else if (uri.startsWith("//")) {
    if (options.defaultProtocol === "file") {
      uri = uri.slice(2);
      loadFile = true;
    } else {
      uri = (options.defaultProtocol || "http") + ":" + uri;
    }
  }
  Object.defineProperty(result, "localFile", {
    value: !!loadFile
  });
  result.href = uri;
  if (options.target) {
    result.target = options.target + "";
  }
  if (options.rel) {
    result.rel = options.rel + "";
  }
  if (options.context === "image" && options.crossOrigin) {
    result.crossOrigin = options.crossOrigin + "";
  }
  return result;
}
function fileLoader2(fs) {
  return fileReject2;
}
async function fileReject2() {
  error4("No file system access.");
}
async function httpLoader2(url, options) {
  const opt = extend4({}, this.options.http, options), type7 = options && options.response, response = await fetch(url, opt);
  return !response.ok ? error4(response.status + "" + response.statusText) : isFunction4(response[type7]) ? response[type7]() : response.text();
}
function delimitedFormat2(delimiter) {
  const parse12 = function(data3, format14) {
    const delim = {
      delimiter
    };
    return dsv2(data3, format14 ? extend4(format14, delim) : delim);
  };
  parse12.responseType = "text";
  return parse12;
}
function dsv2(data3, format14) {
  if (format14.header) {
    data3 = format14.header.map($3).join(format14.delimiter) + "\n" + data3;
  }
  return dsv_default(format14.delimiter).parse(data3 + "");
}
dsv2.responseType = "text";
function isBuffer2(_) {
  return typeof Buffer === "function" && isFunction4(Buffer.isBuffer) ? Buffer.isBuffer(_) : false;
}
function json2(data3, format14) {
  const prop = format14 && format14.property ? field4(format14.property) : identity5;
  return isObject3(data3) && !isBuffer2(data3) ? parseJSON2(prop(data3), format14) : prop(JSON.parse(data3));
}
json2.responseType = "json";
function parseJSON2(data3, format14) {
  if (!isArray4(data3) && isIterable3(data3)) {
    data3 = [...data3];
  }
  return format14 && format14.copy ? JSON.parse(JSON.stringify(data3)) : data3;
}
var filters2 = {
  interior: (a4, b6) => a4 !== b6,
  exterior: (a4, b6) => a4 === b6
};
function topojson2(data3, format14) {
  let method10, object2, property2, filter4;
  data3 = json2(data3, format14);
  if (format14 && format14.feature) {
    method10 = feature_default;
    property2 = format14.feature;
  } else if (format14 && format14.mesh) {
    method10 = mesh_default;
    property2 = format14.mesh;
    filter4 = filters2[format14.filter];
  } else {
    error4("Missing TopoJSON feature or mesh parameter.");
  }
  object2 = (object2 = data3.objects[property2]) ? method10(data3, object2, filter4) : error4("Invalid TopoJSON object: " + property2);
  return object2 && object2.features || [object2];
}
topojson2.responseType = "json";
var format3 = {
  dsv: dsv2,
  csv: delimitedFormat2(","),
  tsv: delimitedFormat2("	"),
  json: json2,
  topojson: topojson2
};
var loader2 = loaderFactory2();

// node_modules/d3-scale/src/init.js
function initRange(domain3, range7) {
  switch (arguments.length) {
    case 0:
      break;
    case 1:
      this.range(domain3);
      break;
    default:
      this.range(range7).domain(domain3);
      break;
  }
  return this;
}
function initInterpolator(domain3, interpolator) {
  switch (arguments.length) {
    case 0:
      break;
    case 1: {
      if (typeof domain3 === "function")
        this.interpolator(domain3);
      else
        this.range(domain3);
      break;
    }
    default: {
      this.domain(domain3);
      if (typeof interpolator === "function")
        this.interpolator(interpolator);
      else
        this.range(interpolator);
      break;
    }
  }
  return this;
}

// node_modules/d3-scale/src/ordinal.js
var implicit = Symbol("implicit");
function ordinal() {
  var index4 = new InternMap(), domain3 = [], range7 = [], unknown = implicit;
  function scale19(d) {
    let i = index4.get(d);
    if (i === void 0) {
      if (unknown !== implicit)
        return unknown;
      index4.set(d, i = domain3.push(d) - 1);
    }
    return range7[i % range7.length];
  }
  scale19.domain = function(_) {
    if (!arguments.length)
      return domain3.slice();
    domain3 = [], index4 = new InternMap();
    for (const value7 of _) {
      if (index4.has(value7))
        continue;
      index4.set(value7, domain3.push(value7) - 1);
    }
    return scale19;
  };
  scale19.range = function(_) {
    return arguments.length ? (range7 = Array.from(_), scale19) : range7.slice();
  };
  scale19.unknown = function(_) {
    return arguments.length ? (unknown = _, scale19) : unknown;
  };
  scale19.copy = function() {
    return ordinal(domain3, range7).unknown(unknown);
  };
  initRange.apply(scale19, arguments);
  return scale19;
}

// node_modules/d3-interpolate/src/index.js
var src_exports = {};
__export(src_exports, {
  interpolate: () => value_default,
  interpolateArray: () => array_default2,
  interpolateBasis: () => basis_default2,
  interpolateBasisClosed: () => basisClosed_default2,
  interpolateCubehelix: () => cubehelix_default,
  interpolateCubehelixLong: () => cubehelixLong,
  interpolateDate: () => date_default,
  interpolateDiscrete: () => discrete_default,
  interpolateHcl: () => hcl_default,
  interpolateHclLong: () => hclLong,
  interpolateHsl: () => hsl_default,
  interpolateHslLong: () => hslLong,
  interpolateHue: () => hue_default,
  interpolateLab: () => lab2,
  interpolateNumber: () => number_default,
  interpolateNumberArray: () => numberArray_default,
  interpolateObject: () => object_default,
  interpolateRgb: () => rgb_default,
  interpolateRgbBasis: () => rgbBasis,
  interpolateRgbBasisClosed: () => rgbBasisClosed,
  interpolateRound: () => round_default,
  interpolateString: () => string_default,
  interpolateTransformCss: () => interpolateTransformCss,
  interpolateTransformSvg: () => interpolateTransformSvg,
  interpolateZoom: () => zoom_default,
  piecewise: () => piecewise,
  quantize: () => quantize_default2
});

// node_modules/d3-color/src/define.js
function define_default(constructor, factory, prototype2) {
  constructor.prototype = factory.prototype = prototype2;
  prototype2.constructor = constructor;
}
function extend5(parent, definition3) {
  var prototype2 = Object.create(parent.prototype);
  for (var key4 in definition3)
    prototype2[key4] = definition3[key4];
  return prototype2;
}

// node_modules/d3-color/src/color.js
function Color() {
}
var darker = 0.7;
var brighter = 1 / darker;
var reI = "\\s*([+-]?\\d+)\\s*";
var reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*";
var reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*";
var reHex = /^#([0-9a-f]{3,8})$/;
var reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`);
var reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`);
var reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`);
var reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`);
var reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`);
var reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);
var named = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
define_default(Color, color, {
  copy(channels) {
    return Object.assign(new this.constructor(), this, channels);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: color_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: color_formatHex,
  formatHex8: color_formatHex8,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});
function color_formatHex() {
  return this.rgb().formatHex();
}
function color_formatHex8() {
  return this.rgb().formatHex8();
}
function color_formatHsl() {
  return hslConvert(this).formatHsl();
}
function color_formatRgb() {
  return this.rgb().formatRgb();
}
function color(format14) {
  var m3, l;
  format14 = (format14 + "").trim().toLowerCase();
  return (m3 = reHex.exec(format14)) ? (l = m3[1].length, m3 = parseInt(m3[1], 16), l === 6 ? rgbn(m3) : l === 3 ? new Rgb(m3 >> 8 & 15 | m3 >> 4 & 240, m3 >> 4 & 15 | m3 & 240, (m3 & 15) << 4 | m3 & 15, 1) : l === 8 ? rgba(m3 >> 24 & 255, m3 >> 16 & 255, m3 >> 8 & 255, (m3 & 255) / 255) : l === 4 ? rgba(m3 >> 12 & 15 | m3 >> 8 & 240, m3 >> 8 & 15 | m3 >> 4 & 240, m3 >> 4 & 15 | m3 & 240, ((m3 & 15) << 4 | m3 & 15) / 255) : null) : (m3 = reRgbInteger.exec(format14)) ? new Rgb(m3[1], m3[2], m3[3], 1) : (m3 = reRgbPercent.exec(format14)) ? new Rgb(m3[1] * 255 / 100, m3[2] * 255 / 100, m3[3] * 255 / 100, 1) : (m3 = reRgbaInteger.exec(format14)) ? rgba(m3[1], m3[2], m3[3], m3[4]) : (m3 = reRgbaPercent.exec(format14)) ? rgba(m3[1] * 255 / 100, m3[2] * 255 / 100, m3[3] * 255 / 100, m3[4]) : (m3 = reHslPercent.exec(format14)) ? hsla(m3[1], m3[2] / 100, m3[3] / 100, 1) : (m3 = reHslaPercent.exec(format14)) ? hsla(m3[1], m3[2] / 100, m3[3] / 100, m3[4]) : named.hasOwnProperty(format14) ? rgbn(named[format14]) : format14 === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
}
function rgbn(n) {
  return new Rgb(n >> 16 & 255, n >> 8 & 255, n & 255, 1);
}
function rgba(r, g, b6, a4) {
  if (a4 <= 0)
    r = g = b6 = NaN;
  return new Rgb(r, g, b6, a4);
}
function rgbConvert(o) {
  if (!(o instanceof Color))
    o = color(o);
  if (!o)
    return new Rgb();
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}
function rgb(r, g, b6, opacity2) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b6, opacity2 == null ? 1 : opacity2);
}
function Rgb(r, g, b6, opacity2) {
  this.r = +r;
  this.g = +g;
  this.b = +b6;
  this.opacity = +opacity2;
}
define_default(Rgb, rgb, extend5(Color, {
  brighter(k3) {
    k3 = k3 == null ? brighter : Math.pow(brighter, k3);
    return new Rgb(this.r * k3, this.g * k3, this.b * k3, this.opacity);
  },
  darker(k3) {
    k3 = k3 == null ? darker : Math.pow(darker, k3);
    return new Rgb(this.r * k3, this.g * k3, this.b * k3, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex,
  formatHex8: rgb_formatHex8,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));
function rgb_formatHex() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
}
function rgb_formatHex8() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function rgb_formatRgb() {
  const a4 = clampa(this.opacity);
  return `${a4 === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a4 === 1 ? ")" : `, ${a4})`}`;
}
function clampa(opacity2) {
  return isNaN(opacity2) ? 1 : Math.max(0, Math.min(1, opacity2));
}
function clampi(value7) {
  return Math.max(0, Math.min(255, Math.round(value7) || 0));
}
function hex(value7) {
  value7 = clampi(value7);
  return (value7 < 16 ? "0" : "") + value7.toString(16);
}
function hsla(h6, s2, l, a4) {
  if (a4 <= 0)
    h6 = s2 = l = NaN;
  else if (l <= 0 || l >= 1)
    h6 = s2 = NaN;
  else if (s2 <= 0)
    h6 = NaN;
  return new Hsl(h6, s2, l, a4);
}
function hslConvert(o) {
  if (o instanceof Hsl)
    return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color))
    o = color(o);
  if (!o)
    return new Hsl();
  if (o instanceof Hsl)
    return o;
  o = o.rgb();
  var r = o.r / 255, g = o.g / 255, b6 = o.b / 255, min5 = Math.min(r, g, b6), max5 = Math.max(r, g, b6), h6 = NaN, s2 = max5 - min5, l = (max5 + min5) / 2;
  if (s2) {
    if (r === max5)
      h6 = (g - b6) / s2 + (g < b6) * 6;
    else if (g === max5)
      h6 = (b6 - r) / s2 + 2;
    else
      h6 = (r - g) / s2 + 4;
    s2 /= l < 0.5 ? max5 + min5 : 2 - max5 - min5;
    h6 *= 60;
  } else {
    s2 = l > 0 && l < 1 ? 0 : h6;
  }
  return new Hsl(h6, s2, l, o.opacity);
}
function hsl(h6, s2, l, opacity2) {
  return arguments.length === 1 ? hslConvert(h6) : new Hsl(h6, s2, l, opacity2 == null ? 1 : opacity2);
}
function Hsl(h6, s2, l, opacity2) {
  this.h = +h6;
  this.s = +s2;
  this.l = +l;
  this.opacity = +opacity2;
}
define_default(Hsl, hsl, extend5(Color, {
  brighter(k3) {
    k3 = k3 == null ? brighter : Math.pow(brighter, k3);
    return new Hsl(this.h, this.s, this.l * k3, this.opacity);
  },
  darker(k3) {
    k3 = k3 == null ? darker : Math.pow(darker, k3);
    return new Hsl(this.h, this.s, this.l * k3, this.opacity);
  },
  rgb() {
    var h6 = this.h % 360 + (this.h < 0) * 360, s2 = isNaN(h6) || isNaN(this.s) ? 0 : this.s, l = this.l, m22 = l + (l < 0.5 ? l : 1 - l) * s2, m1 = 2 * l - m22;
    return new Rgb(
      hsl2rgb(h6 >= 240 ? h6 - 240 : h6 + 120, m1, m22),
      hsl2rgb(h6, m1, m22),
      hsl2rgb(h6 < 120 ? h6 + 240 : h6 - 120, m1, m22),
      this.opacity
    );
  },
  clamp() {
    return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl() {
    const a4 = clampa(this.opacity);
    return `${a4 === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a4 === 1 ? ")" : `, ${a4})`}`;
  }
}));
function clamph(value7) {
  value7 = (value7 || 0) % 360;
  return value7 < 0 ? value7 + 360 : value7;
}
function clampt(value7) {
  return Math.max(0, Math.min(1, value7 || 0));
}
function hsl2rgb(h6, m1, m22) {
  return (h6 < 60 ? m1 + (m22 - m1) * h6 / 60 : h6 < 180 ? m22 : h6 < 240 ? m1 + (m22 - m1) * (240 - h6) / 60 : m1) * 255;
}

// node_modules/d3-color/src/math.js
var radians = Math.PI / 180;
var degrees = 180 / Math.PI;

// node_modules/d3-color/src/lab.js
var K = 18;
var Xn = 0.96422;
var Yn = 1;
var Zn = 0.82521;
var t05 = 4 / 29;
var t12 = 6 / 29;
var t2 = 3 * t12 * t12;
var t3 = t12 * t12 * t12;
function labConvert(o) {
  if (o instanceof Lab)
    return new Lab(o.l, o.a, o.b, o.opacity);
  if (o instanceof Hcl)
    return hcl2lab(o);
  if (!(o instanceof Rgb))
    o = rgbConvert(o);
  var r = rgb2lrgb(o.r), g = rgb2lrgb(o.g), b6 = rgb2lrgb(o.b), y9 = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b6) / Yn), x9, z;
  if (r === g && g === b6)
    x9 = z = y9;
  else {
    x9 = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b6) / Xn);
    z = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b6) / Zn);
  }
  return new Lab(116 * y9 - 16, 500 * (x9 - y9), 200 * (y9 - z), o.opacity);
}
function lab(l, a4, b6, opacity2) {
  return arguments.length === 1 ? labConvert(l) : new Lab(l, a4, b6, opacity2 == null ? 1 : opacity2);
}
function Lab(l, a4, b6, opacity2) {
  this.l = +l;
  this.a = +a4;
  this.b = +b6;
  this.opacity = +opacity2;
}
define_default(Lab, lab, extend5(Color, {
  brighter(k3) {
    return new Lab(this.l + K * (k3 == null ? 1 : k3), this.a, this.b, this.opacity);
  },
  darker(k3) {
    return new Lab(this.l - K * (k3 == null ? 1 : k3), this.a, this.b, this.opacity);
  },
  rgb() {
    var y9 = (this.l + 16) / 116, x9 = isNaN(this.a) ? y9 : y9 + this.a / 500, z = isNaN(this.b) ? y9 : y9 - this.b / 200;
    x9 = Xn * lab2xyz(x9);
    y9 = Yn * lab2xyz(y9);
    z = Zn * lab2xyz(z);
    return new Rgb(
      lrgb2rgb(3.1338561 * x9 - 1.6168667 * y9 - 0.4906146 * z),
      lrgb2rgb(-0.9787684 * x9 + 1.9161415 * y9 + 0.033454 * z),
      lrgb2rgb(0.0719453 * x9 - 0.2289914 * y9 + 1.4052427 * z),
      this.opacity
    );
  }
}));
function xyz2lab(t) {
  return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t05;
}
function lab2xyz(t) {
  return t > t12 ? t * t * t : t2 * (t - t05);
}
function lrgb2rgb(x9) {
  return 255 * (x9 <= 31308e-7 ? 12.92 * x9 : 1.055 * Math.pow(x9, 1 / 2.4) - 0.055);
}
function rgb2lrgb(x9) {
  return (x9 /= 255) <= 0.04045 ? x9 / 12.92 : Math.pow((x9 + 0.055) / 1.055, 2.4);
}
function hclConvert(o) {
  if (o instanceof Hcl)
    return new Hcl(o.h, o.c, o.l, o.opacity);
  if (!(o instanceof Lab))
    o = labConvert(o);
  if (o.a === 0 && o.b === 0)
    return new Hcl(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);
  var h6 = Math.atan2(o.b, o.a) * degrees;
  return new Hcl(h6 < 0 ? h6 + 360 : h6, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
}
function hcl(h6, c5, l, opacity2) {
  return arguments.length === 1 ? hclConvert(h6) : new Hcl(h6, c5, l, opacity2 == null ? 1 : opacity2);
}
function Hcl(h6, c5, l, opacity2) {
  this.h = +h6;
  this.c = +c5;
  this.l = +l;
  this.opacity = +opacity2;
}
function hcl2lab(o) {
  if (isNaN(o.h))
    return new Lab(o.l, 0, 0, o.opacity);
  var h6 = o.h * radians;
  return new Lab(o.l, Math.cos(h6) * o.c, Math.sin(h6) * o.c, o.opacity);
}
define_default(Hcl, hcl, extend5(Color, {
  brighter(k3) {
    return new Hcl(this.h, this.c, this.l + K * (k3 == null ? 1 : k3), this.opacity);
  },
  darker(k3) {
    return new Hcl(this.h, this.c, this.l - K * (k3 == null ? 1 : k3), this.opacity);
  },
  rgb() {
    return hcl2lab(this).rgb();
  }
}));

// node_modules/d3-color/src/cubehelix.js
var A = -0.14861;
var B = 1.78277;
var C = -0.29227;
var D = -0.90649;
var E = 1.97294;
var ED = E * D;
var EB = E * B;
var BC_DA = B * C - D * A;
function cubehelixConvert(o) {
  if (o instanceof Cubehelix)
    return new Cubehelix(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Rgb))
    o = rgbConvert(o);
  var r = o.r / 255, g = o.g / 255, b6 = o.b / 255, l = (BC_DA * b6 + ED * r - EB * g) / (BC_DA + ED - EB), bl6 = b6 - l, k3 = (E * (g - l) - C * bl6) / D, s2 = Math.sqrt(k3 * k3 + bl6 * bl6) / (E * l * (1 - l)), h6 = s2 ? Math.atan2(k3, bl6) * degrees - 120 : NaN;
  return new Cubehelix(h6 < 0 ? h6 + 360 : h6, s2, l, o.opacity);
}
function cubehelix(h6, s2, l, opacity2) {
  return arguments.length === 1 ? cubehelixConvert(h6) : new Cubehelix(h6, s2, l, opacity2 == null ? 1 : opacity2);
}
function Cubehelix(h6, s2, l, opacity2) {
  this.h = +h6;
  this.s = +s2;
  this.l = +l;
  this.opacity = +opacity2;
}
define_default(Cubehelix, cubehelix, extend5(Color, {
  brighter(k3) {
    k3 = k3 == null ? brighter : Math.pow(brighter, k3);
    return new Cubehelix(this.h, this.s, this.l * k3, this.opacity);
  },
  darker(k3) {
    k3 = k3 == null ? darker : Math.pow(darker, k3);
    return new Cubehelix(this.h, this.s, this.l * k3, this.opacity);
  },
  rgb() {
    var h6 = isNaN(this.h) ? 0 : (this.h + 120) * radians, l = +this.l, a4 = isNaN(this.s) ? 0 : this.s * l * (1 - l), cosh3 = Math.cos(h6), sinh3 = Math.sin(h6);
    return new Rgb(
      255 * (l + a4 * (A * cosh3 + B * sinh3)),
      255 * (l + a4 * (C * cosh3 + D * sinh3)),
      255 * (l + a4 * (E * cosh3)),
      this.opacity
    );
  }
}));

// node_modules/d3-interpolate/src/basis.js
function basis(t13, v0, v1, v2, v3) {
  var t22 = t13 * t13, t32 = t22 * t13;
  return ((1 - 3 * t13 + 3 * t22 - t32) * v0 + (4 - 6 * t22 + 3 * t32) * v1 + (1 + 3 * t13 + 3 * t22 - 3 * t32) * v2 + t32 * v3) / 6;
}
function basis_default2(values7) {
  var n = values7.length - 1;
  return function(t) {
    var i = t <= 0 ? t = 0 : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n), v1 = values7[i], v2 = values7[i + 1], v0 = i > 0 ? values7[i - 1] : 2 * v1 - v2, v3 = i < n - 1 ? values7[i + 2] : 2 * v2 - v1;
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}

// node_modules/d3-interpolate/src/basisClosed.js
function basisClosed_default2(values7) {
  var n = values7.length;
  return function(t) {
    var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n), v0 = values7[(i + n - 1) % n], v1 = values7[i % n], v2 = values7[(i + 1) % n], v3 = values7[(i + 2) % n];
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}

// node_modules/d3-interpolate/src/constant.js
var constant_default2 = (x9) => () => x9;

// node_modules/d3-interpolate/src/color.js
function linear2(a4, d) {
  return function(t) {
    return a4 + t * d;
  };
}
function exponential(a4, b6, y9) {
  return a4 = Math.pow(a4, y9), b6 = Math.pow(b6, y9) - a4, y9 = 1 / y9, function(t) {
    return Math.pow(a4 + t * b6, y9);
  };
}
function hue(a4, b6) {
  var d = b6 - a4;
  return d ? linear2(a4, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant_default2(isNaN(a4) ? b6 : a4);
}
function gamma(y9) {
  return (y9 = +y9) === 1 ? nogamma : function(a4, b6) {
    return b6 - a4 ? exponential(a4, b6, y9) : constant_default2(isNaN(a4) ? b6 : a4);
  };
}
function nogamma(a4, b6) {
  var d = b6 - a4;
  return d ? linear2(a4, d) : constant_default2(isNaN(a4) ? b6 : a4);
}

// node_modules/d3-interpolate/src/rgb.js
var rgb_default = function rgbGamma(y9) {
  var color9 = gamma(y9);
  function rgb2(start, end) {
    var r = color9((start = rgb(start)).r, (end = rgb(end)).r), g = color9(start.g, end.g), b6 = color9(start.b, end.b), opacity2 = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.r = r(t);
      start.g = g(t);
      start.b = b6(t);
      start.opacity = opacity2(t);
      return start + "";
    };
  }
  rgb2.gamma = rgbGamma;
  return rgb2;
}(1);
function rgbSpline(spline) {
  return function(colors10) {
    var n = colors10.length, r = new Array(n), g = new Array(n), b6 = new Array(n), i, color9;
    for (i = 0; i < n; ++i) {
      color9 = rgb(colors10[i]);
      r[i] = color9.r || 0;
      g[i] = color9.g || 0;
      b6[i] = color9.b || 0;
    }
    r = spline(r);
    g = spline(g);
    b6 = spline(b6);
    color9.opacity = 1;
    return function(t) {
      color9.r = r(t);
      color9.g = g(t);
      color9.b = b6(t);
      return color9 + "";
    };
  };
}
var rgbBasis = rgbSpline(basis_default2);
var rgbBasisClosed = rgbSpline(basisClosed_default2);

// node_modules/d3-interpolate/src/numberArray.js
function numberArray_default(a4, b6) {
  if (!b6)
    b6 = [];
  var n = a4 ? Math.min(b6.length, a4.length) : 0, c5 = b6.slice(), i;
  return function(t) {
    for (i = 0; i < n; ++i)
      c5[i] = a4[i] * (1 - t) + b6[i] * t;
    return c5;
  };
}
function isNumberArray(x9) {
  return ArrayBuffer.isView(x9) && !(x9 instanceof DataView);
}

// node_modules/d3-interpolate/src/array.js
function array_default2(a4, b6) {
  return (isNumberArray(b6) ? numberArray_default : genericArray)(a4, b6);
}
function genericArray(a4, b6) {
  var nb = b6 ? b6.length : 0, na = a4 ? Math.min(nb, a4.length) : 0, x9 = new Array(na), c5 = new Array(nb), i;
  for (i = 0; i < na; ++i)
    x9[i] = value_default(a4[i], b6[i]);
  for (; i < nb; ++i)
    c5[i] = b6[i];
  return function(t) {
    for (i = 0; i < na; ++i)
      c5[i] = x9[i](t);
    return c5;
  };
}

// node_modules/d3-interpolate/src/date.js
function date_default(a4, b6) {
  var d = /* @__PURE__ */ new Date();
  return a4 = +a4, b6 = +b6, function(t) {
    return d.setTime(a4 * (1 - t) + b6 * t), d;
  };
}

// node_modules/d3-interpolate/src/number.js
function number_default(a4, b6) {
  return a4 = +a4, b6 = +b6, function(t) {
    return a4 * (1 - t) + b6 * t;
  };
}

// node_modules/d3-interpolate/src/object.js
function object_default(a4, b6) {
  var i = {}, c5 = {}, k3;
  if (a4 === null || typeof a4 !== "object")
    a4 = {};
  if (b6 === null || typeof b6 !== "object")
    b6 = {};
  for (k3 in b6) {
    if (k3 in a4) {
      i[k3] = value_default(a4[k3], b6[k3]);
    } else {
      c5[k3] = b6[k3];
    }
  }
  return function(t) {
    for (k3 in i)
      c5[k3] = i[k3](t);
    return c5;
  };
}

// node_modules/d3-interpolate/src/string.js
var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
var reB = new RegExp(reA.source, "g");
function zero6(b6) {
  return function() {
    return b6;
  };
}
function one5(b6) {
  return function(t) {
    return b6(t) + "";
  };
}
function string_default(a4, b6) {
  var bi = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i = -1, s2 = [], q = [];
  a4 = a4 + "", b6 = b6 + "";
  while ((am = reA.exec(a4)) && (bm = reB.exec(b6))) {
    if ((bs = bm.index) > bi) {
      bs = b6.slice(bi, bs);
      if (s2[i])
        s2[i] += bs;
      else
        s2[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) {
      if (s2[i])
        s2[i] += bm;
      else
        s2[++i] = bm;
    } else {
      s2[++i] = null;
      q.push({ i, x: number_default(am, bm) });
    }
    bi = reB.lastIndex;
  }
  if (bi < b6.length) {
    bs = b6.slice(bi);
    if (s2[i])
      s2[i] += bs;
    else
      s2[++i] = bs;
  }
  return s2.length < 2 ? q[0] ? one5(q[0].x) : zero6(b6) : (b6 = q.length, function(t) {
    for (var i2 = 0, o; i2 < b6; ++i2)
      s2[(o = q[i2]).i] = o.x(t);
    return s2.join("");
  });
}

// node_modules/d3-interpolate/src/value.js
function value_default(a4, b6) {
  var t = typeof b6, c5;
  return b6 == null || t === "boolean" ? constant_default2(b6) : (t === "number" ? number_default : t === "string" ? (c5 = color(b6)) ? (b6 = c5, rgb_default) : string_default : b6 instanceof color ? rgb_default : b6 instanceof Date ? date_default : isNumberArray(b6) ? numberArray_default : Array.isArray(b6) ? genericArray : typeof b6.valueOf !== "function" && typeof b6.toString !== "function" || isNaN(b6) ? object_default : number_default)(a4, b6);
}

// node_modules/d3-interpolate/src/discrete.js
function discrete_default(range7) {
  var n = range7.length;
  return function(t) {
    return range7[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
  };
}

// node_modules/d3-interpolate/src/hue.js
function hue_default(a4, b6) {
  var i = hue(+a4, +b6);
  return function(t) {
    var x9 = i(t);
    return x9 - 360 * Math.floor(x9 / 360);
  };
}

// node_modules/d3-interpolate/src/round.js
function round_default(a4, b6) {
  return a4 = +a4, b6 = +b6, function(t) {
    return Math.round(a4 * (1 - t) + b6 * t);
  };
}

// node_modules/d3-interpolate/src/transform/decompose.js
var degrees2 = 180 / Math.PI;
var identity6 = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function decompose_default(a4, b6, c5, d, e3, f) {
  var scaleX, scaleY2, skewX;
  if (scaleX = Math.sqrt(a4 * a4 + b6 * b6))
    a4 /= scaleX, b6 /= scaleX;
  if (skewX = a4 * c5 + b6 * d)
    c5 -= a4 * skewX, d -= b6 * skewX;
  if (scaleY2 = Math.sqrt(c5 * c5 + d * d))
    c5 /= scaleY2, d /= scaleY2, skewX /= scaleY2;
  if (a4 * d < b6 * c5)
    a4 = -a4, b6 = -b6, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e3,
    translateY: f,
    rotate: Math.atan2(b6, a4) * degrees2,
    skewX: Math.atan(skewX) * degrees2,
    scaleX,
    scaleY: scaleY2
  };
}

// node_modules/d3-interpolate/src/transform/parse.js
var svgNode;
function parseCss(value7) {
  const m3 = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value7 + "");
  return m3.isIdentity ? identity6 : decompose_default(m3.a, m3.b, m3.c, m3.d, m3.e, m3.f);
}
function parseSvg(value7) {
  if (value7 == null)
    return identity6;
  if (!svgNode)
    svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value7);
  if (!(value7 = svgNode.transform.baseVal.consolidate()))
    return identity6;
  value7 = value7.matrix;
  return decompose_default(value7.a, value7.b, value7.c, value7.d, value7.e, value7.f);
}

// node_modules/d3-interpolate/src/transform/index.js
function interpolateTransform(parse12, pxComma, pxParen, degParen) {
  function pop(s2) {
    return s2.length ? s2.pop() + " " : "";
  }
  function translate8(xa, ya, xb, yb, s2, q) {
    if (xa !== xb || ya !== yb) {
      var i = s2.push("translate(", null, pxComma, null, pxParen);
      q.push({ i: i - 4, x: number_default(xa, xb) }, { i: i - 2, x: number_default(ya, yb) });
    } else if (xb || yb) {
      s2.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }
  function rotate6(a4, b6, s2, q) {
    if (a4 !== b6) {
      if (a4 - b6 > 180)
        b6 += 360;
      else if (b6 - a4 > 180)
        a4 += 360;
      q.push({ i: s2.push(pop(s2) + "rotate(", null, degParen) - 2, x: number_default(a4, b6) });
    } else if (b6) {
      s2.push(pop(s2) + "rotate(" + b6 + degParen);
    }
  }
  function skewX(a4, b6, s2, q) {
    if (a4 !== b6) {
      q.push({ i: s2.push(pop(s2) + "skewX(", null, degParen) - 2, x: number_default(a4, b6) });
    } else if (b6) {
      s2.push(pop(s2) + "skewX(" + b6 + degParen);
    }
  }
  function scale19(xa, ya, xb, yb, s2, q) {
    if (xa !== xb || ya !== yb) {
      var i = s2.push(pop(s2) + "scale(", null, ",", null, ")");
      q.push({ i: i - 4, x: number_default(xa, xb) }, { i: i - 2, x: number_default(ya, yb) });
    } else if (xb !== 1 || yb !== 1) {
      s2.push(pop(s2) + "scale(" + xb + "," + yb + ")");
    }
  }
  return function(a4, b6) {
    var s2 = [], q = [];
    a4 = parse12(a4), b6 = parse12(b6);
    translate8(a4.translateX, a4.translateY, b6.translateX, b6.translateY, s2, q);
    rotate6(a4.rotate, b6.rotate, s2, q);
    skewX(a4.skewX, b6.skewX, s2, q);
    scale19(a4.scaleX, a4.scaleY, b6.scaleX, b6.scaleY, s2, q);
    a4 = b6 = null;
    return function(t) {
      var i = -1, n = q.length, o;
      while (++i < n)
        s2[(o = q[i]).i] = o.x(t);
      return s2.join("");
    };
  };
}
var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

// node_modules/d3-interpolate/src/zoom.js
var epsilon22 = 1e-12;
function cosh(x9) {
  return ((x9 = Math.exp(x9)) + 1 / x9) / 2;
}
function sinh(x9) {
  return ((x9 = Math.exp(x9)) - 1 / x9) / 2;
}
function tanh(x9) {
  return ((x9 = Math.exp(2 * x9)) - 1) / (x9 + 1);
}
var zoom_default = function zoomRho(rho, rho2, rho4) {
  function zoom5(p02, p1) {
    var ux0 = p02[0], uy0 = p02[1], w0 = p02[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, i, S;
    if (d2 < epsilon22) {
      S = Math.log(w1 / w0) / rho;
      i = function(t) {
        return [
          ux0 + t * dx,
          uy0 + t * dy,
          w0 * Math.exp(rho * t * S)
        ];
      };
    } else {
      var d1 = Math.sqrt(d2), b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1), b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1), r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
      S = (r1 - r0) / rho;
      i = function(t) {
        var s2 = t * S, coshr0 = cosh(r0), u4 = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s2 + r0) - sinh(r0));
        return [
          ux0 + u4 * dx,
          uy0 + u4 * dy,
          w0 * coshr0 / cosh(rho * s2 + r0)
        ];
      };
    }
    i.duration = S * 1e3 * rho / Math.SQRT2;
    return i;
  }
  zoom5.rho = function(_) {
    var _1 = Math.max(1e-3, +_), _2 = _1 * _1, _4 = _2 * _2;
    return zoomRho(_1, _2, _4);
  };
  return zoom5;
}(Math.SQRT2, 2, 4);

// node_modules/d3-interpolate/src/hsl.js
function hsl2(hue2) {
  return function(start, end) {
    var h6 = hue2((start = hsl(start)).h, (end = hsl(end)).h), s2 = nogamma(start.s, end.s), l = nogamma(start.l, end.l), opacity2 = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.h = h6(t);
      start.s = s2(t);
      start.l = l(t);
      start.opacity = opacity2(t);
      return start + "";
    };
  };
}
var hsl_default = hsl2(hue);
var hslLong = hsl2(nogamma);

// node_modules/d3-interpolate/src/lab.js
function lab2(start, end) {
  var l = nogamma((start = lab(start)).l, (end = lab(end)).l), a4 = nogamma(start.a, end.a), b6 = nogamma(start.b, end.b), opacity2 = nogamma(start.opacity, end.opacity);
  return function(t) {
    start.l = l(t);
    start.a = a4(t);
    start.b = b6(t);
    start.opacity = opacity2(t);
    return start + "";
  };
}

// node_modules/d3-interpolate/src/hcl.js
function hcl2(hue2) {
  return function(start, end) {
    var h6 = hue2((start = hcl(start)).h, (end = hcl(end)).h), c5 = nogamma(start.c, end.c), l = nogamma(start.l, end.l), opacity2 = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.h = h6(t);
      start.c = c5(t);
      start.l = l(t);
      start.opacity = opacity2(t);
      return start + "";
    };
  };
}
var hcl_default = hcl2(hue);
var hclLong = hcl2(nogamma);

// node_modules/d3-interpolate/src/cubehelix.js
function cubehelix2(hue2) {
  return function cubehelixGamma(y9) {
    y9 = +y9;
    function cubehelix3(start, end) {
      var h6 = hue2((start = cubehelix(start)).h, (end = cubehelix(end)).h), s2 = nogamma(start.s, end.s), l = nogamma(start.l, end.l), opacity2 = nogamma(start.opacity, end.opacity);
      return function(t) {
        start.h = h6(t);
        start.s = s2(t);
        start.l = l(Math.pow(t, y9));
        start.opacity = opacity2(t);
        return start + "";
      };
    }
    cubehelix3.gamma = cubehelixGamma;
    return cubehelix3;
  }(1);
}
var cubehelix_default = cubehelix2(hue);
var cubehelixLong = cubehelix2(nogamma);

// node_modules/d3-interpolate/src/piecewise.js
function piecewise(interpolate11, values7) {
  if (values7 === void 0)
    values7 = interpolate11, interpolate11 = value_default;
  var i = 0, n = values7.length - 1, v2 = values7[0], I = new Array(n < 0 ? 0 : n);
  while (i < n)
    I[i] = interpolate11(v2, v2 = values7[++i]);
  return function(t) {
    var i2 = Math.max(0, Math.min(n - 1, Math.floor(t *= n)));
    return I[i2](t - i2);
  };
}

// node_modules/d3-interpolate/src/quantize.js
function quantize_default2(interpolator, n) {
  var samples = new Array(n);
  for (var i = 0; i < n; ++i)
    samples[i] = interpolator(i / (n - 1));
  return samples;
}

// node_modules/d3-scale/src/constant.js
function constants(x9) {
  return function() {
    return x9;
  };
}

// node_modules/d3-scale/src/number.js
function number2(x9) {
  return +x9;
}

// node_modules/d3-scale/src/continuous.js
var unit = [0, 1];
function identity7(x9) {
  return x9;
}
function normalize(a4, b6) {
  return (b6 -= a4 = +a4) ? function(x9) {
    return (x9 - a4) / b6;
  } : constants(isNaN(b6) ? NaN : 0.5);
}
function clamper(a4, b6) {
  var t;
  if (a4 > b6)
    t = a4, a4 = b6, b6 = t;
  return function(x9) {
    return Math.max(a4, Math.min(b6, x9));
  };
}
function bimap(domain3, range7, interpolate11) {
  var d0 = domain3[0], d1 = domain3[1], r0 = range7[0], r1 = range7[1];
  if (d1 < d0)
    d0 = normalize(d1, d0), r0 = interpolate11(r1, r0);
  else
    d0 = normalize(d0, d1), r0 = interpolate11(r0, r1);
  return function(x9) {
    return r0(d0(x9));
  };
}
function polymap(domain3, range7, interpolate11) {
  var j = Math.min(domain3.length, range7.length) - 1, d = new Array(j), r = new Array(j), i = -1;
  if (domain3[j] < domain3[0]) {
    domain3 = domain3.slice().reverse();
    range7 = range7.slice().reverse();
  }
  while (++i < j) {
    d[i] = normalize(domain3[i], domain3[i + 1]);
    r[i] = interpolate11(range7[i], range7[i + 1]);
  }
  return function(x9) {
    var i2 = bisect_default2(domain3, x9, 1, j) - 1;
    return r[i2](d[i2](x9));
  };
}
function copy(source3, target2) {
  return target2.domain(source3.domain()).range(source3.range()).interpolate(source3.interpolate()).clamp(source3.clamp()).unknown(source3.unknown());
}
function transformer() {
  var domain3 = unit, range7 = unit, interpolate11 = value_default, transform4, untransform, unknown, clamp6 = identity7, piecewise2, output3, input;
  function rescale() {
    var n = Math.min(domain3.length, range7.length);
    if (clamp6 !== identity7)
      clamp6 = clamper(domain3[0], domain3[n - 1]);
    piecewise2 = n > 2 ? polymap : bimap;
    output3 = input = null;
    return scale19;
  }
  function scale19(x9) {
    return x9 == null || isNaN(x9 = +x9) ? unknown : (output3 || (output3 = piecewise2(domain3.map(transform4), range7, interpolate11)))(transform4(clamp6(x9)));
  }
  scale19.invert = function(y9) {
    return clamp6(untransform((input || (input = piecewise2(range7, domain3.map(transform4), number_default)))(y9)));
  };
  scale19.domain = function(_) {
    return arguments.length ? (domain3 = Array.from(_, number2), rescale()) : domain3.slice();
  };
  scale19.range = function(_) {
    return arguments.length ? (range7 = Array.from(_), rescale()) : range7.slice();
  };
  scale19.rangeRound = function(_) {
    return range7 = Array.from(_), interpolate11 = round_default, rescale();
  };
  scale19.clamp = function(_) {
    return arguments.length ? (clamp6 = _ ? true : identity7, rescale()) : clamp6 !== identity7;
  };
  scale19.interpolate = function(_) {
    return arguments.length ? (interpolate11 = _, rescale()) : interpolate11;
  };
  scale19.unknown = function(_) {
    return arguments.length ? (unknown = _, scale19) : unknown;
  };
  return function(t, u4) {
    transform4 = t, untransform = u4;
    return rescale();
  };
}
function continuous() {
  return transformer()(identity7, identity7);
}

// node_modules/d3-scale/src/tickFormat.js
function tickFormat(start, stop2, count3, specifier) {
  var step = tickStep(start, stop2, count3), precision;
  specifier = formatSpecifier(specifier == null ? ",f" : specifier);
  switch (specifier.type) {
    case "s": {
      var value7 = Math.max(Math.abs(start), Math.abs(stop2));
      if (specifier.precision == null && !isNaN(precision = precisionPrefix_default(step, value7)))
        specifier.precision = precision;
      return formatPrefix(specifier, value7);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      if (specifier.precision == null && !isNaN(precision = precisionRound_default(step, Math.max(Math.abs(start), Math.abs(stop2)))))
        specifier.precision = precision - (specifier.type === "e");
      break;
    }
    case "f":
    case "%": {
      if (specifier.precision == null && !isNaN(precision = precisionFixed_default(step)))
        specifier.precision = precision - (specifier.type === "%") * 2;
      break;
    }
  }
  return format(specifier);
}

// node_modules/d3-scale/src/linear.js
function linearish(scale19) {
  var domain3 = scale19.domain;
  scale19.ticks = function(count3) {
    var d = domain3();
    return ticks(d[0], d[d.length - 1], count3 == null ? 10 : count3);
  };
  scale19.tickFormat = function(count3, specifier) {
    var d = domain3();
    return tickFormat(d[0], d[d.length - 1], count3 == null ? 10 : count3, specifier);
  };
  scale19.nice = function(count3) {
    if (count3 == null)
      count3 = 10;
    var d = domain3();
    var i0 = 0;
    var i1 = d.length - 1;
    var start = d[i0];
    var stop2 = d[i1];
    var prestep;
    var step;
    var maxIter = 10;
    if (stop2 < start) {
      step = start, start = stop2, stop2 = step;
      step = i0, i0 = i1, i1 = step;
    }
    while (maxIter-- > 0) {
      step = tickIncrement(start, stop2, count3);
      if (step === prestep) {
        d[i0] = start;
        d[i1] = stop2;
        return domain3(d);
      } else if (step > 0) {
        start = Math.floor(start / step) * step;
        stop2 = Math.ceil(stop2 / step) * step;
      } else if (step < 0) {
        start = Math.ceil(start * step) / step;
        stop2 = Math.floor(stop2 * step) / step;
      } else {
        break;
      }
      prestep = step;
    }
    return scale19;
  };
  return scale19;
}
function linear3() {
  var scale19 = continuous();
  scale19.copy = function() {
    return copy(scale19, linear3());
  };
  initRange.apply(scale19, arguments);
  return linearish(scale19);
}

// node_modules/d3-scale/src/identity.js
function identity8(domain3) {
  var unknown;
  function scale19(x9) {
    return x9 == null || isNaN(x9 = +x9) ? unknown : x9;
  }
  scale19.invert = scale19;
  scale19.domain = scale19.range = function(_) {
    return arguments.length ? (domain3 = Array.from(_, number2), scale19) : domain3.slice();
  };
  scale19.unknown = function(_) {
    return arguments.length ? (unknown = _, scale19) : unknown;
  };
  scale19.copy = function() {
    return identity8(domain3).unknown(unknown);
  };
  domain3 = arguments.length ? Array.from(domain3, number2) : [0, 1];
  return linearish(scale19);
}

// node_modules/d3-scale/src/nice.js
function nice2(domain3, interval3) {
  domain3 = domain3.slice();
  var i0 = 0, i1 = domain3.length - 1, x07 = domain3[i0], x13 = domain3[i1], t;
  if (x13 < x07) {
    t = i0, i0 = i1, i1 = t;
    t = x07, x07 = x13, x13 = t;
  }
  domain3[i0] = interval3.floor(x07);
  domain3[i1] = interval3.ceil(x13);
  return domain3;
}

// node_modules/d3-scale/src/log.js
function transformLog(x9) {
  return Math.log(x9);
}
function transformExp(x9) {
  return Math.exp(x9);
}
function transformLogn(x9) {
  return -Math.log(-x9);
}
function transformExpn(x9) {
  return -Math.exp(-x9);
}
function pow10(x9) {
  return isFinite(x9) ? +("1e" + x9) : x9 < 0 ? 0 : x9;
}
function powp(base) {
  return base === 10 ? pow10 : base === Math.E ? Math.exp : (x9) => Math.pow(base, x9);
}
function logp(base) {
  return base === Math.E ? Math.log : base === 10 && Math.log10 || base === 2 && Math.log2 || (base = Math.log(base), (x9) => Math.log(x9) / base);
}
function reflect(f) {
  return (x9, k3) => -f(-x9, k3);
}
function loggish(transform4) {
  const scale19 = transform4(transformLog, transformExp);
  const domain3 = scale19.domain;
  let base = 10;
  let logs;
  let pows;
  function rescale() {
    logs = logp(base), pows = powp(base);
    if (domain3()[0] < 0) {
      logs = reflect(logs), pows = reflect(pows);
      transform4(transformLogn, transformExpn);
    } else {
      transform4(transformLog, transformExp);
    }
    return scale19;
  }
  scale19.base = function(_) {
    return arguments.length ? (base = +_, rescale()) : base;
  };
  scale19.domain = function(_) {
    return arguments.length ? (domain3(_), rescale()) : domain3();
  };
  scale19.ticks = (count3) => {
    const d = domain3();
    let u4 = d[0];
    let v2 = d[d.length - 1];
    const r = v2 < u4;
    if (r)
      [u4, v2] = [v2, u4];
    let i = logs(u4);
    let j = logs(v2);
    let k3;
    let t;
    const n = count3 == null ? 10 : +count3;
    let z = [];
    if (!(base % 1) && j - i < n) {
      i = Math.floor(i), j = Math.ceil(j);
      if (u4 > 0)
        for (; i <= j; ++i) {
          for (k3 = 1; k3 < base; ++k3) {
            t = i < 0 ? k3 / pows(-i) : k3 * pows(i);
            if (t < u4)
              continue;
            if (t > v2)
              break;
            z.push(t);
          }
        }
      else
        for (; i <= j; ++i) {
          for (k3 = base - 1; k3 >= 1; --k3) {
            t = i > 0 ? k3 / pows(-i) : k3 * pows(i);
            if (t < u4)
              continue;
            if (t > v2)
              break;
            z.push(t);
          }
        }
      if (z.length * 2 < n)
        z = ticks(u4, v2, n);
    } else {
      z = ticks(i, j, Math.min(j - i, n)).map(pows);
    }
    return r ? z.reverse() : z;
  };
  scale19.tickFormat = (count3, specifier) => {
    if (count3 == null)
      count3 = 10;
    if (specifier == null)
      specifier = base === 10 ? "s" : ",";
    if (typeof specifier !== "function") {
      if (!(base % 1) && (specifier = formatSpecifier(specifier)).precision == null)
        specifier.trim = true;
      specifier = format(specifier);
    }
    if (count3 === Infinity)
      return specifier;
    const k3 = Math.max(1, base * count3 / scale19.ticks().length);
    return (d) => {
      let i = d / pows(Math.round(logs(d)));
      if (i * base < base - 0.5)
        i *= base;
      return i <= k3 ? specifier(d) : "";
    };
  };
  scale19.nice = () => {
    return domain3(nice2(domain3(), {
      floor: (x9) => pows(Math.floor(logs(x9))),
      ceil: (x9) => pows(Math.ceil(logs(x9)))
    }));
  };
  return scale19;
}
function log3() {
  const scale19 = loggish(transformer()).domain([1, 10]);
  scale19.copy = () => copy(scale19, log3()).base(scale19.base());
  initRange.apply(scale19, arguments);
  return scale19;
}

// node_modules/d3-scale/src/symlog.js
function transformSymlog(c5) {
  return function(x9) {
    return Math.sign(x9) * Math.log1p(Math.abs(x9 / c5));
  };
}
function transformSymexp(c5) {
  return function(x9) {
    return Math.sign(x9) * Math.expm1(Math.abs(x9)) * c5;
  };
}
function symlogish(transform4) {
  var c5 = 1, scale19 = transform4(transformSymlog(c5), transformSymexp(c5));
  scale19.constant = function(_) {
    return arguments.length ? transform4(transformSymlog(c5 = +_), transformSymexp(c5)) : c5;
  };
  return linearish(scale19);
}
function symlog2() {
  var scale19 = symlogish(transformer());
  scale19.copy = function() {
    return copy(scale19, symlog2()).constant(scale19.constant());
  };
  return initRange.apply(scale19, arguments);
}

// node_modules/d3-scale/src/pow.js
function transformPow(exponent) {
  return function(x9) {
    return x9 < 0 ? -Math.pow(-x9, exponent) : Math.pow(x9, exponent);
  };
}
function transformSqrt(x9) {
  return x9 < 0 ? -Math.sqrt(-x9) : Math.sqrt(x9);
}
function transformSquare(x9) {
  return x9 < 0 ? -x9 * x9 : x9 * x9;
}
function powish(transform4) {
  var scale19 = transform4(identity7, identity7), exponent = 1;
  function rescale() {
    return exponent === 1 ? transform4(identity7, identity7) : exponent === 0.5 ? transform4(transformSqrt, transformSquare) : transform4(transformPow(exponent), transformPow(1 / exponent));
  }
  scale19.exponent = function(_) {
    return arguments.length ? (exponent = +_, rescale()) : exponent;
  };
  return linearish(scale19);
}
function pow3() {
  var scale19 = powish(transformer());
  scale19.copy = function() {
    return copy(scale19, pow3()).exponent(scale19.exponent());
  };
  initRange.apply(scale19, arguments);
  return scale19;
}
function sqrt2() {
  return pow3.apply(null, arguments).exponent(0.5);
}

// node_modules/d3-scale/src/quantile.js
function quantile2() {
  var domain3 = [], range7 = [], thresholds = [], unknown;
  function rescale() {
    var i = 0, n = Math.max(1, range7.length);
    thresholds = new Array(n - 1);
    while (++i < n)
      thresholds[i - 1] = quantileSorted(domain3, i / n);
    return scale19;
  }
  function scale19(x9) {
    return x9 == null || isNaN(x9 = +x9) ? unknown : range7[bisect_default2(thresholds, x9)];
  }
  scale19.invertExtent = function(y9) {
    var i = range7.indexOf(y9);
    return i < 0 ? [NaN, NaN] : [
      i > 0 ? thresholds[i - 1] : domain3[0],
      i < thresholds.length ? thresholds[i] : domain3[domain3.length - 1]
    ];
  };
  scale19.domain = function(_) {
    if (!arguments.length)
      return domain3.slice();
    domain3 = [];
    for (let d of _)
      if (d != null && !isNaN(d = +d))
        domain3.push(d);
    domain3.sort(ascending2);
    return rescale();
  };
  scale19.range = function(_) {
    return arguments.length ? (range7 = Array.from(_), rescale()) : range7.slice();
  };
  scale19.unknown = function(_) {
    return arguments.length ? (unknown = _, scale19) : unknown;
  };
  scale19.quantiles = function() {
    return thresholds.slice();
  };
  scale19.copy = function() {
    return quantile2().domain(domain3).range(range7).unknown(unknown);
  };
  return initRange.apply(scale19, arguments);
}

// node_modules/d3-scale/src/quantize.js
function quantize() {
  var x07 = 0, x13 = 1, n = 1, domain3 = [0.5], range7 = [0, 1], unknown;
  function scale19(x9) {
    return x9 != null && x9 <= x9 ? range7[bisect_default2(domain3, x9, 0, n)] : unknown;
  }
  function rescale() {
    var i = -1;
    domain3 = new Array(n);
    while (++i < n)
      domain3[i] = ((i + 1) * x13 - (i - n) * x07) / (n + 1);
    return scale19;
  }
  scale19.domain = function(_) {
    return arguments.length ? ([x07, x13] = _, x07 = +x07, x13 = +x13, rescale()) : [x07, x13];
  };
  scale19.range = function(_) {
    return arguments.length ? (n = (range7 = Array.from(_)).length - 1, rescale()) : range7.slice();
  };
  scale19.invertExtent = function(y9) {
    var i = range7.indexOf(y9);
    return i < 0 ? [NaN, NaN] : i < 1 ? [x07, domain3[0]] : i >= n ? [domain3[n - 1], x13] : [domain3[i - 1], domain3[i]];
  };
  scale19.unknown = function(_) {
    return arguments.length ? (unknown = _, scale19) : scale19;
  };
  scale19.thresholds = function() {
    return domain3.slice();
  };
  scale19.copy = function() {
    return quantize().domain([x07, x13]).range(range7).unknown(unknown);
  };
  return initRange.apply(linearish(scale19), arguments);
}

// node_modules/d3-scale/src/threshold.js
function threshold() {
  var domain3 = [0.5], range7 = [0, 1], unknown, n = 1;
  function scale19(x9) {
    return x9 != null && x9 <= x9 ? range7[bisect_default2(domain3, x9, 0, n)] : unknown;
  }
  scale19.domain = function(_) {
    return arguments.length ? (domain3 = Array.from(_), n = Math.min(domain3.length, range7.length - 1), scale19) : domain3.slice();
  };
  scale19.range = function(_) {
    return arguments.length ? (range7 = Array.from(_), n = Math.min(domain3.length, range7.length - 1), scale19) : range7.slice();
  };
  scale19.invertExtent = function(y9) {
    var i = range7.indexOf(y9);
    return [domain3[i - 1], domain3[i]];
  };
  scale19.unknown = function(_) {
    return arguments.length ? (unknown = _, scale19) : unknown;
  };
  scale19.copy = function() {
    return threshold().domain(domain3).range(range7).unknown(unknown);
  };
  return initRange.apply(scale19, arguments);
}

// node_modules/d3-scale/src/time.js
function date(t) {
  return new Date(t);
}
function number3(t) {
  return t instanceof Date ? +t : +/* @__PURE__ */ new Date(+t);
}
function calendar(ticks2, tickInterval, year, month, week3, day, hour, minute, second2, format14) {
  var scale19 = continuous(), invert2 = scale19.invert, domain3 = scale19.domain;
  var formatMillisecond = format14(".%L"), formatSecond = format14(":%S"), formatMinute = format14("%I:%M"), formatHour = format14("%I %p"), formatDay = format14("%a %d"), formatWeek = format14("%b %d"), formatMonth = format14("%B"), formatYear3 = format14("%Y");
  function tickFormat8(date2) {
    return (second2(date2) < date2 ? formatMillisecond : minute(date2) < date2 ? formatSecond : hour(date2) < date2 ? formatMinute : day(date2) < date2 ? formatHour : month(date2) < date2 ? week3(date2) < date2 ? formatDay : formatWeek : year(date2) < date2 ? formatMonth : formatYear3)(date2);
  }
  scale19.invert = function(y9) {
    return new Date(invert2(y9));
  };
  scale19.domain = function(_) {
    return arguments.length ? domain3(Array.from(_, number3)) : domain3().map(date);
  };
  scale19.ticks = function(interval3) {
    var d = domain3();
    return ticks2(d[0], d[d.length - 1], interval3 == null ? 10 : interval3);
  };
  scale19.tickFormat = function(count3, specifier) {
    return specifier == null ? tickFormat8 : format14(specifier);
  };
  scale19.nice = function(interval3) {
    var d = domain3();
    if (!interval3 || typeof interval3.range !== "function")
      interval3 = tickInterval(d[0], d[d.length - 1], interval3 == null ? 10 : interval3);
    return interval3 ? domain3(nice2(d, interval3)) : scale19;
  };
  scale19.copy = function() {
    return copy(scale19, calendar(ticks2, tickInterval, year, month, week3, day, hour, minute, second2, format14));
  };
  return scale19;
}
function time() {
  return initRange.apply(calendar(timeTicks, timeTickInterval, timeYear, timeMonth, timeSunday, timeDay, timeHour, timeMinute, second, timeFormat).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments);
}

// node_modules/d3-scale/src/utcTime.js
function utcTime() {
  return initRange.apply(calendar(utcTicks, utcTickInterval, utcYear, utcMonth, utcSunday, utcDay, utcHour, utcMinute, second, utcFormat).domain([Date.UTC(2e3, 0, 1), Date.UTC(2e3, 0, 2)]), arguments);
}

// node_modules/d3-scale/src/sequential.js
function transformer2() {
  var x07 = 0, x13 = 1, t014, t13, k10, transform4, interpolator = identity7, clamp6 = false, unknown;
  function scale19(x9) {
    return x9 == null || isNaN(x9 = +x9) ? unknown : interpolator(k10 === 0 ? 0.5 : (x9 = (transform4(x9) - t014) * k10, clamp6 ? Math.max(0, Math.min(1, x9)) : x9));
  }
  scale19.domain = function(_) {
    return arguments.length ? ([x07, x13] = _, t014 = transform4(x07 = +x07), t13 = transform4(x13 = +x13), k10 = t014 === t13 ? 0 : 1 / (t13 - t014), scale19) : [x07, x13];
  };
  scale19.clamp = function(_) {
    return arguments.length ? (clamp6 = !!_, scale19) : clamp6;
  };
  scale19.interpolator = function(_) {
    return arguments.length ? (interpolator = _, scale19) : interpolator;
  };
  function range7(interpolate11) {
    return function(_) {
      var r0, r1;
      return arguments.length ? ([r0, r1] = _, interpolator = interpolate11(r0, r1), scale19) : [interpolator(0), interpolator(1)];
    };
  }
  scale19.range = range7(value_default);
  scale19.rangeRound = range7(round_default);
  scale19.unknown = function(_) {
    return arguments.length ? (unknown = _, scale19) : unknown;
  };
  return function(t) {
    transform4 = t, t014 = t(x07), t13 = t(x13), k10 = t014 === t13 ? 0 : 1 / (t13 - t014);
    return scale19;
  };
}
function copy2(source3, target2) {
  return target2.domain(source3.domain()).interpolator(source3.interpolator()).clamp(source3.clamp()).unknown(source3.unknown());
}
function sequential() {
  var scale19 = linearish(transformer2()(identity7));
  scale19.copy = function() {
    return copy2(scale19, sequential());
  };
  return initInterpolator.apply(scale19, arguments);
}
function sequentialLog() {
  var scale19 = loggish(transformer2()).domain([1, 10]);
  scale19.copy = function() {
    return copy2(scale19, sequentialLog()).base(scale19.base());
  };
  return initInterpolator.apply(scale19, arguments);
}
function sequentialSymlog() {
  var scale19 = symlogish(transformer2());
  scale19.copy = function() {
    return copy2(scale19, sequentialSymlog()).constant(scale19.constant());
  };
  return initInterpolator.apply(scale19, arguments);
}
function sequentialPow() {
  var scale19 = powish(transformer2());
  scale19.copy = function() {
    return copy2(scale19, sequentialPow()).exponent(scale19.exponent());
  };
  return initInterpolator.apply(scale19, arguments);
}
function sequentialSqrt() {
  return sequentialPow.apply(null, arguments).exponent(0.5);
}

// node_modules/d3-scale/src/diverging.js
function transformer3() {
  var x07 = 0, x13 = 0.5, x22 = 1, s2 = 1, t014, t13, t22, k10, k21, interpolator = identity7, transform4, clamp6 = false, unknown;
  function scale19(x9) {
    return isNaN(x9 = +x9) ? unknown : (x9 = 0.5 + ((x9 = +transform4(x9)) - t13) * (s2 * x9 < s2 * t13 ? k10 : k21), interpolator(clamp6 ? Math.max(0, Math.min(1, x9)) : x9));
  }
  scale19.domain = function(_) {
    return arguments.length ? ([x07, x13, x22] = _, t014 = transform4(x07 = +x07), t13 = transform4(x13 = +x13), t22 = transform4(x22 = +x22), k10 = t014 === t13 ? 0 : 0.5 / (t13 - t014), k21 = t13 === t22 ? 0 : 0.5 / (t22 - t13), s2 = t13 < t014 ? -1 : 1, scale19) : [x07, x13, x22];
  };
  scale19.clamp = function(_) {
    return arguments.length ? (clamp6 = !!_, scale19) : clamp6;
  };
  scale19.interpolator = function(_) {
    return arguments.length ? (interpolator = _, scale19) : interpolator;
  };
  function range7(interpolate11) {
    return function(_) {
      var r0, r1, r2;
      return arguments.length ? ([r0, r1, r2] = _, interpolator = piecewise(interpolate11, [r0, r1, r2]), scale19) : [interpolator(0), interpolator(0.5), interpolator(1)];
    };
  }
  scale19.range = range7(value_default);
  scale19.rangeRound = range7(round_default);
  scale19.unknown = function(_) {
    return arguments.length ? (unknown = _, scale19) : unknown;
  };
  return function(t) {
    transform4 = t, t014 = t(x07), t13 = t(x13), t22 = t(x22), k10 = t014 === t13 ? 0 : 0.5 / (t13 - t014), k21 = t13 === t22 ? 0 : 0.5 / (t22 - t13), s2 = t13 < t014 ? -1 : 1;
    return scale19;
  };
}
function diverging() {
  var scale19 = linearish(transformer3()(identity7));
  scale19.copy = function() {
    return copy2(scale19, diverging());
  };
  return initInterpolator.apply(scale19, arguments);
}
function divergingLog() {
  var scale19 = loggish(transformer3()).domain([0.1, 1, 10]);
  scale19.copy = function() {
    return copy2(scale19, divergingLog()).base(scale19.base());
  };
  return initInterpolator.apply(scale19, arguments);
}
function divergingSymlog() {
  var scale19 = symlogish(transformer3());
  scale19.copy = function() {
    return copy2(scale19, divergingSymlog()).constant(scale19.constant());
  };
  return initInterpolator.apply(scale19, arguments);
}
function divergingPow() {
  var scale19 = powish(transformer3());
  scale19.copy = function() {
    return copy2(scale19, divergingPow()).exponent(scale19.exponent());
  };
  return initInterpolator.apply(scale19, arguments);
}
function divergingSqrt() {
  return divergingPow.apply(null, arguments).exponent(0.5);
}

// node_modules/d3-scale-chromatic/src/colors.js
function colors_default(specifier) {
  var n = specifier.length / 6 | 0, colors10 = new Array(n), i = 0;
  while (i < n)
    colors10[i] = "#" + specifier.slice(i * 6, ++i * 6);
  return colors10;
}

// node_modules/d3-scale-chromatic/src/categorical/category10.js
var category10_default = colors_default("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf");

// node_modules/d3-scale-chromatic/src/categorical/Accent.js
var Accent_default = colors_default("7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666");

// node_modules/d3-scale-chromatic/src/categorical/Dark2.js
var Dark2_default = colors_default("1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666");

// node_modules/d3-scale-chromatic/src/categorical/observable10.js
var observable10_default = colors_default("4269d0efb118ff725c6cc5b03ca951ff8ab7a463f297bbf59c6b4e9498a0");

// node_modules/d3-scale-chromatic/src/categorical/Paired.js
var Paired_default = colors_default("a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928");

// node_modules/d3-scale-chromatic/src/categorical/Pastel1.js
var Pastel1_default = colors_default("fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2");

// node_modules/d3-scale-chromatic/src/categorical/Pastel2.js
var Pastel2_default = colors_default("b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc");

// node_modules/d3-scale-chromatic/src/categorical/Set1.js
var Set1_default = colors_default("e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999");

// node_modules/d3-scale-chromatic/src/categorical/Set2.js
var Set2_default = colors_default("66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3");

// node_modules/d3-scale-chromatic/src/categorical/Set3.js
var Set3_default = colors_default("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f");

// node_modules/d3-scale-chromatic/src/categorical/Tableau10.js
var Tableau10_default = colors_default("4e79a7f28e2ce1575976b7b259a14fedc949af7aa1ff9da79c755fbab0ab");

// node_modules/d3-scale-chromatic/src/ramp.js
var ramp_default = (scheme38) => rgbBasis(scheme38[scheme38.length - 1]);

// node_modules/d3-scale-chromatic/src/diverging/BrBG.js
var scheme = new Array(3).concat(
  "d8b365f5f5f55ab4ac",
  "a6611adfc27d80cdc1018571",
  "a6611adfc27df5f5f580cdc1018571",
  "8c510ad8b365f6e8c3c7eae55ab4ac01665e",
  "8c510ad8b365f6e8c3f5f5f5c7eae55ab4ac01665e",
  "8c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e",
  "8c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e",
  "5430058c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e003c30",
  "5430058c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e003c30"
).map(colors_default);
var BrBG_default = ramp_default(scheme);

// node_modules/d3-scale-chromatic/src/diverging/PRGn.js
var scheme2 = new Array(3).concat(
  "af8dc3f7f7f77fbf7b",
  "7b3294c2a5cfa6dba0008837",
  "7b3294c2a5cff7f7f7a6dba0008837",
  "762a83af8dc3e7d4e8d9f0d37fbf7b1b7837",
  "762a83af8dc3e7d4e8f7f7f7d9f0d37fbf7b1b7837",
  "762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b7837",
  "762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b7837",
  "40004b762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b783700441b",
  "40004b762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b783700441b"
).map(colors_default);
var PRGn_default = ramp_default(scheme2);

// node_modules/d3-scale-chromatic/src/diverging/PiYG.js
var scheme3 = new Array(3).concat(
  "e9a3c9f7f7f7a1d76a",
  "d01c8bf1b6dab8e1864dac26",
  "d01c8bf1b6daf7f7f7b8e1864dac26",
  "c51b7de9a3c9fde0efe6f5d0a1d76a4d9221",
  "c51b7de9a3c9fde0eff7f7f7e6f5d0a1d76a4d9221",
  "c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221",
  "c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221",
  "8e0152c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221276419",
  "8e0152c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221276419"
).map(colors_default);
var PiYG_default = ramp_default(scheme3);

// node_modules/d3-scale-chromatic/src/diverging/PuOr.js
var scheme4 = new Array(3).concat(
  "998ec3f7f7f7f1a340",
  "5e3c99b2abd2fdb863e66101",
  "5e3c99b2abd2f7f7f7fdb863e66101",
  "542788998ec3d8daebfee0b6f1a340b35806",
  "542788998ec3d8daebf7f7f7fee0b6f1a340b35806",
  "5427888073acb2abd2d8daebfee0b6fdb863e08214b35806",
  "5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b35806",
  "2d004b5427888073acb2abd2d8daebfee0b6fdb863e08214b358067f3b08",
  "2d004b5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b358067f3b08"
).map(colors_default);
var PuOr_default = ramp_default(scheme4);

// node_modules/d3-scale-chromatic/src/diverging/RdBu.js
var scheme5 = new Array(3).concat(
  "ef8a62f7f7f767a9cf",
  "ca0020f4a58292c5de0571b0",
  "ca0020f4a582f7f7f792c5de0571b0",
  "b2182bef8a62fddbc7d1e5f067a9cf2166ac",
  "b2182bef8a62fddbc7f7f7f7d1e5f067a9cf2166ac",
  "b2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac",
  "b2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac",
  "67001fb2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac053061",
  "67001fb2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac053061"
).map(colors_default);
var RdBu_default = ramp_default(scheme5);

// node_modules/d3-scale-chromatic/src/diverging/RdGy.js
var scheme6 = new Array(3).concat(
  "ef8a62ffffff999999",
  "ca0020f4a582bababa404040",
  "ca0020f4a582ffffffbababa404040",
  "b2182bef8a62fddbc7e0e0e09999994d4d4d",
  "b2182bef8a62fddbc7ffffffe0e0e09999994d4d4d",
  "b2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d",
  "b2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d",
  "67001fb2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d1a1a1a",
  "67001fb2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d1a1a1a"
).map(colors_default);
var RdGy_default = ramp_default(scheme6);

// node_modules/d3-scale-chromatic/src/diverging/RdYlBu.js
var scheme7 = new Array(3).concat(
  "fc8d59ffffbf91bfdb",
  "d7191cfdae61abd9e92c7bb6",
  "d7191cfdae61ffffbfabd9e92c7bb6",
  "d73027fc8d59fee090e0f3f891bfdb4575b4",
  "d73027fc8d59fee090ffffbfe0f3f891bfdb4575b4",
  "d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4",
  "d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4",
  "a50026d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4313695",
  "a50026d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4313695"
).map(colors_default);
var RdYlBu_default = ramp_default(scheme7);

// node_modules/d3-scale-chromatic/src/diverging/RdYlGn.js
var scheme8 = new Array(3).concat(
  "fc8d59ffffbf91cf60",
  "d7191cfdae61a6d96a1a9641",
  "d7191cfdae61ffffbfa6d96a1a9641",
  "d73027fc8d59fee08bd9ef8b91cf601a9850",
  "d73027fc8d59fee08bffffbfd9ef8b91cf601a9850",
  "d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850",
  "d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850",
  "a50026d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850006837",
  "a50026d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850006837"
).map(colors_default);
var RdYlGn_default = ramp_default(scheme8);

// node_modules/d3-scale-chromatic/src/diverging/Spectral.js
var scheme9 = new Array(3).concat(
  "fc8d59ffffbf99d594",
  "d7191cfdae61abdda42b83ba",
  "d7191cfdae61ffffbfabdda42b83ba",
  "d53e4ffc8d59fee08be6f59899d5943288bd",
  "d53e4ffc8d59fee08bffffbfe6f59899d5943288bd",
  "d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd",
  "d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd",
  "9e0142d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd5e4fa2",
  "9e0142d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd5e4fa2"
).map(colors_default);
var Spectral_default = ramp_default(scheme9);

// node_modules/d3-scale-chromatic/src/sequential-multi/BuGn.js
var scheme10 = new Array(3).concat(
  "e5f5f999d8c92ca25f",
  "edf8fbb2e2e266c2a4238b45",
  "edf8fbb2e2e266c2a42ca25f006d2c",
  "edf8fbccece699d8c966c2a42ca25f006d2c",
  "edf8fbccece699d8c966c2a441ae76238b45005824",
  "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45005824",
  "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45006d2c00441b"
).map(colors_default);
var BuGn_default = ramp_default(scheme10);

// node_modules/d3-scale-chromatic/src/sequential-multi/BuPu.js
var scheme11 = new Array(3).concat(
  "e0ecf49ebcda8856a7",
  "edf8fbb3cde38c96c688419d",
  "edf8fbb3cde38c96c68856a7810f7c",
  "edf8fbbfd3e69ebcda8c96c68856a7810f7c",
  "edf8fbbfd3e69ebcda8c96c68c6bb188419d6e016b",
  "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d6e016b",
  "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d810f7c4d004b"
).map(colors_default);
var BuPu_default = ramp_default(scheme11);

// node_modules/d3-scale-chromatic/src/sequential-multi/GnBu.js
var scheme12 = new Array(3).concat(
  "e0f3dba8ddb543a2ca",
  "f0f9e8bae4bc7bccc42b8cbe",
  "f0f9e8bae4bc7bccc443a2ca0868ac",
  "f0f9e8ccebc5a8ddb57bccc443a2ca0868ac",
  "f0f9e8ccebc5a8ddb57bccc44eb3d32b8cbe08589e",
  "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe08589e",
  "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe0868ac084081"
).map(colors_default);
var GnBu_default = ramp_default(scheme12);

// node_modules/d3-scale-chromatic/src/sequential-multi/OrRd.js
var scheme13 = new Array(3).concat(
  "fee8c8fdbb84e34a33",
  "fef0d9fdcc8afc8d59d7301f",
  "fef0d9fdcc8afc8d59e34a33b30000",
  "fef0d9fdd49efdbb84fc8d59e34a33b30000",
  "fef0d9fdd49efdbb84fc8d59ef6548d7301f990000",
  "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301f990000",
  "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301fb300007f0000"
).map(colors_default);
var OrRd_default = ramp_default(scheme13);

// node_modules/d3-scale-chromatic/src/sequential-multi/PuBuGn.js
var scheme14 = new Array(3).concat(
  "ece2f0a6bddb1c9099",
  "f6eff7bdc9e167a9cf02818a",
  "f6eff7bdc9e167a9cf1c9099016c59",
  "f6eff7d0d1e6a6bddb67a9cf1c9099016c59",
  "f6eff7d0d1e6a6bddb67a9cf3690c002818a016450",
  "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016450",
  "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016c59014636"
).map(colors_default);
var PuBuGn_default = ramp_default(scheme14);

// node_modules/d3-scale-chromatic/src/sequential-multi/PuBu.js
var scheme15 = new Array(3).concat(
  "ece7f2a6bddb2b8cbe",
  "f1eef6bdc9e174a9cf0570b0",
  "f1eef6bdc9e174a9cf2b8cbe045a8d",
  "f1eef6d0d1e6a6bddb74a9cf2b8cbe045a8d",
  "f1eef6d0d1e6a6bddb74a9cf3690c00570b0034e7b",
  "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0034e7b",
  "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0045a8d023858"
).map(colors_default);
var PuBu_default = ramp_default(scheme15);

// node_modules/d3-scale-chromatic/src/sequential-multi/PuRd.js
var scheme16 = new Array(3).concat(
  "e7e1efc994c7dd1c77",
  "f1eef6d7b5d8df65b0ce1256",
  "f1eef6d7b5d8df65b0dd1c77980043",
  "f1eef6d4b9dac994c7df65b0dd1c77980043",
  "f1eef6d4b9dac994c7df65b0e7298ace125691003f",
  "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125691003f",
  "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125698004367001f"
).map(colors_default);
var PuRd_default = ramp_default(scheme16);

// node_modules/d3-scale-chromatic/src/sequential-multi/RdPu.js
var scheme17 = new Array(3).concat(
  "fde0ddfa9fb5c51b8a",
  "feebe2fbb4b9f768a1ae017e",
  "feebe2fbb4b9f768a1c51b8a7a0177",
  "feebe2fcc5c0fa9fb5f768a1c51b8a7a0177",
  "feebe2fcc5c0fa9fb5f768a1dd3497ae017e7a0177",
  "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a0177",
  "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a017749006a"
).map(colors_default);
var RdPu_default = ramp_default(scheme17);

// node_modules/d3-scale-chromatic/src/sequential-multi/YlGnBu.js
var scheme18 = new Array(3).concat(
  "edf8b17fcdbb2c7fb8",
  "ffffcca1dab441b6c4225ea8",
  "ffffcca1dab441b6c42c7fb8253494",
  "ffffccc7e9b47fcdbb41b6c42c7fb8253494",
  "ffffccc7e9b47fcdbb41b6c41d91c0225ea80c2c84",
  "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea80c2c84",
  "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea8253494081d58"
).map(colors_default);
var YlGnBu_default = ramp_default(scheme18);

// node_modules/d3-scale-chromatic/src/sequential-multi/YlGn.js
var scheme19 = new Array(3).concat(
  "f7fcb9addd8e31a354",
  "ffffccc2e69978c679238443",
  "ffffccc2e69978c67931a354006837",
  "ffffccd9f0a3addd8e78c67931a354006837",
  "ffffccd9f0a3addd8e78c67941ab5d238443005a32",
  "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443005a32",
  "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443006837004529"
).map(colors_default);
var YlGn_default = ramp_default(scheme19);

// node_modules/d3-scale-chromatic/src/sequential-multi/YlOrBr.js
var scheme20 = new Array(3).concat(
  "fff7bcfec44fd95f0e",
  "ffffd4fed98efe9929cc4c02",
  "ffffd4fed98efe9929d95f0e993404",
  "ffffd4fee391fec44ffe9929d95f0e993404",
  "ffffd4fee391fec44ffe9929ec7014cc4c028c2d04",
  "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c028c2d04",
  "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c02993404662506"
).map(colors_default);
var YlOrBr_default = ramp_default(scheme20);

// node_modules/d3-scale-chromatic/src/sequential-multi/YlOrRd.js
var scheme21 = new Array(3).concat(
  "ffeda0feb24cf03b20",
  "ffffb2fecc5cfd8d3ce31a1c",
  "ffffb2fecc5cfd8d3cf03b20bd0026",
  "ffffb2fed976feb24cfd8d3cf03b20bd0026",
  "ffffb2fed976feb24cfd8d3cfc4e2ae31a1cb10026",
  "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cb10026",
  "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cbd0026800026"
).map(colors_default);
var YlOrRd_default = ramp_default(scheme21);

// node_modules/d3-scale-chromatic/src/sequential-single/Blues.js
var scheme22 = new Array(3).concat(
  "deebf79ecae13182bd",
  "eff3ffbdd7e76baed62171b5",
  "eff3ffbdd7e76baed63182bd08519c",
  "eff3ffc6dbef9ecae16baed63182bd08519c",
  "eff3ffc6dbef9ecae16baed64292c62171b5084594",
  "f7fbffdeebf7c6dbef9ecae16baed64292c62171b5084594",
  "f7fbffdeebf7c6dbef9ecae16baed64292c62171b508519c08306b"
).map(colors_default);
var Blues_default = ramp_default(scheme22);

// node_modules/d3-scale-chromatic/src/sequential-single/Greens.js
var scheme23 = new Array(3).concat(
  "e5f5e0a1d99b31a354",
  "edf8e9bae4b374c476238b45",
  "edf8e9bae4b374c47631a354006d2c",
  "edf8e9c7e9c0a1d99b74c47631a354006d2c",
  "edf8e9c7e9c0a1d99b74c47641ab5d238b45005a32",
  "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45005a32",
  "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45006d2c00441b"
).map(colors_default);
var Greens_default = ramp_default(scheme23);

// node_modules/d3-scale-chromatic/src/sequential-single/Greys.js
var scheme24 = new Array(3).concat(
  "f0f0f0bdbdbd636363",
  "f7f7f7cccccc969696525252",
  "f7f7f7cccccc969696636363252525",
  "f7f7f7d9d9d9bdbdbd969696636363252525",
  "f7f7f7d9d9d9bdbdbd969696737373525252252525",
  "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525",
  "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525000000"
).map(colors_default);
var Greys_default = ramp_default(scheme24);

// node_modules/d3-scale-chromatic/src/sequential-single/Purples.js
var scheme25 = new Array(3).concat(
  "efedf5bcbddc756bb1",
  "f2f0f7cbc9e29e9ac86a51a3",
  "f2f0f7cbc9e29e9ac8756bb154278f",
  "f2f0f7dadaebbcbddc9e9ac8756bb154278f",
  "f2f0f7dadaebbcbddc9e9ac8807dba6a51a34a1486",
  "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a34a1486",
  "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a354278f3f007d"
).map(colors_default);
var Purples_default = ramp_default(scheme25);

// node_modules/d3-scale-chromatic/src/sequential-single/Reds.js
var scheme26 = new Array(3).concat(
  "fee0d2fc9272de2d26",
  "fee5d9fcae91fb6a4acb181d",
  "fee5d9fcae91fb6a4ade2d26a50f15",
  "fee5d9fcbba1fc9272fb6a4ade2d26a50f15",
  "fee5d9fcbba1fc9272fb6a4aef3b2ccb181d99000d",
  "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181d99000d",
  "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181da50f1567000d"
).map(colors_default);
var Reds_default = ramp_default(scheme26);

// node_modules/d3-scale-chromatic/src/sequential-single/Oranges.js
var scheme27 = new Array(3).concat(
  "fee6cefdae6be6550d",
  "feeddefdbe85fd8d3cd94701",
  "feeddefdbe85fd8d3ce6550da63603",
  "feeddefdd0a2fdae6bfd8d3ce6550da63603",
  "feeddefdd0a2fdae6bfd8d3cf16913d948018c2d04",
  "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d948018c2d04",
  "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d94801a636037f2704"
).map(colors_default);
var Oranges_default = ramp_default(scheme27);

// node_modules/d3-scale-chromatic/src/sequential-multi/cubehelix.js
var cubehelix_default2 = cubehelixLong(cubehelix(300, 0.5, 0), cubehelix(-240, 0.5, 1));

// node_modules/d3-scale-chromatic/src/sequential-multi/rainbow.js
var warm = cubehelixLong(cubehelix(-100, 0.75, 0.35), cubehelix(80, 1.5, 0.8));
var cool = cubehelixLong(cubehelix(260, 0.75, 0.35), cubehelix(80, 1.5, 0.8));
var c = cubehelix();

// node_modules/d3-scale-chromatic/src/sequential-multi/sinebow.js
var c2 = rgb();
var pi_1_3 = Math.PI / 3;
var pi_2_3 = Math.PI * 2 / 3;

// node_modules/d3-scale-chromatic/src/sequential-multi/viridis.js
function ramp(range7) {
  var n = range7.length;
  return function(t) {
    return range7[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
  };
}
var viridis_default = ramp(colors_default("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725"));
var magma = ramp(colors_default("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf"));
var inferno = ramp(colors_default("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4"));
var plasma = ramp(colors_default("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));

// node_modules/vega-view-transforms/node_modules/vega-scale/build/vega-scale.js
function bandSpace(count3, paddingInner2, paddingOuter2) {
  const space = count3 - paddingInner2 + paddingOuter2 * 2;
  return count3 ? space > 0 ? space : 1 : 0;
}
var Identity = "identity";
var Linear2 = "linear";
var Log = "log";
var Pow = "pow";
var Sqrt = "sqrt";
var Symlog = "symlog";
var Time = "time";
var UTC = "utc";
var Sequential = "sequential";
var Diverging = "diverging";
var Quantile2 = "quantile";
var Quantize = "quantize";
var Threshold = "threshold";
var Ordinal = "ordinal";
var Point = "point";
var Band = "band";
var BinOrdinal = "bin-ordinal";
var Continuous = "continuous";
var Discrete = "discrete";
var Discretizing = "discretizing";
var Interpolating = "interpolating";
var Temporal = "temporal";
function invertRange(scale19) {
  return function(_) {
    let lo = _[0], hi = _[1], t;
    if (hi < lo) {
      t = lo;
      lo = hi;
      hi = t;
    }
    return [scale19.invert(lo), scale19.invert(hi)];
  };
}
function invertRangeExtent(scale19) {
  return function(_) {
    const range7 = scale19.range();
    let lo = _[0], hi = _[1], min5 = -1, max5, t, i, n;
    if (hi < lo) {
      t = lo;
      lo = hi;
      hi = t;
    }
    for (i = 0, n = range7.length; i < n; ++i) {
      if (range7[i] >= lo && range7[i] <= hi) {
        if (min5 < 0)
          min5 = i;
        max5 = i;
      }
    }
    if (min5 < 0)
      return void 0;
    lo = scale19.invertExtent(range7[min5]);
    hi = scale19.invertExtent(range7[max5]);
    return [lo[0] === void 0 ? lo[1] : lo[0], hi[1] === void 0 ? hi[0] : hi[1]];
  };
}
function band2() {
  const scale19 = ordinal().unknown(void 0), domain3 = scale19.domain, ordinalRange = scale19.range;
  let range$1 = [0, 1], step, bandwidth2, round2 = false, paddingInner2 = 0, paddingOuter2 = 0, align2 = 0.5;
  delete scale19.unknown;
  function rescale() {
    const n = domain3().length, reverse4 = range$1[1] < range$1[0], stop2 = range$1[1 - reverse4], space = bandSpace(n, paddingInner2, paddingOuter2);
    let start = range$1[reverse4 - 0];
    step = (stop2 - start) / (space || 1);
    if (round2) {
      step = Math.floor(step);
    }
    start += (stop2 - start - step * (n - paddingInner2)) * align2;
    bandwidth2 = step * (1 - paddingInner2);
    if (round2) {
      start = Math.round(start);
      bandwidth2 = Math.round(bandwidth2);
    }
    const values7 = range(n).map((i) => start + step * i);
    return ordinalRange(reverse4 ? values7.reverse() : values7);
  }
  scale19.domain = function(_) {
    if (arguments.length) {
      domain3(_);
      return rescale();
    } else {
      return domain3();
    }
  };
  scale19.range = function(_) {
    if (arguments.length) {
      range$1 = [+_[0], +_[1]];
      return rescale();
    } else {
      return range$1.slice();
    }
  };
  scale19.rangeRound = function(_) {
    range$1 = [+_[0], +_[1]];
    round2 = true;
    return rescale();
  };
  scale19.bandwidth = function() {
    return bandwidth2;
  };
  scale19.step = function() {
    return step;
  };
  scale19.round = function(_) {
    if (arguments.length) {
      round2 = !!_;
      return rescale();
    } else {
      return round2;
    }
  };
  scale19.padding = function(_) {
    if (arguments.length) {
      paddingOuter2 = Math.max(0, Math.min(1, _));
      paddingInner2 = paddingOuter2;
      return rescale();
    } else {
      return paddingInner2;
    }
  };
  scale19.paddingInner = function(_) {
    if (arguments.length) {
      paddingInner2 = Math.max(0, Math.min(1, _));
      return rescale();
    } else {
      return paddingInner2;
    }
  };
  scale19.paddingOuter = function(_) {
    if (arguments.length) {
      paddingOuter2 = Math.max(0, Math.min(1, _));
      return rescale();
    } else {
      return paddingOuter2;
    }
  };
  scale19.align = function(_) {
    if (arguments.length) {
      align2 = Math.max(0, Math.min(1, _));
      return rescale();
    } else {
      return align2;
    }
  };
  scale19.invertRange = function(_) {
    if (_[0] == null || _[1] == null)
      return;
    const reverse4 = range$1[1] < range$1[0], values7 = reverse4 ? ordinalRange().reverse() : ordinalRange(), n = values7.length - 1;
    let lo = +_[0], hi = +_[1], a4, b6, t;
    if (lo !== lo || hi !== hi)
      return;
    if (hi < lo) {
      t = lo;
      lo = hi;
      hi = t;
    }
    if (hi < values7[0] || lo > range$1[1 - reverse4])
      return;
    a4 = Math.max(0, bisectRight(values7, lo) - 1);
    b6 = lo === hi ? a4 : bisectRight(values7, hi) - 1;
    if (lo - values7[a4] > bandwidth2 + 1e-10)
      ++a4;
    if (reverse4) {
      t = a4;
      a4 = n - b6;
      b6 = n - t;
    }
    return a4 > b6 ? void 0 : domain3().slice(a4, b6 + 1);
  };
  scale19.invert = function(_) {
    const value7 = scale19.invertRange([_, _]);
    return value7 ? value7[0] : value7;
  };
  scale19.copy = function() {
    return band2().domain(domain3()).range(range$1).round(round2).paddingInner(paddingInner2).paddingOuter(paddingOuter2).align(align2);
  };
  return rescale();
}
function pointish(scale19) {
  const copy4 = scale19.copy;
  scale19.padding = scale19.paddingOuter;
  delete scale19.paddingInner;
  scale19.copy = function() {
    return pointish(copy4());
  };
  return scale19;
}
function point6() {
  return pointish(band2().paddingInner(1));
}
var map4 = Array.prototype.map;
function numbers3(_) {
  return map4.call(_, toNumber4);
}
var slice3 = Array.prototype.slice;
function scaleBinOrdinal() {
  let domain3 = [], range7 = [];
  function scale19(x9) {
    return x9 == null || x9 !== x9 ? void 0 : range7[(bisect_default2(domain3, x9) - 1) % range7.length];
  }
  scale19.domain = function(_) {
    if (arguments.length) {
      domain3 = numbers3(_);
      return scale19;
    } else {
      return domain3.slice();
    }
  };
  scale19.range = function(_) {
    if (arguments.length) {
      range7 = slice3.call(_);
      return scale19;
    } else {
      return range7.slice();
    }
  };
  scale19.tickFormat = function(count3, specifier) {
    return tickFormat(domain3[0], peek4(domain3), count3 == null ? 10 : count3, specifier);
  };
  scale19.copy = function() {
    return scaleBinOrdinal().domain(scale19.domain()).range(scale19.range());
  };
  return scale19;
}
var scales = /* @__PURE__ */ new Map();
var VEGA_SCALE = Symbol("vega_scale");
function registerScale(scale19) {
  scale19[VEGA_SCALE] = true;
  return scale19;
}
function create(type7, constructor, metadata6) {
  const ctr = function scale19() {
    const s2 = constructor();
    if (!s2.invertRange) {
      s2.invertRange = s2.invert ? invertRange(s2) : s2.invertExtent ? invertRangeExtent(s2) : void 0;
    }
    s2.type = type7;
    return registerScale(s2);
  };
  ctr.metadata = toSet4(array5(metadata6));
  return ctr;
}
function scale(type7, scale19, metadata6) {
  if (arguments.length > 1) {
    scales.set(type7, create(type7, scale19, metadata6));
    return this;
  } else {
    return isValidScaleType(type7) ? scales.get(type7) : void 0;
  }
}
scale(Identity, identity8);
scale(Linear2, linear3, Continuous);
scale(Log, log3, [Continuous, Log]);
scale(Pow, pow3, Continuous);
scale(Sqrt, sqrt2, Continuous);
scale(Symlog, symlog2, Continuous);
scale(Time, time, [Continuous, Temporal]);
scale(UTC, utcTime, [Continuous, Temporal]);
scale(Sequential, sequential, [Continuous, Interpolating]);
scale(`${Sequential}-${Linear2}`, sequential, [Continuous, Interpolating]);
scale(`${Sequential}-${Log}`, sequentialLog, [Continuous, Interpolating, Log]);
scale(`${Sequential}-${Pow}`, sequentialPow, [Continuous, Interpolating]);
scale(`${Sequential}-${Sqrt}`, sequentialSqrt, [Continuous, Interpolating]);
scale(`${Sequential}-${Symlog}`, sequentialSymlog, [Continuous, Interpolating]);
scale(`${Diverging}-${Linear2}`, diverging, [Continuous, Interpolating]);
scale(`${Diverging}-${Log}`, divergingLog, [Continuous, Interpolating, Log]);
scale(`${Diverging}-${Pow}`, divergingPow, [Continuous, Interpolating]);
scale(`${Diverging}-${Sqrt}`, divergingSqrt, [Continuous, Interpolating]);
scale(`${Diverging}-${Symlog}`, divergingSymlog, [Continuous, Interpolating]);
scale(Quantile2, quantile2, [Discretizing, Quantile2]);
scale(Quantize, quantize, Discretizing);
scale(Threshold, threshold, Discretizing);
scale(BinOrdinal, scaleBinOrdinal, [Discrete, Discretizing]);
scale(Ordinal, ordinal, Discrete);
scale(Band, band2, Discrete);
scale(Point, point6, Discrete);
function isValidScaleType(type7) {
  return scales.has(type7);
}
function hasType(key4, type7) {
  const s2 = scales.get(key4);
  return s2 && s2.metadata[type7];
}
function isDiscrete(key4) {
  return hasType(key4, Discrete);
}
function isDiscretizing(key4) {
  return hasType(key4, Discretizing);
}
function isLogarithmic(key4) {
  return hasType(key4, Log);
}
function isTemporal(key4) {
  return hasType(key4, Temporal);
}
function interpolateColors(colors10, type7, gamma2) {
  return piecewise(interpolate(type7 || "rgb", gamma2), colors10);
}
function interpolate(type7, gamma2) {
  const interp = src_exports[method(type7)];
  return gamma2 != null && interp && interp.gamma ? interp.gamma(gamma2) : interp;
}
function method(type7) {
  return "interpolate" + type7.toLowerCase().split("-").map((s2) => s2[0].toUpperCase() + s2.slice(1)).join("");
}
var continuous2 = {
  blues: "cfe1f2bed8eca8cee58fc1de74b2d75ba3cf4592c63181bd206fb2125ca40a4a90",
  greens: "d3eecdc0e6baabdda594d3917bc77d60ba6c46ab5e329a512089430e7735036429",
  greys: "e2e2e2d4d4d4c4c4c4b1b1b19d9d9d8888887575756262624d4d4d3535351e1e1e",
  oranges: "fdd8b3fdc998fdb87bfda55efc9244f87f2cf06b18e4580bd14904b93d029f3303",
  purples: "e2e1efd4d4e8c4c5e0b4b3d6a3a0cc928ec3827cb97566ae684ea25c3696501f8c",
  reds: "fdc9b4fcb49afc9e80fc8767fa7051f6573fec3f2fdc2a25c81b1db21218970b13",
  blueGreen: "d5efedc1e8e0a7ddd18bd2be70c6a958ba9144ad77319c5d2089460e7736036429",
  bluePurple: "ccddecbad0e4a8c2dd9ab0d4919cc98d85be8b6db28a55a6873c99822287730f71",
  greenBlue: "d3eecec5e8c3b1e1bb9bd8bb82cec269c2ca51b2cd3c9fc7288abd1675b10b60a1",
  orangeRed: "fddcaffdcf9bfdc18afdad77fb9562f67d53ee6545e24932d32d1ebf130da70403",
  purpleBlue: "dbdaebc8cee4b1c3de97b7d87bacd15b9fc93a90c01e7fb70b70ab056199045281",
  purpleBlueGreen: "dbd8eac8cee4b0c3de93b7d872acd1549fc83892bb1c88a3097f8702736b016353",
  purpleRed: "dcc9e2d3b3d7ce9eccd186c0da6bb2e14da0e23189d91e6fc61159ab07498f023a",
  redPurple: "fccfccfcbec0faa9b8f98faff571a5ec539ddb3695c41b8aa908808d0179700174",
  yellowGreen: "e4f4acd1eca0b9e2949ed68880c97c62bb6e47aa5e3297502083440e723b036034",
  yellowOrangeBrown: "feeaa1fedd84fecc63feb746fca031f68921eb7215db5e0bc54c05ab3d038f3204",
  yellowOrangeRed: "fee087fed16ffebd59fea849fd903efc7335f9522bee3423de1b20ca0b22af0225",
  blueOrange: "134b852f78b35da2cb9dcae1d2e5eff2f0ebfce0bafbbf74e8932fc5690d994a07",
  brownBlueGreen: "704108a0651ac79548e3c78af3e6c6eef1eac9e9e48ed1c74da79e187a72025147",
  purpleGreen: "5b1667834792a67fb6c9aed3e6d6e8eff0efd9efd5aedda971bb75368e490e5e29",
  purpleOrange: "4114696647968f83b7b9b4d6dadbebf3eeeafce0bafbbf74e8932fc5690d994a07",
  redBlue: "8c0d25bf363adf745ef4ae91fbdbc9f2efeed2e5ef9dcae15da2cb2f78b3134b85",
  redGrey: "8c0d25bf363adf745ef4ae91fcdccbfaf4f1e2e2e2c0c0c0969696646464343434",
  yellowGreenBlue: "eff9bddbf1b4bde5b594d5b969c5be45b4c22c9ec02182b82163aa23479c1c3185",
  redYellowBlue: "a50026d4322cf16e43fcac64fedd90faf8c1dcf1ecabd6e875abd04a74b4313695",
  redYellowGreen: "a50026d4322cf16e43fcac63fedd8df9f7aed7ee8ea4d86e64bc6122964f006837",
  pinkYellowGreen: "8e0152c0267edd72adf0b3d6faddedf5f3efe1f2cab6de8780bb474f9125276419",
  spectral: "9e0142d13c4bf0704afcac63fedd8dfbf8b0e0f3a1a9dda269bda94288b55e4fa2",
  viridis: "440154470e61481a6c482575472f7d443a834144873d4e8a39568c35608d31688e2d708e2a788e27818e23888e21918d1f988b1fa08822a8842ab07f35b77943bf7154c56866cc5d7ad1518fd744a5db36bcdf27d2e21be9e51afde725",
  magma: "0000040404130b0924150e3720114b2c11603b0f704a107957157e651a80721f817f24828c29819a2e80a8327db6377ac43c75d1426fde4968e95462f1605df76f5cfa7f5efc8f65fe9f6dfeaf78febf84fece91fddea0fcedaffcfdbf",
  inferno: "0000040403130c0826170c3b240c4f330a5f420a68500d6c5d126e6b176e781c6d86216b932667a12b62ae305cbb3755c73e4cd24644dd513ae65c30ed6925f3771af8850ffb9506fca50afcb519fac62df6d645f2e661f3f484fcffa4",
  plasma: "0d088723069033059742039d5002a25d01a66a00a87801a88405a7900da49c179ea72198b12a90ba3488c33d80cb4779d35171da5a69e16462e76e5bed7953f2834cf68f44fa9a3dfca636fdb32ffec029fcce25f9dc24f5ea27f0f921",
  cividis: "00205100235800265d002961012b65042e670831690d346b11366c16396d1c3c6e213f6e26426e2c456e31476e374a6e3c4d6e42506e47536d4c566d51586e555b6e5a5e6e5e616e62646f66676f6a6a706e6d717270717573727976737c79747f7c75827f758682768985778c8877908b78938e789691789a94789e9778a19b78a59e77a9a177aea575b2a874b6ab73bbaf71c0b26fc5b66dc9b96acebd68d3c065d8c462ddc85fe2cb5ce7cf58ebd355f0d652f3da4ff7de4cfae249fce647",
  rainbow: "6e40aa883eb1a43db3bf3cafd83fa4ee4395fe4b83ff576eff6659ff7847ff8c38f3a130e2b72fcfcc36bee044aff05b8ff4576ff65b52f6673af27828ea8d1ddfa319d0b81cbecb23abd82f96e03d82e14c6edb5a5dd0664dbf6e40aa",
  sinebow: "ff4040fc582af47218e78d0bd5a703bfbf00a7d5038de70b72f41858fc2a40ff402afc5818f4720be78d03d5a700bfbf03a7d50b8de71872f42a58fc4040ff582afc7218f48d0be7a703d5bf00bfd503a7e70b8df41872fc2a58ff4040",
  turbo: "23171b32204a3e2a71453493493eae4b49c54a53d7485ee44569ee4074f53c7ff8378af93295f72e9ff42ba9ef28b3e926bce125c5d925cdcf27d5c629dcbc2de3b232e9a738ee9d3ff39347f68950f9805afc7765fd6e70fe667cfd5e88fc5795fb51a1f84badf545b9f140c5ec3cd0e637dae034e4d931ecd12ef4c92bfac029ffb626ffad24ffa223ff9821ff8d1fff821dff771cfd6c1af76118f05616e84b14df4111d5380fcb2f0dc0260ab61f07ac1805a313029b0f00950c00910b00",
  browns: "eedbbdecca96e9b97ae4a865dc9856d18954c7784cc0673fb85536ad44339f3632",
  tealBlues: "bce4d89dd3d181c3cb65b3c245a2b9368fae347da0306a932c5985",
  teals: "bbdfdfa2d4d58ac9c975bcbb61b0af4da5a43799982b8b8c1e7f7f127273006667",
  warmGreys: "dcd4d0cec5c1c0b8b4b3aaa7a59c9998908c8b827f7e7673726866665c5a59504e",
  goldGreen: "f4d166d5ca60b6c35c98bb597cb25760a6564b9c533f8f4f33834a257740146c36",
  goldOrange: "f4d166f8be5cf8aa4cf5983bf3852aef701be2621fd65322c54923b142239e3a26",
  goldRed: "f4d166f6be59f9aa51fc964ef6834bee734ae56249db5247cf4244c43141b71d3e",
  lightGreyRed: "efe9e6e1dad7d5cbc8c8bdb9bbaea9cd967ddc7b43e15f19df4011dc000b",
  lightGreyTeal: "e4eaead6dcddc8ced2b7c2c7a6b4bc64b0bf22a6c32295c11f85be1876bc",
  lightMulti: "e0f1f2c4e9d0b0de9fd0e181f6e072f6c053f3993ef77440ef4a3c",
  lightOrange: "f2e7daf7d5baf9c499fab184fa9c73f68967ef7860e8645bde515bd43d5b",
  lightTealBlue: "e3e9e0c0dccf9aceca7abfc859afc0389fb9328dad2f7ca0276b95255988",
  darkBlue: "3232322d46681a5c930074af008cbf05a7ce25c0dd38daed50f3faffffff",
  darkGold: "3c3c3c584b37725e348c7631ae8b2bcfa424ecc31ef9de30fff184ffffff",
  darkGreen: "3a3a3a215748006f4d048942489e4276b340a6c63dd2d836ffeb2cffffaa",
  darkMulti: "3737371f5287197d8c29a86995ce3fffe800ffffff",
  darkRed: "3434347036339e3c38cc4037e75d1eec8620eeab29f0ce32ffeb2c"
};
var discrete = {
  accent: Accent_default,
  category10: category10_default,
  category20: "1f77b4aec7e8ff7f0effbb782ca02c98df8ad62728ff98969467bdc5b0d58c564bc49c94e377c2f7b6d27f7f7fc7c7c7bcbd22dbdb8d17becf9edae5",
  category20b: "393b795254a36b6ecf9c9ede6379398ca252b5cf6bcedb9c8c6d31bd9e39e7ba52e7cb94843c39ad494ad6616be7969c7b4173a55194ce6dbdde9ed6",
  category20c: "3182bd6baed69ecae1c6dbefe6550dfd8d3cfdae6bfdd0a231a35474c476a1d99bc7e9c0756bb19e9ac8bcbddcdadaeb636363969696bdbdbdd9d9d9",
  dark2: Dark2_default,
  observable10: observable10_default,
  paired: Paired_default,
  pastel1: Pastel1_default,
  pastel2: Pastel2_default,
  set1: Set1_default,
  set2: Set2_default,
  set3: Set3_default,
  tableau10: "4c78a8f58518e4575672b7b254a24beeca3bb279a2ff9da69d755dbab0ac",
  tableau20: "4c78a89ecae9f58518ffbf7954a24b88d27ab79a20f2cf5b43989483bcb6e45756ff9d9879706ebab0acd67195fcbfd2b279a2d6a5c99e765fd8b5a5"
};
function colors(palette) {
  if (isArray4(palette))
    return palette;
  const n = palette.length / 6 | 0, c5 = new Array(n);
  for (let i = 0; i < n; ) {
    c5[i] = "#" + palette.slice(i * 6, ++i * 6);
  }
  return c5;
}
function apply(_, f) {
  for (const k3 in _)
    scheme28(k3, f(_[k3]));
}
var schemes = {};
apply(discrete, colors);
apply(continuous2, (_) => interpolateColors(colors(_)));
function scheme28(name, scheme38) {
  name = name && name.toLowerCase();
  if (arguments.length > 1) {
    schemes[name] = scheme38;
    return this;
  } else {
    return schemes[name];
  }
}
var SymbolLegend = "symbol";
var DiscreteLegend = "discrete";
var defaultFormatter = (value7) => isArray4(value7) ? value7.map((v2) => String(v2)) : String(value7);
var ascending4 = (a4, b6) => a4[1] - b6[1];
var descending2 = (a4, b6) => b6[1] - a4[1];
function validTicks(scale19, ticks2, count3) {
  let range7 = scale19.range(), lo = range7[0], hi = peek4(range7), cmp = ascending4;
  if (lo > hi) {
    range7 = hi;
    hi = lo;
    lo = range7;
    cmp = descending2;
  }
  lo = Math.floor(lo);
  hi = Math.ceil(hi);
  ticks2 = ticks2.map((v2) => [v2, scale19(v2)]).filter((_) => lo <= _[1] && _[1] <= hi).sort(cmp).map((_) => _[0]);
  if (count3 > 0 && ticks2.length > 1) {
    const endpoints = [ticks2[0], peek4(ticks2)];
    while (ticks2.length > count3 && ticks2.length >= 3) {
      ticks2 = ticks2.filter((_, i) => !(i % 2));
    }
    if (ticks2.length < 3) {
      ticks2 = endpoints;
    }
  }
  return ticks2;
}
function tickValues(scale19, count3) {
  return scale19.bins ? validTicks(scale19, scale19.bins, count3) : scale19.ticks ? scale19.ticks(count3) : scale19.domain();
}
function tickFormat2(locale5, scale19, count3, specifier, formatType, noSkip) {
  const type7 = scale19.type;
  let format14 = defaultFormatter;
  if (type7 === Time || formatType === Time) {
    format14 = locale5.timeFormat(specifier);
  } else if (type7 === UTC || formatType === UTC) {
    format14 = locale5.utcFormat(specifier);
  } else if (isLogarithmic(type7)) {
    const varfmt = locale5.formatFloat(specifier);
    if (noSkip || scale19.bins) {
      format14 = varfmt;
    } else {
      const test2 = tickLog(scale19, count3, false);
      format14 = (_) => test2(_) ? varfmt(_) : "";
    }
  } else if (scale19.tickFormat) {
    const d = scale19.domain();
    format14 = locale5.formatSpan(d[0], d[d.length - 1], count3, specifier);
  } else if (specifier) {
    format14 = locale5.format(specifier);
  }
  return format14;
}
function tickLog(scale19, count3, values7) {
  const ticks2 = tickValues(scale19, count3), base = scale19.base(), logb = Math.log(base), k3 = Math.max(1, base * count3 / ticks2.length);
  const test2 = (d) => {
    let i = d / Math.pow(base, Math.round(Math.log(d) / logb));
    if (i * base < base - 0.5)
      i *= base;
    return i <= k3;
  };
  return values7 ? ticks2.filter(test2) : test2;
}
var symbols = {
  [Quantile2]: "quantiles",
  [Quantize]: "thresholds",
  [Threshold]: "domain"
};
var formats2 = {
  [Quantile2]: "quantiles",
  [Quantize]: "domain"
};
function labelValues(scale19, count3) {
  return scale19.bins ? binValues(scale19.bins) : scale19.type === Log ? tickLog(scale19, count3, true) : symbols[scale19.type] ? thresholdValues(scale19[symbols[scale19.type]]()) : tickValues(scale19, count3);
}
function thresholdFormat(locale5, scale19, specifier) {
  const _ = scale19[formats2[scale19.type]](), n = _.length;
  let d = n > 1 ? _[1] - _[0] : _[0], i;
  for (i = 1; i < n; ++i) {
    d = Math.min(d, _[i] - _[i - 1]);
  }
  return locale5.formatSpan(0, d, 3 * 10, specifier);
}
function thresholdValues(thresholds) {
  const values7 = [-Infinity].concat(thresholds);
  values7.max = Infinity;
  return values7;
}
function binValues(bins2) {
  const values7 = bins2.slice(0, -1);
  values7.max = peek4(bins2);
  return values7;
}
var isDiscreteRange = (scale19) => symbols[scale19.type] || scale19.bins;
function labelFormat(locale5, scale19, count3, type7, specifier, formatType, noSkip) {
  const format14 = formats2[scale19.type] && formatType !== Time && formatType !== UTC ? thresholdFormat(locale5, scale19, specifier) : tickFormat2(locale5, scale19, count3, specifier, formatType, noSkip);
  return type7 === SymbolLegend && isDiscreteRange(scale19) ? formatRange(format14) : type7 === DiscreteLegend ? formatDiscrete(format14) : formatPoint(format14);
}
var formatRange = (format14) => (value7, index4, array22) => {
  const limit = get2(array22[index4 + 1], get2(array22.max, Infinity)), lo = formatValue(value7, format14), hi = formatValue(limit, format14);
  return lo && hi ? lo + " – " + hi : hi ? "< " + hi : "≥ " + lo;
};
var get2 = (value7, dflt) => value7 != null ? value7 : dflt;
var formatDiscrete = (format14) => (value7, index4) => index4 ? format14(value7) : null;
var formatPoint = (format14) => (value7) => format14(value7);
var formatValue = (value7, format14) => Number.isFinite(value7) ? format14(value7) : null;
function format4(locale5, scale19, specifier, formatType) {
  const type7 = formatType || scale19.type;
  if (isString3(specifier) && isTemporal(type7)) {
    specifier = specifier.replace(/%a/g, "%A").replace(/%b/g, "%B");
  }
  return !specifier && type7 === Time ? locale5.timeFormat("%A, %d %B %Y, %X") : !specifier && type7 === UTC ? locale5.utcFormat("%A, %d %B %Y, %X UTC") : labelFormat(locale5, scale19, 5, null, specifier, formatType, true);
}
function domainCaption(locale5, scale19, opt) {
  opt = opt || {};
  const max5 = Math.max(3, opt.maxlen || 7), fmt = format4(locale5, scale19, opt.format, opt.formatType);
  if (isDiscretizing(scale19.type)) {
    const v2 = labelValues(scale19).slice(1).map(fmt), n = v2.length;
    return `${n} boundar${n === 1 ? "y" : "ies"}: ${v2.join(", ")}`;
  } else if (isDiscrete(scale19.type)) {
    const d = scale19.domain(), n = d.length, v2 = n > max5 ? d.slice(0, max5 - 2).map(fmt).join(", ") + ", ending with " + d.slice(-1).map(fmt) : d.map(fmt).join(", ");
    return `${n} value${n === 1 ? "" : "s"}: ${v2}`;
  } else {
    const d = scale19.domain();
    return `values from ${fmt(d[0])} to ${fmt(peek4(d))}`;
  }
}

// node_modules/vega-view-transforms/node_modules/vega-scenegraph/build/vega-scenegraph.js
var gradient_id = 0;
var patternPrefix = "p_";
function isGradient(value7) {
  return value7 && value7.gradient;
}
function gradientRef(g, defs, base) {
  const type7 = g.gradient;
  let id24 = g.id, prefix = type7 === "radial" ? patternPrefix : "";
  if (!id24) {
    id24 = g.id = "gradient_" + gradient_id++;
    if (type7 === "radial") {
      g.x1 = get3(g.x1, 0.5);
      g.y1 = get3(g.y1, 0.5);
      g.r1 = get3(g.r1, 0);
      g.x2 = get3(g.x2, 0.5);
      g.y2 = get3(g.y2, 0.5);
      g.r2 = get3(g.r2, 0.5);
      prefix = patternPrefix;
    } else {
      g.x1 = get3(g.x1, 0);
      g.y1 = get3(g.y1, 0);
      g.x2 = get3(g.x2, 1);
      g.y2 = get3(g.y2, 0);
    }
  }
  defs[id24] = g;
  return "url(" + (base || "") + "#" + prefix + id24 + ")";
}
function get3(val, def6) {
  return val != null ? val : def6;
}
var lookup = {
  "basis": {
    curve: basis_default
  },
  "basis-closed": {
    curve: basisClosed_default
  },
  "basis-open": {
    curve: basisOpen_default
  },
  "bundle": {
    curve: bundle_default,
    tension: "beta",
    value: 0.85
  },
  "cardinal": {
    curve: cardinal_default,
    tension: "tension",
    value: 0
  },
  "cardinal-open": {
    curve: cardinalOpen_default,
    tension: "tension",
    value: 0
  },
  "cardinal-closed": {
    curve: cardinalClosed_default,
    tension: "tension",
    value: 0
  },
  "catmull-rom": {
    curve: catmullRom_default,
    tension: "alpha",
    value: 0.5
  },
  "catmull-rom-closed": {
    curve: catmullRomClosed_default,
    tension: "alpha",
    value: 0.5
  },
  "catmull-rom-open": {
    curve: catmullRomOpen_default,
    tension: "alpha",
    value: 0.5
  },
  "linear": {
    curve: linear_default
  },
  "linear-closed": {
    curve: linearClosed_default
  },
  "monotone": {
    horizontal: monotoneY,
    vertical: monotoneX
  },
  "natural": {
    curve: natural_default
  },
  "step": {
    curve: step_default
  },
  "step-after": {
    curve: stepAfter
  },
  "step-before": {
    curve: stepBefore
  }
};
function curves(type7, orientation, tension) {
  var entry2 = has4(lookup, type7) && lookup[type7], curve2 = null;
  if (entry2) {
    curve2 = entry2.curve || entry2[orientation || "vertical"];
    if (entry2.tension && tension != null) {
      curve2 = curve2[entry2.tension](tension);
    }
  }
  return curve2;
}
var paramCounts = {
  m: 2,
  l: 2,
  h: 1,
  v: 1,
  z: 0,
  c: 6,
  s: 4,
  q: 4,
  t: 2,
  a: 7
};
var commandPattern = /[mlhvzcsqta]([^mlhvzcsqta]+|$)/gi;
var numberPattern = /^[+-]?(([0-9]*\.[0-9]+)|([0-9]+\.)|([0-9]+))([eE][+-]?[0-9]+)?/;
var spacePattern = /^((\s+,?\s*)|(,\s*))/;
var flagPattern = /^[01]/;
function parse4(path7) {
  const commands = [];
  const matches = path7.match(commandPattern) || [];
  matches.forEach((str) => {
    let cmd = str[0];
    const type7 = cmd.toLowerCase();
    const paramCount = paramCounts[type7];
    const params2 = parseParams(type7, paramCount, str.slice(1).trim());
    const count3 = params2.length;
    if (count3 < paramCount || count3 && count3 % paramCount !== 0) {
      throw Error("Invalid SVG path, incorrect parameter count");
    }
    commands.push([cmd, ...params2.slice(0, paramCount)]);
    if (count3 === paramCount) {
      return;
    }
    if (type7 === "m") {
      cmd = cmd === "M" ? "L" : "l";
    }
    for (let i = paramCount; i < count3; i += paramCount) {
      commands.push([cmd, ...params2.slice(i, i + paramCount)]);
    }
  });
  return commands;
}
function parseParams(type7, paramCount, segment) {
  const params2 = [];
  for (let index4 = 0; paramCount && index4 < segment.length; ) {
    for (let i = 0; i < paramCount; ++i) {
      const pattern = type7 === "a" && (i === 3 || i === 4) ? flagPattern : numberPattern;
      const match2 = segment.slice(index4).match(pattern);
      if (match2 === null) {
        throw Error("Invalid SVG path, incorrect parameter type");
      }
      index4 += match2[0].length;
      params2.push(+match2[0]);
      const ws = segment.slice(index4).match(spacePattern);
      if (ws !== null) {
        index4 += ws[0].length;
      }
    }
  }
  return params2;
}
var DegToRad = Math.PI / 180;
var Epsilon = 1e-14;
var HalfPi = Math.PI / 2;
var Tau = Math.PI * 2;
var HalfSqrt3 = Math.sqrt(3) / 2;
var segmentCache = {};
var bezierCache = {};
var join = [].join;
function segments(x9, y9, rx, ry, large, sweep, rotateX, ox, oy) {
  const key4 = join.call(arguments);
  if (segmentCache[key4]) {
    return segmentCache[key4];
  }
  const th = rotateX * DegToRad;
  const sin_th = Math.sin(th);
  const cos_th = Math.cos(th);
  rx = Math.abs(rx);
  ry = Math.abs(ry);
  const px6 = cos_th * (ox - x9) * 0.5 + sin_th * (oy - y9) * 0.5;
  const py6 = cos_th * (oy - y9) * 0.5 - sin_th * (ox - x9) * 0.5;
  let pl = px6 * px6 / (rx * rx) + py6 * py6 / (ry * ry);
  if (pl > 1) {
    pl = Math.sqrt(pl);
    rx *= pl;
    ry *= pl;
  }
  const a00 = cos_th / rx;
  const a01 = sin_th / rx;
  const a10 = -sin_th / ry;
  const a11 = cos_th / ry;
  const x07 = a00 * ox + a01 * oy;
  const y07 = a10 * ox + a11 * oy;
  const x13 = a00 * x9 + a01 * y9;
  const y13 = a10 * x9 + a11 * y9;
  const d = (x13 - x07) * (x13 - x07) + (y13 - y07) * (y13 - y07);
  let sfactor_sq = 1 / d - 0.25;
  if (sfactor_sq < 0)
    sfactor_sq = 0;
  let sfactor = Math.sqrt(sfactor_sq);
  if (sweep == large)
    sfactor = -sfactor;
  const xc = 0.5 * (x07 + x13) - sfactor * (y13 - y07);
  const yc = 0.5 * (y07 + y13) + sfactor * (x13 - x07);
  const th0 = Math.atan2(y07 - yc, x07 - xc);
  const th1 = Math.atan2(y13 - yc, x13 - xc);
  let th_arc = th1 - th0;
  if (th_arc < 0 && sweep === 1) {
    th_arc += Tau;
  } else if (th_arc > 0 && sweep === 0) {
    th_arc -= Tau;
  }
  const segs = Math.ceil(Math.abs(th_arc / (HalfPi + 1e-3)));
  const result = [];
  for (let i = 0; i < segs; ++i) {
    const th2 = th0 + i * th_arc / segs;
    const th3 = th0 + (i + 1) * th_arc / segs;
    result[i] = [xc, yc, th2, th3, rx, ry, sin_th, cos_th];
  }
  return segmentCache[key4] = result;
}
function bezier(params2) {
  const key4 = join.call(params2);
  if (bezierCache[key4]) {
    return bezierCache[key4];
  }
  var cx = params2[0], cy = params2[1], th0 = params2[2], th1 = params2[3], rx = params2[4], ry = params2[5], sin_th = params2[6], cos_th = params2[7];
  const a00 = cos_th * rx;
  const a01 = -sin_th * ry;
  const a10 = sin_th * rx;
  const a11 = cos_th * ry;
  const cos_th0 = Math.cos(th0);
  const sin_th0 = Math.sin(th0);
  const cos_th1 = Math.cos(th1);
  const sin_th1 = Math.sin(th1);
  const th_half = 0.5 * (th1 - th0);
  const sin_th_h2 = Math.sin(th_half * 0.5);
  const t = 8 / 3 * sin_th_h2 * sin_th_h2 / Math.sin(th_half);
  const x13 = cx + cos_th0 - t * sin_th0;
  const y13 = cy + sin_th0 + t * cos_th0;
  const x32 = cx + cos_th1;
  const y32 = cy + sin_th1;
  const x22 = x32 + t * sin_th1;
  const y22 = y32 - t * cos_th1;
  return bezierCache[key4] = [a00 * x13 + a01 * y13, a10 * x13 + a11 * y13, a00 * x22 + a01 * y22, a10 * x22 + a11 * y22, a00 * x32 + a01 * y32, a10 * x32 + a11 * y32];
}
var temp = ["l", 0, 0, 0, 0, 0, 0, 0];
function scale$1(current2, sX, sY) {
  const c5 = temp[0] = current2[0];
  if (c5 === "a" || c5 === "A") {
    temp[1] = sX * current2[1];
    temp[2] = sY * current2[2];
    temp[3] = current2[3];
    temp[4] = current2[4];
    temp[5] = current2[5];
    temp[6] = sX * current2[6];
    temp[7] = sY * current2[7];
  } else if (c5 === "h" || c5 === "H") {
    temp[1] = sX * current2[1];
  } else if (c5 === "v" || c5 === "V") {
    temp[1] = sY * current2[1];
  } else {
    for (var i = 1, n = current2.length; i < n; ++i) {
      temp[i] = (i % 2 == 1 ? sX : sY) * current2[i];
    }
  }
  return temp;
}
function pathRender(context7, path7, l, t, sX, sY) {
  var current2, previous = null, x9 = 0, y9 = 0, controlX = 0, controlY = 0, tempX, tempY, tempControlX, tempControlY, anchorX = 0, anchorY = 0;
  if (l == null)
    l = 0;
  if (t == null)
    t = 0;
  if (sX == null)
    sX = 1;
  if (sY == null)
    sY = sX;
  if (context7.beginPath)
    context7.beginPath();
  for (var i = 0, len = path7.length; i < len; ++i) {
    current2 = path7[i];
    if (sX !== 1 || sY !== 1) {
      current2 = scale$1(current2, sX, sY);
    }
    switch (current2[0]) {
      case "l":
        x9 += current2[1];
        y9 += current2[2];
        context7.lineTo(x9 + l, y9 + t);
        break;
      case "L":
        x9 = current2[1];
        y9 = current2[2];
        context7.lineTo(x9 + l, y9 + t);
        break;
      case "h":
        x9 += current2[1];
        context7.lineTo(x9 + l, y9 + t);
        break;
      case "H":
        x9 = current2[1];
        context7.lineTo(x9 + l, y9 + t);
        break;
      case "v":
        y9 += current2[1];
        context7.lineTo(x9 + l, y9 + t);
        break;
      case "V":
        y9 = current2[1];
        context7.lineTo(x9 + l, y9 + t);
        break;
      case "m":
        x9 += current2[1];
        y9 += current2[2];
        anchorX = x9;
        anchorY = y9;
        context7.moveTo(x9 + l, y9 + t);
        break;
      case "M":
        x9 = current2[1];
        y9 = current2[2];
        anchorX = x9;
        anchorY = y9;
        context7.moveTo(x9 + l, y9 + t);
        break;
      case "c":
        tempX = x9 + current2[5];
        tempY = y9 + current2[6];
        controlX = x9 + current2[3];
        controlY = y9 + current2[4];
        context7.bezierCurveTo(
          x9 + current2[1] + l,
          // x1
          y9 + current2[2] + t,
          // y1
          controlX + l,
          // x2
          controlY + t,
          // y2
          tempX + l,
          tempY + t
        );
        x9 = tempX;
        y9 = tempY;
        break;
      case "C":
        x9 = current2[5];
        y9 = current2[6];
        controlX = current2[3];
        controlY = current2[4];
        context7.bezierCurveTo(current2[1] + l, current2[2] + t, controlX + l, controlY + t, x9 + l, y9 + t);
        break;
      case "s":
        tempX = x9 + current2[3];
        tempY = y9 + current2[4];
        controlX = 2 * x9 - controlX;
        controlY = 2 * y9 - controlY;
        context7.bezierCurveTo(controlX + l, controlY + t, x9 + current2[1] + l, y9 + current2[2] + t, tempX + l, tempY + t);
        controlX = x9 + current2[1];
        controlY = y9 + current2[2];
        x9 = tempX;
        y9 = tempY;
        break;
      case "S":
        tempX = current2[3];
        tempY = current2[4];
        controlX = 2 * x9 - controlX;
        controlY = 2 * y9 - controlY;
        context7.bezierCurveTo(controlX + l, controlY + t, current2[1] + l, current2[2] + t, tempX + l, tempY + t);
        x9 = tempX;
        y9 = tempY;
        controlX = current2[1];
        controlY = current2[2];
        break;
      case "q":
        tempX = x9 + current2[3];
        tempY = y9 + current2[4];
        controlX = x9 + current2[1];
        controlY = y9 + current2[2];
        context7.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t);
        x9 = tempX;
        y9 = tempY;
        break;
      case "Q":
        tempX = current2[3];
        tempY = current2[4];
        context7.quadraticCurveTo(current2[1] + l, current2[2] + t, tempX + l, tempY + t);
        x9 = tempX;
        y9 = tempY;
        controlX = current2[1];
        controlY = current2[2];
        break;
      case "t":
        tempX = x9 + current2[1];
        tempY = y9 + current2[2];
        if (previous[0].match(/[QqTt]/) === null) {
          controlX = x9;
          controlY = y9;
        } else if (previous[0] === "t") {
          controlX = 2 * x9 - tempControlX;
          controlY = 2 * y9 - tempControlY;
        } else if (previous[0] === "q") {
          controlX = 2 * x9 - controlX;
          controlY = 2 * y9 - controlY;
        }
        tempControlX = controlX;
        tempControlY = controlY;
        context7.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t);
        x9 = tempX;
        y9 = tempY;
        controlX = x9 + current2[1];
        controlY = y9 + current2[2];
        break;
      case "T":
        tempX = current2[1];
        tempY = current2[2];
        controlX = 2 * x9 - controlX;
        controlY = 2 * y9 - controlY;
        context7.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t);
        x9 = tempX;
        y9 = tempY;
        break;
      case "a":
        drawArc(context7, x9 + l, y9 + t, [current2[1], current2[2], current2[3], current2[4], current2[5], current2[6] + x9 + l, current2[7] + y9 + t]);
        x9 += current2[6];
        y9 += current2[7];
        break;
      case "A":
        drawArc(context7, x9 + l, y9 + t, [current2[1], current2[2], current2[3], current2[4], current2[5], current2[6] + l, current2[7] + t]);
        x9 = current2[6];
        y9 = current2[7];
        break;
      case "z":
      case "Z":
        x9 = anchorX;
        y9 = anchorY;
        context7.closePath();
        break;
    }
    previous = current2;
  }
}
function drawArc(context7, x9, y9, coords) {
  const seg = segments(
    coords[5],
    // end x
    coords[6],
    // end y
    coords[0],
    // radius x
    coords[1],
    // radius y
    coords[3],
    // large flag
    coords[4],
    // sweep flag
    coords[2],
    // rotation
    x9,
    y9
  );
  for (let i = 0; i < seg.length; ++i) {
    const bez = bezier(seg[i]);
    context7.bezierCurveTo(bez[0], bez[1], bez[2], bez[3], bez[4], bez[5]);
  }
}
var Tan30 = 0.5773502691896257;
var builtins = {
  "circle": {
    draw: function(context7, size) {
      const r = Math.sqrt(size) / 2;
      context7.moveTo(r, 0);
      context7.arc(0, 0, r, 0, Tau);
    }
  },
  "cross": {
    draw: function(context7, size) {
      var r = Math.sqrt(size) / 2, s2 = r / 2.5;
      context7.moveTo(-r, -s2);
      context7.lineTo(-r, s2);
      context7.lineTo(-s2, s2);
      context7.lineTo(-s2, r);
      context7.lineTo(s2, r);
      context7.lineTo(s2, s2);
      context7.lineTo(r, s2);
      context7.lineTo(r, -s2);
      context7.lineTo(s2, -s2);
      context7.lineTo(s2, -r);
      context7.lineTo(-s2, -r);
      context7.lineTo(-s2, -s2);
      context7.closePath();
    }
  },
  "diamond": {
    draw: function(context7, size) {
      const r = Math.sqrt(size) / 2;
      context7.moveTo(-r, 0);
      context7.lineTo(0, -r);
      context7.lineTo(r, 0);
      context7.lineTo(0, r);
      context7.closePath();
    }
  },
  "square": {
    draw: function(context7, size) {
      var w8 = Math.sqrt(size), x9 = -w8 / 2;
      context7.rect(x9, x9, w8, w8);
    }
  },
  "arrow": {
    draw: function(context7, size) {
      var r = Math.sqrt(size) / 2, s2 = r / 7, t = r / 2.5, v2 = r / 8;
      context7.moveTo(-s2, r);
      context7.lineTo(s2, r);
      context7.lineTo(s2, -v2);
      context7.lineTo(t, -v2);
      context7.lineTo(0, -r);
      context7.lineTo(-t, -v2);
      context7.lineTo(-s2, -v2);
      context7.closePath();
    }
  },
  "wedge": {
    draw: function(context7, size) {
      var r = Math.sqrt(size) / 2, h6 = HalfSqrt3 * r, o = h6 - r * Tan30, b6 = r / 4;
      context7.moveTo(0, -h6 - o);
      context7.lineTo(-b6, h6 - o);
      context7.lineTo(b6, h6 - o);
      context7.closePath();
    }
  },
  "triangle": {
    draw: function(context7, size) {
      var r = Math.sqrt(size) / 2, h6 = HalfSqrt3 * r, o = h6 - r * Tan30;
      context7.moveTo(0, -h6 - o);
      context7.lineTo(-r, h6 - o);
      context7.lineTo(r, h6 - o);
      context7.closePath();
    }
  },
  "triangle-up": {
    draw: function(context7, size) {
      var r = Math.sqrt(size) / 2, h6 = HalfSqrt3 * r;
      context7.moveTo(0, -h6);
      context7.lineTo(-r, h6);
      context7.lineTo(r, h6);
      context7.closePath();
    }
  },
  "triangle-down": {
    draw: function(context7, size) {
      var r = Math.sqrt(size) / 2, h6 = HalfSqrt3 * r;
      context7.moveTo(0, h6);
      context7.lineTo(-r, -h6);
      context7.lineTo(r, -h6);
      context7.closePath();
    }
  },
  "triangle-right": {
    draw: function(context7, size) {
      var r = Math.sqrt(size) / 2, h6 = HalfSqrt3 * r;
      context7.moveTo(h6, 0);
      context7.lineTo(-h6, -r);
      context7.lineTo(-h6, r);
      context7.closePath();
    }
  },
  "triangle-left": {
    draw: function(context7, size) {
      var r = Math.sqrt(size) / 2, h6 = HalfSqrt3 * r;
      context7.moveTo(-h6, 0);
      context7.lineTo(h6, -r);
      context7.lineTo(h6, r);
      context7.closePath();
    }
  },
  "stroke": {
    draw: function(context7, size) {
      const r = Math.sqrt(size) / 2;
      context7.moveTo(-r, 0);
      context7.lineTo(r, 0);
    }
  }
};
function symbols2(_) {
  return has4(builtins, _) ? builtins[_] : customSymbol(_);
}
var custom8 = {};
function customSymbol(path7) {
  if (!has4(custom8, path7)) {
    const parsed = parse4(path7);
    custom8[path7] = {
      draw: function(context7, size) {
        pathRender(context7, parsed, 0, 0, Math.sqrt(size) / 2);
      }
    };
  }
  return custom8[path7];
}
var C2 = 0.448084975506;
function rectangleX(d) {
  return d.x;
}
function rectangleY(d) {
  return d.y;
}
function rectangleWidth(d) {
  return d.width;
}
function rectangleHeight(d) {
  return d.height;
}
function number4(_) {
  return typeof _ === "function" ? _ : () => +_;
}
function clamp(value7, min5, max5) {
  return Math.max(min5, Math.min(value7, max5));
}
function vg_rect() {
  var x9 = rectangleX, y9 = rectangleY, width2 = rectangleWidth, height2 = rectangleHeight, crTL = number4(0), crTR = crTL, crBL = crTL, crBR = crTL, context7 = null;
  function rectangle6(_, x07, y07) {
    var buffer, x13 = x07 != null ? x07 : +x9.call(this, _), y13 = y07 != null ? y07 : +y9.call(this, _), w8 = +width2.call(this, _), h6 = +height2.call(this, _), s2 = Math.min(w8, h6) / 2, tl6 = clamp(+crTL.call(this, _), 0, s2), tr6 = clamp(+crTR.call(this, _), 0, s2), bl6 = clamp(+crBL.call(this, _), 0, s2), br6 = clamp(+crBR.call(this, _), 0, s2);
    if (!context7)
      context7 = buffer = path();
    if (tl6 <= 0 && tr6 <= 0 && bl6 <= 0 && br6 <= 0) {
      context7.rect(x13, y13, w8, h6);
    } else {
      var x22 = x13 + w8, y22 = y13 + h6;
      context7.moveTo(x13 + tl6, y13);
      context7.lineTo(x22 - tr6, y13);
      context7.bezierCurveTo(x22 - C2 * tr6, y13, x22, y13 + C2 * tr6, x22, y13 + tr6);
      context7.lineTo(x22, y22 - br6);
      context7.bezierCurveTo(x22, y22 - C2 * br6, x22 - C2 * br6, y22, x22 - br6, y22);
      context7.lineTo(x13 + bl6, y22);
      context7.bezierCurveTo(x13 + C2 * bl6, y22, x13, y22 - C2 * bl6, x13, y22 - bl6);
      context7.lineTo(x13, y13 + tl6);
      context7.bezierCurveTo(x13, y13 + C2 * tl6, x13 + C2 * tl6, y13, x13 + tl6, y13);
      context7.closePath();
    }
    if (buffer) {
      context7 = null;
      return buffer + "" || null;
    }
  }
  rectangle6.x = function(_) {
    if (arguments.length) {
      x9 = number4(_);
      return rectangle6;
    } else {
      return x9;
    }
  };
  rectangle6.y = function(_) {
    if (arguments.length) {
      y9 = number4(_);
      return rectangle6;
    } else {
      return y9;
    }
  };
  rectangle6.width = function(_) {
    if (arguments.length) {
      width2 = number4(_);
      return rectangle6;
    } else {
      return width2;
    }
  };
  rectangle6.height = function(_) {
    if (arguments.length) {
      height2 = number4(_);
      return rectangle6;
    } else {
      return height2;
    }
  };
  rectangle6.cornerRadius = function(tl6, tr6, br6, bl6) {
    if (arguments.length) {
      crTL = number4(tl6);
      crTR = tr6 != null ? number4(tr6) : crTL;
      crBR = br6 != null ? number4(br6) : crTL;
      crBL = bl6 != null ? number4(bl6) : crTR;
      return rectangle6;
    } else {
      return crTL;
    }
  };
  rectangle6.context = function(_) {
    if (arguments.length) {
      context7 = _ == null ? null : _;
      return rectangle6;
    } else {
      return context7;
    }
  };
  return rectangle6;
}
function vg_trail() {
  var x9, y9, size, defined2, context7 = null, ready, x13, y13, r1;
  function point21(x22, y22, w22) {
    const r2 = w22 / 2;
    if (ready) {
      var ux = y13 - y22, uy = x22 - x13;
      if (ux || uy) {
        var ud = Math.hypot(ux, uy), rx = (ux /= ud) * r1, ry = (uy /= ud) * r1, t = Math.atan2(uy, ux);
        context7.moveTo(x13 - rx, y13 - ry);
        context7.lineTo(x22 - ux * r2, y22 - uy * r2);
        context7.arc(x22, y22, r2, t - Math.PI, t);
        context7.lineTo(x13 + rx, y13 + ry);
        context7.arc(x13, y13, r1, t, t + Math.PI);
      } else {
        context7.arc(x22, y22, r2, 0, Tau);
      }
      context7.closePath();
    } else {
      ready = 1;
    }
    x13 = x22;
    y13 = y22;
    r1 = r2;
  }
  function trail7(data3) {
    var i, n = data3.length, d, defined0 = false, buffer;
    if (context7 == null)
      context7 = buffer = path();
    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined2(d = data3[i], i, data3)) === defined0) {
        if (defined0 = !defined0)
          ready = 0;
      }
      if (defined0)
        point21(+x9(d, i, data3), +y9(d, i, data3), +size(d, i, data3));
    }
    if (buffer) {
      context7 = null;
      return buffer + "" || null;
    }
  }
  trail7.x = function(_) {
    if (arguments.length) {
      x9 = _;
      return trail7;
    } else {
      return x9;
    }
  };
  trail7.y = function(_) {
    if (arguments.length) {
      y9 = _;
      return trail7;
    } else {
      return y9;
    }
  };
  trail7.size = function(_) {
    if (arguments.length) {
      size = _;
      return trail7;
    } else {
      return size;
    }
  };
  trail7.defined = function(_) {
    if (arguments.length) {
      defined2 = _;
      return trail7;
    } else {
      return defined2;
    }
  };
  trail7.context = function(_) {
    if (arguments.length) {
      if (_ == null) {
        context7 = null;
      } else {
        context7 = _;
      }
      return trail7;
    } else {
      return context7;
    }
  };
  return trail7;
}
function value$1(a4, b6) {
  return a4 != null ? a4 : b6;
}
var x2 = (item) => item.x || 0;
var y2 = (item) => item.y || 0;
var w = (item) => item.width || 0;
var h = (item) => item.height || 0;
var xw = (item) => (item.x || 0) + (item.width || 0);
var yh = (item) => (item.y || 0) + (item.height || 0);
var sa = (item) => item.startAngle || 0;
var ea = (item) => item.endAngle || 0;
var pa = (item) => item.padAngle || 0;
var ir = (item) => item.innerRadius || 0;
var or = (item) => item.outerRadius || 0;
var cr = (item) => item.cornerRadius || 0;
var tl = (item) => value$1(item.cornerRadiusTopLeft, item.cornerRadius) || 0;
var tr = (item) => value$1(item.cornerRadiusTopRight, item.cornerRadius) || 0;
var br = (item) => value$1(item.cornerRadiusBottomRight, item.cornerRadius) || 0;
var bl = (item) => value$1(item.cornerRadiusBottomLeft, item.cornerRadius) || 0;
var sz = (item) => value$1(item.size, 64);
var ts = (item) => item.size || 1;
var def = (item) => !(item.defined === false);
var type = (item) => symbols2(item.shape || "circle");
var arcShape = arc_default().startAngle(sa).endAngle(ea).padAngle(pa).innerRadius(ir).outerRadius(or).cornerRadius(cr);
var areavShape = area_default().x(x2).y1(y2).y0(yh).defined(def);
var areahShape = area_default().y(y2).x1(x2).x0(xw).defined(def);
var lineShape = line_default().x(x2).y(y2).defined(def);
var rectShape = vg_rect().x(x2).y(y2).width(w).height(h).cornerRadius(tl, tr, br, bl);
var symbolShape = Symbol2().type(type).size(sz);
var trailShape = vg_trail().x(x2).y(y2).defined(def).size(ts);
function hasCornerRadius(item) {
  return item.cornerRadius || item.cornerRadiusTopLeft || item.cornerRadiusTopRight || item.cornerRadiusBottomRight || item.cornerRadiusBottomLeft;
}
function arc$1(context7, item) {
  return arcShape.context(context7)(item);
}
function area$1(context7, items) {
  const item = items[0], interp = item.interpolate || "linear";
  return (item.orient === "horizontal" ? areahShape : areavShape).curve(curves(interp, item.orient, item.tension)).context(context7)(items);
}
function line$1(context7, items) {
  const item = items[0], interp = item.interpolate || "linear";
  return lineShape.curve(curves(interp, item.orient, item.tension)).context(context7)(items);
}
function rectangle(context7, item, x9, y9) {
  return rectShape.context(context7)(item, x9, y9);
}
function shape$1(context7, item) {
  return (item.mark.shape || item.shape).context(context7)(item);
}
function symbol$1(context7, item) {
  return symbolShape.context(context7)(item);
}
function trail$1(context7, items) {
  return trailShape.context(context7)(items);
}
var clip_id = 1;
function clip$1(renderer, item, size) {
  var clip7 = item.clip, defs = renderer._defs, id24 = item.clip_id || (item.clip_id = "clip" + clip_id++), c5 = defs.clipping[id24] || (defs.clipping[id24] = {
    id: id24
  });
  if (isFunction4(clip7)) {
    c5.path = clip7(null);
  } else if (hasCornerRadius(size)) {
    c5.path = rectangle(null, size, 0, 0);
  } else {
    c5.width = size.width || 0;
    c5.height = size.height || 0;
  }
  return "url(#" + id24 + ")";
}
function Bounds(b6) {
  this.clear();
  if (b6)
    this.union(b6);
}
Bounds.prototype = {
  clone() {
    return new Bounds(this);
  },
  clear() {
    this.x1 = +Number.MAX_VALUE;
    this.y1 = +Number.MAX_VALUE;
    this.x2 = -Number.MAX_VALUE;
    this.y2 = -Number.MAX_VALUE;
    return this;
  },
  empty() {
    return this.x1 === +Number.MAX_VALUE && this.y1 === +Number.MAX_VALUE && this.x2 === -Number.MAX_VALUE && this.y2 === -Number.MAX_VALUE;
  },
  equals(b6) {
    return this.x1 === b6.x1 && this.y1 === b6.y1 && this.x2 === b6.x2 && this.y2 === b6.y2;
  },
  set(x13, y13, x22, y22) {
    if (x22 < x13) {
      this.x2 = x13;
      this.x1 = x22;
    } else {
      this.x1 = x13;
      this.x2 = x22;
    }
    if (y22 < y13) {
      this.y2 = y13;
      this.y1 = y22;
    } else {
      this.y1 = y13;
      this.y2 = y22;
    }
    return this;
  },
  add(x9, y9) {
    if (x9 < this.x1)
      this.x1 = x9;
    if (y9 < this.y1)
      this.y1 = y9;
    if (x9 > this.x2)
      this.x2 = x9;
    if (y9 > this.y2)
      this.y2 = y9;
    return this;
  },
  expand(d) {
    this.x1 -= d;
    this.y1 -= d;
    this.x2 += d;
    this.y2 += d;
    return this;
  },
  round() {
    this.x1 = Math.floor(this.x1);
    this.y1 = Math.floor(this.y1);
    this.x2 = Math.ceil(this.x2);
    this.y2 = Math.ceil(this.y2);
    return this;
  },
  scale(s2) {
    this.x1 *= s2;
    this.y1 *= s2;
    this.x2 *= s2;
    this.y2 *= s2;
    return this;
  },
  translate(dx, dy) {
    this.x1 += dx;
    this.x2 += dx;
    this.y1 += dy;
    this.y2 += dy;
    return this;
  },
  rotate(angle2, x9, y9) {
    const p = this.rotatedPoints(angle2, x9, y9);
    return this.clear().add(p[0], p[1]).add(p[2], p[3]).add(p[4], p[5]).add(p[6], p[7]);
  },
  rotatedPoints(angle2, x9, y9) {
    var {
      x1: x13,
      y1: y13,
      x2: x22,
      y2: y22
    } = this, cos4 = Math.cos(angle2), sin4 = Math.sin(angle2), cx = x9 - x9 * cos4 + y9 * sin4, cy = y9 - x9 * sin4 - y9 * cos4;
    return [cos4 * x13 - sin4 * y13 + cx, sin4 * x13 + cos4 * y13 + cy, cos4 * x13 - sin4 * y22 + cx, sin4 * x13 + cos4 * y22 + cy, cos4 * x22 - sin4 * y13 + cx, sin4 * x22 + cos4 * y13 + cy, cos4 * x22 - sin4 * y22 + cx, sin4 * x22 + cos4 * y22 + cy];
  },
  union(b6) {
    if (b6.x1 < this.x1)
      this.x1 = b6.x1;
    if (b6.y1 < this.y1)
      this.y1 = b6.y1;
    if (b6.x2 > this.x2)
      this.x2 = b6.x2;
    if (b6.y2 > this.y2)
      this.y2 = b6.y2;
    return this;
  },
  intersect(b6) {
    if (b6.x1 > this.x1)
      this.x1 = b6.x1;
    if (b6.y1 > this.y1)
      this.y1 = b6.y1;
    if (b6.x2 < this.x2)
      this.x2 = b6.x2;
    if (b6.y2 < this.y2)
      this.y2 = b6.y2;
    return this;
  },
  encloses(b6) {
    return b6 && this.x1 <= b6.x1 && this.x2 >= b6.x2 && this.y1 <= b6.y1 && this.y2 >= b6.y2;
  },
  alignsWith(b6) {
    return b6 && (this.x1 == b6.x1 || this.x2 == b6.x2 || this.y1 == b6.y1 || this.y2 == b6.y2);
  },
  intersects(b6) {
    return b6 && !(this.x2 < b6.x1 || this.x1 > b6.x2 || this.y2 < b6.y1 || this.y1 > b6.y2);
  },
  contains(x9, y9) {
    return !(x9 < this.x1 || x9 > this.x2 || y9 < this.y1 || y9 > this.y2);
  },
  width() {
    return this.x2 - this.x1;
  },
  height() {
    return this.y2 - this.y1;
  }
};
function Item(mark) {
  this.mark = mark;
  this.bounds = this.bounds || new Bounds();
}
function GroupItem(mark) {
  Item.call(this, mark);
  this.items = this.items || [];
}
inherits4(GroupItem, Item);
var ResourceLoader = class {
  constructor(customLoader) {
    this._pending = 0;
    this._loader = customLoader || loader2();
  }
  pending() {
    return this._pending;
  }
  sanitizeURL(uri) {
    const loader7 = this;
    increment(loader7);
    return loader7._loader.sanitize(uri, {
      context: "href"
    }).then((opt) => {
      decrement(loader7);
      return opt;
    }).catch(() => {
      decrement(loader7);
      return null;
    });
  }
  loadImage(uri) {
    const loader7 = this, Image2 = domImage();
    increment(loader7);
    return loader7._loader.sanitize(uri, {
      context: "image"
    }).then((opt) => {
      const url = opt.href;
      if (!url || !Image2)
        throw {
          url
        };
      const img = new Image2();
      const cors = has4(opt, "crossOrigin") ? opt.crossOrigin : "anonymous";
      if (cors != null)
        img.crossOrigin = cors;
      img.onload = () => decrement(loader7);
      img.onerror = () => decrement(loader7);
      img.src = url;
      return img;
    }).catch((e3) => {
      decrement(loader7);
      return {
        complete: false,
        width: 0,
        height: 0,
        src: e3 && e3.url || ""
      };
    });
  }
  ready() {
    const loader7 = this;
    return new Promise((accept) => {
      function poll(value7) {
        if (!loader7.pending())
          accept(value7);
        else
          setTimeout(() => {
            poll(true);
          }, 10);
      }
      poll(false);
    });
  }
};
function increment(loader7) {
  loader7._pending += 1;
}
function decrement(loader7) {
  loader7._pending -= 1;
}
function boundStroke(bounds6, item, miter) {
  if (item.stroke && item.opacity !== 0 && item.strokeOpacity !== 0) {
    const sw = item.strokeWidth != null ? +item.strokeWidth : 1;
    bounds6.expand(sw + (miter ? miterAdjustment(item, sw) : 0));
  }
  return bounds6;
}
function miterAdjustment(item, strokeWidth) {
  return item.strokeJoin && item.strokeJoin !== "miter" ? 0 : strokeWidth;
}
var circleThreshold = Tau - 1e-8;
var bounds;
var lx;
var ly;
var rot;
var ma;
var mb;
var mc;
var md;
var add3 = (x9, y9) => bounds.add(x9, y9);
var addL = (x9, y9) => add3(lx = x9, ly = y9);
var addX = (x9) => add3(x9, bounds.y1);
var addY = (y9) => add3(bounds.x1, y9);
var px = (x9, y9) => ma * x9 + mc * y9;
var py = (x9, y9) => mb * x9 + md * y9;
var addp = (x9, y9) => add3(px(x9, y9), py(x9, y9));
var addpL = (x9, y9) => addL(px(x9, y9), py(x9, y9));
function boundContext(_, deg) {
  bounds = _;
  if (deg) {
    rot = deg * DegToRad;
    ma = md = Math.cos(rot);
    mb = Math.sin(rot);
    mc = -mb;
  } else {
    ma = md = 1;
    rot = mb = mc = 0;
  }
  return context$1;
}
var context$1 = {
  beginPath() {
  },
  closePath() {
  },
  moveTo: addpL,
  lineTo: addpL,
  rect(x9, y9, w8, h6) {
    if (rot) {
      addp(x9 + w8, y9);
      addp(x9 + w8, y9 + h6);
      addp(x9, y9 + h6);
      addpL(x9, y9);
    } else {
      add3(x9 + w8, y9 + h6);
      addL(x9, y9);
    }
  },
  quadraticCurveTo(x13, y13, x22, y22) {
    const px1 = px(x13, y13), py1 = py(x13, y13), px22 = px(x22, y22), py22 = py(x22, y22);
    quadExtrema(lx, px1, px22, addX);
    quadExtrema(ly, py1, py22, addY);
    addL(px22, py22);
  },
  bezierCurveTo(x13, y13, x22, y22, x32, y32) {
    const px1 = px(x13, y13), py1 = py(x13, y13), px22 = px(x22, y22), py22 = py(x22, y22), px32 = px(x32, y32), py32 = py(x32, y32);
    cubicExtrema(lx, px1, px22, px32, addX);
    cubicExtrema(ly, py1, py22, py32, addY);
    addL(px32, py32);
  },
  arc(cx, cy, r, sa6, ea7, ccw) {
    sa6 += rot;
    ea7 += rot;
    lx = r * Math.cos(ea7) + cx;
    ly = r * Math.sin(ea7) + cy;
    if (Math.abs(ea7 - sa6) > circleThreshold) {
      add3(cx - r, cy - r);
      add3(cx + r, cy + r);
    } else {
      const update3 = (a4) => add3(r * Math.cos(a4) + cx, r * Math.sin(a4) + cy);
      let s2, i;
      update3(sa6);
      update3(ea7);
      if (ea7 !== sa6) {
        sa6 = sa6 % Tau;
        if (sa6 < 0)
          sa6 += Tau;
        ea7 = ea7 % Tau;
        if (ea7 < 0)
          ea7 += Tau;
        if (ea7 < sa6) {
          ccw = !ccw;
          s2 = sa6;
          sa6 = ea7;
          ea7 = s2;
        }
        if (ccw) {
          ea7 -= Tau;
          s2 = sa6 - sa6 % HalfPi;
          for (i = 0; i < 4 && s2 > ea7; ++i, s2 -= HalfPi)
            update3(s2);
        } else {
          s2 = sa6 - sa6 % HalfPi + HalfPi;
          for (i = 0; i < 4 && s2 < ea7; ++i, s2 = s2 + HalfPi)
            update3(s2);
        }
      }
    }
  }
};
function quadExtrema(x07, x13, x22, cb) {
  const t = (x07 - x13) / (x07 + x22 - 2 * x13);
  if (0 < t && t < 1)
    cb(x07 + (x13 - x07) * t);
}
function cubicExtrema(x07, x13, x22, x32, cb) {
  const a4 = x32 - x07 + 3 * x13 - 3 * x22, b6 = x07 + x22 - 2 * x13, c5 = x07 - x13;
  let t014 = 0, t13 = 0, r;
  if (Math.abs(a4) > Epsilon) {
    r = b6 * b6 + c5 * a4;
    if (r >= 0) {
      r = Math.sqrt(r);
      t014 = (-b6 + r) / a4;
      t13 = (-b6 - r) / a4;
    }
  } else {
    t014 = 0.5 * c5 / b6;
  }
  if (0 < t014 && t014 < 1)
    cb(cubic(t014, x07, x13, x22, x32));
  if (0 < t13 && t13 < 1)
    cb(cubic(t13, x07, x13, x22, x32));
}
function cubic(t, x07, x13, x22, x32) {
  const s2 = 1 - t, s22 = s2 * s2, t22 = t * t;
  return s22 * s2 * x07 + 3 * s22 * t * x13 + 3 * s2 * t22 * x22 + t22 * t * x32;
}
var context = (context = domCanvas(1, 1)) ? context.getContext("2d") : null;
var b = new Bounds();
function intersectPath(draw7) {
  return function(item, brush) {
    if (!context)
      return true;
    draw7(context, item);
    b.clear().union(item.bounds).intersect(brush).round();
    const {
      x1: x13,
      y1: y13,
      x2: x22,
      y2: y22
    } = b;
    for (let y9 = y13; y9 <= y22; ++y9) {
      for (let x9 = x13; x9 <= x22; ++x9) {
        if (context.isPointInPath(x9, y9)) {
          return true;
        }
      }
    }
    return false;
  };
}
function intersectPoint(item, box) {
  return box.contains(item.x || 0, item.y || 0);
}
function intersectRect(item, box) {
  const x9 = item.x || 0, y9 = item.y || 0, w8 = item.width || 0, h6 = item.height || 0;
  return box.intersects(b.set(x9, y9, x9 + w8, y9 + h6));
}
function intersectRule(item, box) {
  const x9 = item.x || 0, y9 = item.y || 0, x22 = item.x2 != null ? item.x2 : x9, y22 = item.y2 != null ? item.y2 : y9;
  return intersectBoxLine(box, x9, y9, x22, y22);
}
function intersectBoxLine(box, x9, y9, u4, v2) {
  const {
    x1: x13,
    y1: y13,
    x2: x22,
    y2: y22
  } = box, dx = u4 - x9, dy = v2 - y9;
  let t014 = 0, t13 = 1, p, q, r, e3;
  for (e3 = 0; e3 < 4; ++e3) {
    if (e3 === 0) {
      p = -dx;
      q = -(x13 - x9);
    }
    if (e3 === 1) {
      p = dx;
      q = x22 - x9;
    }
    if (e3 === 2) {
      p = -dy;
      q = -(y13 - y9);
    }
    if (e3 === 3) {
      p = dy;
      q = y22 - y9;
    }
    if (Math.abs(p) < 1e-10 && q < 0)
      return false;
    r = q / p;
    if (p < 0) {
      if (r > t13)
        return false;
      else if (r > t014)
        t014 = r;
    } else if (p > 0) {
      if (r < t014)
        return false;
      else if (r < t13)
        t13 = r;
    }
  }
  return true;
}
function blend(context7, item) {
  context7.globalCompositeOperation = item.blend || "source-over";
}
function value(value7, dflt) {
  return value7 == null ? dflt : value7;
}
function addStops(gradient8, stops) {
  const n = stops.length;
  for (let i = 0; i < n; ++i) {
    gradient8.addColorStop(stops[i].offset, stops[i].color);
  }
  return gradient8;
}
function gradient(context7, spec, bounds6) {
  const w8 = bounds6.width(), h6 = bounds6.height();
  let gradient8;
  if (spec.gradient === "radial") {
    gradient8 = context7.createRadialGradient(bounds6.x1 + value(spec.x1, 0.5) * w8, bounds6.y1 + value(spec.y1, 0.5) * h6, Math.max(w8, h6) * value(spec.r1, 0), bounds6.x1 + value(spec.x2, 0.5) * w8, bounds6.y1 + value(spec.y2, 0.5) * h6, Math.max(w8, h6) * value(spec.r2, 0.5));
  } else {
    const x13 = value(spec.x1, 0), y13 = value(spec.y1, 0), x22 = value(spec.x2, 1), y22 = value(spec.y2, 0);
    if (x13 === x22 || y13 === y22 || w8 === h6) {
      gradient8 = context7.createLinearGradient(bounds6.x1 + x13 * w8, bounds6.y1 + y13 * h6, bounds6.x1 + x22 * w8, bounds6.y1 + y22 * h6);
    } else {
      const image7 = domCanvas(Math.ceil(w8), Math.ceil(h6)), ictx = image7.getContext("2d");
      ictx.scale(w8, h6);
      ictx.fillStyle = addStops(ictx.createLinearGradient(x13, y13, x22, y22), spec.stops);
      ictx.fillRect(0, 0, w8, h6);
      return context7.createPattern(image7, "no-repeat");
    }
  }
  return addStops(gradient8, spec.stops);
}
function color2(context7, item, value7) {
  return isGradient(value7) ? gradient(context7, value7, item.bounds) : value7;
}
function fill(context7, item, opacity2) {
  opacity2 *= item.fillOpacity == null ? 1 : item.fillOpacity;
  if (opacity2 > 0) {
    context7.globalAlpha = opacity2;
    context7.fillStyle = color2(context7, item, item.fill);
    return true;
  } else {
    return false;
  }
}
var Empty2 = [];
function stroke(context7, item, opacity2) {
  var lw = (lw = item.strokeWidth) != null ? lw : 1;
  if (lw <= 0)
    return false;
  opacity2 *= item.strokeOpacity == null ? 1 : item.strokeOpacity;
  if (opacity2 > 0) {
    context7.globalAlpha = opacity2;
    context7.strokeStyle = color2(context7, item, item.stroke);
    context7.lineWidth = lw;
    context7.lineCap = item.strokeCap || "butt";
    context7.lineJoin = item.strokeJoin || "miter";
    context7.miterLimit = item.strokeMiterLimit || 10;
    if (context7.setLineDash) {
      context7.setLineDash(item.strokeDash || Empty2);
      context7.lineDashOffset = item.strokeDashOffset || 0;
    }
    return true;
  } else {
    return false;
  }
}
function compare3(a4, b6) {
  return a4.zindex - b6.zindex || a4.index - b6.index;
}
function zorder(scene) {
  if (!scene.zdirty)
    return scene.zitems;
  var items = scene.items, output3 = [], item, i, n;
  for (i = 0, n = items.length; i < n; ++i) {
    item = items[i];
    item.index = i;
    if (item.zindex)
      output3.push(item);
  }
  scene.zdirty = false;
  return scene.zitems = output3.sort(compare3);
}
function visit(scene, visitor) {
  var items = scene.items, i, n;
  if (!items || !items.length)
    return;
  const zitems = zorder(scene);
  if (zitems && zitems.length) {
    for (i = 0, n = items.length; i < n; ++i) {
      if (!items[i].zindex)
        visitor(items[i]);
    }
    items = zitems;
  }
  for (i = 0, n = items.length; i < n; ++i) {
    visitor(items[i]);
  }
}
function pickVisit(scene, visitor) {
  var items = scene.items, hit6, i;
  if (!items || !items.length)
    return null;
  const zitems = zorder(scene);
  if (zitems && zitems.length)
    items = zitems;
  for (i = items.length; --i >= 0; ) {
    if (hit6 = visitor(items[i]))
      return hit6;
  }
  if (items === zitems) {
    for (items = scene.items, i = items.length; --i >= 0; ) {
      if (!items[i].zindex) {
        if (hit6 = visitor(items[i]))
          return hit6;
      }
    }
  }
  return null;
}
function drawAll(path7) {
  return function(context7, scene, bounds6) {
    visit(scene, (item) => {
      if (!bounds6 || bounds6.intersects(item.bounds)) {
        drawPath(path7, context7, item, item);
      }
    });
  };
}
function drawOne(path7) {
  return function(context7, scene, bounds6) {
    if (scene.items.length && (!bounds6 || bounds6.intersects(scene.bounds))) {
      drawPath(path7, context7, scene.items[0], scene.items);
    }
  };
}
function drawPath(path7, context7, item, items) {
  var opacity2 = item.opacity == null ? 1 : item.opacity;
  if (opacity2 === 0)
    return;
  if (path7(context7, items))
    return;
  blend(context7, item);
  if (item.fill && fill(context7, item, opacity2)) {
    context7.fill();
  }
  if (item.stroke && stroke(context7, item, opacity2)) {
    context7.stroke();
  }
}
function pick$1(test2) {
  test2 = test2 || truthy4;
  return function(context7, scene, x9, y9, gx, gy) {
    x9 *= context7.pixelRatio;
    y9 *= context7.pixelRatio;
    return pickVisit(scene, (item) => {
      const b6 = item.bounds;
      if (b6 && !b6.contains(gx, gy) || !b6)
        return;
      if (test2(context7, item, x9, y9, gx, gy))
        return item;
    });
  };
}
function hitPath(path7, filled) {
  return function(context7, o, x9, y9) {
    var item = Array.isArray(o) ? o[0] : o, fill6 = filled == null ? item.fill : filled, stroke6 = item.stroke && context7.isPointInStroke, lw, lc;
    if (stroke6) {
      lw = item.strokeWidth;
      lc = item.strokeCap;
      context7.lineWidth = lw != null ? lw : 1;
      context7.lineCap = lc != null ? lc : "butt";
    }
    return path7(context7, o) ? false : fill6 && context7.isPointInPath(x9, y9) || stroke6 && context7.isPointInStroke(x9, y9);
  };
}
function pickPath(path7) {
  return pick$1(hitPath(path7));
}
function translate(x9, y9) {
  return "translate(" + x9 + "," + y9 + ")";
}
function rotate(a4) {
  return "rotate(" + a4 + ")";
}
function scale2(scaleX, scaleY2) {
  return "scale(" + scaleX + "," + scaleY2 + ")";
}
function translateItem(item) {
  return translate(item.x || 0, item.y || 0);
}
function rotateItem(item) {
  return translate(item.x || 0, item.y || 0) + (item.angle ? " " + rotate(item.angle) : "");
}
function transformItem(item) {
  return translate(item.x || 0, item.y || 0) + (item.angle ? " " + rotate(item.angle) : "") + (item.scaleX || item.scaleY ? " " + scale2(item.scaleX || 1, item.scaleY || 1) : "");
}
function markItemPath(type7, shape6, isect) {
  function attr6(emit6, item) {
    emit6("transform", rotateItem(item));
    emit6("d", shape6(null, item));
  }
  function bound6(bounds6, item) {
    shape6(boundContext(bounds6, item.angle), item);
    return boundStroke(bounds6, item).translate(item.x || 0, item.y || 0);
  }
  function draw7(context7, item) {
    var x9 = item.x || 0, y9 = item.y || 0, a4 = item.angle || 0;
    context7.translate(x9, y9);
    if (a4)
      context7.rotate(a4 *= DegToRad);
    context7.beginPath();
    shape6(context7, item);
    if (a4)
      context7.rotate(-a4);
    context7.translate(-x9, -y9);
  }
  return {
    type: type7,
    tag: "path",
    nested: false,
    attr: attr6,
    bound: bound6,
    draw: drawAll(draw7),
    pick: pickPath(draw7),
    isect: isect || intersectPath(draw7)
  };
}
var arc = markItemPath("arc", arc$1);
function pickArea(a4, p) {
  var v2 = a4[0].orient === "horizontal" ? p[1] : p[0], z = a4[0].orient === "horizontal" ? "y" : "x", i = a4.length, min5 = Infinity, hit6, d;
  while (--i >= 0) {
    if (a4[i].defined === false)
      continue;
    d = Math.abs(a4[i][z] - v2);
    if (d < min5) {
      min5 = d;
      hit6 = a4[i];
    }
  }
  return hit6;
}
function pickLine(a4, p) {
  var t = Math.pow(a4[0].strokeWidth || 1, 2), i = a4.length, dx, dy, dd;
  while (--i >= 0) {
    if (a4[i].defined === false)
      continue;
    dx = a4[i].x - p[0];
    dy = a4[i].y - p[1];
    dd = dx * dx + dy * dy;
    if (dd < t)
      return a4[i];
  }
  return null;
}
function pickTrail(a4, p) {
  var i = a4.length, dx, dy, dd;
  while (--i >= 0) {
    if (a4[i].defined === false)
      continue;
    dx = a4[i].x - p[0];
    dy = a4[i].y - p[1];
    dd = dx * dx + dy * dy;
    dx = a4[i].size || 1;
    if (dd < dx * dx)
      return a4[i];
  }
  return null;
}
function markMultiItemPath(type7, shape6, tip) {
  function attr6(emit6, item) {
    var items = item.mark.items;
    if (items.length)
      emit6("d", shape6(null, items));
  }
  function bound6(bounds6, mark) {
    var items = mark.items;
    if (items.length === 0) {
      return bounds6;
    } else {
      shape6(boundContext(bounds6), items);
      return boundStroke(bounds6, items[0]);
    }
  }
  function draw7(context7, items) {
    context7.beginPath();
    shape6(context7, items);
  }
  const hit6 = hitPath(draw7);
  function pick7(context7, scene, x9, y9, gx, gy) {
    var items = scene.items, b6 = scene.bounds;
    if (!items || !items.length || b6 && !b6.contains(gx, gy)) {
      return null;
    }
    x9 *= context7.pixelRatio;
    y9 *= context7.pixelRatio;
    return hit6(context7, items, x9, y9) ? items[0] : null;
  }
  return {
    type: type7,
    tag: "path",
    nested: true,
    attr: attr6,
    bound: bound6,
    draw: drawOne(draw7),
    pick: pick7,
    isect: intersectPoint,
    tip
  };
}
var area = markMultiItemPath("area", area$1, pickArea);
function clip(context7, scene) {
  var clip7 = scene.clip;
  context7.save();
  if (isFunction4(clip7)) {
    context7.beginPath();
    clip7(context7);
    context7.clip();
  } else {
    clipGroup(context7, scene.group);
  }
}
function clipGroup(context7, group7) {
  context7.beginPath();
  hasCornerRadius(group7) ? rectangle(context7, group7, 0, 0) : context7.rect(0, 0, group7.width || 0, group7.height || 0);
  context7.clip();
}
function offset$1(item) {
  const sw = value(item.strokeWidth, 1);
  return item.strokeOffset != null ? item.strokeOffset : item.stroke && sw > 0.5 && sw < 1.5 ? 0.5 - Math.abs(sw - 1) : 0;
}
function attr$5(emit6, item) {
  emit6("transform", translateItem(item));
}
function emitRectangle(emit6, item) {
  const off = offset$1(item);
  emit6("d", rectangle(null, item, off, off));
}
function background(emit6, item) {
  emit6("class", "background");
  emit6("aria-hidden", true);
  emitRectangle(emit6, item);
}
function foreground(emit6, item) {
  emit6("class", "foreground");
  emit6("aria-hidden", true);
  if (item.strokeForeground) {
    emitRectangle(emit6, item);
  } else {
    emit6("d", "");
  }
}
function content(emit6, item, renderer) {
  const url = item.clip ? clip$1(renderer, item, item) : null;
  emit6("clip-path", url);
}
function bound$5(bounds6, group7) {
  if (!group7.clip && group7.items) {
    const items = group7.items, m3 = items.length;
    for (let j = 0; j < m3; ++j) {
      bounds6.union(items[j].bounds);
    }
  }
  if ((group7.clip || group7.width || group7.height) && !group7.noBound) {
    bounds6.add(0, 0).add(group7.width || 0, group7.height || 0);
  }
  boundStroke(bounds6, group7);
  return bounds6.translate(group7.x || 0, group7.y || 0);
}
function rectanglePath(context7, group7, x9, y9) {
  const off = offset$1(group7);
  context7.beginPath();
  rectangle(context7, group7, (x9 || 0) + off, (y9 || 0) + off);
}
var hitBackground = hitPath(rectanglePath);
var hitForeground = hitPath(rectanglePath, false);
var hitCorner = hitPath(rectanglePath, true);
function draw$4(context7, scene, bounds6, markTypes) {
  visit(scene, (group7) => {
    const gx = group7.x || 0, gy = group7.y || 0, fore = group7.strokeForeground, opacity2 = group7.opacity == null ? 1 : group7.opacity;
    if ((group7.stroke || group7.fill) && opacity2) {
      rectanglePath(context7, group7, gx, gy);
      blend(context7, group7);
      if (group7.fill && fill(context7, group7, opacity2)) {
        context7.fill();
      }
      if (group7.stroke && !fore && stroke(context7, group7, opacity2)) {
        context7.stroke();
      }
    }
    context7.save();
    context7.translate(gx, gy);
    if (group7.clip)
      clipGroup(context7, group7);
    if (bounds6)
      bounds6.translate(-gx, -gy);
    visit(group7, (item) => {
      if (item.marktype === "group" || markTypes == null || markTypes.includes(item.marktype)) {
        this.draw(context7, item, bounds6, markTypes);
      }
    });
    if (bounds6)
      bounds6.translate(gx, gy);
    context7.restore();
    if (fore && group7.stroke && opacity2) {
      rectanglePath(context7, group7, gx, gy);
      blend(context7, group7);
      if (stroke(context7, group7, opacity2)) {
        context7.stroke();
      }
    }
  });
}
function pick(context7, scene, x9, y9, gx, gy) {
  if (scene.bounds && !scene.bounds.contains(gx, gy) || !scene.items) {
    return null;
  }
  const cx = x9 * context7.pixelRatio, cy = y9 * context7.pixelRatio;
  return pickVisit(scene, (group7) => {
    let hit6, dx, dy;
    const b6 = group7.bounds;
    if (b6 && !b6.contains(gx, gy))
      return;
    dx = group7.x || 0;
    dy = group7.y || 0;
    const dw = dx + (group7.width || 0), dh = dy + (group7.height || 0), c5 = group7.clip;
    if (c5 && (gx < dx || gx > dw || gy < dy || gy > dh))
      return;
    context7.save();
    context7.translate(dx, dy);
    dx = gx - dx;
    dy = gy - dy;
    if (c5 && hasCornerRadius(group7) && !hitCorner(context7, group7, cx, cy)) {
      context7.restore();
      return null;
    }
    const fore = group7.strokeForeground, ix = scene.interactive !== false;
    if (ix && fore && group7.stroke && hitForeground(context7, group7, cx, cy)) {
      context7.restore();
      return group7;
    }
    hit6 = pickVisit(group7, (mark) => pickMark(mark, dx, dy) ? this.pick(mark, x9, y9, dx, dy) : null);
    if (!hit6 && ix && (group7.fill || !fore && group7.stroke) && hitBackground(context7, group7, cx, cy)) {
      hit6 = group7;
    }
    context7.restore();
    return hit6 || null;
  });
}
function pickMark(mark, x9, y9) {
  return (mark.interactive !== false || mark.marktype === "group") && mark.bounds && mark.bounds.contains(x9, y9);
}
var group2 = {
  type: "group",
  tag: "g",
  nested: false,
  attr: attr$5,
  bound: bound$5,
  draw: draw$4,
  pick,
  isect: intersectRect,
  content,
  background,
  foreground
};
var metadata = {
  "xmlns": "http://www.w3.org/2000/svg",
  "xmlns:xlink": "http://www.w3.org/1999/xlink",
  "version": "1.1"
};
function getImage(item, renderer) {
  var image7 = item.image;
  if (!image7 || item.url && item.url !== image7.url) {
    image7 = {
      complete: false,
      width: 0,
      height: 0
    };
    renderer.loadImage(item.url).then((image8) => {
      item.image = image8;
      item.image.url = item.url;
    });
  }
  return image7;
}
function imageWidth(item, image7) {
  return item.width != null ? item.width : !image7 || !image7.width ? 0 : item.aspect !== false && item.height ? item.height * image7.width / image7.height : image7.width;
}
function imageHeight(item, image7) {
  return item.height != null ? item.height : !image7 || !image7.height ? 0 : item.aspect !== false && item.width ? item.width * image7.height / image7.width : image7.height;
}
function imageXOffset(align2, w8) {
  return align2 === "center" ? w8 / 2 : align2 === "right" ? w8 : 0;
}
function imageYOffset(baseline3, h6) {
  return baseline3 === "middle" ? h6 / 2 : baseline3 === "bottom" ? h6 : 0;
}
function attr$4(emit6, item, renderer) {
  const img = getImage(item, renderer), w8 = imageWidth(item, img), h6 = imageHeight(item, img), x9 = (item.x || 0) - imageXOffset(item.align, w8), y9 = (item.y || 0) - imageYOffset(item.baseline, h6), i = !img.src && img.toDataURL ? img.toDataURL() : img.src || "";
  emit6("href", i, metadata["xmlns:xlink"], "xlink:href");
  emit6("transform", translate(x9, y9));
  emit6("width", w8);
  emit6("height", h6);
  emit6("preserveAspectRatio", item.aspect === false ? "none" : "xMidYMid");
}
function bound$4(bounds6, item) {
  const img = item.image, w8 = imageWidth(item, img), h6 = imageHeight(item, img), x9 = (item.x || 0) - imageXOffset(item.align, w8), y9 = (item.y || 0) - imageYOffset(item.baseline, h6);
  return bounds6.set(x9, y9, x9 + w8, y9 + h6);
}
function draw$3(context7, scene, bounds6) {
  visit(scene, (item) => {
    if (bounds6 && !bounds6.intersects(item.bounds))
      return;
    const img = getImage(item, this);
    let w8 = imageWidth(item, img);
    let h6 = imageHeight(item, img);
    if (w8 === 0 || h6 === 0)
      return;
    let x9 = (item.x || 0) - imageXOffset(item.align, w8), y9 = (item.y || 0) - imageYOffset(item.baseline, h6), opacity2, ar0, ar1, t;
    if (item.aspect !== false) {
      ar0 = img.width / img.height;
      ar1 = item.width / item.height;
      if (ar0 === ar0 && ar1 === ar1 && ar0 !== ar1) {
        if (ar1 < ar0) {
          t = w8 / ar0;
          y9 += (h6 - t) / 2;
          h6 = t;
        } else {
          t = h6 * ar0;
          x9 += (w8 - t) / 2;
          w8 = t;
        }
      }
    }
    if (img.complete || img.toDataURL) {
      blend(context7, item);
      context7.globalAlpha = (opacity2 = item.opacity) != null ? opacity2 : 1;
      context7.imageSmoothingEnabled = item.smooth !== false;
      context7.drawImage(img, x9, y9, w8, h6);
    }
  });
}
var image = {
  type: "image",
  tag: "image",
  nested: false,
  attr: attr$4,
  bound: bound$4,
  draw: draw$3,
  pick: pick$1(),
  isect: truthy4,
  // bounds check is sufficient
  get: getImage,
  xOffset: imageXOffset,
  yOffset: imageYOffset
};
var line = markMultiItemPath("line", line$1, pickLine);
function attr$3(emit6, item) {
  var sx = item.scaleX || 1, sy = item.scaleY || 1;
  if (sx !== 1 || sy !== 1) {
    emit6("vector-effect", "non-scaling-stroke");
  }
  emit6("transform", transformItem(item));
  emit6("d", item.path);
}
function path$1(context7, item) {
  var path7 = item.path;
  if (path7 == null)
    return true;
  var x9 = item.x || 0, y9 = item.y || 0, sx = item.scaleX || 1, sy = item.scaleY || 1, a4 = (item.angle || 0) * DegToRad, cache2 = item.pathCache;
  if (!cache2 || cache2.path !== path7) {
    (item.pathCache = cache2 = parse4(path7)).path = path7;
  }
  if (a4 && context7.rotate && context7.translate) {
    context7.translate(x9, y9);
    context7.rotate(a4);
    pathRender(context7, cache2, 0, 0, sx, sy);
    context7.rotate(-a4);
    context7.translate(-x9, -y9);
  } else {
    pathRender(context7, cache2, x9, y9, sx, sy);
  }
}
function bound$3(bounds6, item) {
  return path$1(boundContext(bounds6, item.angle), item) ? bounds6.set(0, 0, 0, 0) : boundStroke(bounds6, item, true);
}
var path$2 = {
  type: "path",
  tag: "path",
  nested: false,
  attr: attr$3,
  bound: bound$3,
  draw: drawAll(path$1),
  pick: pickPath(path$1),
  isect: intersectPath(path$1)
};
function attr$2(emit6, item) {
  emit6("d", rectangle(null, item));
}
function bound$2(bounds6, item) {
  var x9, y9;
  return boundStroke(bounds6.set(x9 = item.x || 0, y9 = item.y || 0, x9 + item.width || 0, y9 + item.height || 0), item);
}
function draw$2(context7, item) {
  context7.beginPath();
  rectangle(context7, item);
}
var rect = {
  type: "rect",
  tag: "path",
  nested: false,
  attr: attr$2,
  bound: bound$2,
  draw: drawAll(draw$2),
  pick: pickPath(draw$2),
  isect: intersectRect
};
function attr$1(emit6, item) {
  emit6("transform", translateItem(item));
  emit6("x2", item.x2 != null ? item.x2 - (item.x || 0) : 0);
  emit6("y2", item.y2 != null ? item.y2 - (item.y || 0) : 0);
}
function bound$1(bounds6, item) {
  var x13, y13;
  return boundStroke(bounds6.set(x13 = item.x || 0, y13 = item.y || 0, item.x2 != null ? item.x2 : x13, item.y2 != null ? item.y2 : y13), item);
}
function path2(context7, item, opacity2) {
  var x13, y13, x22, y22;
  if (item.stroke && stroke(context7, item, opacity2)) {
    x13 = item.x || 0;
    y13 = item.y || 0;
    x22 = item.x2 != null ? item.x2 : x13;
    y22 = item.y2 != null ? item.y2 : y13;
    context7.beginPath();
    context7.moveTo(x13, y13);
    context7.lineTo(x22, y22);
    return true;
  }
  return false;
}
function draw$1(context7, scene, bounds6) {
  visit(scene, (item) => {
    if (bounds6 && !bounds6.intersects(item.bounds))
      return;
    var opacity2 = item.opacity == null ? 1 : item.opacity;
    if (opacity2 && path2(context7, item, opacity2)) {
      blend(context7, item);
      context7.stroke();
    }
  });
}
function hit$1(context7, item, x9, y9) {
  if (!context7.isPointInStroke)
    return false;
  return path2(context7, item, 1) && context7.isPointInStroke(x9, y9);
}
var rule = {
  type: "rule",
  tag: "line",
  nested: false,
  attr: attr$1,
  bound: bound$1,
  draw: draw$1,
  pick: pick$1(hit$1),
  isect: intersectRule
};
var shape = markItemPath("shape", shape$1);
var symbol = markItemPath("symbol", symbol$1, intersectPoint);
var widthCache = lruCache2();
var textMetrics = {
  height: fontSize,
  measureWidth,
  estimateWidth,
  width: estimateWidth,
  canvas: useCanvas
};
useCanvas(true);
function useCanvas(use) {
  textMetrics.width = use && context ? measureWidth : estimateWidth;
}
function estimateWidth(item, text7) {
  return _estimateWidth(textValue(item, text7), fontSize(item));
}
function _estimateWidth(text7, currentFontHeight) {
  return ~~(0.8 * text7.length * currentFontHeight);
}
function measureWidth(item, text7) {
  return fontSize(item) <= 0 || !(text7 = textValue(item, text7)) ? 0 : _measureWidth(text7, font(item));
}
function _measureWidth(text7, currentFont) {
  const key4 = `(${currentFont}) ${text7}`;
  let width2 = widthCache.get(key4);
  if (width2 === void 0) {
    context.font = currentFont;
    width2 = context.measureText(text7).width;
    widthCache.set(key4, width2);
  }
  return width2;
}
function fontSize(item) {
  return item.fontSize != null ? +item.fontSize || 0 : 11;
}
function lineHeight(item) {
  return item.lineHeight != null ? item.lineHeight : fontSize(item) + 2;
}
function lineArray(_) {
  return isArray4(_) ? _.length > 1 ? _ : _[0] : _;
}
function textLines(item) {
  return lineArray(item.lineBreak && item.text && !isArray4(item.text) ? item.text.split(item.lineBreak) : item.text);
}
function multiLineOffset(item) {
  const tl6 = textLines(item);
  return (isArray4(tl6) ? tl6.length - 1 : 0) * lineHeight(item);
}
function textValue(item, line8) {
  const text7 = line8 == null ? "" : (line8 + "").trim();
  return item.limit > 0 && text7.length ? truncate2(item, text7) : text7;
}
function widthGetter(item) {
  if (textMetrics.width === measureWidth) {
    const currentFont = font(item);
    return (text7) => _measureWidth(text7, currentFont);
  } else if (textMetrics.width === estimateWidth) {
    const currentFontHeight = fontSize(item);
    return (text7) => _estimateWidth(text7, currentFontHeight);
  } else {
    return (text7) => textMetrics.width(item, text7);
  }
}
function truncate2(item, text7) {
  var limit = +item.limit, width2 = widthGetter(item);
  if (width2(text7) < limit)
    return text7;
  var ellipsis = item.ellipsis || "…", rtl = item.dir === "rtl", lo = 0, hi = text7.length, mid;
  limit -= width2(ellipsis);
  if (rtl) {
    while (lo < hi) {
      mid = lo + hi >>> 1;
      if (width2(text7.slice(mid)) > limit)
        lo = mid + 1;
      else
        hi = mid;
    }
    return ellipsis + text7.slice(lo);
  } else {
    while (lo < hi) {
      mid = 1 + (lo + hi >>> 1);
      if (width2(text7.slice(0, mid)) < limit)
        lo = mid;
      else
        hi = mid - 1;
    }
    return text7.slice(0, lo) + ellipsis;
  }
}
function fontFamily(item, quote) {
  var font7 = item.font;
  return (quote && font7 ? String(font7).replace(/"/g, "'") : font7) || "sans-serif";
}
function font(item, quote) {
  return (item.fontStyle ? item.fontStyle + " " : "") + (item.fontVariant ? item.fontVariant + " " : "") + (item.fontWeight ? item.fontWeight + " " : "") + fontSize(item) + "px " + fontFamily(item, quote);
}
function offset(item) {
  var baseline3 = item.baseline, h6 = fontSize(item);
  return Math.round(baseline3 === "top" ? 0.79 * h6 : baseline3 === "middle" ? 0.3 * h6 : baseline3 === "bottom" ? -0.21 * h6 : baseline3 === "line-top" ? 0.29 * h6 + 0.5 * lineHeight(item) : baseline3 === "line-bottom" ? 0.29 * h6 - 0.5 * lineHeight(item) : 0);
}
var textAlign = {
  "left": "start",
  "center": "middle",
  "right": "end"
};
var tempBounds = new Bounds();
function anchorPoint(item) {
  var x9 = item.x || 0, y9 = item.y || 0, r = item.radius || 0, t;
  if (r) {
    t = (item.theta || 0) - HalfPi;
    x9 += r * Math.cos(t);
    y9 += r * Math.sin(t);
  }
  tempBounds.x1 = x9;
  tempBounds.y1 = y9;
  return tempBounds;
}
function attr(emit6, item) {
  var dx = item.dx || 0, dy = (item.dy || 0) + offset(item), p = anchorPoint(item), x9 = p.x1, y9 = p.y1, a4 = item.angle || 0, t;
  emit6("text-anchor", textAlign[item.align] || "start");
  if (a4) {
    t = translate(x9, y9) + " " + rotate(a4);
    if (dx || dy)
      t += " " + translate(dx, dy);
  } else {
    t = translate(x9 + dx, y9 + dy);
  }
  emit6("transform", t);
}
function bound(bounds6, item, mode2) {
  var h6 = textMetrics.height(item), a4 = item.align, p = anchorPoint(item), x9 = p.x1, y9 = p.y1, dx = item.dx || 0, dy = (item.dy || 0) + offset(item) - Math.round(0.8 * h6), tl6 = textLines(item), w8;
  if (isArray4(tl6)) {
    h6 += lineHeight(item) * (tl6.length - 1);
    w8 = tl6.reduce((w9, t) => Math.max(w9, textMetrics.width(item, t)), 0);
  } else {
    w8 = textMetrics.width(item, tl6);
  }
  if (a4 === "center") {
    dx -= w8 / 2;
  } else if (a4 === "right") {
    dx -= w8;
  } else
    ;
  bounds6.set(dx += x9, dy += y9, dx + w8, dy + h6);
  if (item.angle && !mode2) {
    bounds6.rotate(item.angle * DegToRad, x9, y9);
  } else if (mode2 === 2) {
    return bounds6.rotatedPoints(item.angle * DegToRad, x9, y9);
  }
  return bounds6;
}
function draw(context7, scene, bounds6) {
  visit(scene, (item) => {
    var opacity2 = item.opacity == null ? 1 : item.opacity, p, x9, y9, i, lh, tl6, str;
    if (bounds6 && !bounds6.intersects(item.bounds) || // bounds check
    opacity2 === 0 || item.fontSize <= 0 || item.text == null || item.text.length === 0)
      return;
    context7.font = font(item);
    context7.textAlign = item.align || "left";
    p = anchorPoint(item);
    x9 = p.x1, y9 = p.y1;
    if (item.angle) {
      context7.save();
      context7.translate(x9, y9);
      context7.rotate(item.angle * DegToRad);
      x9 = y9 = 0;
    }
    x9 += item.dx || 0;
    y9 += (item.dy || 0) + offset(item);
    tl6 = textLines(item);
    blend(context7, item);
    if (isArray4(tl6)) {
      lh = lineHeight(item);
      for (i = 0; i < tl6.length; ++i) {
        str = textValue(item, tl6[i]);
        if (item.fill && fill(context7, item, opacity2)) {
          context7.fillText(str, x9, y9);
        }
        if (item.stroke && stroke(context7, item, opacity2)) {
          context7.strokeText(str, x9, y9);
        }
        y9 += lh;
      }
    } else {
      str = textValue(item, tl6);
      if (item.fill && fill(context7, item, opacity2)) {
        context7.fillText(str, x9, y9);
      }
      if (item.stroke && stroke(context7, item, opacity2)) {
        context7.strokeText(str, x9, y9);
      }
    }
    if (item.angle)
      context7.restore();
  });
}
function hit(context7, item, x9, y9, gx, gy) {
  if (item.fontSize <= 0)
    return false;
  if (!item.angle)
    return true;
  var p = anchorPoint(item), ax = p.x1, ay = p.y1, b6 = bound(tempBounds, item, 1), a4 = -item.angle * DegToRad, cos4 = Math.cos(a4), sin4 = Math.sin(a4), px6 = cos4 * gx - sin4 * gy + (ax - cos4 * ax + sin4 * ay), py6 = sin4 * gx + cos4 * gy + (ay - sin4 * ax - cos4 * ay);
  return b6.contains(px6, py6);
}
function intersectText(item, box) {
  const p = bound(tempBounds, item, 2);
  return intersectBoxLine(box, p[0], p[1], p[2], p[3]) || intersectBoxLine(box, p[0], p[1], p[4], p[5]) || intersectBoxLine(box, p[4], p[5], p[6], p[7]) || intersectBoxLine(box, p[2], p[3], p[6], p[7]);
}
var text = {
  type: "text",
  tag: "text",
  nested: false,
  attr,
  bound,
  draw,
  pick: pick$1(hit),
  isect: intersectText
};
var trail = markMultiItemPath("trail", trail$1, pickTrail);
var Marks = {
  arc,
  area,
  group: group2,
  image,
  line,
  path: path$2,
  rect,
  rule,
  shape,
  symbol,
  text,
  trail
};
function domCreate(doc, tag, ns) {
  if (!doc && typeof document !== "undefined" && document.createElement) {
    doc = document;
  }
  return doc ? ns ? doc.createElementNS(ns, tag) : doc.createElement(tag) : null;
}
function domFind(el, tag) {
  tag = tag.toLowerCase();
  var nodes = el.childNodes, i = 0, n = nodes.length;
  for (; i < n; ++i)
    if (nodes[i].tagName.toLowerCase() === tag) {
      return nodes[i];
    }
}
function domChild(el, index4, tag, ns) {
  var a4 = el.childNodes[index4], b6;
  if (!a4 || a4.tagName.toLowerCase() !== tag.toLowerCase()) {
    b6 = a4 || null;
    a4 = domCreate(el.ownerDocument, tag, ns);
    el.insertBefore(a4, b6);
  }
  return a4;
}
function domClear(el, index4) {
  var nodes = el.childNodes, curr = nodes.length;
  while (curr > index4)
    el.removeChild(nodes[--curr]);
  return el;
}
function cssClass(mark) {
  return "mark-" + mark.marktype + (mark.role ? " role-" + mark.role : "") + (mark.name ? " " + mark.name : "");
}
function point7(event2, el) {
  const rect7 = el.getBoundingClientRect();
  return [event2.clientX - rect7.left - (el.clientLeft || 0), event2.clientY - rect7.top - (el.clientTop || 0)];
}
function resolveItem(item, event2, el, origin) {
  var mark = item && item.mark, mdef, p;
  if (mark && (mdef = Marks[mark.marktype]).tip) {
    p = point7(event2, el);
    p[0] -= origin[0];
    p[1] -= origin[1];
    while (item = item.mark.group) {
      p[0] -= item.x || 0;
      p[1] -= item.y || 0;
    }
    item = mdef.tip(mark.items, p);
  }
  return item;
}
var Handler = class {
  /**
   * Create a new Handler instance.
   * @param {object} [customLoader] - Optional loader instance for
   *   href URL sanitization. If not specified, a standard loader
   *   instance will be generated.
   * @param {function} [customTooltip] - Optional tooltip handler
   *   function for custom tooltip display.
   * @constructor
   */
  constructor(customLoader, customTooltip) {
    this._active = null;
    this._handlers = {};
    this._loader = customLoader || loader2();
    this._tooltip = customTooltip || defaultTooltip;
  }
  /**
   * Initialize a new Handler instance.
   * @param {DOMElement} el - The containing DOM element for the display.
   * @param {Array<number>} origin - The origin of the display, in pixels.
   *   The coordinate system will be translated to this point.
   * @param {object} [obj] - Optional context object that should serve as
   *   the "this" context for event callbacks.
   * @return {Handler} - This handler instance.
   */
  initialize(el, origin, obj) {
    this._el = el;
    this._obj = obj || null;
    return this.origin(origin);
  }
  /**
   * Returns the parent container element for a visualization.
   * @return {DOMElement} - The containing DOM element.
   */
  element() {
    return this._el;
  }
  /**
   * Returns the scene element (e.g., canvas or SVG) of the visualization
   * Subclasses must override if the first child is not the scene element.
   * @return {DOMElement} - The scene (e.g., canvas or SVG) element.
   */
  canvas() {
    return this._el && this._el.firstChild;
  }
  /**
   * Get / set the origin coordinates of the visualization.
   */
  origin(origin) {
    if (arguments.length) {
      this._origin = origin || [0, 0];
      return this;
    } else {
      return this._origin.slice();
    }
  }
  /**
   * Get / set the scenegraph root.
   */
  scene(scene) {
    if (!arguments.length)
      return this._scene;
    this._scene = scene;
    return this;
  }
  /**
   * Add an event handler. Subclasses should override this method.
   */
  on() {
  }
  /**
   * Remove an event handler. Subclasses should override this method.
   */
  off() {
  }
  /**
   * Utility method for finding the array index of an event handler.
   * @param {Array} h - An array of registered event handlers.
   * @param {string} type - The event type.
   * @param {function} handler - The event handler instance to find.
   * @return {number} - The handler's array index or -1 if not registered.
   */
  _handlerIndex(h6, type7, handler) {
    for (let i = h6 ? h6.length : 0; --i >= 0; ) {
      if (h6[i].type === type7 && (!handler || h6[i].handler === handler)) {
        return i;
      }
    }
    return -1;
  }
  /**
   * Returns an array with registered event handlers.
   * @param {string} [type] - The event type to query. Any annotations
   *   are ignored; for example, for the argument "click.foo", ".foo" will
   *   be ignored and the method returns all "click" handlers. If type is
   *   null or unspecified, this method returns handlers for all types.
   * @return {Array} - A new array containing all registered event handlers.
   */
  handlers(type7) {
    const h6 = this._handlers, a4 = [];
    if (type7) {
      a4.push(...h6[this.eventName(type7)]);
    } else {
      for (const k3 in h6) {
        a4.push(...h6[k3]);
      }
    }
    return a4;
  }
  /**
   * Parses an event name string to return the specific event type.
   * For example, given "click.foo" returns "click"
   * @param {string} name - The input event type string.
   * @return {string} - A string with the event type only.
   */
  eventName(name) {
    const i = name.indexOf(".");
    return i < 0 ? name : name.slice(0, i);
  }
  /**
   * Handle hyperlink navigation in response to an item.href value.
   * @param {Event} event - The event triggering hyperlink navigation.
   * @param {Item} item - The scenegraph item.
   * @param {string} href - The URL to navigate to.
   */
  handleHref(event2, item, href6) {
    this._loader.sanitize(href6, {
      context: "href"
    }).then((opt) => {
      const e3 = new MouseEvent(event2.type, event2), a4 = domCreate(null, "a");
      for (const name in opt)
        a4.setAttribute(name, opt[name]);
      a4.dispatchEvent(e3);
    }).catch(() => {
    });
  }
  /**
   * Handle tooltip display in response to an item.tooltip value.
   * @param {Event} event - The event triggering tooltip display.
   * @param {Item} item - The scenegraph item.
   * @param {boolean} show - A boolean flag indicating whether
   *   to show or hide a tooltip for the given item.
   */
  handleTooltip(event2, item, show) {
    if (item && item.tooltip != null) {
      item = resolveItem(item, event2, this.canvas(), this._origin);
      const value7 = show && item && item.tooltip || null;
      this._tooltip.call(this._obj, this, event2, item, value7);
    }
  }
  /**
   * Returns the size of a scenegraph item and its position relative
   * to the viewport.
   * @param {Item} item - The scenegraph item.
   * @return {object} - A bounding box object (compatible with the
   *   DOMRect type) consisting of x, y, width, heigh, top, left,
   *   right, and bottom properties.
   */
  getItemBoundingClientRect(item) {
    const el = this.canvas();
    if (!el)
      return;
    const rect7 = el.getBoundingClientRect(), origin = this._origin, bounds6 = item.bounds, width2 = bounds6.width(), height2 = bounds6.height();
    let x9 = bounds6.x1 + origin[0] + rect7.left, y9 = bounds6.y1 + origin[1] + rect7.top;
    while (item.mark && (item = item.mark.group)) {
      x9 += item.x || 0;
      y9 += item.y || 0;
    }
    return {
      x: x9,
      y: y9,
      width: width2,
      height: height2,
      left: x9,
      top: y9,
      right: x9 + width2,
      bottom: y9 + height2
    };
  }
};
function defaultTooltip(handler, event2, item, value7) {
  handler.element().setAttribute("title", value7 || "");
}
var Renderer = class {
  /**
   * Create a new Renderer instance.
   * @param {object} [loader] - Optional loader instance for
   *   image and href URL sanitization. If not specified, a
   *   standard loader instance will be generated.
   * @constructor
   */
  constructor(loader7) {
    this._el = null;
    this._bgcolor = null;
    this._loader = new ResourceLoader(loader7);
  }
  /**
   * Initialize a new Renderer instance.
   * @param {DOMElement} el - The containing DOM element for the display.
   * @param {number} width - The coordinate width of the display, in pixels.
   * @param {number} height - The coordinate height of the display, in pixels.
   * @param {Array<number>} origin - The origin of the display, in pixels.
   *   The coordinate system will be translated to this point.
   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
   *   the width and height to determine the final pixel size.
   * @return {Renderer} - This renderer instance.
   */
  initialize(el, width2, height2, origin, scaleFactor) {
    this._el = el;
    return this.resize(width2, height2, origin, scaleFactor);
  }
  /**
   * Returns the parent container element for a visualization.
   * @return {DOMElement} - The containing DOM element.
   */
  element() {
    return this._el;
  }
  /**
   * Returns the scene element (e.g., canvas or SVG) of the visualization
   * Subclasses must override if the first child is not the scene element.
   * @return {DOMElement} - The scene (e.g., canvas or SVG) element.
   */
  canvas() {
    return this._el && this._el.firstChild;
  }
  /**
   * Get / set the background color.
   */
  background(bgcolor) {
    if (arguments.length === 0)
      return this._bgcolor;
    this._bgcolor = bgcolor;
    return this;
  }
  /**
   * Resize the display.
   * @param {number} width - The new coordinate width of the display, in pixels.
   * @param {number} height - The new coordinate height of the display, in pixels.
   * @param {Array<number>} origin - The new origin of the display, in pixels.
   *   The coordinate system will be translated to this point.
   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
   *   the width and height to determine the final pixel size.
   * @return {Renderer} - This renderer instance;
   */
  resize(width2, height2, origin, scaleFactor) {
    this._width = width2;
    this._height = height2;
    this._origin = origin || [0, 0];
    this._scale = scaleFactor || 1;
    return this;
  }
  /**
   * Report a dirty item whose bounds should be redrawn.
   * This base class method does nothing. Subclasses that perform
   * incremental should implement this method.
   * @param {Item} item - The dirty item whose bounds should be redrawn.
   */
  dirty() {
  }
  /**
   * Render an input scenegraph, potentially with a set of dirty items.
   * This method will perform an immediate rendering with available resources.
   * The renderer may also need to perform image loading to perform a complete
   * render. This process can lead to asynchronous re-rendering of the scene
   * after this method returns. To receive notification when rendering is
   * complete, use the renderAsync method instead.
   * @param {object} scene - The root mark of a scenegraph to render.
   * @param {Array} markTypes - Array of the mark types to render.
   *                            If undefined, render all mark types
   * @return {Renderer} - This renderer instance.
   */
  render(scene, markTypes) {
    const r = this;
    r._call = function() {
      r._render(scene, markTypes);
    };
    r._call();
    r._call = null;
    return r;
  }
  /**
   * Internal rendering method. Renderer subclasses should override this
   * method to actually perform rendering.
   * @param {object} scene - The root mark of a scenegraph to render.
   * @param {Array} markTypes - Array of the mark types to render.
   *                            If undefined, render all mark types
   */
  _render() {
  }
  /**
   * Asynchronous rendering method. Similar to render, but returns a Promise
   * that resolves when all rendering is completed. Sometimes a renderer must
   * perform image loading to get a complete rendering. The returned
   * Promise will not resolve until this process completes.
   * @param {object} scene - The root mark of a scenegraph to render.
   * @param {Array} markTypes - Array of the mark types to render.
   *                            If undefined, render all mark types
   * @return {Promise} - A Promise that resolves when rendering is complete.
   */
  renderAsync(scene, markTypes) {
    const r = this.render(scene, markTypes);
    return this._ready ? this._ready.then(() => r) : Promise.resolve(r);
  }
  /**
   * Internal method for asynchronous resource loading.
   * Proxies method calls to the ImageLoader, and tracks loading
   * progress to invoke a re-render once complete.
   * @param {string} method - The method name to invoke on the ImageLoader.
   * @param {string} uri - The URI for the requested resource.
   * @return {Promise} - A Promise that resolves to the requested resource.
   */
  _load(method10, uri) {
    var r = this, p = r._loader[method10](uri);
    if (!r._ready) {
      const call = r._call;
      r._ready = r._loader.ready().then((redraw) => {
        if (redraw)
          call();
        r._ready = null;
      });
    }
    return p;
  }
  /**
   * Sanitize a URL to include as a hyperlink in the rendered scene.
   * This method proxies a call to ImageLoader.sanitizeURL, but also tracks
   * image loading progress and invokes a re-render once complete.
   * @param {string} uri - The URI string to sanitize.
   * @return {Promise} - A Promise that resolves to the sanitized URL.
   */
  sanitizeURL(uri) {
    return this._load("sanitizeURL", uri);
  }
  /**
   * Requests an image to include in the rendered scene.
   * This method proxies a call to ImageLoader.loadImage, but also tracks
   * image loading progress and invokes a re-render once complete.
   * @param {string} uri - The URI string of the image.
   * @return {Promise} - A Promise that resolves to the loaded Image.
   */
  loadImage(uri) {
    return this._load("loadImage", uri);
  }
};
var KeyDownEvent = "keydown";
var KeyPressEvent = "keypress";
var KeyUpEvent = "keyup";
var DragEnterEvent = "dragenter";
var DragLeaveEvent = "dragleave";
var DragOverEvent = "dragover";
var PointerDownEvent = "pointerdown";
var PointerUpEvent = "pointerup";
var PointerMoveEvent = "pointermove";
var PointerOutEvent = "pointerout";
var PointerOverEvent = "pointerover";
var MouseDownEvent = "mousedown";
var MouseUpEvent = "mouseup";
var MouseMoveEvent = "mousemove";
var MouseOutEvent = "mouseout";
var MouseOverEvent = "mouseover";
var ClickEvent = "click";
var DoubleClickEvent = "dblclick";
var WheelEvent = "wheel";
var MouseWheelEvent = "mousewheel";
var TouchStartEvent = "touchstart";
var TouchMoveEvent = "touchmove";
var TouchEndEvent = "touchend";
var Events = [KeyDownEvent, KeyPressEvent, KeyUpEvent, DragEnterEvent, DragLeaveEvent, DragOverEvent, PointerDownEvent, PointerUpEvent, PointerMoveEvent, PointerOutEvent, PointerOverEvent, MouseDownEvent, MouseUpEvent, MouseMoveEvent, MouseOutEvent, MouseOverEvent, ClickEvent, DoubleClickEvent, WheelEvent, MouseWheelEvent, TouchStartEvent, TouchMoveEvent, TouchEndEvent];
var TooltipShowEvent = PointerMoveEvent;
var TooltipHideEvent = MouseOutEvent;
var HrefEvent = ClickEvent;
var CanvasHandler = class extends Handler {
  constructor(loader7, tooltip2) {
    super(loader7, tooltip2);
    this._down = null;
    this._touch = null;
    this._first = true;
    this._events = {};
    this.events = Events;
    this.pointermove = move([PointerMoveEvent, MouseMoveEvent], [PointerOverEvent, MouseOverEvent], [PointerOutEvent, MouseOutEvent]);
    this.dragover = move([DragOverEvent], [DragEnterEvent], [DragLeaveEvent]), this.pointerout = inactive([PointerOutEvent, MouseOutEvent]);
    this.dragleave = inactive([DragLeaveEvent]);
  }
  initialize(el, origin, obj) {
    this._canvas = el && domFind(el, "canvas");
    [ClickEvent, MouseDownEvent, PointerDownEvent, PointerMoveEvent, PointerOutEvent, DragLeaveEvent].forEach((type7) => eventListenerCheck(this, type7));
    return super.initialize(el, origin, obj);
  }
  // return the backing canvas instance
  canvas() {
    return this._canvas;
  }
  // retrieve the current canvas context
  context() {
    return this._canvas.getContext("2d");
  }
  // to keep old versions of firefox happy
  DOMMouseScroll(evt) {
    this.fire(MouseWheelEvent, evt);
  }
  pointerdown(evt) {
    this._down = this._active;
    this.fire(PointerDownEvent, evt);
  }
  mousedown(evt) {
    this._down = this._active;
    this.fire(MouseDownEvent, evt);
  }
  click(evt) {
    if (this._down === this._active) {
      this.fire(ClickEvent, evt);
      this._down = null;
    }
  }
  touchstart(evt) {
    this._touch = this.pickEvent(evt.changedTouches[0]);
    if (this._first) {
      this._active = this._touch;
      this._first = false;
    }
    this.fire(TouchStartEvent, evt, true);
  }
  touchmove(evt) {
    this.fire(TouchMoveEvent, evt, true);
  }
  touchend(evt) {
    this.fire(TouchEndEvent, evt, true);
    this._touch = null;
  }
  // fire an event
  fire(type7, evt, touch2) {
    const a4 = touch2 ? this._touch : this._active, h6 = this._handlers[type7];
    evt.vegaType = type7;
    if (type7 === HrefEvent && a4 && a4.href) {
      this.handleHref(evt, a4, a4.href);
    } else if (type7 === TooltipShowEvent || type7 === TooltipHideEvent) {
      this.handleTooltip(evt, a4, type7 !== TooltipHideEvent);
    }
    if (h6) {
      for (let i = 0, len = h6.length; i < len; ++i) {
        h6[i].handler.call(this._obj, evt, a4);
      }
    }
  }
  // add an event handler
  on(type7, handler) {
    const name = this.eventName(type7), h6 = this._handlers, i = this._handlerIndex(h6[name], type7, handler);
    if (i < 0) {
      eventListenerCheck(this, type7);
      (h6[name] || (h6[name] = [])).push({
        type: type7,
        handler
      });
    }
    return this;
  }
  // remove an event handler
  off(type7, handler) {
    const name = this.eventName(type7), h6 = this._handlers[name], i = this._handlerIndex(h6, type7, handler);
    if (i >= 0) {
      h6.splice(i, 1);
    }
    return this;
  }
  pickEvent(evt) {
    const p = point7(evt, this._canvas), o = this._origin;
    return this.pick(this._scene, p[0], p[1], p[0] - o[0], p[1] - o[1]);
  }
  // find the scenegraph item at the current pointer position
  // x, y -- the absolute x, y pointer coordinates on the canvas element
  // gx, gy -- the relative coordinates within the current group
  pick(scene, x9, y9, gx, gy) {
    const g = this.context(), mark = Marks[scene.marktype];
    return mark.pick.call(this, g, scene, x9, y9, gx, gy);
  }
};
var eventBundle = (type7) => type7 === TouchStartEvent || type7 === TouchMoveEvent || type7 === TouchEndEvent ? [TouchStartEvent, TouchMoveEvent, TouchEndEvent] : [type7];
function eventListenerCheck(handler, type7) {
  eventBundle(type7).forEach((_) => addEventListener(handler, _));
}
function addEventListener(handler, type7) {
  const canvas = handler.canvas();
  if (canvas && !handler._events[type7]) {
    handler._events[type7] = 1;
    canvas.addEventListener(type7, handler[type7] ? (evt) => handler[type7](evt) : (evt) => handler.fire(type7, evt));
  }
}
function fireAll(handler, types, event2) {
  types.forEach((type7) => handler.fire(type7, event2));
}
function move(moveEvents, overEvents, outEvents) {
  return function(evt) {
    const a4 = this._active, p = this.pickEvent(evt);
    if (p === a4) {
      fireAll(this, moveEvents, evt);
    } else {
      if (!a4 || !a4.exit) {
        fireAll(this, outEvents, evt);
      }
      this._active = p;
      fireAll(this, overEvents, evt);
      fireAll(this, moveEvents, evt);
    }
  };
}
function inactive(types) {
  return function(evt) {
    fireAll(this, types, evt);
    this._active = null;
  };
}
function devicePixelRatio() {
  return typeof window !== "undefined" ? window.devicePixelRatio || 1 : 1;
}
function resize(canvas, width2, height2, origin, scaleFactor, opt) {
  const inDOM = typeof HTMLElement !== "undefined" && canvas instanceof HTMLElement && canvas.parentNode != null, context7 = canvas.getContext("2d"), ratio = inDOM ? devicePixelRatio() : scaleFactor;
  canvas.width = width2 * ratio;
  canvas.height = height2 * ratio;
  for (const key4 in opt) {
    context7[key4] = opt[key4];
  }
  if (inDOM && ratio !== 1) {
    canvas.style.width = width2 + "px";
    canvas.style.height = height2 + "px";
  }
  context7.pixelRatio = ratio;
  context7.setTransform(ratio, 0, 0, ratio, ratio * origin[0], ratio * origin[1]);
  return canvas;
}
var CanvasRenderer = class extends Renderer {
  constructor(loader7) {
    super(loader7);
    this._options = {};
    this._redraw = false;
    this._dirty = new Bounds();
    this._tempb = new Bounds();
  }
  initialize(el, width2, height2, origin, scaleFactor, options) {
    this._options = options || {};
    this._canvas = this._options.externalContext ? null : domCanvas(1, 1, this._options.type);
    if (el && this._canvas) {
      domClear(el, 0).appendChild(this._canvas);
      this._canvas.setAttribute("class", "marks");
    }
    return super.initialize(el, width2, height2, origin, scaleFactor);
  }
  resize(width2, height2, origin, scaleFactor) {
    super.resize(width2, height2, origin, scaleFactor);
    if (this._canvas) {
      resize(this._canvas, this._width, this._height, this._origin, this._scale, this._options.context);
    } else {
      const ctx = this._options.externalContext;
      if (!ctx)
        error4("CanvasRenderer is missing a valid canvas or context");
      ctx.scale(this._scale, this._scale);
      ctx.translate(this._origin[0], this._origin[1]);
    }
    this._redraw = true;
    return this;
  }
  canvas() {
    return this._canvas;
  }
  context() {
    return this._options.externalContext || (this._canvas ? this._canvas.getContext("2d") : null);
  }
  dirty(item) {
    const b6 = this._tempb.clear().union(item.bounds);
    let g = item.mark.group;
    while (g) {
      b6.translate(g.x || 0, g.y || 0);
      g = g.mark.group;
    }
    this._dirty.union(b6);
  }
  _render(scene, markTypes) {
    const g = this.context(), o = this._origin, w8 = this._width, h6 = this._height, db = this._dirty, vb = viewBounds(o, w8, h6);
    g.save();
    const b6 = this._redraw || db.empty() ? (this._redraw = false, vb.expand(1)) : clipToBounds(g, vb.intersect(db), o);
    this.clear(-o[0], -o[1], w8, h6);
    this.draw(g, scene, b6, markTypes);
    g.restore();
    db.clear();
    return this;
  }
  draw(ctx, scene, bounds6, markTypes) {
    if (scene.marktype !== "group" && markTypes != null && !markTypes.includes(scene.marktype)) {
      return;
    }
    const mark = Marks[scene.marktype];
    if (scene.clip)
      clip(ctx, scene);
    mark.draw.call(this, ctx, scene, bounds6, markTypes);
    if (scene.clip)
      ctx.restore();
  }
  clear(x9, y9, w8, h6) {
    const opt = this._options, g = this.context();
    if (opt.type !== "pdf" && !opt.externalContext) {
      g.clearRect(x9, y9, w8, h6);
    }
    if (this._bgcolor != null) {
      g.fillStyle = this._bgcolor;
      g.fillRect(x9, y9, w8, h6);
    }
  }
};
var viewBounds = (origin, width2, height2) => new Bounds().set(0, 0, width2, height2).translate(-origin[0], -origin[1]);
function clipToBounds(g, b6, origin) {
  b6.expand(1).round();
  if (g.pixelRatio % 1) {
    b6.scale(g.pixelRatio).round().scale(1 / g.pixelRatio);
  }
  b6.translate(-(origin[0] % 1), -(origin[1] % 1));
  g.beginPath();
  g.rect(b6.x1, b6.y1, b6.width(), b6.height());
  g.clip();
  return b6;
}
var SVGHandler = class extends Handler {
  constructor(loader7, tooltip2) {
    super(loader7, tooltip2);
    const h6 = this;
    h6._hrefHandler = listener(h6, (evt, item) => {
      if (item && item.href)
        h6.handleHref(evt, item, item.href);
    });
    h6._tooltipHandler = listener(h6, (evt, item) => {
      h6.handleTooltip(evt, item, evt.type !== TooltipHideEvent);
    });
  }
  initialize(el, origin, obj) {
    let svg = this._svg;
    if (svg) {
      svg.removeEventListener(HrefEvent, this._hrefHandler);
      svg.removeEventListener(TooltipShowEvent, this._tooltipHandler);
      svg.removeEventListener(TooltipHideEvent, this._tooltipHandler);
    }
    this._svg = svg = el && domFind(el, "svg");
    if (svg) {
      svg.addEventListener(HrefEvent, this._hrefHandler);
      svg.addEventListener(TooltipShowEvent, this._tooltipHandler);
      svg.addEventListener(TooltipHideEvent, this._tooltipHandler);
    }
    return super.initialize(el, origin, obj);
  }
  canvas() {
    return this._svg;
  }
  // add an event handler
  on(type7, handler) {
    const name = this.eventName(type7), h6 = this._handlers, i = this._handlerIndex(h6[name], type7, handler);
    if (i < 0) {
      const x9 = {
        type: type7,
        handler,
        listener: listener(this, handler)
      };
      (h6[name] || (h6[name] = [])).push(x9);
      if (this._svg) {
        this._svg.addEventListener(name, x9.listener);
      }
    }
    return this;
  }
  // remove an event handler
  off(type7, handler) {
    const name = this.eventName(type7), h6 = this._handlers[name], i = this._handlerIndex(h6, type7, handler);
    if (i >= 0) {
      if (this._svg) {
        this._svg.removeEventListener(name, h6[i].listener);
      }
      h6.splice(i, 1);
    }
    return this;
  }
};
var listener = (context7, handler) => (evt) => {
  let item = evt.target.__data__;
  item = Array.isArray(item) ? item[0] : item;
  evt.vegaType = evt.type;
  handler.call(context7._obj, evt, item);
};
var ARIA_HIDDEN = "aria-hidden";
var ARIA_LABEL = "aria-label";
var ARIA_ROLE = "role";
var ARIA_ROLEDESCRIPTION = "aria-roledescription";
var GRAPHICS_OBJECT = "graphics-object";
var GRAPHICS_SYMBOL = "graphics-symbol";
var bundle = (role, roledesc, label) => ({
  [ARIA_ROLE]: role,
  [ARIA_ROLEDESCRIPTION]: roledesc,
  [ARIA_LABEL]: label || void 0
});
var AriaIgnore = toSet4(["axis-domain", "axis-grid", "axis-label", "axis-tick", "axis-title", "legend-band", "legend-entry", "legend-gradient", "legend-label", "legend-title", "legend-symbol", "title"]);
var AriaGuides = {
  "axis": {
    desc: "axis",
    caption: axisCaption
  },
  "legend": {
    desc: "legend",
    caption: legendCaption
  },
  "title-text": {
    desc: "title",
    caption: (item) => `Title text '${titleCaption(item)}'`
  },
  "title-subtitle": {
    desc: "subtitle",
    caption: (item) => `Subtitle text '${titleCaption(item)}'`
  }
};
var AriaEncode = {
  ariaRole: ARIA_ROLE,
  ariaRoleDescription: ARIA_ROLEDESCRIPTION,
  description: ARIA_LABEL
};
function ariaItemAttributes(emit6, item) {
  const hide = item.aria === false;
  emit6(ARIA_HIDDEN, hide || void 0);
  if (hide || item.description == null) {
    for (const prop in AriaEncode) {
      emit6(AriaEncode[prop], void 0);
    }
  } else {
    const type7 = item.mark.marktype;
    emit6(ARIA_LABEL, item.description);
    emit6(ARIA_ROLE, item.ariaRole || (type7 === "group" ? GRAPHICS_OBJECT : GRAPHICS_SYMBOL));
    emit6(ARIA_ROLEDESCRIPTION, item.ariaRoleDescription || `${type7} mark`);
  }
}
function ariaMarkAttributes(mark) {
  return mark.aria === false ? {
    [ARIA_HIDDEN]: true
  } : AriaIgnore[mark.role] ? null : AriaGuides[mark.role] ? ariaGuide(mark, AriaGuides[mark.role]) : ariaMark(mark);
}
function ariaMark(mark) {
  const type7 = mark.marktype;
  const recurse6 = type7 === "group" || type7 === "text" || mark.items.some((_) => _.description != null && _.aria !== false);
  return bundle(recurse6 ? GRAPHICS_OBJECT : GRAPHICS_SYMBOL, `${type7} mark container`, mark.description);
}
function ariaGuide(mark, opt) {
  try {
    const item = mark.items[0], caption = opt.caption || (() => "");
    return bundle(opt.role || GRAPHICS_SYMBOL, opt.desc, item.description || caption(item));
  } catch (err) {
    return null;
  }
}
function titleCaption(item) {
  return array5(item.text).join(" ");
}
function axisCaption(item) {
  const datum2 = item.datum, orient2 = item.orient, title2 = datum2.title ? extractTitle(item) : null, ctx = item.context, scale19 = ctx.scales[datum2.scale].value, locale5 = ctx.dataflow.locale(), type7 = scale19.type, xy = orient2 === "left" || orient2 === "right" ? "Y" : "X";
  return `${xy}-axis` + (title2 ? ` titled '${title2}'` : "") + ` for a ${isDiscrete(type7) ? "discrete" : type7} scale with ${domainCaption(locale5, scale19, item)}`;
}
function legendCaption(item) {
  const datum2 = item.datum, title2 = datum2.title ? extractTitle(item) : null, type7 = `${datum2.type || ""} legend`.trim(), scales10 = datum2.scales, props = Object.keys(scales10), ctx = item.context, scale19 = ctx.scales[scales10[props[0]]].value, locale5 = ctx.dataflow.locale();
  return capitalize(type7) + (title2 ? ` titled '${title2}'` : "") + ` for ${channelCaption(props)} with ${domainCaption(locale5, scale19, item)}`;
}
function extractTitle(item) {
  try {
    return array5(peek4(item.items).items[0].text).join(" ");
  } catch (err) {
    return null;
  }
}
function channelCaption(props) {
  props = props.map((p) => p + (p === "fill" || p === "stroke" ? " color" : ""));
  return props.length < 2 ? props[0] : props.slice(0, -1).join(", ") + " and " + peek4(props);
}
function capitalize(s2) {
  return s2.length ? s2[0].toUpperCase() + s2.slice(1) : s2;
}
var innerText = (val) => (val + "").replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
var attrText = (val) => innerText(val).replace(/"/g, "&quot;").replace(/\t/g, "&#x9;").replace(/\n/g, "&#xA;").replace(/\r/g, "&#xD;");
function markup() {
  let buf = "", outer = "", inner = "";
  const stack2 = [], clear2 = () => outer = inner = "", push = (tag) => {
    if (outer) {
      buf += `${outer}>${inner}`;
      clear2();
    }
    stack2.push(tag);
  }, attr6 = (name, value7) => {
    if (value7 != null)
      outer += ` ${name}="${attrText(value7)}"`;
    return m3;
  }, m3 = {
    open(tag, ...attrs) {
      push(tag);
      outer = "<" + tag;
      for (const set7 of attrs) {
        for (const key4 in set7)
          attr6(key4, set7[key4]);
      }
      return m3;
    },
    close() {
      const tag = stack2.pop();
      if (outer) {
        buf += outer + (inner ? `>${inner}</${tag}>` : "/>");
      } else {
        buf += `</${tag}>`;
      }
      clear2();
      return m3;
    },
    attr: attr6,
    text: (t) => (inner += innerText(t), m3),
    toString: () => buf
  };
  return m3;
}
var serializeXML = (node) => _serialize(markup(), node) + "";
function _serialize(m3, node) {
  m3.open(node.tagName);
  if (node.hasAttributes()) {
    const attrs = node.attributes, n = attrs.length;
    for (let i = 0; i < n; ++i) {
      m3.attr(attrs[i].name, attrs[i].value);
    }
  }
  if (node.hasChildNodes()) {
    const children3 = node.childNodes;
    for (const child of children3) {
      child.nodeType === 3 ? m3.text(child.nodeValue) : _serialize(m3, child);
    }
  }
  return m3.close();
}
var stylesAttr = {
  fill: "fill",
  fillOpacity: "fill-opacity",
  stroke: "stroke",
  strokeOpacity: "stroke-opacity",
  strokeWidth: "stroke-width",
  strokeCap: "stroke-linecap",
  strokeJoin: "stroke-linejoin",
  strokeDash: "stroke-dasharray",
  strokeDashOffset: "stroke-dashoffset",
  strokeMiterLimit: "stroke-miterlimit",
  opacity: "opacity"
};
var stylesCss = {
  blend: "mix-blend-mode"
};
var rootAttributes = {
  "fill": "none",
  "stroke-miterlimit": 10
};
var RootIndex = 0;
var xmlns = "http://www.w3.org/2000/xmlns/";
var svgns = metadata.xmlns;
var SVGRenderer = class extends Renderer {
  constructor(loader7) {
    super(loader7);
    this._dirtyID = 0;
    this._dirty = [];
    this._svg = null;
    this._root = null;
    this._defs = null;
  }
  /**
   * Initialize a new SVGRenderer instance.
   * @param {DOMElement} el - The containing DOM element for the display.
   * @param {number} width - The coordinate width of the display, in pixels.
   * @param {number} height - The coordinate height of the display, in pixels.
   * @param {Array<number>} origin - The origin of the display, in pixels.
   *   The coordinate system will be translated to this point.
   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
   *   the width and height to determine the final pixel size.
   * @return {SVGRenderer} - This renderer instance.
   */
  initialize(el, width2, height2, origin, scaleFactor) {
    this._defs = {};
    this._clearDefs();
    if (el) {
      this._svg = domChild(el, 0, "svg", svgns);
      this._svg.setAttributeNS(xmlns, "xmlns", svgns);
      this._svg.setAttributeNS(xmlns, "xmlns:xlink", metadata["xmlns:xlink"]);
      this._svg.setAttribute("version", metadata["version"]);
      this._svg.setAttribute("class", "marks");
      domClear(el, 1);
      this._root = domChild(this._svg, RootIndex, "g", svgns);
      setAttributes(this._root, rootAttributes);
      domClear(this._svg, RootIndex + 1);
    }
    this.background(this._bgcolor);
    return super.initialize(el, width2, height2, origin, scaleFactor);
  }
  /**
   * Get / set the background color.
   */
  background(bgcolor) {
    if (arguments.length && this._svg) {
      this._svg.style.setProperty("background-color", bgcolor);
    }
    return super.background(...arguments);
  }
  /**
   * Resize the display.
   * @param {number} width - The new coordinate width of the display, in pixels.
   * @param {number} height - The new coordinate height of the display, in pixels.
   * @param {Array<number>} origin - The new origin of the display, in pixels.
   *   The coordinate system will be translated to this point.
   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
   *   the width and height to determine the final pixel size.
   * @return {SVGRenderer} - This renderer instance;
   */
  resize(width2, height2, origin, scaleFactor) {
    super.resize(width2, height2, origin, scaleFactor);
    if (this._svg) {
      setAttributes(this._svg, {
        width: this._width * this._scale,
        height: this._height * this._scale,
        viewBox: `0 0 ${this._width} ${this._height}`
      });
      this._root.setAttribute("transform", `translate(${this._origin})`);
    }
    this._dirty = [];
    return this;
  }
  /**
   * Returns the SVG element of the visualization.
   * @return {DOMElement} - The SVG element.
   */
  canvas() {
    return this._svg;
  }
  /**
   * Returns an SVG text string for the rendered content,
   * or null if this renderer is currently headless.
   */
  svg() {
    const svg = this._svg, bg = this._bgcolor;
    if (!svg)
      return null;
    let node;
    if (bg) {
      svg.removeAttribute("style");
      node = domChild(svg, RootIndex, "rect", svgns);
      setAttributes(node, {
        width: this._width,
        height: this._height,
        fill: bg
      });
    }
    const text7 = serializeXML(svg);
    if (bg) {
      svg.removeChild(node);
      this._svg.style.setProperty("background-color", bg);
    }
    return text7;
  }
  /**
   * Internal rendering method.
   * @param {object} scene - The root mark of a scenegraph to render.
   * @param {Array} markTypes - Array of the mark types to render.
   *                            If undefined, render all mark types
   */
  _render(scene, markTypes) {
    if (this._dirtyCheck()) {
      if (this._dirtyAll)
        this._clearDefs();
      this.mark(this._root, scene, void 0, markTypes);
      domClear(this._root, 1);
    }
    this.defs();
    this._dirty = [];
    ++this._dirtyID;
    return this;
  }
  // -- Manage rendering of items marked as dirty --
  /**
   * Flag a mark item as dirty.
   * @param {Item} item - The mark item.
   */
  dirty(item) {
    if (item.dirty !== this._dirtyID) {
      item.dirty = this._dirtyID;
      this._dirty.push(item);
    }
  }
  /**
   * Check if a mark item is considered dirty.
   * @param {Item} item - The mark item.
   */
  isDirty(item) {
    return this._dirtyAll || !item._svg || !item._svg.ownerSVGElement || item.dirty === this._dirtyID;
  }
  /**
   * Internal method to check dirty status and, if possible,
   * make targetted updates without a full rendering pass.
   */
  _dirtyCheck() {
    this._dirtyAll = true;
    const items = this._dirty;
    if (!items.length || !this._dirtyID)
      return true;
    const id24 = ++this._dirtyID;
    let item, mark, type7, mdef, i, n, o;
    for (i = 0, n = items.length; i < n; ++i) {
      item = items[i];
      mark = item.mark;
      if (mark.marktype !== type7) {
        type7 = mark.marktype;
        mdef = Marks[type7];
      }
      if (mark.zdirty && mark.dirty !== id24) {
        this._dirtyAll = false;
        dirtyParents(item, id24);
        mark.items.forEach((i2) => {
          i2.dirty = id24;
        });
      }
      if (mark.zdirty)
        continue;
      if (item.exit) {
        if (mdef.nested && mark.items.length) {
          o = mark.items[0];
          if (o._svg)
            this._update(mdef, o._svg, o);
        } else if (item._svg) {
          o = item._svg.parentNode;
          if (o)
            o.removeChild(item._svg);
        }
        item._svg = null;
        continue;
      }
      item = mdef.nested ? mark.items[0] : item;
      if (item._update === id24)
        continue;
      if (!item._svg || !item._svg.ownerSVGElement) {
        this._dirtyAll = false;
        dirtyParents(item, id24);
      } else {
        this._update(mdef, item._svg, item);
      }
      item._update = id24;
    }
    return !this._dirtyAll;
  }
  // -- Construct & maintain scenegraph to SVG mapping ---
  /**
   * Render a set of mark items.
   * @param {SVGElement} el - The parent element in the SVG tree.
   * @param {object} scene - The mark parent to render.
   * @param {SVGElement} prev - The previous sibling in the SVG tree.
   * @param {Array} markTypes - Array of the mark types to render.
   *                            If undefined, render all mark types
   */
  mark(el, scene, prev, markTypes) {
    if (!this.isDirty(scene)) {
      return scene._svg;
    }
    const svg = this._svg, markType2 = scene.marktype, mdef = Marks[markType2], events3 = scene.interactive === false ? "none" : null, isGroup = mdef.tag === "g";
    const parent = bind(scene, el, prev, "g", svg);
    if (markType2 !== "group" && markTypes != null && !markTypes.includes(markType2)) {
      domClear(parent, 0);
      return scene._svg;
    }
    parent.setAttribute("class", cssClass(scene));
    const aria2 = ariaMarkAttributes(scene);
    for (const key4 in aria2)
      setAttribute(parent, key4, aria2[key4]);
    if (!isGroup) {
      setAttribute(parent, "pointer-events", events3);
    }
    setAttribute(parent, "clip-path", scene.clip ? clip$1(this, scene, scene.group) : null);
    let sibling = null, i = 0;
    const process2 = (item) => {
      const dirty = this.isDirty(item), node = bind(item, parent, sibling, mdef.tag, svg);
      if (dirty) {
        this._update(mdef, node, item);
        if (isGroup)
          recurse(this, node, item, markTypes);
      }
      sibling = node;
      ++i;
    };
    if (mdef.nested) {
      if (scene.items.length)
        process2(scene.items[0]);
    } else {
      visit(scene, process2);
    }
    domClear(parent, i);
    return parent;
  }
  /**
   * Update the attributes of an SVG element for a mark item.
   * @param {object} mdef - The mark definition object
   * @param {SVGElement} el - The SVG element.
   * @param {Item} item - The mark item.
   */
  _update(mdef, el, item) {
    element = el;
    values = el.__values__;
    ariaItemAttributes(emit, item);
    mdef.attr(emit, item, this);
    const extra = mark_extras[mdef.type];
    if (extra)
      extra.call(this, mdef, el, item);
    if (element)
      this.style(element, item);
  }
  /**
   * Update the presentation attributes of an SVG element for a mark item.
   * @param {SVGElement} el - The SVG element.
   * @param {Item} item - The mark item.
   */
  style(el, item) {
    if (item == null)
      return;
    for (const prop in stylesAttr) {
      let value7 = prop === "font" ? fontFamily(item) : item[prop];
      if (value7 === values[prop])
        continue;
      const name = stylesAttr[prop];
      if (value7 == null) {
        el.removeAttribute(name);
      } else {
        if (isGradient(value7)) {
          value7 = gradientRef(value7, this._defs.gradient, href());
        }
        el.setAttribute(name, value7 + "");
      }
      values[prop] = value7;
    }
    for (const prop in stylesCss) {
      setStyle(el, stylesCss[prop], item[prop]);
    }
  }
  /**
   * Render SVG defs, as needed.
   * Must be called *after* marks have been processed to ensure the
   * collected state is current and accurate.
   */
  defs() {
    const svg = this._svg, defs = this._defs;
    let el = defs.el, index4 = 0;
    for (const id24 in defs.gradient) {
      if (!el)
        defs.el = el = domChild(svg, RootIndex + 1, "defs", svgns);
      index4 = updateGradient(el, defs.gradient[id24], index4);
    }
    for (const id24 in defs.clipping) {
      if (!el)
        defs.el = el = domChild(svg, RootIndex + 1, "defs", svgns);
      index4 = updateClipping(el, defs.clipping[id24], index4);
    }
    if (el) {
      index4 === 0 ? (svg.removeChild(el), defs.el = null) : domClear(el, index4);
    }
  }
  /**
   * Clear defs caches.
   */
  _clearDefs() {
    const def6 = this._defs;
    def6.gradient = {};
    def6.clipping = {};
  }
};
function dirtyParents(item, id24) {
  for (; item && item.dirty !== id24; item = item.mark.group) {
    item.dirty = id24;
    if (item.mark && item.mark.dirty !== id24) {
      item.mark.dirty = id24;
    } else
      return;
  }
}
function updateGradient(el, grad, index4) {
  let i, n, stop2;
  if (grad.gradient === "radial") {
    let pt = domChild(el, index4++, "pattern", svgns);
    setAttributes(pt, {
      id: patternPrefix + grad.id,
      viewBox: "0,0,1,1",
      width: "100%",
      height: "100%",
      preserveAspectRatio: "xMidYMid slice"
    });
    pt = domChild(pt, 0, "rect", svgns);
    setAttributes(pt, {
      width: 1,
      height: 1,
      fill: `url(${href()}#${grad.id})`
    });
    el = domChild(el, index4++, "radialGradient", svgns);
    setAttributes(el, {
      id: grad.id,
      fx: grad.x1,
      fy: grad.y1,
      fr: grad.r1,
      cx: grad.x2,
      cy: grad.y2,
      r: grad.r2
    });
  } else {
    el = domChild(el, index4++, "linearGradient", svgns);
    setAttributes(el, {
      id: grad.id,
      x1: grad.x1,
      x2: grad.x2,
      y1: grad.y1,
      y2: grad.y2
    });
  }
  for (i = 0, n = grad.stops.length; i < n; ++i) {
    stop2 = domChild(el, i, "stop", svgns);
    stop2.setAttribute("offset", grad.stops[i].offset);
    stop2.setAttribute("stop-color", grad.stops[i].color);
  }
  domClear(el, i);
  return index4;
}
function updateClipping(el, clip7, index4) {
  let mask;
  el = domChild(el, index4, "clipPath", svgns);
  el.setAttribute("id", clip7.id);
  if (clip7.path) {
    mask = domChild(el, 0, "path", svgns);
    mask.setAttribute("d", clip7.path);
  } else {
    mask = domChild(el, 0, "rect", svgns);
    setAttributes(mask, {
      x: 0,
      y: 0,
      width: clip7.width,
      height: clip7.height
    });
  }
  domClear(el, 1);
  return index4 + 1;
}
function recurse(renderer, el, group7, markTypes) {
  el = el.lastChild.previousSibling;
  let prev, idx = 0;
  visit(group7, (item) => {
    prev = renderer.mark(el, item, prev, markTypes);
    ++idx;
  });
  domClear(el, 1 + idx);
}
function bind(item, el, sibling, tag, svg) {
  let node = item._svg, doc;
  if (!node) {
    doc = el.ownerDocument;
    node = domCreate(doc, tag, svgns);
    item._svg = node;
    if (item.mark) {
      node.__data__ = item;
      node.__values__ = {
        fill: "default"
      };
      if (tag === "g") {
        const bg = domCreate(doc, "path", svgns);
        node.appendChild(bg);
        bg.__data__ = item;
        const cg = domCreate(doc, "g", svgns);
        node.appendChild(cg);
        cg.__data__ = item;
        const fg = domCreate(doc, "path", svgns);
        node.appendChild(fg);
        fg.__data__ = item;
        fg.__values__ = {
          fill: "default"
        };
      }
    }
  }
  if (node.ownerSVGElement !== svg || siblingCheck(node, sibling)) {
    el.insertBefore(node, sibling ? sibling.nextSibling : el.firstChild);
  }
  return node;
}
function siblingCheck(node, sibling) {
  return node.parentNode && node.parentNode.childNodes.length > 1 && node.previousSibling != sibling;
}
var element = null;
var values = null;
var mark_extras = {
  group(mdef, el, item) {
    const fg = element = el.childNodes[2];
    values = fg.__values__;
    mdef.foreground(emit, item, this);
    values = el.__values__;
    element = el.childNodes[1];
    mdef.content(emit, item, this);
    const bg = element = el.childNodes[0];
    mdef.background(emit, item, this);
    const value7 = item.mark.interactive === false ? "none" : null;
    if (value7 !== values.events) {
      setAttribute(fg, "pointer-events", value7);
      setAttribute(bg, "pointer-events", value7);
      values.events = value7;
    }
    if (item.strokeForeground && item.stroke) {
      const fill6 = item.fill;
      setAttribute(fg, "display", null);
      this.style(bg, item);
      setAttribute(bg, "stroke", null);
      if (fill6)
        item.fill = null;
      values = fg.__values__;
      this.style(fg, item);
      if (fill6)
        item.fill = fill6;
      element = null;
    } else {
      setAttribute(fg, "display", "none");
    }
  },
  image(mdef, el, item) {
    if (item.smooth === false) {
      setStyle(el, "image-rendering", "optimizeSpeed");
      setStyle(el, "image-rendering", "pixelated");
    } else {
      setStyle(el, "image-rendering", null);
    }
  },
  text(mdef, el, item) {
    const tl6 = textLines(item);
    let key4, value7, doc, lh;
    if (isArray4(tl6)) {
      value7 = tl6.map((_) => textValue(item, _));
      key4 = value7.join("\n");
      if (key4 !== values.text) {
        domClear(el, 0);
        doc = el.ownerDocument;
        lh = lineHeight(item);
        value7.forEach((t, i) => {
          const ts6 = domCreate(doc, "tspan", svgns);
          ts6.__data__ = item;
          ts6.textContent = t;
          if (i) {
            ts6.setAttribute("x", 0);
            ts6.setAttribute("dy", lh);
          }
          el.appendChild(ts6);
        });
        values.text = key4;
      }
    } else {
      value7 = textValue(item, tl6);
      if (value7 !== values.text) {
        el.textContent = value7;
        values.text = value7;
      }
    }
    setAttribute(el, "font-family", fontFamily(item));
    setAttribute(el, "font-size", fontSize(item) + "px");
    setAttribute(el, "font-style", item.fontStyle);
    setAttribute(el, "font-variant", item.fontVariant);
    setAttribute(el, "font-weight", item.fontWeight);
  }
};
function emit(name, value7, ns) {
  if (value7 === values[name])
    return;
  if (ns) {
    setAttributeNS(element, name, value7, ns);
  } else {
    setAttribute(element, name, value7);
  }
  values[name] = value7;
}
function setStyle(el, name, value7) {
  if (value7 !== values[name]) {
    if (value7 == null) {
      el.style.removeProperty(name);
    } else {
      el.style.setProperty(name, value7 + "");
    }
    values[name] = value7;
  }
}
function setAttributes(el, attrs) {
  for (const key4 in attrs) {
    setAttribute(el, key4, attrs[key4]);
  }
}
function setAttribute(el, name, value7) {
  if (value7 != null) {
    el.setAttribute(name, value7);
  } else {
    el.removeAttribute(name);
  }
}
function setAttributeNS(el, name, value7, ns) {
  if (value7 != null) {
    el.setAttributeNS(ns, name, value7);
  } else {
    el.removeAttributeNS(ns, name);
  }
}
function href() {
  let loc;
  return typeof window === "undefined" ? "" : (loc = window.location).hash ? loc.href.slice(0, -loc.hash.length) : loc.href;
}
var SVGStringRenderer = class extends Renderer {
  constructor(loader7) {
    super(loader7);
    this._text = null;
    this._defs = {
      gradient: {},
      clipping: {}
    };
  }
  /**
   * Returns the rendered SVG text string,
   * or null if rendering has not yet occurred.
   */
  svg() {
    return this._text;
  }
  /**
   * Internal rendering method.
   * @param {object} scene - The root mark of a scenegraph to render.
   */
  _render(scene) {
    const m3 = markup();
    m3.open("svg", extend4({}, metadata, {
      class: "marks",
      width: this._width * this._scale,
      height: this._height * this._scale,
      viewBox: `0 0 ${this._width} ${this._height}`
    }));
    const bg = this._bgcolor;
    if (bg && bg !== "transparent" && bg !== "none") {
      m3.open("rect", {
        width: this._width,
        height: this._height,
        fill: bg
      }).close();
    }
    m3.open("g", rootAttributes, {
      transform: "translate(" + this._origin + ")"
    });
    this.mark(m3, scene);
    m3.close();
    this.defs(m3);
    this._text = m3.close() + "";
    return this;
  }
  /**
   * Render a set of mark items.
   * @param {object} m - The markup context.
   * @param {object} scene - The mark parent to render.
   */
  mark(m3, scene) {
    const mdef = Marks[scene.marktype], tag = mdef.tag, attrList = [ariaItemAttributes, mdef.attr];
    m3.open("g", {
      "class": cssClass(scene),
      "clip-path": scene.clip ? clip$1(this, scene, scene.group) : null
    }, ariaMarkAttributes(scene), {
      "pointer-events": tag !== "g" && scene.interactive === false ? "none" : null
    });
    const process2 = (item) => {
      const href6 = this.href(item);
      if (href6)
        m3.open("a", href6);
      m3.open(tag, this.attr(scene, item, attrList, tag !== "g" ? tag : null));
      if (tag === "text") {
        const tl6 = textLines(item);
        if (isArray4(tl6)) {
          const attrs = {
            x: 0,
            dy: lineHeight(item)
          };
          for (let i = 0; i < tl6.length; ++i) {
            m3.open("tspan", i ? attrs : null).text(textValue(item, tl6[i])).close();
          }
        } else {
          m3.text(textValue(item, tl6));
        }
      } else if (tag === "g") {
        const fore = item.strokeForeground, fill6 = item.fill, stroke6 = item.stroke;
        if (fore && stroke6) {
          item.stroke = null;
        }
        m3.open("path", this.attr(scene, item, mdef.background, "bgrect")).close();
        m3.open("g", this.attr(scene, item, mdef.content));
        visit(item, (scene2) => this.mark(m3, scene2));
        m3.close();
        if (fore && stroke6) {
          if (fill6)
            item.fill = null;
          item.stroke = stroke6;
          m3.open("path", this.attr(scene, item, mdef.foreground, "bgrect")).close();
          if (fill6)
            item.fill = fill6;
        } else {
          m3.open("path", this.attr(scene, item, mdef.foreground, "bgfore")).close();
        }
      }
      m3.close();
      if (href6)
        m3.close();
    };
    if (mdef.nested) {
      if (scene.items && scene.items.length)
        process2(scene.items[0]);
    } else {
      visit(scene, process2);
    }
    return m3.close();
  }
  /**
   * Get href attributes for a hyperlinked mark item.
   * @param {Item} item - The mark item.
   */
  href(item) {
    const href6 = item.href;
    let attr6;
    if (href6) {
      if (attr6 = this._hrefs && this._hrefs[href6]) {
        return attr6;
      } else {
        this.sanitizeURL(href6).then((attr7) => {
          attr7["xlink:href"] = attr7.href;
          attr7.href = null;
          (this._hrefs || (this._hrefs = {}))[href6] = attr7;
        });
      }
    }
    return null;
  }
  /**
   * Get an object of SVG attributes for a mark item.
   * @param {object} scene - The mark parent.
   * @param {Item} item - The mark item.
   * @param {array|function} attrs - One or more attribute emitters.
   * @param {string} tag - The tag being rendered.
   */
  attr(scene, item, attrs, tag) {
    const object2 = {}, emit6 = (name, value7, ns, prefixed) => {
      object2[prefixed || name] = value7;
    };
    if (Array.isArray(attrs)) {
      attrs.forEach((fn) => fn(emit6, item, this));
    } else {
      attrs(emit6, item, this);
    }
    if (tag) {
      style(object2, item, scene, tag, this._defs);
    }
    return object2;
  }
  /**
   * Render SVG defs, as needed.
   * Must be called *after* marks have been processed to ensure the
   * collected state is current and accurate.
   * @param {object} m - The markup context.
   */
  defs(m3) {
    const gradient8 = this._defs.gradient, clipping = this._defs.clipping, count3 = Object.keys(gradient8).length + Object.keys(clipping).length;
    if (count3 === 0)
      return;
    m3.open("defs");
    for (const id24 in gradient8) {
      const def6 = gradient8[id24], stops = def6.stops;
      if (def6.gradient === "radial") {
        m3.open("pattern", {
          id: patternPrefix + id24,
          viewBox: "0,0,1,1",
          width: "100%",
          height: "100%",
          preserveAspectRatio: "xMidYMid slice"
        });
        m3.open("rect", {
          width: "1",
          height: "1",
          fill: "url(#" + id24 + ")"
        }).close();
        m3.close();
        m3.open("radialGradient", {
          id: id24,
          fx: def6.x1,
          fy: def6.y1,
          fr: def6.r1,
          cx: def6.x2,
          cy: def6.y2,
          r: def6.r2
        });
      } else {
        m3.open("linearGradient", {
          id: id24,
          x1: def6.x1,
          x2: def6.x2,
          y1: def6.y1,
          y2: def6.y2
        });
      }
      for (let i = 0; i < stops.length; ++i) {
        m3.open("stop", {
          offset: stops[i].offset,
          "stop-color": stops[i].color
        }).close();
      }
      m3.close();
    }
    for (const id24 in clipping) {
      const def6 = clipping[id24];
      m3.open("clipPath", {
        id: id24
      });
      if (def6.path) {
        m3.open("path", {
          d: def6.path
        }).close();
      } else {
        m3.open("rect", {
          x: 0,
          y: 0,
          width: def6.width,
          height: def6.height
        }).close();
      }
      m3.close();
    }
    m3.close();
  }
};
function style(s2, item, scene, tag, defs) {
  let styleList;
  if (item == null)
    return s2;
  if (tag === "bgrect" && scene.interactive === false) {
    s2["pointer-events"] = "none";
  }
  if (tag === "bgfore") {
    if (scene.interactive === false) {
      s2["pointer-events"] = "none";
    }
    s2.display = "none";
    if (item.fill !== null)
      return s2;
  }
  if (tag === "image" && item.smooth === false) {
    styleList = ["image-rendering: optimizeSpeed;", "image-rendering: pixelated;"];
  }
  if (tag === "text") {
    s2["font-family"] = fontFamily(item);
    s2["font-size"] = fontSize(item) + "px";
    s2["font-style"] = item.fontStyle;
    s2["font-variant"] = item.fontVariant;
    s2["font-weight"] = item.fontWeight;
  }
  for (const prop in stylesAttr) {
    let value7 = item[prop];
    const name = stylesAttr[prop];
    if (value7 === "transparent" && (name === "fill" || name === "stroke"))
      ;
    else if (value7 != null) {
      if (isGradient(value7)) {
        value7 = gradientRef(value7, defs.gradient, "");
      }
      s2[name] = value7;
    }
  }
  for (const prop in stylesCss) {
    const value7 = item[prop];
    if (value7 != null) {
      styleList = styleList || [];
      styleList.push(`${stylesCss[prop]}: ${value7};`);
    }
  }
  if (styleList) {
    s2.style = styleList.join(" ");
  }
  return s2;
}
var OPTS = {
  svgMarkTypes: ["text"],
  svgOnTop: true,
  debug: false
};
var HybridRenderer = class extends Renderer {
  constructor(loader7) {
    super(loader7);
    this._svgRenderer = new SVGRenderer(loader7);
    this._canvasRenderer = new CanvasRenderer(loader7);
  }
  /**
   * Initialize a new HybridRenderer instance.
   * @param {DOMElement} el - The containing DOM element for the display.
   * @param {number} width - The coordinate width of the display, in pixels.
   * @param {number} height - The coordinate height of the display, in pixels.
   * @param {Array<number>} origin - The origin of the display, in pixels.
   *   The coordinate system will be translated to this point.
   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
   *   the width and height to determine the final pixel size.
   * @return {HybridRenderer} - This renderer instance.
   */
  initialize(el, width2, height2, origin, scaleFactor) {
    this._root_el = domChild(el, 0, "div");
    const bottomEl = domChild(this._root_el, 0, "div");
    const topEl = domChild(this._root_el, 1, "div");
    this._root_el.style.position = "relative";
    if (!OPTS.debug) {
      bottomEl.style.height = "100%";
      topEl.style.position = "absolute";
      topEl.style.top = "0";
      topEl.style.left = "0";
      topEl.style.height = "100%";
      topEl.style.width = "100%";
    }
    this._svgEl = OPTS.svgOnTop ? topEl : bottomEl;
    this._canvasEl = OPTS.svgOnTop ? bottomEl : topEl;
    this._svgEl.style.pointerEvents = "none";
    this._canvasRenderer.initialize(this._canvasEl, width2, height2, origin, scaleFactor);
    this._svgRenderer.initialize(this._svgEl, width2, height2, origin, scaleFactor);
    return super.initialize(el, width2, height2, origin, scaleFactor);
  }
  /**
   * Flag a mark item as dirty.
   * @param {Item} item - The mark item.
   */
  dirty(item) {
    if (OPTS.svgMarkTypes.includes(item.mark.marktype)) {
      this._svgRenderer.dirty(item);
    } else {
      this._canvasRenderer.dirty(item);
    }
    return this;
  }
  /**
   * Internal rendering method.
   * @param {object} scene - The root mark of a scenegraph to render.
   * @param {Array} markTypes - Array of the mark types to render.
   *                            If undefined, render all mark types
   */
  _render(scene, markTypes) {
    const allMarkTypes = markTypes ?? ["arc", "area", "image", "line", "path", "rect", "rule", "shape", "symbol", "text", "trail"];
    const canvasMarkTypes = allMarkTypes.filter((m3) => !OPTS.svgMarkTypes.includes(m3));
    this._svgRenderer.render(scene, OPTS.svgMarkTypes);
    this._canvasRenderer.render(scene, canvasMarkTypes);
  }
  /**
   * Resize the display.
   * @param {number} width - The new coordinate width of the display, in pixels.
   * @param {number} height - The new coordinate height of the display, in pixels.
   * @param {Array<number>} origin - The new origin of the display, in pixels.
   *   The coordinate system will be translated to this point.
   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
   *   the width and height to determine the final pixel size.
   * @return {SVGRenderer} - This renderer instance;
   */
  resize(width2, height2, origin, scaleFactor) {
    super.resize(width2, height2, origin, scaleFactor);
    this._svgRenderer.resize(width2, height2, origin, scaleFactor);
    this._canvasRenderer.resize(width2, height2, origin, scaleFactor);
    return this;
  }
  background(bgcolor) {
    if (OPTS.svgOnTop) {
      this._canvasRenderer.background(bgcolor);
    } else {
      this._svgRenderer.background(bgcolor);
    }
    return this;
  }
};
var HybridHandler = class extends CanvasHandler {
  constructor(loader7, tooltip2) {
    super(loader7, tooltip2);
  }
  initialize(el, origin, obj) {
    const canvas = domChild(domChild(el, 0, "div"), OPTS.svgOnTop ? 0 : 1, "div");
    return super.initialize(canvas, origin, obj);
  }
};
var Canvas = "canvas";
var Hybrid = "hybrid";
var PNG = "png";
var SVG = "svg";
var None3 = "none";
var modules = {};
modules[Canvas] = modules[PNG] = {
  renderer: CanvasRenderer,
  headless: CanvasRenderer,
  handler: CanvasHandler
};
modules[SVG] = {
  renderer: SVGRenderer,
  headless: SVGStringRenderer,
  handler: SVGHandler
};
modules[Hybrid] = {
  renderer: HybridRenderer,
  headless: HybridRenderer,
  handler: HybridHandler
};
modules[None3] = {};
var clipBounds = new Bounds();
function boundClip(mark) {
  const clip7 = mark.clip;
  if (isFunction4(clip7)) {
    clip7(boundContext(clipBounds.clear()));
  } else if (clip7) {
    clipBounds.set(0, 0, mark.group.width, mark.group.height);
  } else
    return;
  mark.bounds.intersect(clipBounds);
}

// node_modules/vega-view-transforms/build/vega-view-transforms.js
var Top = "top";
var Left = "left";
var Right = "right";
var Bottom = "bottom";
var TopLeft = "top-left";
var TopRight = "top-right";
var BottomLeft = "bottom-left";
var BottomRight = "bottom-right";
var Start = "start";
var Middle = "middle";
var End = "end";
var X = "x";
var Y = "y";
var Group = "group";
var AxisRole = "axis";
var TitleRole = "title";
var FrameRole = "frame";
var ScopeRole = "scope";
var LegendRole = "legend";
var RowHeader = "row-header";
var RowFooter = "row-footer";
var RowTitle = "row-title";
var ColHeader = "column-header";
var ColFooter = "column-footer";
var ColTitle = "column-title";
var Padding = "padding";
var Symbols = "symbol";
var Fit = "fit";
var FitX = "fit-x";
var FitY = "fit-y";
var Pad = "pad";
var None4 = "none";
var All = "all";
var Each = "each";
var Flush = "flush";
var Column = "column";
var Row = "row";
function Bound(params2) {
  Transform.call(this, null, params2);
}
inherits4(Bound, Transform, {
  transform(_, pulse2) {
    const view = pulse2.dataflow, mark = _.mark, type7 = mark.marktype, entry2 = Marks[type7], bound6 = entry2.bound;
    let markBounds = mark.bounds, rebound;
    if (entry2.nested) {
      if (mark.items.length)
        view.dirty(mark.items[0]);
      markBounds = boundItem(mark, bound6);
      mark.items.forEach((item) => {
        item.bounds.clear().union(markBounds);
      });
    } else if (type7 === Group || _.modified()) {
      pulse2.visit(pulse2.MOD, (item) => view.dirty(item));
      markBounds.clear();
      mark.items.forEach((item) => markBounds.union(boundItem(item, bound6)));
      switch (mark.role) {
        case AxisRole:
        case LegendRole:
        case TitleRole:
          pulse2.reflow();
      }
    } else {
      rebound = pulse2.changed(pulse2.REM);
      pulse2.visit(pulse2.ADD, (item) => {
        markBounds.union(boundItem(item, bound6));
      });
      pulse2.visit(pulse2.MOD, (item) => {
        rebound = rebound || markBounds.alignsWith(item.bounds);
        view.dirty(item);
        markBounds.union(boundItem(item, bound6));
      });
      if (rebound) {
        markBounds.clear();
        mark.items.forEach((item) => markBounds.union(item.bounds));
      }
    }
    boundClip(mark);
    return pulse2.modifies("bounds");
  }
});
function boundItem(item, bound6, opt) {
  return bound6(item.bounds.clear(), item, opt);
}
var COUNTER_NAME = ":vega_identifier:";
function Identifier(params2) {
  Transform.call(this, 0, params2);
}
Identifier.Definition = {
  "type": "Identifier",
  "metadata": {
    "modifies": true
  },
  "params": [{
    "name": "as",
    "type": "string",
    "required": true
  }]
};
inherits4(Identifier, Transform, {
  transform(_, pulse2) {
    const counter = getCounter(pulse2.dataflow), as = _.as;
    let id24 = counter.value;
    pulse2.visit(pulse2.ADD, (t) => t[as] = t[as] || ++id24);
    counter.set(this.value = id24);
    return pulse2;
  }
});
function getCounter(view) {
  return view._signals[COUNTER_NAME] || (view._signals[COUNTER_NAME] = view.add(0));
}
function Mark(params2) {
  Transform.call(this, null, params2);
}
inherits4(Mark, Transform, {
  transform(_, pulse2) {
    let mark = this.value;
    if (!mark) {
      mark = pulse2.dataflow.scenegraph().mark(_.markdef, lookup$1(_), _.index);
      mark.group.context = _.context;
      if (!_.context.group)
        _.context.group = mark.group;
      mark.source = this.source;
      mark.clip = _.clip;
      mark.interactive = _.interactive;
      this.value = mark;
    }
    const Init = mark.marktype === Group ? GroupItem : Item;
    pulse2.visit(pulse2.ADD, (item) => Init.call(item, mark));
    if (_.modified("clip") || _.modified("interactive")) {
      mark.clip = _.clip;
      mark.interactive = !!_.interactive;
      mark.zdirty = true;
      pulse2.reflow();
    }
    mark.items = pulse2.source;
    return pulse2;
  }
});
function lookup$1(_) {
  const g = _.groups, p = _.parent;
  return g && g.size === 1 ? g.get(Object.keys(g.object)[0]) : g && p ? g.lookup(p) : null;
}
function Overlap(params2) {
  Transform.call(this, null, params2);
}
var methods = {
  parity: (items) => items.filter((item, i) => i % 2 ? item.opacity = 0 : 1),
  greedy: (items, sep) => {
    let a4;
    return items.filter((b6, i) => !i || !intersect2(a4.bounds, b6.bounds, sep) ? (a4 = b6, 1) : b6.opacity = 0);
  }
};
var intersect2 = (a4, b6, sep) => sep > Math.max(b6.x1 - a4.x2, a4.x1 - b6.x2, b6.y1 - a4.y2, a4.y1 - b6.y2);
var hasOverlap = (items, pad5) => {
  for (var i = 1, n = items.length, a4 = items[0].bounds, b6; i < n; a4 = b6, ++i) {
    if (intersect2(a4, b6 = items[i].bounds, pad5))
      return true;
  }
};
var hasBounds = (item) => {
  const b6 = item.bounds;
  return b6.width() > 1 && b6.height() > 1;
};
var boundTest = (scale19, orient2, tolerance) => {
  var range7 = scale19.range(), b6 = new Bounds();
  if (orient2 === Top || orient2 === Bottom) {
    b6.set(range7[0], -Infinity, range7[1], Infinity);
  } else {
    b6.set(-Infinity, range7[0], Infinity, range7[1]);
  }
  b6.expand(tolerance || 1);
  return (item) => b6.encloses(item.bounds);
};
var reset = (source3) => {
  source3.forEach((item) => item.opacity = 1);
  return source3;
};
var reflow = (pulse2, _) => pulse2.reflow(_.modified()).modifies("opacity");
inherits4(Overlap, Transform, {
  transform(_, pulse2) {
    const reduce3 = methods[_.method] || methods.parity, sep = _.separation || 0;
    let source3 = pulse2.materialize(pulse2.SOURCE).source, items, test2;
    if (!source3 || !source3.length)
      return;
    if (!_.method) {
      if (_.modified("method")) {
        reset(source3);
        pulse2 = reflow(pulse2, _);
      }
      return pulse2;
    }
    source3 = source3.filter(hasBounds);
    if (!source3.length)
      return;
    if (_.sort) {
      source3 = source3.slice().sort(_.sort);
    }
    items = reset(source3);
    pulse2 = reflow(pulse2, _);
    if (items.length >= 3 && hasOverlap(items, sep)) {
      do {
        items = reduce3(items, sep);
      } while (items.length >= 3 && hasOverlap(items, sep));
      if (items.length < 3 && !peek4(source3).opacity) {
        if (items.length > 1)
          peek4(items).opacity = 0;
        peek4(source3).opacity = 1;
      }
    }
    if (_.boundScale && _.boundTolerance >= 0) {
      test2 = boundTest(_.boundScale, _.boundOrient, +_.boundTolerance);
      source3.forEach((item) => {
        if (!test2(item))
          item.opacity = 0;
      });
    }
    const bounds6 = items[0].mark.bounds.clear();
    source3.forEach((item) => {
      if (item.opacity)
        bounds6.union(item.bounds);
    });
    return pulse2;
  }
});
function Render(params2) {
  Transform.call(this, null, params2);
}
inherits4(Render, Transform, {
  transform(_, pulse2) {
    const view = pulse2.dataflow;
    pulse2.visit(pulse2.ALL, (item) => view.dirty(item));
    if (pulse2.fields && pulse2.fields["zindex"]) {
      const item = pulse2.source && pulse2.source[0];
      if (item)
        item.mark.zdirty = true;
    }
  }
});
var tempBounds2 = new Bounds();
function set3(item, property2, value7) {
  return item[property2] === value7 ? 0 : (item[property2] = value7, 1);
}
function isYAxis(mark) {
  var orient2 = mark.items[0].orient;
  return orient2 === Left || orient2 === Right;
}
function axisIndices(datum2) {
  let index4 = +datum2.grid;
  return [
    datum2.ticks ? index4++ : -1,
    // ticks index
    datum2.labels ? index4++ : -1,
    // labels index
    index4 + +datum2.domain
    // title index
  ];
}
function axisLayout(view, axis, width2, height2) {
  var item = axis.items[0], datum2 = item.datum, delta = item.translate != null ? item.translate : 0.5, orient2 = item.orient, indices = axisIndices(datum2), range7 = item.range, offset9 = item.offset, position2 = item.position, minExtent = item.minExtent, maxExtent = item.maxExtent, title2 = datum2.title && item.items[indices[2]].items[0], titlePadding = item.titlePadding, bounds6 = item.bounds, dl = title2 && multiLineOffset(title2), x9 = 0, y9 = 0, i, s2;
  tempBounds2.clear().union(bounds6);
  bounds6.clear();
  if ((i = indices[0]) > -1)
    bounds6.union(item.items[i].bounds);
  if ((i = indices[1]) > -1)
    bounds6.union(item.items[i].bounds);
  switch (orient2) {
    case Top:
      x9 = position2 || 0;
      y9 = -offset9;
      s2 = Math.max(minExtent, Math.min(maxExtent, -bounds6.y1));
      bounds6.add(0, -s2).add(range7, 0);
      if (title2)
        axisTitleLayout(view, title2, s2, titlePadding, dl, 0, -1, bounds6);
      break;
    case Left:
      x9 = -offset9;
      y9 = position2 || 0;
      s2 = Math.max(minExtent, Math.min(maxExtent, -bounds6.x1));
      bounds6.add(-s2, 0).add(0, range7);
      if (title2)
        axisTitleLayout(view, title2, s2, titlePadding, dl, 1, -1, bounds6);
      break;
    case Right:
      x9 = width2 + offset9;
      y9 = position2 || 0;
      s2 = Math.max(minExtent, Math.min(maxExtent, bounds6.x2));
      bounds6.add(0, 0).add(s2, range7);
      if (title2)
        axisTitleLayout(view, title2, s2, titlePadding, dl, 1, 1, bounds6);
      break;
    case Bottom:
      x9 = position2 || 0;
      y9 = height2 + offset9;
      s2 = Math.max(minExtent, Math.min(maxExtent, bounds6.y2));
      bounds6.add(0, 0).add(range7, s2);
      if (title2)
        axisTitleLayout(view, title2, s2, titlePadding, 0, 0, 1, bounds6);
      break;
    default:
      x9 = item.x;
      y9 = item.y;
  }
  boundStroke(bounds6.translate(x9, y9), item);
  if (set3(item, "x", x9 + delta) | set3(item, "y", y9 + delta)) {
    item.bounds = tempBounds2;
    view.dirty(item);
    item.bounds = bounds6;
    view.dirty(item);
  }
  return item.mark.bounds.clear().union(bounds6);
}
function axisTitleLayout(view, title2, offset9, pad5, dl, isYAxis2, sign4, bounds6) {
  const b6 = title2.bounds;
  if (title2.auto) {
    const v2 = sign4 * (offset9 + dl + pad5);
    let dx = 0, dy = 0;
    view.dirty(title2);
    isYAxis2 ? dx = (title2.x || 0) - (title2.x = v2) : dy = (title2.y || 0) - (title2.y = v2);
    title2.mark.bounds.clear().union(b6.translate(-dx, -dy));
    view.dirty(title2);
  }
  bounds6.union(b6);
}
var min3 = (a4, b6) => Math.floor(Math.min(a4, b6));
var max3 = (a4, b6) => Math.ceil(Math.max(a4, b6));
function gridLayoutGroups(group7) {
  var groups2 = group7.items, n = groups2.length, i = 0, mark, items;
  const views = {
    marks: [],
    rowheaders: [],
    rowfooters: [],
    colheaders: [],
    colfooters: [],
    rowtitle: null,
    coltitle: null
  };
  for (; i < n; ++i) {
    mark = groups2[i];
    items = mark.items;
    if (mark.marktype === Group) {
      switch (mark.role) {
        case AxisRole:
        case LegendRole:
        case TitleRole:
          break;
        case RowHeader:
          views.rowheaders.push(...items);
          break;
        case RowFooter:
          views.rowfooters.push(...items);
          break;
        case ColHeader:
          views.colheaders.push(...items);
          break;
        case ColFooter:
          views.colfooters.push(...items);
          break;
        case RowTitle:
          views.rowtitle = items[0];
          break;
        case ColTitle:
          views.coltitle = items[0];
          break;
        default:
          views.marks.push(...items);
      }
    }
  }
  return views;
}
function bboxFlush(item) {
  return new Bounds().set(0, 0, item.width || 0, item.height || 0);
}
function bboxFull(item) {
  const b6 = item.bounds.clone();
  return b6.empty() ? b6.set(0, 0, 0, 0) : b6.translate(-(item.x || 0), -(item.y || 0));
}
function get4(opt, key4, d) {
  const v2 = isObject3(opt) ? opt[key4] : opt;
  return v2 != null ? v2 : d !== void 0 ? d : 0;
}
function offsetValue(v2) {
  return v2 < 0 ? Math.ceil(-v2) : 0;
}
function gridLayout(view, groups2, opt) {
  var dirty = !opt.nodirty, bbox = opt.bounds === Flush ? bboxFlush : bboxFull, bounds6 = tempBounds2.set(0, 0, 0, 0), alignCol = get4(opt.align, Column), alignRow = get4(opt.align, Row), padCol = get4(opt.padding, Column), padRow = get4(opt.padding, Row), ncols = opt.columns || groups2.length, nrows = ncols <= 0 ? 1 : Math.ceil(groups2.length / ncols), n = groups2.length, xOffset = Array(n), xExtent = Array(ncols), xMax = 0, yOffset = Array(n), yExtent = Array(nrows), yMax = 0, dx = Array(n), dy = Array(n), boxes = Array(n), m3, i, c5, r, b6, g, px6, py6, x9, y9, offset9;
  for (i = 0; i < ncols; ++i)
    xExtent[i] = 0;
  for (i = 0; i < nrows; ++i)
    yExtent[i] = 0;
  for (i = 0; i < n; ++i) {
    g = groups2[i];
    b6 = boxes[i] = bbox(g);
    g.x = g.x || 0;
    dx[i] = 0;
    g.y = g.y || 0;
    dy[i] = 0;
    c5 = i % ncols;
    r = ~~(i / ncols);
    xMax = Math.max(xMax, px6 = Math.ceil(b6.x2));
    yMax = Math.max(yMax, py6 = Math.ceil(b6.y2));
    xExtent[c5] = Math.max(xExtent[c5], px6);
    yExtent[r] = Math.max(yExtent[r], py6);
    xOffset[i] = padCol + offsetValue(b6.x1);
    yOffset[i] = padRow + offsetValue(b6.y1);
    if (dirty)
      view.dirty(groups2[i]);
  }
  for (i = 0; i < n; ++i) {
    if (i % ncols === 0)
      xOffset[i] = 0;
    if (i < ncols)
      yOffset[i] = 0;
  }
  if (alignCol === Each) {
    for (c5 = 1; c5 < ncols; ++c5) {
      for (offset9 = 0, i = c5; i < n; i += ncols) {
        if (offset9 < xOffset[i])
          offset9 = xOffset[i];
      }
      for (i = c5; i < n; i += ncols) {
        xOffset[i] = offset9 + xExtent[c5 - 1];
      }
    }
  } else if (alignCol === All) {
    for (offset9 = 0, i = 0; i < n; ++i) {
      if (i % ncols && offset9 < xOffset[i])
        offset9 = xOffset[i];
    }
    for (i = 0; i < n; ++i) {
      if (i % ncols)
        xOffset[i] = offset9 + xMax;
    }
  } else {
    for (alignCol = false, c5 = 1; c5 < ncols; ++c5) {
      for (i = c5; i < n; i += ncols) {
        xOffset[i] += xExtent[c5 - 1];
      }
    }
  }
  if (alignRow === Each) {
    for (r = 1; r < nrows; ++r) {
      for (offset9 = 0, i = r * ncols, m3 = i + ncols; i < m3; ++i) {
        if (offset9 < yOffset[i])
          offset9 = yOffset[i];
      }
      for (i = r * ncols; i < m3; ++i) {
        yOffset[i] = offset9 + yExtent[r - 1];
      }
    }
  } else if (alignRow === All) {
    for (offset9 = 0, i = ncols; i < n; ++i) {
      if (offset9 < yOffset[i])
        offset9 = yOffset[i];
    }
    for (i = ncols; i < n; ++i) {
      yOffset[i] = offset9 + yMax;
    }
  } else {
    for (alignRow = false, r = 1; r < nrows; ++r) {
      for (i = r * ncols, m3 = i + ncols; i < m3; ++i) {
        yOffset[i] += yExtent[r - 1];
      }
    }
  }
  for (x9 = 0, i = 0; i < n; ++i) {
    x9 = xOffset[i] + (i % ncols ? x9 : 0);
    dx[i] += x9 - groups2[i].x;
  }
  for (c5 = 0; c5 < ncols; ++c5) {
    for (y9 = 0, i = c5; i < n; i += ncols) {
      y9 += yOffset[i];
      dy[i] += y9 - groups2[i].y;
    }
  }
  if (alignCol && get4(opt.center, Column) && nrows > 1) {
    for (i = 0; i < n; ++i) {
      b6 = alignCol === All ? xMax : xExtent[i % ncols];
      x9 = b6 - boxes[i].x2 - groups2[i].x - dx[i];
      if (x9 > 0)
        dx[i] += x9 / 2;
    }
  }
  if (alignRow && get4(opt.center, Row) && ncols !== 1) {
    for (i = 0; i < n; ++i) {
      b6 = alignRow === All ? yMax : yExtent[~~(i / ncols)];
      y9 = b6 - boxes[i].y2 - groups2[i].y - dy[i];
      if (y9 > 0)
        dy[i] += y9 / 2;
    }
  }
  for (i = 0; i < n; ++i) {
    bounds6.union(boxes[i].translate(dx[i], dy[i]));
  }
  x9 = get4(opt.anchor, X);
  y9 = get4(opt.anchor, Y);
  switch (get4(opt.anchor, Column)) {
    case End:
      x9 -= bounds6.width();
      break;
    case Middle:
      x9 -= bounds6.width() / 2;
  }
  switch (get4(opt.anchor, Row)) {
    case End:
      y9 -= bounds6.height();
      break;
    case Middle:
      y9 -= bounds6.height() / 2;
  }
  x9 = Math.round(x9);
  y9 = Math.round(y9);
  bounds6.clear();
  for (i = 0; i < n; ++i) {
    groups2[i].mark.bounds.clear();
  }
  for (i = 0; i < n; ++i) {
    g = groups2[i];
    g.x += dx[i] += x9;
    g.y += dy[i] += y9;
    bounds6.union(g.mark.bounds.union(g.bounds.translate(dx[i], dy[i])));
    if (dirty)
      view.dirty(g);
  }
  return bounds6;
}
function trellisLayout(view, group7, opt) {
  var views = gridLayoutGroups(group7), groups2 = views.marks, bbox = opt.bounds === Flush ? boundFlush : boundFull, off = opt.offset, ncols = opt.columns || groups2.length, nrows = ncols <= 0 ? 1 : Math.ceil(groups2.length / ncols), cells = nrows * ncols, x9, y9, x22, y22, anchor, band11, offset9;
  const bounds6 = gridLayout(view, groups2, opt);
  if (bounds6.empty())
    bounds6.set(0, 0, 0, 0);
  if (views.rowheaders) {
    band11 = get4(opt.headerBand, Row, null);
    x9 = layoutHeaders(view, views.rowheaders, groups2, ncols, nrows, -get4(off, "rowHeader"), min3, 0, bbox, "x1", 0, ncols, 1, band11);
  }
  if (views.colheaders) {
    band11 = get4(opt.headerBand, Column, null);
    y9 = layoutHeaders(view, views.colheaders, groups2, ncols, ncols, -get4(off, "columnHeader"), min3, 1, bbox, "y1", 0, 1, ncols, band11);
  }
  if (views.rowfooters) {
    band11 = get4(opt.footerBand, Row, null);
    x22 = layoutHeaders(view, views.rowfooters, groups2, ncols, nrows, get4(off, "rowFooter"), max3, 0, bbox, "x2", ncols - 1, ncols, 1, band11);
  }
  if (views.colfooters) {
    band11 = get4(opt.footerBand, Column, null);
    y22 = layoutHeaders(view, views.colfooters, groups2, ncols, ncols, get4(off, "columnFooter"), max3, 1, bbox, "y2", cells - ncols, 1, ncols, band11);
  }
  if (views.rowtitle) {
    anchor = get4(opt.titleAnchor, Row);
    offset9 = get4(off, "rowTitle");
    offset9 = anchor === End ? x22 + offset9 : x9 - offset9;
    band11 = get4(opt.titleBand, Row, 0.5);
    layoutTitle(view, views.rowtitle, offset9, 0, bounds6, band11);
  }
  if (views.coltitle) {
    anchor = get4(opt.titleAnchor, Column);
    offset9 = get4(off, "columnTitle");
    offset9 = anchor === End ? y22 + offset9 : y9 - offset9;
    band11 = get4(opt.titleBand, Column, 0.5);
    layoutTitle(view, views.coltitle, offset9, 1, bounds6, band11);
  }
}
function boundFlush(item, field25) {
  return field25 === "x1" ? item.x || 0 : field25 === "y1" ? item.y || 0 : field25 === "x2" ? (item.x || 0) + (item.width || 0) : field25 === "y2" ? (item.y || 0) + (item.height || 0) : void 0;
}
function boundFull(item, field25) {
  return item.bounds[field25];
}
function layoutHeaders(view, headers, groups2, ncols, limit, offset9, agg, isX2, bound6, bf, start, stride, back, band11) {
  var n = groups2.length, init2 = 0, edge = 0, i, j, k3, m3, b6, h6, g, x9, y9;
  if (!n)
    return init2;
  for (i = start; i < n; i += stride) {
    if (groups2[i])
      init2 = agg(init2, bound6(groups2[i], bf));
  }
  if (!headers.length)
    return init2;
  if (headers.length > limit) {
    view.warn("Grid headers exceed limit: " + limit);
    headers = headers.slice(0, limit);
  }
  init2 += offset9;
  for (j = 0, m3 = headers.length; j < m3; ++j) {
    view.dirty(headers[j]);
    headers[j].mark.bounds.clear();
  }
  for (i = start, j = 0, m3 = headers.length; j < m3; ++j, i += stride) {
    h6 = headers[j];
    b6 = h6.mark.bounds;
    for (k3 = i; k3 >= 0 && (g = groups2[k3]) == null; k3 -= back)
      ;
    if (isX2) {
      x9 = band11 == null ? g.x : Math.round(g.bounds.x1 + band11 * g.bounds.width());
      y9 = init2;
    } else {
      x9 = init2;
      y9 = band11 == null ? g.y : Math.round(g.bounds.y1 + band11 * g.bounds.height());
    }
    b6.union(h6.bounds.translate(x9 - (h6.x || 0), y9 - (h6.y || 0)));
    h6.x = x9;
    h6.y = y9;
    view.dirty(h6);
    edge = agg(edge, b6[bf]);
  }
  return edge;
}
function layoutTitle(view, g, offset9, isX2, bounds6, band11) {
  if (!g)
    return;
  view.dirty(g);
  var x9 = offset9, y9 = offset9;
  isX2 ? x9 = Math.round(bounds6.x1 + band11 * bounds6.width()) : y9 = Math.round(bounds6.y1 + band11 * bounds6.height());
  g.bounds.translate(x9 - (g.x || 0), y9 - (g.y || 0));
  g.mark.bounds.clear().union(g.bounds);
  g.x = x9;
  g.y = y9;
  view.dirty(g);
}
function lookup2(config, orient2) {
  const opt = config[orient2] || {};
  return (key4, d) => opt[key4] != null ? opt[key4] : config[key4] != null ? config[key4] : d;
}
function offsets(legends, value7) {
  let max5 = -Infinity;
  legends.forEach((item) => {
    if (item.offset != null)
      max5 = Math.max(max5, item.offset);
  });
  return max5 > -Infinity ? max5 : value7;
}
function legendParams(g, orient2, config, xb, yb, w8, h6) {
  const _ = lookup2(config, orient2), offset9 = offsets(g, _("offset", 0)), anchor = _("anchor", Start), mult2 = anchor === End ? 1 : anchor === Middle ? 0.5 : 0;
  const p = {
    align: Each,
    bounds: _("bounds", Flush),
    columns: _("direction") === "vertical" ? 1 : g.length,
    padding: _("margin", 8),
    center: _("center"),
    nodirty: true
  };
  switch (orient2) {
    case Left:
      p.anchor = {
        x: Math.floor(xb.x1) - offset9,
        column: End,
        y: mult2 * (h6 || xb.height() + 2 * xb.y1),
        row: anchor
      };
      break;
    case Right:
      p.anchor = {
        x: Math.ceil(xb.x2) + offset9,
        y: mult2 * (h6 || xb.height() + 2 * xb.y1),
        row: anchor
      };
      break;
    case Top:
      p.anchor = {
        y: Math.floor(yb.y1) - offset9,
        row: End,
        x: mult2 * (w8 || yb.width() + 2 * yb.x1),
        column: anchor
      };
      break;
    case Bottom:
      p.anchor = {
        y: Math.ceil(yb.y2) + offset9,
        x: mult2 * (w8 || yb.width() + 2 * yb.x1),
        column: anchor
      };
      break;
    case TopLeft:
      p.anchor = {
        x: offset9,
        y: offset9
      };
      break;
    case TopRight:
      p.anchor = {
        x: w8 - offset9,
        y: offset9,
        column: End
      };
      break;
    case BottomLeft:
      p.anchor = {
        x: offset9,
        y: h6 - offset9,
        row: End
      };
      break;
    case BottomRight:
      p.anchor = {
        x: w8 - offset9,
        y: h6 - offset9,
        column: End,
        row: End
      };
      break;
  }
  return p;
}
function legendLayout(view, legend) {
  var item = legend.items[0], datum2 = item.datum, orient2 = item.orient, bounds6 = item.bounds, x9 = item.x, y9 = item.y, w8, h6;
  item._bounds ? item._bounds.clear().union(bounds6) : item._bounds = bounds6.clone();
  bounds6.clear();
  legendGroupLayout(view, item, item.items[0].items[0]);
  bounds6 = legendBounds(item, bounds6);
  w8 = 2 * item.padding;
  h6 = 2 * item.padding;
  if (!bounds6.empty()) {
    w8 = Math.ceil(bounds6.width() + w8);
    h6 = Math.ceil(bounds6.height() + h6);
  }
  if (datum2.type === Symbols) {
    legendEntryLayout(item.items[0].items[0].items[0].items);
  }
  if (orient2 !== None4) {
    item.x = x9 = 0;
    item.y = y9 = 0;
  }
  item.width = w8;
  item.height = h6;
  boundStroke(bounds6.set(x9, y9, x9 + w8, y9 + h6), item);
  item.mark.bounds.clear().union(bounds6);
  return item;
}
function legendBounds(item, b6) {
  item.items.forEach((_) => b6.union(_.bounds));
  b6.x1 = item.padding;
  b6.y1 = item.padding;
  return b6;
}
function legendGroupLayout(view, item, entry2) {
  var pad5 = item.padding, ex = pad5 - entry2.x, ey = pad5 - entry2.y;
  if (!item.datum.title) {
    if (ex || ey)
      translate2(view, entry2, ex, ey);
  } else {
    var title2 = item.items[1].items[0], anchor = title2.anchor, tpad = item.titlePadding || 0, tx = pad5 - title2.x, ty = pad5 - title2.y;
    switch (title2.orient) {
      case Left:
        ex += Math.ceil(title2.bounds.width()) + tpad;
        break;
      case Right:
      case Bottom:
        break;
      default:
        ey += title2.bounds.height() + tpad;
    }
    if (ex || ey)
      translate2(view, entry2, ex, ey);
    switch (title2.orient) {
      case Left:
        ty += legendTitleOffset(item, entry2, title2, anchor, 1, 1);
        break;
      case Right:
        tx += legendTitleOffset(item, entry2, title2, End, 0, 0) + tpad;
        ty += legendTitleOffset(item, entry2, title2, anchor, 1, 1);
        break;
      case Bottom:
        tx += legendTitleOffset(item, entry2, title2, anchor, 0, 0);
        ty += legendTitleOffset(item, entry2, title2, End, -1, 0, 1) + tpad;
        break;
      default:
        tx += legendTitleOffset(item, entry2, title2, anchor, 0, 0);
    }
    if (tx || ty)
      translate2(view, title2, tx, ty);
    if ((tx = Math.round(title2.bounds.x1 - pad5)) < 0) {
      translate2(view, entry2, -tx, 0);
      translate2(view, title2, -tx, 0);
    }
  }
}
function legendTitleOffset(item, entry2, title2, anchor, y9, lr, noBar) {
  const grad = item.datum.type !== "symbol", vgrad = title2.datum.vgrad, e3 = grad && (lr || !vgrad) && !noBar ? entry2.items[0] : entry2, s2 = e3.bounds[y9 ? "y2" : "x2"] - item.padding, u4 = vgrad && lr ? s2 : 0, v2 = vgrad && lr ? 0 : s2, o = y9 <= 0 ? 0 : multiLineOffset(title2);
  return Math.round(anchor === Start ? u4 : anchor === End ? v2 - o : 0.5 * (s2 - o));
}
function translate2(view, item, dx, dy) {
  item.x += dx;
  item.y += dy;
  item.bounds.translate(dx, dy);
  item.mark.bounds.translate(dx, dy);
  view.dirty(item);
}
function legendEntryLayout(entries2) {
  const widths = entries2.reduce((w8, g) => {
    w8[g.column] = Math.max(g.bounds.x2 - g.x, w8[g.column] || 0);
    return w8;
  }, {});
  entries2.forEach((g) => {
    g.width = widths[g.column];
    g.height = g.bounds.y2 - g.y;
  });
}
function titleLayout(view, mark, width2, height2, viewBounds6) {
  var group7 = mark.items[0], frame2 = group7.frame, orient2 = group7.orient, anchor = group7.anchor, offset9 = group7.offset, padding3 = group7.padding, title2 = group7.items[0].items[0], subtitle = group7.items[1] && group7.items[1].items[0], end = orient2 === Left || orient2 === Right ? height2 : width2, start = 0, x9 = 0, y9 = 0, sx = 0, sy = 0, pos;
  if (frame2 !== Group) {
    orient2 === Left ? (start = viewBounds6.y2, end = viewBounds6.y1) : orient2 === Right ? (start = viewBounds6.y1, end = viewBounds6.y2) : (start = viewBounds6.x1, end = viewBounds6.x2);
  } else if (orient2 === Left) {
    start = height2, end = 0;
  }
  pos = anchor === Start ? start : anchor === End ? end : (start + end) / 2;
  if (subtitle && subtitle.text) {
    switch (orient2) {
      case Top:
      case Bottom:
        sy = title2.bounds.height() + padding3;
        break;
      case Left:
        sx = title2.bounds.width() + padding3;
        break;
      case Right:
        sx = -title2.bounds.width() - padding3;
        break;
    }
    tempBounds2.clear().union(subtitle.bounds);
    tempBounds2.translate(sx - (subtitle.x || 0), sy - (subtitle.y || 0));
    if (set3(subtitle, "x", sx) | set3(subtitle, "y", sy)) {
      view.dirty(subtitle);
      subtitle.bounds.clear().union(tempBounds2);
      subtitle.mark.bounds.clear().union(tempBounds2);
      view.dirty(subtitle);
    }
    tempBounds2.clear().union(subtitle.bounds);
  } else {
    tempBounds2.clear();
  }
  tempBounds2.union(title2.bounds);
  switch (orient2) {
    case Top:
      x9 = pos;
      y9 = viewBounds6.y1 - tempBounds2.height() - offset9;
      break;
    case Left:
      x9 = viewBounds6.x1 - tempBounds2.width() - offset9;
      y9 = pos;
      break;
    case Right:
      x9 = viewBounds6.x2 + tempBounds2.width() + offset9;
      y9 = pos;
      break;
    case Bottom:
      x9 = pos;
      y9 = viewBounds6.y2 + offset9;
      break;
    default:
      x9 = group7.x;
      y9 = group7.y;
  }
  if (set3(group7, "x", x9) | set3(group7, "y", y9)) {
    tempBounds2.translate(x9, y9);
    view.dirty(group7);
    group7.bounds.clear().union(tempBounds2);
    mark.bounds.clear().union(tempBounds2);
    view.dirty(group7);
  }
  return group7.bounds;
}
function ViewLayout(params2) {
  Transform.call(this, null, params2);
}
inherits4(ViewLayout, Transform, {
  transform(_, pulse2) {
    const view = pulse2.dataflow;
    _.mark.items.forEach((group7) => {
      if (_.layout)
        trellisLayout(view, group7, _.layout);
      layoutGroup(view, group7, _);
    });
    return shouldReflow(_.mark.group) ? pulse2.reflow() : pulse2;
  }
});
function shouldReflow(group7) {
  return group7 && group7.mark.role !== "legend-entry";
}
function layoutGroup(view, group7, _) {
  var items = group7.items, width2 = Math.max(0, group7.width || 0), height2 = Math.max(0, group7.height || 0), viewBounds6 = new Bounds().set(0, 0, width2, height2), xBounds = viewBounds6.clone(), yBounds = viewBounds6.clone(), legends = [], title2, mark, orient2, b6, i, n;
  for (i = 0, n = items.length; i < n; ++i) {
    mark = items[i];
    switch (mark.role) {
      case AxisRole:
        b6 = isYAxis(mark) ? xBounds : yBounds;
        b6.union(axisLayout(view, mark, width2, height2));
        break;
      case TitleRole:
        title2 = mark;
        break;
      case LegendRole:
        legends.push(legendLayout(view, mark));
        break;
      case FrameRole:
      case ScopeRole:
      case RowHeader:
      case RowFooter:
      case RowTitle:
      case ColHeader:
      case ColFooter:
      case ColTitle:
        xBounds.union(mark.bounds);
        yBounds.union(mark.bounds);
        break;
      default:
        viewBounds6.union(mark.bounds);
    }
  }
  if (legends.length) {
    const l = {};
    legends.forEach((item) => {
      orient2 = item.orient || Right;
      if (orient2 !== None4)
        (l[orient2] || (l[orient2] = [])).push(item);
    });
    for (const orient3 in l) {
      const g = l[orient3];
      gridLayout(view, g, legendParams(g, orient3, _.legends, xBounds, yBounds, width2, height2));
    }
    legends.forEach((item) => {
      const b7 = item.bounds;
      if (!b7.equals(item._bounds)) {
        item.bounds = item._bounds;
        view.dirty(item);
        item.bounds = b7;
        view.dirty(item);
      }
      if (_.autosize && (_.autosize.type === Fit || _.autosize.type === FitX || _.autosize.type === FitY)) {
        switch (item.orient) {
          case Left:
          case Right:
            viewBounds6.add(b7.x1, 0).add(b7.x2, 0);
            break;
          case Top:
          case Bottom:
            viewBounds6.add(0, b7.y1).add(0, b7.y2);
        }
      } else {
        viewBounds6.union(b7);
      }
    });
  }
  viewBounds6.union(xBounds).union(yBounds);
  if (title2) {
    viewBounds6.union(titleLayout(view, title2, width2, height2, viewBounds6));
  }
  if (group7.clip) {
    viewBounds6.set(0, 0, group7.width || 0, group7.height || 0);
  }
  viewSizeLayout(view, group7, viewBounds6, _);
}
function viewSizeLayout(view, group7, viewBounds6, _) {
  const auto = _.autosize || {}, type7 = auto.type;
  if (view._autosize < 1 || !type7)
    return;
  let viewWidth2 = view._width, viewHeight2 = view._height, width2 = Math.max(0, group7.width || 0), left = Math.max(0, Math.ceil(-viewBounds6.x1)), height2 = Math.max(0, group7.height || 0), top = Math.max(0, Math.ceil(-viewBounds6.y1));
  const right = Math.max(0, Math.ceil(viewBounds6.x2 - width2)), bottom = Math.max(0, Math.ceil(viewBounds6.y2 - height2));
  if (auto.contains === Padding) {
    const padding3 = view.padding();
    viewWidth2 -= padding3.left + padding3.right;
    viewHeight2 -= padding3.top + padding3.bottom;
  }
  if (type7 === None4) {
    left = 0;
    top = 0;
    width2 = viewWidth2;
    height2 = viewHeight2;
  } else if (type7 === Fit) {
    width2 = Math.max(0, viewWidth2 - left - right);
    height2 = Math.max(0, viewHeight2 - top - bottom);
  } else if (type7 === FitX) {
    width2 = Math.max(0, viewWidth2 - left - right);
    viewHeight2 = height2 + top + bottom;
  } else if (type7 === FitY) {
    viewWidth2 = width2 + left + right;
    height2 = Math.max(0, viewHeight2 - top - bottom);
  } else if (type7 === Pad) {
    viewWidth2 = width2 + left + right;
    viewHeight2 = height2 + top + bottom;
  }
  view._resizeView(viewWidth2, viewHeight2, width2, height2, [left, top], auto.resize);
}

// node_modules/vega-encode/build/vega-encode.js
var vega_encode_exports = {};
__export(vega_encode_exports, {
  axisticks: () => AxisTicks,
  datajoin: () => DataJoin,
  encode: () => Encode,
  legendentries: () => LegendEntries,
  linkpath: () => LinkPath,
  pie: () => Pie,
  scale: () => Scale,
  sortitems: () => SortItems,
  stack: () => Stack
});

// node_modules/vega-encode/node_modules/vega-util/build/vega-util.js
function accessor5(fn, fields, name) {
  fn.fields = fields || [];
  fn.fname = name;
  return fn;
}
function getter5(path7) {
  return path7.length === 1 ? get15(path7[0]) : getN5(path7);
}
var get15 = (field25) => function(obj) {
  return obj[field25];
};
var getN5 = (path7) => {
  const len = path7.length;
  return function(obj) {
    for (let i = 0; i < len; ++i) {
      obj = obj[path7[i]];
    }
    return obj;
  };
};
function error5(message) {
  throw Error(message);
}
function splitAccessPath5(p) {
  const path7 = [], n = p.length;
  let q = null, b6 = 0, s2 = "", i, j, c5;
  p = p + "";
  function push() {
    path7.push(s2 + p.substring(i, j));
    s2 = "";
    i = j + 1;
  }
  for (i = j = 0; j < n; ++j) {
    c5 = p[j];
    if (c5 === "\\") {
      s2 += p.substring(i, j++);
      i = j;
    } else if (c5 === q) {
      push();
      q = null;
      b6 = -1;
    } else if (q) {
      continue;
    } else if (i === b6 && c5 === '"') {
      i = j + 1;
      q = c5;
    } else if (i === b6 && c5 === "'") {
      i = j + 1;
      q = c5;
    } else if (c5 === "." && !b6) {
      if (j > i) {
        push();
      } else {
        i = j + 1;
      }
    } else if (c5 === "[") {
      if (j > i)
        push();
      b6 = i = j + 1;
    } else if (c5 === "]") {
      if (!b6)
        error5("Access path missing open bracket: " + p);
      if (b6 > 0)
        push();
      b6 = 0;
      i = j + 1;
    }
  }
  if (b6)
    error5("Access path missing closing bracket: " + p);
  if (q)
    error5("Access path missing closing quote: " + p);
  if (j > i) {
    j++;
    push();
  }
  return path7;
}
function field5(field25, name, opt) {
  const path7 = splitAccessPath5(field25);
  field25 = path7.length === 1 ? path7[0] : field25;
  return accessor5((opt && opt.get || getter5)(path7), [field25], name || field25);
}
var id5 = field5("id");
var identity9 = accessor5((_) => _, [], "identity");
var zero7 = accessor5(() => 0, [], "zero");
var one6 = accessor5(() => 1, [], "one");
var truthy5 = accessor5(() => true, [], "true");
var falsy5 = accessor5(() => false, [], "false");
var DisallowedObjectProperties5 = /* @__PURE__ */ new Set([...Object.getOwnPropertyNames(Object.prototype).filter((name) => typeof Object.prototype[name] === "function"), "__proto__"]);
var isArray5 = Array.isArray;
function isObject4(_) {
  return _ === Object(_);
}
function peek5(array22) {
  return array22[array22.length - 1];
}
function toNumber5(_) {
  return _ == null || _ === "" ? null : +_;
}
var exp3 = (sign4) => (x9) => sign4 * Math.exp(x9);
var log4 = (sign4) => (x9) => Math.log(sign4 * x9);
var symlog3 = (c5) => (x9) => Math.sign(x9) * Math.log1p(Math.abs(x9 / c5));
var symexp2 = (c5) => (x9) => Math.sign(x9) * Math.expm1(Math.abs(x9)) * c5;
var pow4 = (exponent) => (x9) => x9 < 0 ? -Math.pow(-x9, exponent) : Math.pow(x9, exponent);
function zoom2(domain3, anchor, scale19, lift, ground) {
  const d0 = lift(domain3[0]), d1 = lift(peek5(domain3)), da2 = anchor != null ? lift(anchor) : (d0 + d1) / 2;
  return [ground(da2 + (d0 - da2) * scale19), ground(da2 + (d1 - da2) * scale19)];
}
function zoomLinear2(domain3, anchor, scale19) {
  return zoom2(domain3, anchor, scale19, toNumber5, identity9);
}
function zoomLog2(domain3, anchor, scale19) {
  const sign4 = Math.sign(domain3[0]);
  return zoom2(domain3, anchor, scale19, log4(sign4), exp3(sign4));
}
function zoomPow2(domain3, anchor, scale19, exponent) {
  return zoom2(domain3, anchor, scale19, pow4(exponent), pow4(1 / exponent));
}
function zoomSymlog2(domain3, anchor, scale19, constant15) {
  return zoom2(domain3, anchor, scale19, symlog3(constant15), symexp2(constant15));
}
function array6(_) {
  return _ != null ? isArray5(_) ? _ : [_] : [];
}
function isFunction5(_) {
  return typeof _ === "function";
}
function constant7(_) {
  return isFunction5(_) ? _ : () => _;
}
function extend6(_) {
  for (let x9, k3, i = 1, len = arguments.length; i < len; ++i) {
    x9 = arguments[i];
    for (k3 in x9) {
      _[k3] = x9[k3];
    }
  }
  return _;
}
function has5(object2, property2) {
  return Object.hasOwn(object2, property2);
}
var NULL3 = {};
function fastmap3(input) {
  let obj = {}, test2;
  function has$1(key4) {
    return has5(obj, key4) && obj[key4] !== NULL3;
  }
  const map13 = {
    size: 0,
    empty: 0,
    object: obj,
    has: has$1,
    get(key4) {
      return has$1(key4) ? obj[key4] : void 0;
    },
    set(key4, value7) {
      if (!has$1(key4)) {
        ++map13.size;
        if (obj[key4] === NULL3)
          --map13.empty;
      }
      obj[key4] = value7;
      return this;
    },
    delete(key4) {
      if (has$1(key4)) {
        --map13.size;
        ++map13.empty;
        obj[key4] = NULL3;
      }
      return this;
    },
    clear() {
      map13.size = map13.empty = 0;
      map13.object = obj = {};
    },
    test(_) {
      if (arguments.length) {
        test2 = _;
        return map13;
      } else {
        return test2;
      }
    },
    clean() {
      const next = {};
      let size = 0;
      for (const key4 in obj) {
        const value7 = obj[key4];
        if (value7 !== NULL3 && (!test2 || !test2(value7))) {
          next[key4] = value7;
          ++size;
        }
      }
      map13.size = size;
      map13.empty = 0;
      map13.object = obj = next;
    }
  };
  if (input)
    Object.keys(input).forEach((key4) => {
      map13.set(key4, input[key4]);
    });
  return map13;
}
function inherits5(child, parent, members) {
  const proto = child.prototype = Object.create(parent.prototype);
  Object.defineProperty(proto, "constructor", {
    value: child,
    writable: true,
    enumerable: true,
    configurable: true
  });
  return extend6(proto, members);
}
function isNumber5(_) {
  return typeof _ === "number";
}
function isString4(_) {
  return typeof _ === "string";
}
function span5(array22) {
  return array22 && peek5(array22) - array22[0] || 0;
}
function $4(x9) {
  return isArray5(x9) ? `[${x9.map((v2) => v2 === null ? "null" : $4(v2))}]` : isObject4(x9) || isString4(x9) ? (
    // Output valid JSON and JS source strings.
    // See https://github.com/judofyr/timeless/blob/master/posts/json-isnt-a-javascript-subset.md
    JSON.stringify(x9).replaceAll("\u2028", "\\u2028").replaceAll("\u2029", "\\u2029")
  ) : x9;
}
function toSet5(_) {
  const s2 = {}, n = _.length;
  for (let i = 0; i < n; ++i)
    s2[_[i]] = true;
  return s2;
}

// node_modules/vega-encode/node_modules/vega-time/build/vega-time.js
var YEAR4 = "year";
var QUARTER4 = "quarter";
var MONTH4 = "month";
var WEEK4 = "week";
var DATE4 = "date";
var DAY4 = "day";
var DAYOFYEAR4 = "dayofyear";
var HOURS4 = "hours";
var MINUTES4 = "minutes";
var SECONDS4 = "seconds";
var MILLISECONDS4 = "milliseconds";
var TIME_UNITS4 = [YEAR4, QUARTER4, MONTH4, WEEK4, DATE4, DAY4, DAYOFYEAR4, HOURS4, MINUTES4, SECONDS4, MILLISECONDS4];
var UNITS4 = TIME_UNITS4.reduce((o, u4, i) => (o[u4] = 1 + i, o), {});
var defaultSpecifiers4 = {
  [YEAR4]: "%Y ",
  [QUARTER4]: "Q%q ",
  [MONTH4]: "%b ",
  [DATE4]: "%d ",
  [WEEK4]: "W%U ",
  [DAY4]: "%a ",
  [DAYOFYEAR4]: "%j ",
  [HOURS4]: "%H:00",
  [MINUTES4]: "00:%M",
  [SECONDS4]: ":%S",
  [MILLISECONDS4]: ".%L",
  [`${YEAR4}-${MONTH4}`]: "%Y-%m ",
  [`${YEAR4}-${MONTH4}-${DATE4}`]: "%Y-%m-%d ",
  [`${HOURS4}-${MINUTES4}`]: "%H:%M"
};
var t06 = /* @__PURE__ */ new Date();
function localYear4(y9) {
  t06.setFullYear(y9);
  t06.setMonth(0);
  t06.setDate(1);
  t06.setHours(0, 0, 0, 0);
  return t06;
}
function localDayOfYear4(d) {
  return timeDay.count(localYear4(d.getFullYear()) - 1, d);
}
function localWeekNum4(d) {
  return timeSunday.count(localYear4(d.getFullYear()) - 1, d);
}
function localFirst4(y9) {
  return localYear4(y9).getDay();
}
function utcDayOfYear4(d) {
  const y9 = Date.UTC(d.getUTCFullYear(), 0, 1);
  return utcDay.count(y9 - 1, d);
}
function utcWeekNum4(d) {
  const y9 = Date.UTC(d.getUTCFullYear(), 0, 1);
  return utcSunday.count(y9 - 1, d);
}
function utcFirst4(y9) {
  t06.setTime(Date.UTC(y9, 0, 1));
  return t06.getUTCDay();
}
function weekday4(week3, day, firstDay) {
  return day + week3 * 7 - (firstDay + 6) % 7;
}
var localGet4 = {
  [YEAR4]: (d) => d.getFullYear(),
  [QUARTER4]: (d) => Math.floor(d.getMonth() / 3),
  [MONTH4]: (d) => d.getMonth(),
  [DATE4]: (d) => d.getDate(),
  [HOURS4]: (d) => d.getHours(),
  [MINUTES4]: (d) => d.getMinutes(),
  [SECONDS4]: (d) => d.getSeconds(),
  [MILLISECONDS4]: (d) => d.getMilliseconds(),
  [DAYOFYEAR4]: (d) => localDayOfYear4(d),
  [WEEK4]: (d) => localWeekNum4(d),
  [WEEK4 + DAY4]: (d, y9) => weekday4(localWeekNum4(d), d.getDay(), localFirst4(y9)),
  [DAY4]: (d, y9) => weekday4(1, d.getDay(), localFirst4(y9))
};
var localInv4 = {
  [QUARTER4]: (q) => 3 * q,
  [WEEK4]: (w8, y9) => weekday4(w8, 0, localFirst4(y9))
};
var utcGet4 = {
  [YEAR4]: (d) => d.getUTCFullYear(),
  [QUARTER4]: (d) => Math.floor(d.getUTCMonth() / 3),
  [MONTH4]: (d) => d.getUTCMonth(),
  [DATE4]: (d) => d.getUTCDate(),
  [HOURS4]: (d) => d.getUTCHours(),
  [MINUTES4]: (d) => d.getUTCMinutes(),
  [SECONDS4]: (d) => d.getUTCSeconds(),
  [MILLISECONDS4]: (d) => d.getUTCMilliseconds(),
  [DAYOFYEAR4]: (d) => utcDayOfYear4(d),
  [WEEK4]: (d) => utcWeekNum4(d),
  [DAY4]: (d, y9) => weekday4(1, d.getUTCDay(), utcFirst4(y9)),
  [WEEK4 + DAY4]: (d, y9) => weekday4(utcWeekNum4(d), d.getUTCDay(), utcFirst4(y9))
};
var utcInv4 = {
  [QUARTER4]: (q) => 3 * q,
  [WEEK4]: (w8, y9) => weekday4(w8, 0, utcFirst4(y9))
};
var timeIntervals4 = {
  [YEAR4]: timeYear,
  [QUARTER4]: timeMonth.every(3),
  [MONTH4]: timeMonth,
  [WEEK4]: timeSunday,
  [DATE4]: timeDay,
  [DAY4]: timeDay,
  [DAYOFYEAR4]: timeDay,
  [HOURS4]: timeHour,
  [MINUTES4]: timeMinute,
  [SECONDS4]: second,
  [MILLISECONDS4]: millisecond
};
var utcIntervals4 = {
  [YEAR4]: utcYear,
  [QUARTER4]: utcMonth.every(3),
  [MONTH4]: utcMonth,
  [WEEK4]: utcSunday,
  [DATE4]: utcDay,
  [DAY4]: utcDay,
  [DAYOFYEAR4]: utcDay,
  [HOURS4]: utcHour,
  [MINUTES4]: utcMinute,
  [SECONDS4]: second,
  [MILLISECONDS4]: millisecond
};
function timeInterval5(unit2) {
  return timeIntervals4[unit2];
}
function utcInterval4(unit2) {
  return utcIntervals4[unit2];
}
var durationSecond5 = 1e3;
var durationMinute5 = durationSecond5 * 60;
var durationHour5 = durationMinute5 * 60;
var durationDay5 = durationHour5 * 24;
var durationWeek5 = durationDay5 * 7;
var durationMonth5 = durationDay5 * 30;
var durationYear5 = durationDay5 * 365;
var Milli4 = [YEAR4, MONTH4, DATE4, HOURS4, MINUTES4, SECONDS4, MILLISECONDS4];
var Seconds4 = Milli4.slice(0, -1);
var Minutes4 = Seconds4.slice(0, -1);
var Hours4 = Minutes4.slice(0, -1);
var Day4 = Hours4.slice(0, -1);
var Week4 = [YEAR4, WEEK4];
var Month4 = [YEAR4, MONTH4];
var Year4 = [YEAR4];
var intervals4 = [[Seconds4, 1, durationSecond5], [Seconds4, 5, 5 * durationSecond5], [Seconds4, 15, 15 * durationSecond5], [Seconds4, 30, 30 * durationSecond5], [Minutes4, 1, durationMinute5], [Minutes4, 5, 5 * durationMinute5], [Minutes4, 15, 15 * durationMinute5], [Minutes4, 30, 30 * durationMinute5], [Hours4, 1, durationHour5], [Hours4, 3, 3 * durationHour5], [Hours4, 6, 6 * durationHour5], [Hours4, 12, 12 * durationHour5], [Day4, 1, durationDay5], [Week4, 1, durationWeek5], [Month4, 1, durationMonth5], [Month4, 3, 3 * durationMonth5], [Year4, 1, durationYear5]];

// node_modules/vega-encode/node_modules/vega-scale/build/vega-scale.js
function bandSpace2(count3, paddingInner2, paddingOuter2) {
  const space = count3 - paddingInner2 + paddingOuter2 * 2;
  return count3 ? space > 0 ? space : 1 : 0;
}
var Identity2 = "identity";
var Linear3 = "linear";
var Log2 = "log";
var Pow2 = "pow";
var Sqrt2 = "sqrt";
var Symlog2 = "symlog";
var Time2 = "time";
var UTC2 = "utc";
var Sequential2 = "sequential";
var Diverging2 = "diverging";
var Quantile3 = "quantile";
var Quantize2 = "quantize";
var Threshold2 = "threshold";
var Ordinal2 = "ordinal";
var Point2 = "point";
var Band2 = "band";
var BinOrdinal2 = "bin-ordinal";
var Continuous2 = "continuous";
var Discrete2 = "discrete";
var Discretizing2 = "discretizing";
var Interpolating2 = "interpolating";
var Temporal2 = "temporal";
function invertRange2(scale19) {
  return function(_) {
    let lo = _[0], hi = _[1], t;
    if (hi < lo) {
      t = lo;
      lo = hi;
      hi = t;
    }
    return [scale19.invert(lo), scale19.invert(hi)];
  };
}
function invertRangeExtent2(scale19) {
  return function(_) {
    const range7 = scale19.range();
    let lo = _[0], hi = _[1], min5 = -1, max5, t, i, n;
    if (hi < lo) {
      t = lo;
      lo = hi;
      hi = t;
    }
    for (i = 0, n = range7.length; i < n; ++i) {
      if (range7[i] >= lo && range7[i] <= hi) {
        if (min5 < 0)
          min5 = i;
        max5 = i;
      }
    }
    if (min5 < 0)
      return void 0;
    lo = scale19.invertExtent(range7[min5]);
    hi = scale19.invertExtent(range7[max5]);
    return [lo[0] === void 0 ? lo[1] : lo[0], hi[1] === void 0 ? hi[0] : hi[1]];
  };
}
function band3() {
  const scale19 = ordinal().unknown(void 0), domain3 = scale19.domain, ordinalRange = scale19.range;
  let range$1 = [0, 1], step, bandwidth2, round2 = false, paddingInner2 = 0, paddingOuter2 = 0, align2 = 0.5;
  delete scale19.unknown;
  function rescale() {
    const n = domain3().length, reverse4 = range$1[1] < range$1[0], stop2 = range$1[1 - reverse4], space = bandSpace2(n, paddingInner2, paddingOuter2);
    let start = range$1[reverse4 - 0];
    step = (stop2 - start) / (space || 1);
    if (round2) {
      step = Math.floor(step);
    }
    start += (stop2 - start - step * (n - paddingInner2)) * align2;
    bandwidth2 = step * (1 - paddingInner2);
    if (round2) {
      start = Math.round(start);
      bandwidth2 = Math.round(bandwidth2);
    }
    const values7 = range(n).map((i) => start + step * i);
    return ordinalRange(reverse4 ? values7.reverse() : values7);
  }
  scale19.domain = function(_) {
    if (arguments.length) {
      domain3(_);
      return rescale();
    } else {
      return domain3();
    }
  };
  scale19.range = function(_) {
    if (arguments.length) {
      range$1 = [+_[0], +_[1]];
      return rescale();
    } else {
      return range$1.slice();
    }
  };
  scale19.rangeRound = function(_) {
    range$1 = [+_[0], +_[1]];
    round2 = true;
    return rescale();
  };
  scale19.bandwidth = function() {
    return bandwidth2;
  };
  scale19.step = function() {
    return step;
  };
  scale19.round = function(_) {
    if (arguments.length) {
      round2 = !!_;
      return rescale();
    } else {
      return round2;
    }
  };
  scale19.padding = function(_) {
    if (arguments.length) {
      paddingOuter2 = Math.max(0, Math.min(1, _));
      paddingInner2 = paddingOuter2;
      return rescale();
    } else {
      return paddingInner2;
    }
  };
  scale19.paddingInner = function(_) {
    if (arguments.length) {
      paddingInner2 = Math.max(0, Math.min(1, _));
      return rescale();
    } else {
      return paddingInner2;
    }
  };
  scale19.paddingOuter = function(_) {
    if (arguments.length) {
      paddingOuter2 = Math.max(0, Math.min(1, _));
      return rescale();
    } else {
      return paddingOuter2;
    }
  };
  scale19.align = function(_) {
    if (arguments.length) {
      align2 = Math.max(0, Math.min(1, _));
      return rescale();
    } else {
      return align2;
    }
  };
  scale19.invertRange = function(_) {
    if (_[0] == null || _[1] == null)
      return;
    const reverse4 = range$1[1] < range$1[0], values7 = reverse4 ? ordinalRange().reverse() : ordinalRange(), n = values7.length - 1;
    let lo = +_[0], hi = +_[1], a4, b6, t;
    if (lo !== lo || hi !== hi)
      return;
    if (hi < lo) {
      t = lo;
      lo = hi;
      hi = t;
    }
    if (hi < values7[0] || lo > range$1[1 - reverse4])
      return;
    a4 = Math.max(0, bisectRight(values7, lo) - 1);
    b6 = lo === hi ? a4 : bisectRight(values7, hi) - 1;
    if (lo - values7[a4] > bandwidth2 + 1e-10)
      ++a4;
    if (reverse4) {
      t = a4;
      a4 = n - b6;
      b6 = n - t;
    }
    return a4 > b6 ? void 0 : domain3().slice(a4, b6 + 1);
  };
  scale19.invert = function(_) {
    const value7 = scale19.invertRange([_, _]);
    return value7 ? value7[0] : value7;
  };
  scale19.copy = function() {
    return band3().domain(domain3()).range(range$1).round(round2).paddingInner(paddingInner2).paddingOuter(paddingOuter2).align(align2);
  };
  return rescale();
}
function pointish2(scale19) {
  const copy4 = scale19.copy;
  scale19.padding = scale19.paddingOuter;
  delete scale19.paddingInner;
  scale19.copy = function() {
    return pointish2(copy4());
  };
  return scale19;
}
function point8() {
  return pointish2(band3().paddingInner(1));
}
var map5 = Array.prototype.map;
function numbers4(_) {
  return map5.call(_, toNumber5);
}
var slice4 = Array.prototype.slice;
function scaleBinOrdinal2() {
  let domain3 = [], range7 = [];
  function scale19(x9) {
    return x9 == null || x9 !== x9 ? void 0 : range7[(bisect_default2(domain3, x9) - 1) % range7.length];
  }
  scale19.domain = function(_) {
    if (arguments.length) {
      domain3 = numbers4(_);
      return scale19;
    } else {
      return domain3.slice();
    }
  };
  scale19.range = function(_) {
    if (arguments.length) {
      range7 = slice4.call(_);
      return scale19;
    } else {
      return range7.slice();
    }
  };
  scale19.tickFormat = function(count3, specifier) {
    return tickFormat(domain3[0], peek5(domain3), count3 == null ? 10 : count3, specifier);
  };
  scale19.copy = function() {
    return scaleBinOrdinal2().domain(scale19.domain()).range(scale19.range());
  };
  return scale19;
}
var scales2 = /* @__PURE__ */ new Map();
var VEGA_SCALE2 = Symbol("vega_scale");
function registerScale2(scale19) {
  scale19[VEGA_SCALE2] = true;
  return scale19;
}
function create2(type7, constructor, metadata6) {
  const ctr = function scale19() {
    const s2 = constructor();
    if (!s2.invertRange) {
      s2.invertRange = s2.invert ? invertRange2(s2) : s2.invertExtent ? invertRangeExtent2(s2) : void 0;
    }
    s2.type = type7;
    return registerScale2(s2);
  };
  ctr.metadata = toSet5(array6(metadata6));
  return ctr;
}
function scale3(type7, scale19, metadata6) {
  if (arguments.length > 1) {
    scales2.set(type7, create2(type7, scale19, metadata6));
    return this;
  } else {
    return isValidScaleType2(type7) ? scales2.get(type7) : void 0;
  }
}
scale3(Identity2, identity8);
scale3(Linear3, linear3, Continuous2);
scale3(Log2, log3, [Continuous2, Log2]);
scale3(Pow2, pow3, Continuous2);
scale3(Sqrt2, sqrt2, Continuous2);
scale3(Symlog2, symlog2, Continuous2);
scale3(Time2, time, [Continuous2, Temporal2]);
scale3(UTC2, utcTime, [Continuous2, Temporal2]);
scale3(Sequential2, sequential, [Continuous2, Interpolating2]);
scale3(`${Sequential2}-${Linear3}`, sequential, [Continuous2, Interpolating2]);
scale3(`${Sequential2}-${Log2}`, sequentialLog, [Continuous2, Interpolating2, Log2]);
scale3(`${Sequential2}-${Pow2}`, sequentialPow, [Continuous2, Interpolating2]);
scale3(`${Sequential2}-${Sqrt2}`, sequentialSqrt, [Continuous2, Interpolating2]);
scale3(`${Sequential2}-${Symlog2}`, sequentialSymlog, [Continuous2, Interpolating2]);
scale3(`${Diverging2}-${Linear3}`, diverging, [Continuous2, Interpolating2]);
scale3(`${Diverging2}-${Log2}`, divergingLog, [Continuous2, Interpolating2, Log2]);
scale3(`${Diverging2}-${Pow2}`, divergingPow, [Continuous2, Interpolating2]);
scale3(`${Diverging2}-${Sqrt2}`, divergingSqrt, [Continuous2, Interpolating2]);
scale3(`${Diverging2}-${Symlog2}`, divergingSymlog, [Continuous2, Interpolating2]);
scale3(Quantile3, quantile2, [Discretizing2, Quantile3]);
scale3(Quantize2, quantize, Discretizing2);
scale3(Threshold2, threshold, Discretizing2);
scale3(BinOrdinal2, scaleBinOrdinal2, [Discrete2, Discretizing2]);
scale3(Ordinal2, ordinal, Discrete2);
scale3(Band2, band3, Discrete2);
scale3(Point2, point8, Discrete2);
function isValidScaleType2(type7) {
  return scales2.has(type7);
}
function hasType2(key4, type7) {
  const s2 = scales2.get(key4);
  return s2 && s2.metadata[type7];
}
function isContinuous(key4) {
  return hasType2(key4, Continuous2);
}
function isLogarithmic2(key4) {
  return hasType2(key4, Log2);
}
function isInterpolating(key4) {
  return hasType2(key4, Interpolating2);
}
var scaleProps = ["clamp", "base", "constant", "exponent"];
function interpolateRange(interpolator, range7) {
  const start = range7[0], span12 = peek5(range7) - start;
  return function(i) {
    return interpolator(start + i * span12);
  };
}
function interpolateColors2(colors10, type7, gamma2) {
  return piecewise(interpolate2(type7 || "rgb", gamma2), colors10);
}
function quantizeInterpolator(interpolator, count3) {
  const samples = new Array(count3), n = count3 + 1;
  for (let i = 0; i < count3; )
    samples[i] = interpolator(++i / n);
  return samples;
}
function scaleFraction(scale$16, min5, max5) {
  const delta = max5 - min5;
  let i, t, s2;
  if (!delta || !Number.isFinite(delta)) {
    return constant7(0.5);
  } else {
    i = (t = scale$16.type).indexOf("-");
    t = i < 0 ? t : t.slice(i + 1);
    s2 = scale3(t)().domain([min5, max5]).range([0, 1]);
    scaleProps.forEach((m3) => scale$16[m3] ? s2[m3](scale$16[m3]()) : 0);
    return s2;
  }
}
function interpolate2(type7, gamma2) {
  const interp = src_exports[method2(type7)];
  return gamma2 != null && interp && interp.gamma ? interp.gamma(gamma2) : interp;
}
function method2(type7) {
  return "interpolate" + type7.toLowerCase().split("-").map((s2) => s2[0].toUpperCase() + s2.slice(1)).join("");
}
var continuous3 = {
  blues: "cfe1f2bed8eca8cee58fc1de74b2d75ba3cf4592c63181bd206fb2125ca40a4a90",
  greens: "d3eecdc0e6baabdda594d3917bc77d60ba6c46ab5e329a512089430e7735036429",
  greys: "e2e2e2d4d4d4c4c4c4b1b1b19d9d9d8888887575756262624d4d4d3535351e1e1e",
  oranges: "fdd8b3fdc998fdb87bfda55efc9244f87f2cf06b18e4580bd14904b93d029f3303",
  purples: "e2e1efd4d4e8c4c5e0b4b3d6a3a0cc928ec3827cb97566ae684ea25c3696501f8c",
  reds: "fdc9b4fcb49afc9e80fc8767fa7051f6573fec3f2fdc2a25c81b1db21218970b13",
  blueGreen: "d5efedc1e8e0a7ddd18bd2be70c6a958ba9144ad77319c5d2089460e7736036429",
  bluePurple: "ccddecbad0e4a8c2dd9ab0d4919cc98d85be8b6db28a55a6873c99822287730f71",
  greenBlue: "d3eecec5e8c3b1e1bb9bd8bb82cec269c2ca51b2cd3c9fc7288abd1675b10b60a1",
  orangeRed: "fddcaffdcf9bfdc18afdad77fb9562f67d53ee6545e24932d32d1ebf130da70403",
  purpleBlue: "dbdaebc8cee4b1c3de97b7d87bacd15b9fc93a90c01e7fb70b70ab056199045281",
  purpleBlueGreen: "dbd8eac8cee4b0c3de93b7d872acd1549fc83892bb1c88a3097f8702736b016353",
  purpleRed: "dcc9e2d3b3d7ce9eccd186c0da6bb2e14da0e23189d91e6fc61159ab07498f023a",
  redPurple: "fccfccfcbec0faa9b8f98faff571a5ec539ddb3695c41b8aa908808d0179700174",
  yellowGreen: "e4f4acd1eca0b9e2949ed68880c97c62bb6e47aa5e3297502083440e723b036034",
  yellowOrangeBrown: "feeaa1fedd84fecc63feb746fca031f68921eb7215db5e0bc54c05ab3d038f3204",
  yellowOrangeRed: "fee087fed16ffebd59fea849fd903efc7335f9522bee3423de1b20ca0b22af0225",
  blueOrange: "134b852f78b35da2cb9dcae1d2e5eff2f0ebfce0bafbbf74e8932fc5690d994a07",
  brownBlueGreen: "704108a0651ac79548e3c78af3e6c6eef1eac9e9e48ed1c74da79e187a72025147",
  purpleGreen: "5b1667834792a67fb6c9aed3e6d6e8eff0efd9efd5aedda971bb75368e490e5e29",
  purpleOrange: "4114696647968f83b7b9b4d6dadbebf3eeeafce0bafbbf74e8932fc5690d994a07",
  redBlue: "8c0d25bf363adf745ef4ae91fbdbc9f2efeed2e5ef9dcae15da2cb2f78b3134b85",
  redGrey: "8c0d25bf363adf745ef4ae91fcdccbfaf4f1e2e2e2c0c0c0969696646464343434",
  yellowGreenBlue: "eff9bddbf1b4bde5b594d5b969c5be45b4c22c9ec02182b82163aa23479c1c3185",
  redYellowBlue: "a50026d4322cf16e43fcac64fedd90faf8c1dcf1ecabd6e875abd04a74b4313695",
  redYellowGreen: "a50026d4322cf16e43fcac63fedd8df9f7aed7ee8ea4d86e64bc6122964f006837",
  pinkYellowGreen: "8e0152c0267edd72adf0b3d6faddedf5f3efe1f2cab6de8780bb474f9125276419",
  spectral: "9e0142d13c4bf0704afcac63fedd8dfbf8b0e0f3a1a9dda269bda94288b55e4fa2",
  viridis: "440154470e61481a6c482575472f7d443a834144873d4e8a39568c35608d31688e2d708e2a788e27818e23888e21918d1f988b1fa08822a8842ab07f35b77943bf7154c56866cc5d7ad1518fd744a5db36bcdf27d2e21be9e51afde725",
  magma: "0000040404130b0924150e3720114b2c11603b0f704a107957157e651a80721f817f24828c29819a2e80a8327db6377ac43c75d1426fde4968e95462f1605df76f5cfa7f5efc8f65fe9f6dfeaf78febf84fece91fddea0fcedaffcfdbf",
  inferno: "0000040403130c0826170c3b240c4f330a5f420a68500d6c5d126e6b176e781c6d86216b932667a12b62ae305cbb3755c73e4cd24644dd513ae65c30ed6925f3771af8850ffb9506fca50afcb519fac62df6d645f2e661f3f484fcffa4",
  plasma: "0d088723069033059742039d5002a25d01a66a00a87801a88405a7900da49c179ea72198b12a90ba3488c33d80cb4779d35171da5a69e16462e76e5bed7953f2834cf68f44fa9a3dfca636fdb32ffec029fcce25f9dc24f5ea27f0f921",
  cividis: "00205100235800265d002961012b65042e670831690d346b11366c16396d1c3c6e213f6e26426e2c456e31476e374a6e3c4d6e42506e47536d4c566d51586e555b6e5a5e6e5e616e62646f66676f6a6a706e6d717270717573727976737c79747f7c75827f758682768985778c8877908b78938e789691789a94789e9778a19b78a59e77a9a177aea575b2a874b6ab73bbaf71c0b26fc5b66dc9b96acebd68d3c065d8c462ddc85fe2cb5ce7cf58ebd355f0d652f3da4ff7de4cfae249fce647",
  rainbow: "6e40aa883eb1a43db3bf3cafd83fa4ee4395fe4b83ff576eff6659ff7847ff8c38f3a130e2b72fcfcc36bee044aff05b8ff4576ff65b52f6673af27828ea8d1ddfa319d0b81cbecb23abd82f96e03d82e14c6edb5a5dd0664dbf6e40aa",
  sinebow: "ff4040fc582af47218e78d0bd5a703bfbf00a7d5038de70b72f41858fc2a40ff402afc5818f4720be78d03d5a700bfbf03a7d50b8de71872f42a58fc4040ff582afc7218f48d0be7a703d5bf00bfd503a7e70b8df41872fc2a58ff4040",
  turbo: "23171b32204a3e2a71453493493eae4b49c54a53d7485ee44569ee4074f53c7ff8378af93295f72e9ff42ba9ef28b3e926bce125c5d925cdcf27d5c629dcbc2de3b232e9a738ee9d3ff39347f68950f9805afc7765fd6e70fe667cfd5e88fc5795fb51a1f84badf545b9f140c5ec3cd0e637dae034e4d931ecd12ef4c92bfac029ffb626ffad24ffa223ff9821ff8d1fff821dff771cfd6c1af76118f05616e84b14df4111d5380fcb2f0dc0260ab61f07ac1805a313029b0f00950c00910b00",
  browns: "eedbbdecca96e9b97ae4a865dc9856d18954c7784cc0673fb85536ad44339f3632",
  tealBlues: "bce4d89dd3d181c3cb65b3c245a2b9368fae347da0306a932c5985",
  teals: "bbdfdfa2d4d58ac9c975bcbb61b0af4da5a43799982b8b8c1e7f7f127273006667",
  warmGreys: "dcd4d0cec5c1c0b8b4b3aaa7a59c9998908c8b827f7e7673726866665c5a59504e",
  goldGreen: "f4d166d5ca60b6c35c98bb597cb25760a6564b9c533f8f4f33834a257740146c36",
  goldOrange: "f4d166f8be5cf8aa4cf5983bf3852aef701be2621fd65322c54923b142239e3a26",
  goldRed: "f4d166f6be59f9aa51fc964ef6834bee734ae56249db5247cf4244c43141b71d3e",
  lightGreyRed: "efe9e6e1dad7d5cbc8c8bdb9bbaea9cd967ddc7b43e15f19df4011dc000b",
  lightGreyTeal: "e4eaead6dcddc8ced2b7c2c7a6b4bc64b0bf22a6c32295c11f85be1876bc",
  lightMulti: "e0f1f2c4e9d0b0de9fd0e181f6e072f6c053f3993ef77440ef4a3c",
  lightOrange: "f2e7daf7d5baf9c499fab184fa9c73f68967ef7860e8645bde515bd43d5b",
  lightTealBlue: "e3e9e0c0dccf9aceca7abfc859afc0389fb9328dad2f7ca0276b95255988",
  darkBlue: "3232322d46681a5c930074af008cbf05a7ce25c0dd38daed50f3faffffff",
  darkGold: "3c3c3c584b37725e348c7631ae8b2bcfa424ecc31ef9de30fff184ffffff",
  darkGreen: "3a3a3a215748006f4d048942489e4276b340a6c63dd2d836ffeb2cffffaa",
  darkMulti: "3737371f5287197d8c29a86995ce3fffe800ffffff",
  darkRed: "3434347036339e3c38cc4037e75d1eec8620eeab29f0ce32ffeb2c"
};
var discrete2 = {
  accent: Accent_default,
  category10: category10_default,
  category20: "1f77b4aec7e8ff7f0effbb782ca02c98df8ad62728ff98969467bdc5b0d58c564bc49c94e377c2f7b6d27f7f7fc7c7c7bcbd22dbdb8d17becf9edae5",
  category20b: "393b795254a36b6ecf9c9ede6379398ca252b5cf6bcedb9c8c6d31bd9e39e7ba52e7cb94843c39ad494ad6616be7969c7b4173a55194ce6dbdde9ed6",
  category20c: "3182bd6baed69ecae1c6dbefe6550dfd8d3cfdae6bfdd0a231a35474c476a1d99bc7e9c0756bb19e9ac8bcbddcdadaeb636363969696bdbdbdd9d9d9",
  dark2: Dark2_default,
  observable10: observable10_default,
  paired: Paired_default,
  pastel1: Pastel1_default,
  pastel2: Pastel2_default,
  set1: Set1_default,
  set2: Set2_default,
  set3: Set3_default,
  tableau10: "4c78a8f58518e4575672b7b254a24beeca3bb279a2ff9da69d755dbab0ac",
  tableau20: "4c78a89ecae9f58518ffbf7954a24b88d27ab79a20f2cf5b43989483bcb6e45756ff9d9879706ebab0acd67195fcbfd2b279a2d6a5c99e765fd8b5a5"
};
function colors2(palette) {
  if (isArray5(palette))
    return palette;
  const n = palette.length / 6 | 0, c5 = new Array(n);
  for (let i = 0; i < n; ) {
    c5[i] = "#" + palette.slice(i * 6, ++i * 6);
  }
  return c5;
}
function apply2(_, f) {
  for (const k3 in _)
    scheme29(k3, f(_[k3]));
}
var schemes2 = {};
apply2(discrete2, colors2);
apply2(continuous3, (_) => interpolateColors2(colors2(_)));
function scheme29(name, scheme38) {
  name = name && name.toLowerCase();
  if (arguments.length > 1) {
    schemes2[name] = scheme38;
    return this;
  } else {
    return schemes2[name];
  }
}
var SymbolLegend2 = "symbol";
var DiscreteLegend2 = "discrete";
var GradientLegend = "gradient";
var defaultFormatter2 = (value7) => isArray5(value7) ? value7.map((v2) => String(v2)) : String(value7);
var ascending5 = (a4, b6) => a4[1] - b6[1];
var descending3 = (a4, b6) => b6[1] - a4[1];
function tickCount(scale19, count3, minStep) {
  let step;
  if (isNumber5(count3)) {
    if (scale19.bins) {
      count3 = Math.max(count3, scale19.bins.length);
    }
    if (minStep != null) {
      count3 = Math.min(count3, Math.floor(span5(scale19.domain()) / minStep || 1) + 1);
    }
  }
  if (isObject4(count3)) {
    step = count3.step;
    count3 = count3.interval;
  }
  if (isString4(count3)) {
    count3 = scale19.type === Time2 ? timeInterval5(count3) : scale19.type == UTC2 ? utcInterval4(count3) : error5("Only time and utc scales accept interval strings.");
    if (step)
      count3 = count3.every(step);
  }
  return count3;
}
function validTicks2(scale19, ticks2, count3) {
  let range7 = scale19.range(), lo = range7[0], hi = peek5(range7), cmp = ascending5;
  if (lo > hi) {
    range7 = hi;
    hi = lo;
    lo = range7;
    cmp = descending3;
  }
  lo = Math.floor(lo);
  hi = Math.ceil(hi);
  ticks2 = ticks2.map((v2) => [v2, scale19(v2)]).filter((_) => lo <= _[1] && _[1] <= hi).sort(cmp).map((_) => _[0]);
  if (count3 > 0 && ticks2.length > 1) {
    const endpoints = [ticks2[0], peek5(ticks2)];
    while (ticks2.length > count3 && ticks2.length >= 3) {
      ticks2 = ticks2.filter((_, i) => !(i % 2));
    }
    if (ticks2.length < 3) {
      ticks2 = endpoints;
    }
  }
  return ticks2;
}
function tickValues2(scale19, count3) {
  return scale19.bins ? validTicks2(scale19, scale19.bins, count3) : scale19.ticks ? scale19.ticks(count3) : scale19.domain();
}
function tickFormat3(locale5, scale19, count3, specifier, formatType, noSkip) {
  const type7 = scale19.type;
  let format14 = defaultFormatter2;
  if (type7 === Time2 || formatType === Time2) {
    format14 = locale5.timeFormat(specifier);
  } else if (type7 === UTC2 || formatType === UTC2) {
    format14 = locale5.utcFormat(specifier);
  } else if (isLogarithmic2(type7)) {
    const varfmt = locale5.formatFloat(specifier);
    if (noSkip || scale19.bins) {
      format14 = varfmt;
    } else {
      const test2 = tickLog2(scale19, count3, false);
      format14 = (_) => test2(_) ? varfmt(_) : "";
    }
  } else if (scale19.tickFormat) {
    const d = scale19.domain();
    format14 = locale5.formatSpan(d[0], d[d.length - 1], count3, specifier);
  } else if (specifier) {
    format14 = locale5.format(specifier);
  }
  return format14;
}
function tickLog2(scale19, count3, values7) {
  const ticks2 = tickValues2(scale19, count3), base = scale19.base(), logb = Math.log(base), k3 = Math.max(1, base * count3 / ticks2.length);
  const test2 = (d) => {
    let i = d / Math.pow(base, Math.round(Math.log(d) / logb));
    if (i * base < base - 0.5)
      i *= base;
    return i <= k3;
  };
  return values7 ? ticks2.filter(test2) : test2;
}
var symbols3 = {
  [Quantile3]: "quantiles",
  [Quantize2]: "thresholds",
  [Threshold2]: "domain"
};
var formats3 = {
  [Quantile3]: "quantiles",
  [Quantize2]: "domain"
};
function labelValues2(scale19, count3) {
  return scale19.bins ? binValues2(scale19.bins) : scale19.type === Log2 ? tickLog2(scale19, count3, true) : symbols3[scale19.type] ? thresholdValues2(scale19[symbols3[scale19.type]]()) : tickValues2(scale19, count3);
}
function thresholdFormat2(locale5, scale19, specifier) {
  const _ = scale19[formats3[scale19.type]](), n = _.length;
  let d = n > 1 ? _[1] - _[0] : _[0], i;
  for (i = 1; i < n; ++i) {
    d = Math.min(d, _[i] - _[i - 1]);
  }
  return locale5.formatSpan(0, d, 3 * 10, specifier);
}
function thresholdValues2(thresholds) {
  const values7 = [-Infinity].concat(thresholds);
  values7.max = Infinity;
  return values7;
}
function binValues2(bins2) {
  const values7 = bins2.slice(0, -1);
  values7.max = peek5(bins2);
  return values7;
}
var isDiscreteRange2 = (scale19) => symbols3[scale19.type] || scale19.bins;
function labelFormat2(locale5, scale19, count3, type7, specifier, formatType, noSkip) {
  const format14 = formats3[scale19.type] && formatType !== Time2 && formatType !== UTC2 ? thresholdFormat2(locale5, scale19, specifier) : tickFormat3(locale5, scale19, count3, specifier, formatType, noSkip);
  return type7 === SymbolLegend2 && isDiscreteRange2(scale19) ? formatRange2(format14) : type7 === DiscreteLegend2 ? formatDiscrete2(format14) : formatPoint2(format14);
}
var formatRange2 = (format14) => (value7, index4, array22) => {
  const limit = get5(array22[index4 + 1], get5(array22.max, Infinity)), lo = formatValue2(value7, format14), hi = formatValue2(limit, format14);
  return lo && hi ? lo + " – " + hi : hi ? "< " + hi : "≥ " + lo;
};
var get5 = (value7, dflt) => value7 != null ? value7 : dflt;
var formatDiscrete2 = (format14) => (value7, index4) => index4 ? format14(value7) : null;
var formatPoint2 = (format14) => (value7) => format14(value7);
var formatValue2 = (value7, format14) => Number.isFinite(value7) ? format14(value7) : null;
function labelFraction(scale19) {
  const domain3 = scale19.domain(), count3 = domain3.length - 1;
  let lo = +domain3[0], hi = +peek5(domain3), span12 = hi - lo;
  if (scale19.type === Threshold2) {
    const adjust = count3 ? span12 / count3 : 0.1;
    lo -= adjust;
    hi += adjust;
    span12 = hi - lo;
  }
  return (value7) => (value7 - lo) / span12;
}

// node_modules/vega-encode/build/vega-encode.js
function AxisTicks(params2) {
  Transform.call(this, null, params2);
}
inherits5(AxisTicks, Transform, {
  transform(_, pulse2) {
    if (this.value && !_.modified()) {
      return pulse2.StopPropagation;
    }
    var locale5 = pulse2.dataflow.locale(), out = pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS), ticks2 = this.value, scale19 = _.scale, tally = _.count == null ? _.values ? _.values.length : 10 : _.count, count3 = tickCount(scale19, tally, _.minstep), format14 = _.format || tickFormat3(locale5, scale19, count3, _.formatSpecifier, _.formatType, !!_.values), values7 = _.values ? validTicks2(scale19, _.values, count3) : tickValues2(scale19, count3);
    if (ticks2)
      out.rem = ticks2;
    ticks2 = values7.map((value7, i) => ingest$1({
      index: i / (values7.length - 1 || 1),
      value: value7,
      label: format14(value7)
    }));
    if (_.extra && ticks2.length) {
      ticks2.push(ingest$1({
        index: -1,
        extra: {
          value: ticks2[0].value
        },
        label: ""
      }));
    }
    out.source = ticks2;
    out.add = ticks2;
    this.value = ticks2;
    return out;
  }
});
function DataJoin(params2) {
  Transform.call(this, null, params2);
}
function defaultItemCreate() {
  return ingest$1({});
}
function newMap(key4) {
  const map13 = fastmap3().test((t) => t.exit);
  map13.lookup = (t) => map13.get(key4(t));
  return map13;
}
inherits5(DataJoin, Transform, {
  transform(_, pulse2) {
    var df = pulse2.dataflow, out = pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS), item = _.item || defaultItemCreate, key4 = _.key || tupleid, map13 = this.value;
    if (isArray5(out.encode)) {
      out.encode = null;
    }
    if (map13 && (_.modified("key") || pulse2.modified(key4))) {
      error5("DataJoin does not support modified key function or fields.");
    }
    if (!map13) {
      pulse2 = pulse2.addAll();
      this.value = map13 = newMap(key4);
    }
    pulse2.visit(pulse2.ADD, (t) => {
      const k3 = key4(t);
      let x9 = map13.get(k3);
      if (x9) {
        if (x9.exit) {
          map13.empty--;
          out.add.push(x9);
        } else {
          out.mod.push(x9);
        }
      } else {
        x9 = item(t);
        map13.set(k3, x9);
        out.add.push(x9);
      }
      x9.datum = t;
      x9.exit = false;
    });
    pulse2.visit(pulse2.MOD, (t) => {
      const k3 = key4(t), x9 = map13.get(k3);
      if (x9) {
        x9.datum = t;
        out.mod.push(x9);
      }
    });
    pulse2.visit(pulse2.REM, (t) => {
      const k3 = key4(t), x9 = map13.get(k3);
      if (t === x9.datum && !x9.exit) {
        out.rem.push(x9);
        x9.exit = true;
        ++map13.empty;
      }
    });
    if (pulse2.changed(pulse2.ADD_MOD))
      out.modifies("datum");
    if (pulse2.clean() || _.clean && map13.empty > df.cleanThreshold) {
      df.runAfter(map13.clean);
    }
    return out;
  }
});
function Encode(params2) {
  Transform.call(this, null, params2);
}
inherits5(Encode, Transform, {
  transform(_, pulse2) {
    var out = pulse2.fork(pulse2.ADD_REM), fmod = _.mod || false, encoders = _.encoders, encode2 = pulse2.encode;
    if (isArray5(encode2)) {
      if (out.changed() || encode2.every((e3) => encoders[e3])) {
        encode2 = encode2[0];
        out.encode = null;
      } else {
        return pulse2.StopPropagation;
      }
    }
    var reenter = encode2 === "enter", update3 = encoders.update || falsy5, enter = encoders.enter || falsy5, exit = encoders.exit || falsy5, set7 = (encode2 && !reenter ? encoders[encode2] : update3) || falsy5;
    if (pulse2.changed(pulse2.ADD)) {
      pulse2.visit(pulse2.ADD, (t) => {
        enter(t, _);
        update3(t, _);
      });
      out.modifies(enter.output);
      out.modifies(update3.output);
      if (set7 !== falsy5 && set7 !== update3) {
        pulse2.visit(pulse2.ADD, (t) => {
          set7(t, _);
        });
        out.modifies(set7.output);
      }
    }
    if (pulse2.changed(pulse2.REM) && exit !== falsy5) {
      pulse2.visit(pulse2.REM, (t) => {
        exit(t, _);
      });
      out.modifies(exit.output);
    }
    if (reenter || set7 !== falsy5) {
      const flag2 = pulse2.MOD | (_.modified() ? pulse2.REFLOW : 0);
      if (reenter) {
        pulse2.visit(flag2, (t) => {
          const mod = enter(t, _) || fmod;
          if (set7(t, _) || mod)
            out.mod.push(t);
        });
        if (out.mod.length)
          out.modifies(enter.output);
      } else {
        pulse2.visit(flag2, (t) => {
          if (set7(t, _) || fmod)
            out.mod.push(t);
        });
      }
      if (out.mod.length)
        out.modifies(set7.output);
    }
    return out.changed() ? out : pulse2.StopPropagation;
  }
});
function LegendEntries(params2) {
  Transform.call(this, [], params2);
}
inherits5(LegendEntries, Transform, {
  transform(_, pulse2) {
    if (this.value != null && !_.modified()) {
      return pulse2.StopPropagation;
    }
    var locale5 = pulse2.dataflow.locale(), out = pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS), items = this.value, type7 = _.type || SymbolLegend2, scale19 = _.scale, limit = +_.limit, count3 = tickCount(scale19, _.count == null ? 5 : _.count, _.minstep), lskip = !!_.values || type7 === SymbolLegend2, format14 = _.format || labelFormat2(locale5, scale19, count3, type7, _.formatSpecifier, _.formatType, lskip), values7 = _.values || labelValues2(scale19, count3), domain3, fraction, size, offset9, ellipsis;
    if (items)
      out.rem = items;
    if (type7 === SymbolLegend2) {
      if (limit && values7.length > limit) {
        pulse2.dataflow.warn("Symbol legend count exceeds limit, filtering items.");
        items = values7.slice(0, limit - 1);
        ellipsis = true;
      } else {
        items = values7;
      }
      if (isFunction5(size = _.size)) {
        if (!_.values && scale19(items[0]) === 0) {
          items = items.slice(1);
        }
        offset9 = items.reduce((max5, value7) => Math.max(max5, size(value7, _)), 0);
      } else {
        size = constant7(offset9 = size || 8);
      }
      items = items.map((value7, index4) => ingest$1({
        index: index4,
        label: format14(value7, index4, items),
        value: value7,
        offset: offset9,
        size: size(value7, _)
      }));
      if (ellipsis) {
        ellipsis = values7[items.length];
        items.push(ingest$1({
          index: items.length,
          label: `…${values7.length - items.length} entries`,
          value: ellipsis,
          offset: offset9,
          size: size(ellipsis, _)
        }));
      }
    } else if (type7 === GradientLegend) {
      domain3 = scale19.domain(), fraction = scaleFraction(scale19, domain3[0], peek5(domain3));
      if (values7.length < 3 && !_.values && domain3[0] !== peek5(domain3)) {
        values7 = [domain3[0], peek5(domain3)];
      }
      items = values7.map((value7, index4) => ingest$1({
        index: index4,
        label: format14(value7, index4, values7),
        value: value7,
        perc: fraction(value7)
      }));
    } else {
      size = values7.length - 1;
      fraction = labelFraction(scale19);
      items = values7.map((value7, index4) => ingest$1({
        index: index4,
        label: format14(value7, index4, values7),
        value: value7,
        perc: index4 ? fraction(value7) : 0,
        perc2: index4 === size ? 1 : fraction(values7[index4 + 1])
      }));
    }
    out.source = items;
    out.add = items;
    this.value = items;
    return out;
  }
});
var sourceX = (t) => t.source.x;
var sourceY = (t) => t.source.y;
var targetX = (t) => t.target.x;
var targetY = (t) => t.target.y;
function LinkPath(params2) {
  Transform.call(this, {}, params2);
}
LinkPath.Definition = {
  "type": "LinkPath",
  "metadata": {
    "modifies": true
  },
  "params": [{
    "name": "sourceX",
    "type": "field",
    "default": "source.x"
  }, {
    "name": "sourceY",
    "type": "field",
    "default": "source.y"
  }, {
    "name": "targetX",
    "type": "field",
    "default": "target.x"
  }, {
    "name": "targetY",
    "type": "field",
    "default": "target.y"
  }, {
    "name": "orient",
    "type": "enum",
    "default": "vertical",
    "values": ["horizontal", "vertical", "radial"]
  }, {
    "name": "shape",
    "type": "enum",
    "default": "line",
    "values": ["line", "arc", "curve", "diagonal", "orthogonal"]
  }, {
    "name": "require",
    "type": "signal"
  }, {
    "name": "as",
    "type": "string",
    "default": "path"
  }]
};
inherits5(LinkPath, Transform, {
  transform(_, pulse2) {
    var sx = _.sourceX || sourceX, sy = _.sourceY || sourceY, tx = _.targetX || targetX, ty = _.targetY || targetY, as = _.as || "path", orient2 = _.orient || "vertical", shape6 = _.shape || "line", path7 = Paths.get(shape6 + "-" + orient2) || Paths.get(shape6);
    if (!path7) {
      error5("LinkPath unsupported type: " + _.shape + (_.orient ? "-" + _.orient : ""));
    }
    pulse2.visit(pulse2.SOURCE, (t) => {
      t[as] = path7(sx(t), sy(t), tx(t), ty(t));
    });
    return pulse2.reflow(_.modified()).modifies(as);
  }
});
var line2 = (sx, sy, tx, ty) => "M" + sx + "," + sy + "L" + tx + "," + ty;
var lineR = (sa6, sr, ta, tr6) => line2(sr * Math.cos(sa6), sr * Math.sin(sa6), tr6 * Math.cos(ta), tr6 * Math.sin(ta));
var arc2 = (sx, sy, tx, ty) => {
  var dx = tx - sx, dy = ty - sy, rr = Math.hypot(dx, dy) / 2, ra = 180 * Math.atan2(dy, dx) / Math.PI;
  return "M" + sx + "," + sy + "A" + rr + "," + rr + " " + ra + " 0 1 " + tx + "," + ty;
};
var arcR = (sa6, sr, ta, tr6) => arc2(sr * Math.cos(sa6), sr * Math.sin(sa6), tr6 * Math.cos(ta), tr6 * Math.sin(ta));
var curve = (sx, sy, tx, ty) => {
  const dx = tx - sx, dy = ty - sy, ix = 0.2 * (dx + dy), iy = 0.2 * (dy - dx);
  return "M" + sx + "," + sy + "C" + (sx + ix) + "," + (sy + iy) + " " + (tx + iy) + "," + (ty - ix) + " " + tx + "," + ty;
};
var curveR = (sa6, sr, ta, tr6) => curve(sr * Math.cos(sa6), sr * Math.sin(sa6), tr6 * Math.cos(ta), tr6 * Math.sin(ta));
var orthoX = (sx, sy, tx, ty) => "M" + sx + "," + sy + "V" + ty + "H" + tx;
var orthoY = (sx, sy, tx, ty) => "M" + sx + "," + sy + "H" + tx + "V" + ty;
var orthoR = (sa6, sr, ta, tr6) => {
  const sc = Math.cos(sa6), ss = Math.sin(sa6), tc = Math.cos(ta), ts6 = Math.sin(ta), sf = Math.abs(ta - sa6) > Math.PI ? ta <= sa6 : ta > sa6;
  return "M" + sr * sc + "," + sr * ss + "A" + sr + "," + sr + " 0 0," + (sf ? 1 : 0) + " " + sr * tc + "," + sr * ts6 + "L" + tr6 * tc + "," + tr6 * ts6;
};
var diagonalX = (sx, sy, tx, ty) => {
  const m3 = (sx + tx) / 2;
  return "M" + sx + "," + sy + "C" + m3 + "," + sy + " " + m3 + "," + ty + " " + tx + "," + ty;
};
var diagonalY = (sx, sy, tx, ty) => {
  const m3 = (sy + ty) / 2;
  return "M" + sx + "," + sy + "C" + sx + "," + m3 + " " + tx + "," + m3 + " " + tx + "," + ty;
};
var diagonalR = (sa6, sr, ta, tr6) => {
  const sc = Math.cos(sa6), ss = Math.sin(sa6), tc = Math.cos(ta), ts6 = Math.sin(ta), mr = (sr + tr6) / 2;
  return "M" + sr * sc + "," + sr * ss + "C" + mr * sc + "," + mr * ss + " " + mr * tc + "," + mr * ts6 + " " + tr6 * tc + "," + tr6 * ts6;
};
var Paths = fastmap3({
  "line": line2,
  "line-radial": lineR,
  "arc": arc2,
  "arc-radial": arcR,
  "curve": curve,
  "curve-radial": curveR,
  "orthogonal-horizontal": orthoX,
  "orthogonal-vertical": orthoY,
  "orthogonal-radial": orthoR,
  "diagonal-horizontal": diagonalX,
  "diagonal-vertical": diagonalY,
  "diagonal-radial": diagonalR
});
function Pie(params2) {
  Transform.call(this, null, params2);
}
Pie.Definition = {
  "type": "Pie",
  "metadata": {
    "modifies": true
  },
  "params": [{
    "name": "field",
    "type": "field"
  }, {
    "name": "startAngle",
    "type": "number",
    "default": 0
  }, {
    "name": "endAngle",
    "type": "number",
    "default": 6.283185307179586
  }, {
    "name": "sort",
    "type": "boolean",
    "default": false
  }, {
    "name": "as",
    "type": "string",
    "array": true,
    "length": 2,
    "default": ["startAngle", "endAngle"]
  }]
};
inherits5(Pie, Transform, {
  transform(_, pulse2) {
    var as = _.as || ["startAngle", "endAngle"], startAngle = as[0], endAngle = as[1], field25 = _.field || one6, start = _.startAngle || 0, stop2 = _.endAngle != null ? _.endAngle : 2 * Math.PI, data3 = pulse2.source, values7 = data3.map(field25), n = values7.length, a4 = start, k3 = (stop2 - start) / sum(values7), index4 = range(n), i, t, v2;
    if (_.sort) {
      index4.sort((a5, b6) => values7[a5] - values7[b6]);
    }
    for (i = 0; i < n; ++i) {
      v2 = values7[index4[i]];
      t = data3[index4[i]];
      t[startAngle] = a4;
      t[endAngle] = a4 += v2 * k3;
    }
    this.value = values7;
    return pulse2.reflow(_.modified()).modifies(as);
  }
});
var DEFAULT_COUNT = 5;
function includeZero(scale19) {
  const type7 = scale19.type;
  return !scale19.bins && (type7 === Linear3 || type7 === Pow2 || type7 === Sqrt2);
}
function includePad(type7) {
  return isContinuous(type7) && type7 !== Sequential2;
}
var SKIP2 = toSet5(["set", "modified", "clear", "type", "scheme", "schemeExtent", "schemeCount", "domain", "domainMin", "domainMid", "domainMax", "domainRaw", "domainImplicit", "nice", "zero", "bins", "range", "rangeStep", "round", "reverse", "interpolate", "interpolateGamma"]);
function Scale(params2) {
  Transform.call(this, null, params2);
  this.modified(true);
}
inherits5(Scale, Transform, {
  transform(_, pulse2) {
    var df = pulse2.dataflow, scale$16 = this.value, key4 = scaleKey(_);
    if (!scale$16 || key4 !== scale$16.type) {
      this.value = scale$16 = scale3(key4)();
    }
    for (key4 in _)
      if (!SKIP2[key4]) {
        if (key4 === "padding" && includePad(scale$16.type))
          continue;
        isFunction5(scale$16[key4]) ? scale$16[key4](_[key4]) : df.warn("Unsupported scale property: " + key4);
      }
    configureRange(scale$16, _, configureBins(scale$16, _, configureDomain(scale$16, _, df)));
    return pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS);
  }
});
function scaleKey(_) {
  var t = _.type, d = "", n;
  if (t === Sequential2)
    return Sequential2 + "-" + Linear3;
  if (isContinuousColor(_)) {
    n = _.rawDomain ? _.rawDomain.length : _.domain ? _.domain.length + +(_.domainMid != null) : 0;
    d = n === 2 ? Sequential2 + "-" : n === 3 ? Diverging2 + "-" : "";
  }
  return (d + t || Linear3).toLowerCase();
}
function isContinuousColor(_) {
  const t = _.type;
  return isContinuous(t) && t !== Time2 && t !== UTC2 && (_.scheme || _.range && _.range.length && _.range.every(isString4));
}
function configureDomain(scale19, _, df) {
  const raw = rawDomain(scale19, _.domainRaw, df);
  if (raw > -1)
    return raw;
  var domain3 = _.domain, type7 = scale19.type, zero28 = _.zero || _.zero === void 0 && includeZero(scale19), n, mid;
  if (!domain3)
    return 0;
  if (zero28 || _.domainMin != null || _.domainMax != null || _.domainMid != null) {
    n = (domain3 = domain3.slice()).length - 1 || 1;
    if (zero28) {
      if (domain3[0] > 0)
        domain3[0] = 0;
      if (domain3[n] < 0)
        domain3[n] = 0;
    }
    if (_.domainMin != null)
      domain3[0] = _.domainMin;
    if (_.domainMax != null)
      domain3[n] = _.domainMax;
    if (_.domainMid != null) {
      mid = _.domainMid;
      const i = mid > domain3[n] ? n + 1 : mid < domain3[0] ? 0 : n;
      if (i !== n)
        df.warn("Scale domainMid exceeds domain min or max.", mid);
      domain3.splice(i, 0, mid);
    }
  }
  if (includePad(type7) && _.padding && domain3[0] !== peek5(domain3)) {
    domain3 = padDomain(type7, domain3, _.range, _.padding, _.exponent, _.constant);
  }
  scale19.domain(domainCheck(type7, domain3, df));
  if (type7 === Ordinal2) {
    scale19.unknown(_.domainImplicit ? implicit : void 0);
  }
  if (_.nice && scale19.nice) {
    scale19.nice(_.nice !== true && tickCount(scale19, _.nice) || null);
  }
  return domain3.length;
}
function rawDomain(scale19, raw, df) {
  if (raw) {
    scale19.domain(domainCheck(scale19.type, raw, df));
    return raw.length;
  } else {
    return -1;
  }
}
function padDomain(type7, domain3, range7, pad5, exponent, constant15) {
  var span12 = Math.abs(peek5(range7) - range7[0]), frac = span12 / (span12 - 2 * pad5), d = type7 === Log2 ? zoomLog2(domain3, null, frac) : type7 === Sqrt2 ? zoomPow2(domain3, null, frac, 0.5) : type7 === Pow2 ? zoomPow2(domain3, null, frac, exponent || 1) : type7 === Symlog2 ? zoomSymlog2(domain3, null, frac, constant15 || 1) : zoomLinear2(domain3, null, frac);
  domain3 = domain3.slice();
  domain3[0] = d[0];
  domain3[domain3.length - 1] = d[1];
  return domain3;
}
function domainCheck(type7, domain3, df) {
  if (isLogarithmic2(type7)) {
    var s2 = Math.abs(domain3.reduce((s3, v2) => s3 + (v2 < 0 ? -1 : v2 > 0 ? 1 : 0), 0));
    if (s2 !== domain3.length) {
      df.warn("Log scale domain includes zero: " + $4(domain3));
    }
  }
  return domain3;
}
function configureBins(scale19, _, count3) {
  let bins2 = _.bins;
  if (bins2 && !isArray5(bins2)) {
    const domain3 = scale19.domain(), lo = domain3[0], hi = peek5(domain3), step = bins2.step;
    let start = bins2.start == null ? lo : bins2.start, stop2 = bins2.stop == null ? hi : bins2.stop;
    if (!step)
      error5("Scale bins parameter missing step property.");
    if (start < lo)
      start = step * Math.ceil(lo / step);
    if (stop2 > hi)
      stop2 = step * Math.floor(hi / step);
    bins2 = range(start, stop2 + step / 2, step);
  }
  if (bins2) {
    scale19.bins = bins2;
  } else if (scale19.bins) {
    delete scale19.bins;
  }
  if (scale19.type === BinOrdinal2) {
    if (!bins2) {
      scale19.bins = scale19.domain();
    } else if (!_.domain && !_.domainRaw) {
      scale19.domain(bins2);
      count3 = bins2.length;
    }
  }
  return count3;
}
function configureRange(scale19, _, count3) {
  var type7 = scale19.type, round2 = _.round || false, range7 = _.range;
  if (_.rangeStep != null) {
    range7 = configureRangeStep(type7, _, count3);
  } else if (_.scheme) {
    range7 = configureScheme(type7, _, count3);
    if (isFunction5(range7)) {
      if (scale19.interpolator) {
        return scale19.interpolator(range7);
      } else {
        error5(`Scale type ${type7} does not support interpolating color schemes.`);
      }
    }
  }
  if (range7 && isInterpolating(type7)) {
    return scale19.interpolator(interpolateColors2(flip(range7, _.reverse), _.interpolate, _.interpolateGamma));
  }
  if (range7 && _.interpolate && scale19.interpolate) {
    scale19.interpolate(interpolate2(_.interpolate, _.interpolateGamma));
  } else if (isFunction5(scale19.round)) {
    scale19.round(round2);
  } else if (isFunction5(scale19.rangeRound)) {
    scale19.interpolate(round2 ? round_default : value_default);
  }
  if (range7)
    scale19.range(flip(range7, _.reverse));
}
function configureRangeStep(type7, _, count3) {
  if (type7 !== Band2 && type7 !== Point2) {
    error5("Only band and point scales support rangeStep.");
  }
  var outer = (_.paddingOuter != null ? _.paddingOuter : _.padding) || 0, inner = type7 === Point2 ? 1 : (_.paddingInner != null ? _.paddingInner : _.padding) || 0;
  return [0, _.rangeStep * bandSpace2(count3, inner, outer)];
}
function configureScheme(type7, _, count3) {
  var extent8 = _.schemeExtent, name, scheme$1;
  if (isArray5(_.scheme)) {
    scheme$1 = interpolateColors2(_.scheme, _.interpolate, _.interpolateGamma);
  } else {
    name = _.scheme.toLowerCase();
    scheme$1 = scheme29(name);
    if (!scheme$1)
      error5(`Unrecognized scheme name: ${_.scheme}`);
  }
  count3 = type7 === Threshold2 ? count3 + 1 : type7 === BinOrdinal2 ? count3 - 1 : type7 === Quantile3 || type7 === Quantize2 ? +_.schemeCount || DEFAULT_COUNT : count3;
  return isInterpolating(type7) ? adjustScheme(scheme$1, extent8, _.reverse) : isFunction5(scheme$1) ? quantizeInterpolator(adjustScheme(scheme$1, extent8), count3) : type7 === Ordinal2 ? scheme$1 : scheme$1.slice(0, count3);
}
function adjustScheme(scheme38, extent8, reverse4) {
  return isFunction5(scheme38) && (extent8 || reverse4) ? interpolateRange(scheme38, flip(extent8 || [0, 1], reverse4)) : scheme38;
}
function flip(array22, reverse4) {
  return reverse4 ? array22.slice().reverse() : array22;
}
function SortItems(params2) {
  Transform.call(this, null, params2);
}
inherits5(SortItems, Transform, {
  transform(_, pulse2) {
    const mod = _.modified("sort") || pulse2.changed(pulse2.ADD) || pulse2.modified(_.sort.fields) || pulse2.modified("datum");
    if (mod)
      pulse2.source.sort(stableCompare(_.sort));
    this.modified(mod);
    return pulse2;
  }
});
var Zero = "zero";
var Center = "center";
var Normalize = "normalize";
var DefOutput = ["y0", "y1"];
function Stack(params2) {
  Transform.call(this, null, params2);
}
Stack.Definition = {
  "type": "Stack",
  "metadata": {
    "modifies": true
  },
  "params": [{
    "name": "field",
    "type": "field"
  }, {
    "name": "groupby",
    "type": "field",
    "array": true
  }, {
    "name": "sort",
    "type": "compare"
  }, {
    "name": "offset",
    "type": "enum",
    "default": Zero,
    "values": [Zero, Center, Normalize]
  }, {
    "name": "as",
    "type": "string",
    "array": true,
    "length": 2,
    "default": DefOutput
  }]
};
inherits5(Stack, Transform, {
  transform(_, pulse2) {
    var as = _.as || DefOutput, y07 = as[0], y13 = as[1], sort4 = stableCompare(_.sort), field25 = _.field || one6, stack2 = _.offset === Center ? stackCenter : _.offset === Normalize ? stackNormalize : stackZero, groups2, i, n, max5;
    groups2 = partition2(pulse2.source, _.groupby, sort4, field25);
    for (i = 0, n = groups2.length, max5 = groups2.max; i < n; ++i) {
      stack2(groups2[i], max5, field25, y07, y13);
    }
    return pulse2.reflow(_.modified()).modifies(as);
  }
});
function stackCenter(group7, max5, field25, y07, y13) {
  var last = (max5 - group7.sum) / 2, m3 = group7.length, j = 0, t;
  for (; j < m3; ++j) {
    t = group7[j];
    t[y07] = last;
    t[y13] = last += Math.abs(field25(t));
  }
}
function stackNormalize(group7, max5, field25, y07, y13) {
  var scale19 = 1 / group7.sum, last = 0, m3 = group7.length, j = 0, v2 = 0, t;
  for (; j < m3; ++j) {
    t = group7[j];
    t[y07] = last;
    t[y13] = last = scale19 * (v2 += Math.abs(field25(t)));
  }
}
function stackZero(group7, max5, field25, y07, y13) {
  var lastPos = 0, lastNeg = 0, m3 = group7.length, j = 0, v2, t;
  for (; j < m3; ++j) {
    t = group7[j];
    v2 = +field25(t);
    if (v2 < 0) {
      t[y07] = lastNeg;
      t[y13] = lastNeg += v2;
    } else {
      t[y07] = lastPos;
      t[y13] = lastPos += v2;
    }
  }
}
function partition2(data3, groupby, sort4, field25) {
  var groups2 = [], get23 = (f) => f(t), map13, i, n, m3, t, k3, g, s2, max5;
  if (groupby == null) {
    groups2.push(data3.slice());
  } else {
    for (map13 = {}, i = 0, n = data3.length; i < n; ++i) {
      t = data3[i];
      k3 = groupby.map(get23);
      g = map13[k3];
      if (!g) {
        map13[k3] = g = [];
        groups2.push(g);
      }
      g.push(t);
    }
  }
  for (k3 = 0, max5 = 0, m3 = groups2.length; k3 < m3; ++k3) {
    g = groups2[k3];
    for (i = 0, s2 = 0, n = g.length; i < n; ++i) {
      s2 += Math.abs(field25(g[i]));
    }
    g.sum = s2;
    if (s2 > max5)
      max5 = s2;
    if (sort4)
      g.sort(sort4);
  }
  groups2.max = max5;
  return groups2;
}

// node_modules/vega-geo/build/vega-geo.js
var vega_geo_exports = {};
__export(vega_geo_exports, {
  contour: () => Contour,
  geojson: () => GeoJSON,
  geopath: () => GeoPath,
  geopoint: () => GeoPoint,
  geoshape: () => GeoShape,
  graticule: () => Graticule,
  heatmap: () => Heatmap,
  isocontour: () => Isocontour,
  kde2d: () => KDE2D,
  projection: () => Projection
});

// node_modules/vega-geo/node_modules/vega-util/build/vega-util.js
function accessor6(fn, fields, name) {
  fn.fields = fields || [];
  fn.fname = name;
  return fn;
}
function accessorName3(fn) {
  return fn == null ? null : fn.fname;
}
function accessorFields3(fn) {
  return fn == null ? null : fn.fields;
}
function getter6(path7) {
  return path7.length === 1 ? get16(path7[0]) : getN6(path7);
}
var get16 = (field25) => function(obj) {
  return obj[field25];
};
var getN6 = (path7) => {
  const len = path7.length;
  return function(obj) {
    for (let i = 0; i < len; ++i) {
      obj = obj[path7[i]];
    }
    return obj;
  };
};
function error6(message) {
  throw Error(message);
}
function splitAccessPath6(p) {
  const path7 = [], n = p.length;
  let q = null, b6 = 0, s2 = "", i, j, c5;
  p = p + "";
  function push() {
    path7.push(s2 + p.substring(i, j));
    s2 = "";
    i = j + 1;
  }
  for (i = j = 0; j < n; ++j) {
    c5 = p[j];
    if (c5 === "\\") {
      s2 += p.substring(i, j++);
      i = j;
    } else if (c5 === q) {
      push();
      q = null;
      b6 = -1;
    } else if (q) {
      continue;
    } else if (i === b6 && c5 === '"') {
      i = j + 1;
      q = c5;
    } else if (i === b6 && c5 === "'") {
      i = j + 1;
      q = c5;
    } else if (c5 === "." && !b6) {
      if (j > i) {
        push();
      } else {
        i = j + 1;
      }
    } else if (c5 === "[") {
      if (j > i)
        push();
      b6 = i = j + 1;
    } else if (c5 === "]") {
      if (!b6)
        error6("Access path missing open bracket: " + p);
      if (b6 > 0)
        push();
      b6 = 0;
      i = j + 1;
    }
  }
  if (b6)
    error6("Access path missing closing bracket: " + p);
  if (q)
    error6("Access path missing closing quote: " + p);
  if (j > i) {
    j++;
    push();
  }
  return path7;
}
function field6(field25, name, opt) {
  const path7 = splitAccessPath6(field25);
  field25 = path7.length === 1 ? path7[0] : field25;
  return accessor6((opt && opt.get || getter6)(path7), [field25], name || field25);
}
var id6 = field6("id");
var identity10 = accessor6((_) => _, [], "identity");
var zero8 = accessor6(() => 0, [], "zero");
var one7 = accessor6(() => 1, [], "one");
var truthy6 = accessor6(() => true, [], "true");
var falsy6 = accessor6(() => false, [], "false");
var DisallowedObjectProperties6 = /* @__PURE__ */ new Set([...Object.getOwnPropertyNames(Object.prototype).filter((name) => typeof Object.prototype[name] === "function"), "__proto__"]);
var isArray6 = Array.isArray;
function array7(_) {
  return _ != null ? isArray6(_) ? _ : [_] : [];
}
function isFunction6(_) {
  return typeof _ === "function";
}
function constant8(_) {
  return isFunction6(_) ? _ : () => _;
}
function extend7(_) {
  for (let x9, k3, i = 1, len = arguments.length; i < len; ++i) {
    x9 = arguments[i];
    for (k3 in x9) {
      _[k3] = x9[k3];
    }
  }
  return _;
}
function extent4(array22, f) {
  let i = 0, n, v2, min5, max5;
  if (array22 && (n = array22.length)) {
    if (f == null) {
      for (v2 = array22[i]; i < n && (v2 == null || v2 !== v2); v2 = array22[++i])
        ;
      min5 = max5 = v2;
      for (; i < n; ++i) {
        v2 = array22[i];
        if (v2 != null) {
          if (v2 < min5)
            min5 = v2;
          if (v2 > max5)
            max5 = v2;
        }
      }
    } else {
      for (v2 = f(array22[i]); i < n && (v2 == null || v2 !== v2); v2 = f(array22[++i]))
        ;
      min5 = max5 = v2;
      for (; i < n; ++i) {
        v2 = f(array22[i]);
        if (v2 != null) {
          if (v2 < min5)
            min5 = v2;
          if (v2 > max5)
            max5 = v2;
        }
      }
    }
  }
  return [min5, max5];
}
function inherits6(child, parent, members) {
  const proto = child.prototype = Object.create(parent.prototype);
  Object.defineProperty(proto, "constructor", {
    value: child,
    writable: true,
    enumerable: true,
    configurable: true
  });
  return extend7(proto, members);
}
function isNumber6(_) {
  return typeof _ === "number";
}
function toSet6(_) {
  const s2 = {}, n = _.length;
  for (let i = 0; i < n; ++i)
    s2[_[i]] = true;
  return s2;
}

// node_modules/d3-geo/src/math.js
var epsilon4 = 1e-6;
var epsilon23 = 1e-12;
var pi3 = Math.PI;
var halfPi2 = pi3 / 2;
var quarterPi = pi3 / 4;
var tau3 = pi3 * 2;
var degrees3 = 180 / pi3;
var radians2 = pi3 / 180;
var abs2 = Math.abs;
var atan = Math.atan;
var atan22 = Math.atan2;
var cos2 = Math.cos;
var ceil = Math.ceil;
var exp4 = Math.exp;
var hypot = Math.hypot;
var log5 = Math.log;
var pow5 = Math.pow;
var sin2 = Math.sin;
var sign2 = Math.sign || function(x9) {
  return x9 > 0 ? 1 : x9 < 0 ? -1 : 0;
};
var sqrt4 = Math.sqrt;
var tan = Math.tan;
function acos2(x9) {
  return x9 > 1 ? 0 : x9 < -1 ? pi3 : Math.acos(x9);
}
function asin2(x9) {
  return x9 > 1 ? halfPi2 : x9 < -1 ? -halfPi2 : Math.asin(x9);
}

// node_modules/d3-geo/src/noop.js
function noop2() {
}

// node_modules/d3-geo/src/stream.js
function streamGeometry(geometry, stream2) {
  if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {
    streamGeometryType[geometry.type](geometry, stream2);
  }
}
var streamObjectType = {
  Feature: function(object2, stream2) {
    streamGeometry(object2.geometry, stream2);
  },
  FeatureCollection: function(object2, stream2) {
    var features = object2.features, i = -1, n = features.length;
    while (++i < n)
      streamGeometry(features[i].geometry, stream2);
  }
};
var streamGeometryType = {
  Sphere: function(object2, stream2) {
    stream2.sphere();
  },
  Point: function(object2, stream2) {
    object2 = object2.coordinates;
    stream2.point(object2[0], object2[1], object2[2]);
  },
  MultiPoint: function(object2, stream2) {
    var coordinates = object2.coordinates, i = -1, n = coordinates.length;
    while (++i < n)
      object2 = coordinates[i], stream2.point(object2[0], object2[1], object2[2]);
  },
  LineString: function(object2, stream2) {
    streamLine(object2.coordinates, stream2, 0);
  },
  MultiLineString: function(object2, stream2) {
    var coordinates = object2.coordinates, i = -1, n = coordinates.length;
    while (++i < n)
      streamLine(coordinates[i], stream2, 0);
  },
  Polygon: function(object2, stream2) {
    streamPolygon(object2.coordinates, stream2);
  },
  MultiPolygon: function(object2, stream2) {
    var coordinates = object2.coordinates, i = -1, n = coordinates.length;
    while (++i < n)
      streamPolygon(coordinates[i], stream2);
  },
  GeometryCollection: function(object2, stream2) {
    var geometries = object2.geometries, i = -1, n = geometries.length;
    while (++i < n)
      streamGeometry(geometries[i], stream2);
  }
};
function streamLine(coordinates, stream2, closed) {
  var i = -1, n = coordinates.length - closed, coordinate;
  stream2.lineStart();
  while (++i < n)
    coordinate = coordinates[i], stream2.point(coordinate[0], coordinate[1], coordinate[2]);
  stream2.lineEnd();
}
function streamPolygon(coordinates, stream2) {
  var i = -1, n = coordinates.length;
  stream2.polygonStart();
  while (++i < n)
    streamLine(coordinates[i], stream2, 1);
  stream2.polygonEnd();
}
function stream_default(object2, stream2) {
  if (object2 && streamObjectType.hasOwnProperty(object2.type)) {
    streamObjectType[object2.type](object2, stream2);
  } else {
    streamGeometry(object2, stream2);
  }
}

// node_modules/d3-geo/src/area.js
var areaRingSum = new Adder();
var areaSum = new Adder();
var lambda00;
var phi00;
var lambda0;
var cosPhi0;
var sinPhi0;
var areaStream = {
  point: noop2,
  lineStart: noop2,
  lineEnd: noop2,
  polygonStart: function() {
    areaRingSum = new Adder();
    areaStream.lineStart = areaRingStart;
    areaStream.lineEnd = areaRingEnd;
  },
  polygonEnd: function() {
    var areaRing = +areaRingSum;
    areaSum.add(areaRing < 0 ? tau3 + areaRing : areaRing);
    this.lineStart = this.lineEnd = this.point = noop2;
  },
  sphere: function() {
    areaSum.add(tau3);
  }
};
function areaRingStart() {
  areaStream.point = areaPointFirst;
}
function areaRingEnd() {
  areaPoint(lambda00, phi00);
}
function areaPointFirst(lambda, phi2) {
  areaStream.point = areaPoint;
  lambda00 = lambda, phi00 = phi2;
  lambda *= radians2, phi2 *= radians2;
  lambda0 = lambda, cosPhi0 = cos2(phi2 = phi2 / 2 + quarterPi), sinPhi0 = sin2(phi2);
}
function areaPoint(lambda, phi2) {
  lambda *= radians2, phi2 *= radians2;
  phi2 = phi2 / 2 + quarterPi;
  var dLambda = lambda - lambda0, sdLambda = dLambda >= 0 ? 1 : -1, adLambda = sdLambda * dLambda, cosPhi = cos2(phi2), sinPhi = sin2(phi2), k3 = sinPhi0 * sinPhi, u4 = cosPhi0 * cosPhi + k3 * cos2(adLambda), v2 = k3 * sdLambda * sin2(adLambda);
  areaRingSum.add(atan22(v2, u4));
  lambda0 = lambda, cosPhi0 = cosPhi, sinPhi0 = sinPhi;
}
function area_default2(object2) {
  areaSum = new Adder();
  stream_default(object2, areaStream);
  return areaSum * 2;
}

// node_modules/d3-geo/src/cartesian.js
function spherical(cartesian2) {
  return [atan22(cartesian2[1], cartesian2[0]), asin2(cartesian2[2])];
}
function cartesian(spherical2) {
  var lambda = spherical2[0], phi2 = spherical2[1], cosPhi = cos2(phi2);
  return [cosPhi * cos2(lambda), cosPhi * sin2(lambda), sin2(phi2)];
}
function cartesianDot(a4, b6) {
  return a4[0] * b6[0] + a4[1] * b6[1] + a4[2] * b6[2];
}
function cartesianCross(a4, b6) {
  return [a4[1] * b6[2] - a4[2] * b6[1], a4[2] * b6[0] - a4[0] * b6[2], a4[0] * b6[1] - a4[1] * b6[0]];
}
function cartesianAddInPlace(a4, b6) {
  a4[0] += b6[0], a4[1] += b6[1], a4[2] += b6[2];
}
function cartesianScale(vector, k3) {
  return [vector[0] * k3, vector[1] * k3, vector[2] * k3];
}
function cartesianNormalizeInPlace(d) {
  var l = sqrt4(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
  d[0] /= l, d[1] /= l, d[2] /= l;
}

// node_modules/d3-geo/src/bounds.js
var lambda02;
var phi0;
var lambda1;
var phi1;
var lambda2;
var lambda002;
var phi002;
var p0;
var deltaSum;
var ranges;
var range2;
var boundsStream = {
  point: boundsPoint,
  lineStart: boundsLineStart,
  lineEnd: boundsLineEnd,
  polygonStart: function() {
    boundsStream.point = boundsRingPoint;
    boundsStream.lineStart = boundsRingStart;
    boundsStream.lineEnd = boundsRingEnd;
    deltaSum = new Adder();
    areaStream.polygonStart();
  },
  polygonEnd: function() {
    areaStream.polygonEnd();
    boundsStream.point = boundsPoint;
    boundsStream.lineStart = boundsLineStart;
    boundsStream.lineEnd = boundsLineEnd;
    if (areaRingSum < 0)
      lambda02 = -(lambda1 = 180), phi0 = -(phi1 = 90);
    else if (deltaSum > epsilon4)
      phi1 = 90;
    else if (deltaSum < -epsilon4)
      phi0 = -90;
    range2[0] = lambda02, range2[1] = lambda1;
  },
  sphere: function() {
    lambda02 = -(lambda1 = 180), phi0 = -(phi1 = 90);
  }
};
function boundsPoint(lambda, phi2) {
  ranges.push(range2 = [lambda02 = lambda, lambda1 = lambda]);
  if (phi2 < phi0)
    phi0 = phi2;
  if (phi2 > phi1)
    phi1 = phi2;
}
function linePoint(lambda, phi2) {
  var p = cartesian([lambda * radians2, phi2 * radians2]);
  if (p0) {
    var normal = cartesianCross(p0, p), equatorial = [normal[1], -normal[0], 0], inflection = cartesianCross(equatorial, normal);
    cartesianNormalizeInPlace(inflection);
    inflection = spherical(inflection);
    var delta = lambda - lambda2, sign4 = delta > 0 ? 1 : -1, lambdai = inflection[0] * degrees3 * sign4, phii, antimeridian = abs2(delta) > 180;
    if (antimeridian ^ (sign4 * lambda2 < lambdai && lambdai < sign4 * lambda)) {
      phii = inflection[1] * degrees3;
      if (phii > phi1)
        phi1 = phii;
    } else if (lambdai = (lambdai + 360) % 360 - 180, antimeridian ^ (sign4 * lambda2 < lambdai && lambdai < sign4 * lambda)) {
      phii = -inflection[1] * degrees3;
      if (phii < phi0)
        phi0 = phii;
    } else {
      if (phi2 < phi0)
        phi0 = phi2;
      if (phi2 > phi1)
        phi1 = phi2;
    }
    if (antimeridian) {
      if (lambda < lambda2) {
        if (angle(lambda02, lambda) > angle(lambda02, lambda1))
          lambda1 = lambda;
      } else {
        if (angle(lambda, lambda1) > angle(lambda02, lambda1))
          lambda02 = lambda;
      }
    } else {
      if (lambda1 >= lambda02) {
        if (lambda < lambda02)
          lambda02 = lambda;
        if (lambda > lambda1)
          lambda1 = lambda;
      } else {
        if (lambda > lambda2) {
          if (angle(lambda02, lambda) > angle(lambda02, lambda1))
            lambda1 = lambda;
        } else {
          if (angle(lambda, lambda1) > angle(lambda02, lambda1))
            lambda02 = lambda;
        }
      }
    }
  } else {
    ranges.push(range2 = [lambda02 = lambda, lambda1 = lambda]);
  }
  if (phi2 < phi0)
    phi0 = phi2;
  if (phi2 > phi1)
    phi1 = phi2;
  p0 = p, lambda2 = lambda;
}
function boundsLineStart() {
  boundsStream.point = linePoint;
}
function boundsLineEnd() {
  range2[0] = lambda02, range2[1] = lambda1;
  boundsStream.point = boundsPoint;
  p0 = null;
}
function boundsRingPoint(lambda, phi2) {
  if (p0) {
    var delta = lambda - lambda2;
    deltaSum.add(abs2(delta) > 180 ? delta + (delta > 0 ? 360 : -360) : delta);
  } else {
    lambda002 = lambda, phi002 = phi2;
  }
  areaStream.point(lambda, phi2);
  linePoint(lambda, phi2);
}
function boundsRingStart() {
  areaStream.lineStart();
}
function boundsRingEnd() {
  boundsRingPoint(lambda002, phi002);
  areaStream.lineEnd();
  if (abs2(deltaSum) > epsilon4)
    lambda02 = -(lambda1 = 180);
  range2[0] = lambda02, range2[1] = lambda1;
  p0 = null;
}
function angle(lambda03, lambda12) {
  return (lambda12 -= lambda03) < 0 ? lambda12 + 360 : lambda12;
}
function rangeCompare(a4, b6) {
  return a4[0] - b6[0];
}
function rangeContains(range7, x9) {
  return range7[0] <= range7[1] ? range7[0] <= x9 && x9 <= range7[1] : x9 < range7[0] || range7[1] < x9;
}
function bounds_default(feature2) {
  var i, n, a4, b6, merged, deltaMax, delta;
  phi1 = lambda1 = -(lambda02 = phi0 = Infinity);
  ranges = [];
  stream_default(feature2, boundsStream);
  if (n = ranges.length) {
    ranges.sort(rangeCompare);
    for (i = 1, a4 = ranges[0], merged = [a4]; i < n; ++i) {
      b6 = ranges[i];
      if (rangeContains(a4, b6[0]) || rangeContains(a4, b6[1])) {
        if (angle(a4[0], b6[1]) > angle(a4[0], a4[1]))
          a4[1] = b6[1];
        if (angle(b6[0], a4[1]) > angle(a4[0], a4[1]))
          a4[0] = b6[0];
      } else {
        merged.push(a4 = b6);
      }
    }
    for (deltaMax = -Infinity, n = merged.length - 1, i = 0, a4 = merged[n]; i <= n; a4 = b6, ++i) {
      b6 = merged[i];
      if ((delta = angle(a4[1], b6[0])) > deltaMax)
        deltaMax = delta, lambda02 = b6[0], lambda1 = a4[1];
    }
  }
  ranges = range2 = null;
  return lambda02 === Infinity || phi0 === Infinity ? [[NaN, NaN], [NaN, NaN]] : [[lambda02, phi0], [lambda1, phi1]];
}

// node_modules/d3-geo/src/centroid.js
var W0;
var W1;
var X0;
var Y0;
var Z0;
var X1;
var Y1;
var Z1;
var X2;
var Y2;
var Z2;
var lambda003;
var phi003;
var x0;
var y0;
var z0;
var centroidStream = {
  sphere: noop2,
  point: centroidPoint,
  lineStart: centroidLineStart,
  lineEnd: centroidLineEnd,
  polygonStart: function() {
    centroidStream.lineStart = centroidRingStart;
    centroidStream.lineEnd = centroidRingEnd;
  },
  polygonEnd: function() {
    centroidStream.lineStart = centroidLineStart;
    centroidStream.lineEnd = centroidLineEnd;
  }
};
function centroidPoint(lambda, phi2) {
  lambda *= radians2, phi2 *= radians2;
  var cosPhi = cos2(phi2);
  centroidPointCartesian(cosPhi * cos2(lambda), cosPhi * sin2(lambda), sin2(phi2));
}
function centroidPointCartesian(x9, y9, z) {
  ++W0;
  X0 += (x9 - X0) / W0;
  Y0 += (y9 - Y0) / W0;
  Z0 += (z - Z0) / W0;
}
function centroidLineStart() {
  centroidStream.point = centroidLinePointFirst;
}
function centroidLinePointFirst(lambda, phi2) {
  lambda *= radians2, phi2 *= radians2;
  var cosPhi = cos2(phi2);
  x0 = cosPhi * cos2(lambda);
  y0 = cosPhi * sin2(lambda);
  z0 = sin2(phi2);
  centroidStream.point = centroidLinePoint;
  centroidPointCartesian(x0, y0, z0);
}
function centroidLinePoint(lambda, phi2) {
  lambda *= radians2, phi2 *= radians2;
  var cosPhi = cos2(phi2), x9 = cosPhi * cos2(lambda), y9 = cosPhi * sin2(lambda), z = sin2(phi2), w8 = atan22(sqrt4((w8 = y0 * z - z0 * y9) * w8 + (w8 = z0 * x9 - x0 * z) * w8 + (w8 = x0 * y9 - y0 * x9) * w8), x0 * x9 + y0 * y9 + z0 * z);
  W1 += w8;
  X1 += w8 * (x0 + (x0 = x9));
  Y1 += w8 * (y0 + (y0 = y9));
  Z1 += w8 * (z0 + (z0 = z));
  centroidPointCartesian(x0, y0, z0);
}
function centroidLineEnd() {
  centroidStream.point = centroidPoint;
}
function centroidRingStart() {
  centroidStream.point = centroidRingPointFirst;
}
function centroidRingEnd() {
  centroidRingPoint(lambda003, phi003);
  centroidStream.point = centroidPoint;
}
function centroidRingPointFirst(lambda, phi2) {
  lambda003 = lambda, phi003 = phi2;
  lambda *= radians2, phi2 *= radians2;
  centroidStream.point = centroidRingPoint;
  var cosPhi = cos2(phi2);
  x0 = cosPhi * cos2(lambda);
  y0 = cosPhi * sin2(lambda);
  z0 = sin2(phi2);
  centroidPointCartesian(x0, y0, z0);
}
function centroidRingPoint(lambda, phi2) {
  lambda *= radians2, phi2 *= radians2;
  var cosPhi = cos2(phi2), x9 = cosPhi * cos2(lambda), y9 = cosPhi * sin2(lambda), z = sin2(phi2), cx = y0 * z - z0 * y9, cy = z0 * x9 - x0 * z, cz = x0 * y9 - y0 * x9, m3 = hypot(cx, cy, cz), w8 = asin2(m3), v2 = m3 && -w8 / m3;
  X2.add(v2 * cx);
  Y2.add(v2 * cy);
  Z2.add(v2 * cz);
  W1 += w8;
  X1 += w8 * (x0 + (x0 = x9));
  Y1 += w8 * (y0 + (y0 = y9));
  Z1 += w8 * (z0 + (z0 = z));
  centroidPointCartesian(x0, y0, z0);
}
function centroid_default(object2) {
  W0 = W1 = X0 = Y0 = Z0 = X1 = Y1 = Z1 = 0;
  X2 = new Adder();
  Y2 = new Adder();
  Z2 = new Adder();
  stream_default(object2, centroidStream);
  var x9 = +X2, y9 = +Y2, z = +Z2, m3 = hypot(x9, y9, z);
  if (m3 < epsilon23) {
    x9 = X1, y9 = Y1, z = Z1;
    if (W1 < epsilon4)
      x9 = X0, y9 = Y0, z = Z0;
    m3 = hypot(x9, y9, z);
    if (m3 < epsilon23)
      return [NaN, NaN];
  }
  return [atan22(y9, x9) * degrees3, asin2(z / m3) * degrees3];
}

// node_modules/d3-geo/src/compose.js
function compose_default(a4, b6) {
  function compose(x9, y9) {
    return x9 = a4(x9, y9), b6(x9[0], x9[1]);
  }
  if (a4.invert && b6.invert)
    compose.invert = function(x9, y9) {
      return x9 = b6.invert(x9, y9), x9 && a4.invert(x9[0], x9[1]);
    };
  return compose;
}

// node_modules/d3-geo/src/rotation.js
function rotationIdentity(lambda, phi2) {
  if (abs2(lambda) > pi3)
    lambda -= Math.round(lambda / tau3) * tau3;
  return [lambda, phi2];
}
rotationIdentity.invert = rotationIdentity;
function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {
  return (deltaLambda %= tau3) ? deltaPhi || deltaGamma ? compose_default(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma)) : rotationLambda(deltaLambda) : deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma) : rotationIdentity;
}
function forwardRotationLambda(deltaLambda) {
  return function(lambda, phi2) {
    lambda += deltaLambda;
    if (abs2(lambda) > pi3)
      lambda -= Math.round(lambda / tau3) * tau3;
    return [lambda, phi2];
  };
}
function rotationLambda(deltaLambda) {
  var rotation = forwardRotationLambda(deltaLambda);
  rotation.invert = forwardRotationLambda(-deltaLambda);
  return rotation;
}
function rotationPhiGamma(deltaPhi, deltaGamma) {
  var cosDeltaPhi = cos2(deltaPhi), sinDeltaPhi = sin2(deltaPhi), cosDeltaGamma = cos2(deltaGamma), sinDeltaGamma = sin2(deltaGamma);
  function rotation(lambda, phi2) {
    var cosPhi = cos2(phi2), x9 = cos2(lambda) * cosPhi, y9 = sin2(lambda) * cosPhi, z = sin2(phi2), k3 = z * cosDeltaPhi + x9 * sinDeltaPhi;
    return [
      atan22(y9 * cosDeltaGamma - k3 * sinDeltaGamma, x9 * cosDeltaPhi - z * sinDeltaPhi),
      asin2(k3 * cosDeltaGamma + y9 * sinDeltaGamma)
    ];
  }
  rotation.invert = function(lambda, phi2) {
    var cosPhi = cos2(phi2), x9 = cos2(lambda) * cosPhi, y9 = sin2(lambda) * cosPhi, z = sin2(phi2), k3 = z * cosDeltaGamma - y9 * sinDeltaGamma;
    return [
      atan22(y9 * cosDeltaGamma + z * sinDeltaGamma, x9 * cosDeltaPhi + k3 * sinDeltaPhi),
      asin2(k3 * cosDeltaPhi - x9 * sinDeltaPhi)
    ];
  };
  return rotation;
}
function rotation_default(rotate6) {
  rotate6 = rotateRadians(rotate6[0] * radians2, rotate6[1] * radians2, rotate6.length > 2 ? rotate6[2] * radians2 : 0);
  function forward(coordinates) {
    coordinates = rotate6(coordinates[0] * radians2, coordinates[1] * radians2);
    return coordinates[0] *= degrees3, coordinates[1] *= degrees3, coordinates;
  }
  forward.invert = function(coordinates) {
    coordinates = rotate6.invert(coordinates[0] * radians2, coordinates[1] * radians2);
    return coordinates[0] *= degrees3, coordinates[1] *= degrees3, coordinates;
  };
  return forward;
}

// node_modules/d3-geo/src/circle.js
function circleStream(stream2, radius2, delta, direction, t014, t13) {
  if (!delta)
    return;
  var cosRadius = cos2(radius2), sinRadius = sin2(radius2), step = direction * delta;
  if (t014 == null) {
    t014 = radius2 + direction * tau3;
    t13 = radius2 - step / 2;
  } else {
    t014 = circleRadius(cosRadius, t014);
    t13 = circleRadius(cosRadius, t13);
    if (direction > 0 ? t014 < t13 : t014 > t13)
      t014 += direction * tau3;
  }
  for (var point21, t = t014; direction > 0 ? t > t13 : t < t13; t -= step) {
    point21 = spherical([cosRadius, -sinRadius * cos2(t), -sinRadius * sin2(t)]);
    stream2.point(point21[0], point21[1]);
  }
}
function circleRadius(cosRadius, point21) {
  point21 = cartesian(point21), point21[0] -= cosRadius;
  cartesianNormalizeInPlace(point21);
  var radius2 = acos2(-point21[1]);
  return ((-point21[2] < 0 ? -radius2 : radius2) + tau3 - epsilon4) % tau3;
}

// node_modules/d3-geo/src/clip/buffer.js
function buffer_default() {
  var lines = [], line8;
  return {
    point: function(x9, y9, m3) {
      line8.push([x9, y9, m3]);
    },
    lineStart: function() {
      lines.push(line8 = []);
    },
    lineEnd: noop2,
    rejoin: function() {
      if (lines.length > 1)
        lines.push(lines.pop().concat(lines.shift()));
    },
    result: function() {
      var result = lines;
      lines = [];
      line8 = null;
      return result;
    }
  };
}

// node_modules/d3-geo/src/pointEqual.js
function pointEqual_default(a4, b6) {
  return abs2(a4[0] - b6[0]) < epsilon4 && abs2(a4[1] - b6[1]) < epsilon4;
}

// node_modules/d3-geo/src/clip/rejoin.js
function Intersection(point21, points2, other, entry2) {
  this.x = point21;
  this.z = points2;
  this.o = other;
  this.e = entry2;
  this.v = false;
  this.n = this.p = null;
}
function rejoin_default(segments6, compareIntersection2, startInside, interpolate11, stream2) {
  var subject = [], clip7 = [], i, n;
  segments6.forEach(function(segment) {
    if ((n2 = segment.length - 1) <= 0)
      return;
    var n2, p02 = segment[0], p1 = segment[n2], x9;
    if (pointEqual_default(p02, p1)) {
      if (!p02[2] && !p1[2]) {
        stream2.lineStart();
        for (i = 0; i < n2; ++i)
          stream2.point((p02 = segment[i])[0], p02[1]);
        stream2.lineEnd();
        return;
      }
      p1[0] += 2 * epsilon4;
    }
    subject.push(x9 = new Intersection(p02, segment, null, true));
    clip7.push(x9.o = new Intersection(p02, null, x9, false));
    subject.push(x9 = new Intersection(p1, segment, null, false));
    clip7.push(x9.o = new Intersection(p1, null, x9, true));
  });
  if (!subject.length)
    return;
  clip7.sort(compareIntersection2);
  link2(subject);
  link2(clip7);
  for (i = 0, n = clip7.length; i < n; ++i) {
    clip7[i].e = startInside = !startInside;
  }
  var start = subject[0], points2, point21;
  while (1) {
    var current2 = start, isSubject = true;
    while (current2.v)
      if ((current2 = current2.n) === start)
        return;
    points2 = current2.z;
    stream2.lineStart();
    do {
      current2.v = current2.o.v = true;
      if (current2.e) {
        if (isSubject) {
          for (i = 0, n = points2.length; i < n; ++i)
            stream2.point((point21 = points2[i])[0], point21[1]);
        } else {
          interpolate11(current2.x, current2.n.x, 1, stream2);
        }
        current2 = current2.n;
      } else {
        if (isSubject) {
          points2 = current2.p.z;
          for (i = points2.length - 1; i >= 0; --i)
            stream2.point((point21 = points2[i])[0], point21[1]);
        } else {
          interpolate11(current2.x, current2.p.x, -1, stream2);
        }
        current2 = current2.p;
      }
      current2 = current2.o;
      points2 = current2.z;
      isSubject = !isSubject;
    } while (!current2.v);
    stream2.lineEnd();
  }
}
function link2(array22) {
  if (!(n = array22.length))
    return;
  var n, i = 0, a4 = array22[0], b6;
  while (++i < n) {
    a4.n = b6 = array22[i];
    b6.p = a4;
    a4 = b6;
  }
  a4.n = b6 = array22[0];
  b6.p = a4;
}

// node_modules/d3-geo/src/polygonContains.js
function longitude(point21) {
  return abs2(point21[0]) <= pi3 ? point21[0] : sign2(point21[0]) * ((abs2(point21[0]) + pi3) % tau3 - pi3);
}
function polygonContains_default(polygon, point21) {
  var lambda = longitude(point21), phi2 = point21[1], sinPhi = sin2(phi2), normal = [sin2(lambda), -cos2(lambda), 0], angle2 = 0, winding = 0;
  var sum4 = new Adder();
  if (sinPhi === 1)
    phi2 = halfPi2 + epsilon4;
  else if (sinPhi === -1)
    phi2 = -halfPi2 - epsilon4;
  for (var i = 0, n = polygon.length; i < n; ++i) {
    if (!(m3 = (ring = polygon[i]).length))
      continue;
    var ring, m3, point0 = ring[m3 - 1], lambda03 = longitude(point0), phi03 = point0[1] / 2 + quarterPi, sinPhi02 = sin2(phi03), cosPhi02 = cos2(phi03);
    for (var j = 0; j < m3; ++j, lambda03 = lambda12, sinPhi02 = sinPhi1, cosPhi02 = cosPhi1, point0 = point1) {
      var point1 = ring[j], lambda12 = longitude(point1), phi12 = point1[1] / 2 + quarterPi, sinPhi1 = sin2(phi12), cosPhi1 = cos2(phi12), delta = lambda12 - lambda03, sign4 = delta >= 0 ? 1 : -1, absDelta = sign4 * delta, antimeridian = absDelta > pi3, k3 = sinPhi02 * sinPhi1;
      sum4.add(atan22(k3 * sign4 * sin2(absDelta), cosPhi02 * cosPhi1 + k3 * cos2(absDelta)));
      angle2 += antimeridian ? delta + sign4 * tau3 : delta;
      if (antimeridian ^ lambda03 >= lambda ^ lambda12 >= lambda) {
        var arc8 = cartesianCross(cartesian(point0), cartesian(point1));
        cartesianNormalizeInPlace(arc8);
        var intersection2 = cartesianCross(normal, arc8);
        cartesianNormalizeInPlace(intersection2);
        var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin2(intersection2[2]);
        if (phi2 > phiArc || phi2 === phiArc && (arc8[0] || arc8[1])) {
          winding += antimeridian ^ delta >= 0 ? 1 : -1;
        }
      }
    }
  }
  return (angle2 < -epsilon4 || angle2 < epsilon4 && sum4 < -epsilon23) ^ winding & 1;
}

// node_modules/d3-geo/src/clip/index.js
function clip_default(pointVisible, clipLine, interpolate11, start) {
  return function(sink) {
    var line8 = clipLine(sink), ringBuffer = buffer_default(), ringSink = clipLine(ringBuffer), polygonStarted = false, polygon, segments6, ring;
    var clip7 = {
      point: point21,
      lineStart,
      lineEnd,
      polygonStart: function() {
        clip7.point = pointRing;
        clip7.lineStart = ringStart;
        clip7.lineEnd = ringEnd;
        segments6 = [];
        polygon = [];
      },
      polygonEnd: function() {
        clip7.point = point21;
        clip7.lineStart = lineStart;
        clip7.lineEnd = lineEnd;
        segments6 = merge2(segments6);
        var startInside = polygonContains_default(polygon, start);
        if (segments6.length) {
          if (!polygonStarted)
            sink.polygonStart(), polygonStarted = true;
          rejoin_default(segments6, compareIntersection, startInside, interpolate11, sink);
        } else if (startInside) {
          if (!polygonStarted)
            sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          interpolate11(null, null, 1, sink);
          sink.lineEnd();
        }
        if (polygonStarted)
          sink.polygonEnd(), polygonStarted = false;
        segments6 = polygon = null;
      },
      sphere: function() {
        sink.polygonStart();
        sink.lineStart();
        interpolate11(null, null, 1, sink);
        sink.lineEnd();
        sink.polygonEnd();
      }
    };
    function point21(lambda, phi2) {
      if (pointVisible(lambda, phi2))
        sink.point(lambda, phi2);
    }
    function pointLine(lambda, phi2) {
      line8.point(lambda, phi2);
    }
    function lineStart() {
      clip7.point = pointLine;
      line8.lineStart();
    }
    function lineEnd() {
      clip7.point = point21;
      line8.lineEnd();
    }
    function pointRing(lambda, phi2) {
      ring.push([lambda, phi2]);
      ringSink.point(lambda, phi2);
    }
    function ringStart() {
      ringSink.lineStart();
      ring = [];
    }
    function ringEnd() {
      pointRing(ring[0][0], ring[0][1]);
      ringSink.lineEnd();
      var clean = ringSink.clean(), ringSegments = ringBuffer.result(), i, n = ringSegments.length, m3, segment, point22;
      ring.pop();
      polygon.push(ring);
      ring = null;
      if (!n)
        return;
      if (clean & 1) {
        segment = ringSegments[0];
        if ((m3 = segment.length - 1) > 0) {
          if (!polygonStarted)
            sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          for (i = 0; i < m3; ++i)
            sink.point((point22 = segment[i])[0], point22[1]);
          sink.lineEnd();
        }
        return;
      }
      if (n > 1 && clean & 2)
        ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
      segments6.push(ringSegments.filter(validSegment));
    }
    return clip7;
  };
}
function validSegment(segment) {
  return segment.length > 1;
}
function compareIntersection(a4, b6) {
  return ((a4 = a4.x)[0] < 0 ? a4[1] - halfPi2 - epsilon4 : halfPi2 - a4[1]) - ((b6 = b6.x)[0] < 0 ? b6[1] - halfPi2 - epsilon4 : halfPi2 - b6[1]);
}

// node_modules/d3-geo/src/clip/antimeridian.js
var antimeridian_default = clip_default(
  function() {
    return true;
  },
  clipAntimeridianLine,
  clipAntimeridianInterpolate,
  [-pi3, -halfPi2]
);
function clipAntimeridianLine(stream2) {
  var lambda03 = NaN, phi03 = NaN, sign0 = NaN, clean;
  return {
    lineStart: function() {
      stream2.lineStart();
      clean = 1;
    },
    point: function(lambda12, phi12) {
      var sign1 = lambda12 > 0 ? pi3 : -pi3, delta = abs2(lambda12 - lambda03);
      if (abs2(delta - pi3) < epsilon4) {
        stream2.point(lambda03, phi03 = (phi03 + phi12) / 2 > 0 ? halfPi2 : -halfPi2);
        stream2.point(sign0, phi03);
        stream2.lineEnd();
        stream2.lineStart();
        stream2.point(sign1, phi03);
        stream2.point(lambda12, phi03);
        clean = 0;
      } else if (sign0 !== sign1 && delta >= pi3) {
        if (abs2(lambda03 - sign0) < epsilon4)
          lambda03 -= sign0 * epsilon4;
        if (abs2(lambda12 - sign1) < epsilon4)
          lambda12 -= sign1 * epsilon4;
        phi03 = clipAntimeridianIntersect(lambda03, phi03, lambda12, phi12);
        stream2.point(sign0, phi03);
        stream2.lineEnd();
        stream2.lineStart();
        stream2.point(sign1, phi03);
        clean = 0;
      }
      stream2.point(lambda03 = lambda12, phi03 = phi12);
      sign0 = sign1;
    },
    lineEnd: function() {
      stream2.lineEnd();
      lambda03 = phi03 = NaN;
    },
    clean: function() {
      return 2 - clean;
    }
  };
}
function clipAntimeridianIntersect(lambda03, phi03, lambda12, phi12) {
  var cosPhi02, cosPhi1, sinLambda0Lambda1 = sin2(lambda03 - lambda12);
  return abs2(sinLambda0Lambda1) > epsilon4 ? atan((sin2(phi03) * (cosPhi1 = cos2(phi12)) * sin2(lambda12) - sin2(phi12) * (cosPhi02 = cos2(phi03)) * sin2(lambda03)) / (cosPhi02 * cosPhi1 * sinLambda0Lambda1)) : (phi03 + phi12) / 2;
}
function clipAntimeridianInterpolate(from, to, direction, stream2) {
  var phi2;
  if (from == null) {
    phi2 = direction * halfPi2;
    stream2.point(-pi3, phi2);
    stream2.point(0, phi2);
    stream2.point(pi3, phi2);
    stream2.point(pi3, 0);
    stream2.point(pi3, -phi2);
    stream2.point(0, -phi2);
    stream2.point(-pi3, -phi2);
    stream2.point(-pi3, 0);
    stream2.point(-pi3, phi2);
  } else if (abs2(from[0] - to[0]) > epsilon4) {
    var lambda = from[0] < to[0] ? pi3 : -pi3;
    phi2 = direction * lambda / 2;
    stream2.point(-lambda, phi2);
    stream2.point(0, phi2);
    stream2.point(lambda, phi2);
  } else {
    stream2.point(to[0], to[1]);
  }
}

// node_modules/d3-geo/src/clip/circle.js
function circle_default2(radius2) {
  var cr6 = cos2(radius2), delta = 2 * radians2, smallRadius = cr6 > 0, notHemisphere = abs2(cr6) > epsilon4;
  function interpolate11(from, to, direction, stream2) {
    circleStream(stream2, radius2, delta, direction, from, to);
  }
  function visible(lambda, phi2) {
    return cos2(lambda) * cos2(phi2) > cr6;
  }
  function clipLine(stream2) {
    var point0, c0, v0, v00, clean;
    return {
      lineStart: function() {
        v00 = v0 = false;
        clean = 1;
      },
      point: function(lambda, phi2) {
        var point1 = [lambda, phi2], point22, v2 = visible(lambda, phi2), c5 = smallRadius ? v2 ? 0 : code(lambda, phi2) : v2 ? code(lambda + (lambda < 0 ? pi3 : -pi3), phi2) : 0;
        if (!point0 && (v00 = v0 = v2))
          stream2.lineStart();
        if (v2 !== v0) {
          point22 = intersect6(point0, point1);
          if (!point22 || pointEqual_default(point0, point22) || pointEqual_default(point1, point22))
            point1[2] = 1;
        }
        if (v2 !== v0) {
          clean = 0;
          if (v2) {
            stream2.lineStart();
            point22 = intersect6(point1, point0);
            stream2.point(point22[0], point22[1]);
          } else {
            point22 = intersect6(point0, point1);
            stream2.point(point22[0], point22[1], 2);
            stream2.lineEnd();
          }
          point0 = point22;
        } else if (notHemisphere && point0 && smallRadius ^ v2) {
          var t;
          if (!(c5 & c0) && (t = intersect6(point1, point0, true))) {
            clean = 0;
            if (smallRadius) {
              stream2.lineStart();
              stream2.point(t[0][0], t[0][1]);
              stream2.point(t[1][0], t[1][1]);
              stream2.lineEnd();
            } else {
              stream2.point(t[1][0], t[1][1]);
              stream2.lineEnd();
              stream2.lineStart();
              stream2.point(t[0][0], t[0][1], 3);
            }
          }
        }
        if (v2 && (!point0 || !pointEqual_default(point0, point1))) {
          stream2.point(point1[0], point1[1]);
        }
        point0 = point1, v0 = v2, c0 = c5;
      },
      lineEnd: function() {
        if (v0)
          stream2.lineEnd();
        point0 = null;
      },
      // Rejoin first and last segments if there were intersections and the first
      // and last points were visible.
      clean: function() {
        return clean | (v00 && v0) << 1;
      }
    };
  }
  function intersect6(a4, b6, two) {
    var pa6 = cartesian(a4), pb = cartesian(b6);
    var n1 = [1, 0, 0], n2 = cartesianCross(pa6, pb), n2n2 = cartesianDot(n2, n2), n1n2 = n2[0], determinant = n2n2 - n1n2 * n1n2;
    if (!determinant)
      return !two && a4;
    var c1 = cr6 * n2n2 / determinant, c22 = -cr6 * n1n2 / determinant, n1xn2 = cartesianCross(n1, n2), A6 = cartesianScale(n1, c1), B4 = cartesianScale(n2, c22);
    cartesianAddInPlace(A6, B4);
    var u4 = n1xn2, w8 = cartesianDot(A6, u4), uu = cartesianDot(u4, u4), t22 = w8 * w8 - uu * (cartesianDot(A6, A6) - 1);
    if (t22 < 0)
      return;
    var t = sqrt4(t22), q = cartesianScale(u4, (-w8 - t) / uu);
    cartesianAddInPlace(q, A6);
    q = spherical(q);
    if (!two)
      return q;
    var lambda03 = a4[0], lambda12 = b6[0], phi03 = a4[1], phi12 = b6[1], z;
    if (lambda12 < lambda03)
      z = lambda03, lambda03 = lambda12, lambda12 = z;
    var delta2 = lambda12 - lambda03, polar = abs2(delta2 - pi3) < epsilon4, meridian = polar || delta2 < epsilon4;
    if (!polar && phi12 < phi03)
      z = phi03, phi03 = phi12, phi12 = z;
    if (meridian ? polar ? phi03 + phi12 > 0 ^ q[1] < (abs2(q[0] - lambda03) < epsilon4 ? phi03 : phi12) : phi03 <= q[1] && q[1] <= phi12 : delta2 > pi3 ^ (lambda03 <= q[0] && q[0] <= lambda12)) {
      var q1 = cartesianScale(u4, (-w8 + t) / uu);
      cartesianAddInPlace(q1, A6);
      return [q, spherical(q1)];
    }
  }
  function code(lambda, phi2) {
    var r = smallRadius ? radius2 : pi3 - radius2, code2 = 0;
    if (lambda < -r)
      code2 |= 1;
    else if (lambda > r)
      code2 |= 2;
    if (phi2 < -r)
      code2 |= 4;
    else if (phi2 > r)
      code2 |= 8;
    return code2;
  }
  return clip_default(visible, clipLine, interpolate11, smallRadius ? [0, -radius2] : [-pi3, radius2 - pi3]);
}

// node_modules/d3-geo/src/clip/line.js
function line_default2(a4, b6, x07, y07, x13, y13) {
  var ax = a4[0], ay = a4[1], bx = b6[0], by = b6[1], t014 = 0, t13 = 1, dx = bx - ax, dy = by - ay, r;
  r = x07 - ax;
  if (!dx && r > 0)
    return;
  r /= dx;
  if (dx < 0) {
    if (r < t014)
      return;
    if (r < t13)
      t13 = r;
  } else if (dx > 0) {
    if (r > t13)
      return;
    if (r > t014)
      t014 = r;
  }
  r = x13 - ax;
  if (!dx && r < 0)
    return;
  r /= dx;
  if (dx < 0) {
    if (r > t13)
      return;
    if (r > t014)
      t014 = r;
  } else if (dx > 0) {
    if (r < t014)
      return;
    if (r < t13)
      t13 = r;
  }
  r = y07 - ay;
  if (!dy && r > 0)
    return;
  r /= dy;
  if (dy < 0) {
    if (r < t014)
      return;
    if (r < t13)
      t13 = r;
  } else if (dy > 0) {
    if (r > t13)
      return;
    if (r > t014)
      t014 = r;
  }
  r = y13 - ay;
  if (!dy && r < 0)
    return;
  r /= dy;
  if (dy < 0) {
    if (r > t13)
      return;
    if (r > t014)
      t014 = r;
  } else if (dy > 0) {
    if (r < t014)
      return;
    if (r < t13)
      t13 = r;
  }
  if (t014 > 0)
    a4[0] = ax + t014 * dx, a4[1] = ay + t014 * dy;
  if (t13 < 1)
    b6[0] = ax + t13 * dx, b6[1] = ay + t13 * dy;
  return true;
}

// node_modules/d3-geo/src/clip/rectangle.js
var clipMax = 1e9;
var clipMin = -clipMax;
function clipRectangle(x07, y07, x13, y13) {
  function visible(x9, y9) {
    return x07 <= x9 && x9 <= x13 && y07 <= y9 && y9 <= y13;
  }
  function interpolate11(from, to, direction, stream2) {
    var a4 = 0, a1 = 0;
    if (from == null || (a4 = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoint(from, to) < 0 ^ direction > 0) {
      do
        stream2.point(a4 === 0 || a4 === 3 ? x07 : x13, a4 > 1 ? y13 : y07);
      while ((a4 = (a4 + direction + 4) % 4) !== a1);
    } else {
      stream2.point(to[0], to[1]);
    }
  }
  function corner(p, direction) {
    return abs2(p[0] - x07) < epsilon4 ? direction > 0 ? 0 : 3 : abs2(p[0] - x13) < epsilon4 ? direction > 0 ? 2 : 1 : abs2(p[1] - y07) < epsilon4 ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2;
  }
  function compareIntersection2(a4, b6) {
    return comparePoint(a4.x, b6.x);
  }
  function comparePoint(a4, b6) {
    var ca3 = corner(a4, 1), cb = corner(b6, 1);
    return ca3 !== cb ? ca3 - cb : ca3 === 0 ? b6[1] - a4[1] : ca3 === 1 ? a4[0] - b6[0] : ca3 === 2 ? a4[1] - b6[1] : b6[0] - a4[0];
  }
  return function(stream2) {
    var activeStream = stream2, bufferStream = buffer_default(), segments6, polygon, ring, x__, y__, v__, x_, y_, v_, first, clean;
    var clipStream = {
      point: point21,
      lineStart,
      lineEnd,
      polygonStart,
      polygonEnd
    };
    function point21(x9, y9) {
      if (visible(x9, y9))
        activeStream.point(x9, y9);
    }
    function polygonInside() {
      var winding = 0;
      for (var i = 0, n = polygon.length; i < n; ++i) {
        for (var ring2 = polygon[i], j = 1, m3 = ring2.length, point22 = ring2[0], a0, a1, b0 = point22[0], b1 = point22[1]; j < m3; ++j) {
          a0 = b0, a1 = b1, point22 = ring2[j], b0 = point22[0], b1 = point22[1];
          if (a1 <= y13) {
            if (b1 > y13 && (b0 - a0) * (y13 - a1) > (b1 - a1) * (x07 - a0))
              ++winding;
          } else {
            if (b1 <= y13 && (b0 - a0) * (y13 - a1) < (b1 - a1) * (x07 - a0))
              --winding;
          }
        }
      }
      return winding;
    }
    function polygonStart() {
      activeStream = bufferStream, segments6 = [], polygon = [], clean = true;
    }
    function polygonEnd() {
      var startInside = polygonInside(), cleanInside = clean && startInside, visible2 = (segments6 = merge2(segments6)).length;
      if (cleanInside || visible2) {
        stream2.polygonStart();
        if (cleanInside) {
          stream2.lineStart();
          interpolate11(null, null, 1, stream2);
          stream2.lineEnd();
        }
        if (visible2) {
          rejoin_default(segments6, compareIntersection2, startInside, interpolate11, stream2);
        }
        stream2.polygonEnd();
      }
      activeStream = stream2, segments6 = polygon = ring = null;
    }
    function lineStart() {
      clipStream.point = linePoint2;
      if (polygon)
        polygon.push(ring = []);
      first = true;
      v_ = false;
      x_ = y_ = NaN;
    }
    function lineEnd() {
      if (segments6) {
        linePoint2(x__, y__);
        if (v__ && v_)
          bufferStream.rejoin();
        segments6.push(bufferStream.result());
      }
      clipStream.point = point21;
      if (v_)
        activeStream.lineEnd();
    }
    function linePoint2(x9, y9) {
      var v2 = visible(x9, y9);
      if (polygon)
        ring.push([x9, y9]);
      if (first) {
        x__ = x9, y__ = y9, v__ = v2;
        first = false;
        if (v2) {
          activeStream.lineStart();
          activeStream.point(x9, y9);
        }
      } else {
        if (v2 && v_)
          activeStream.point(x9, y9);
        else {
          var a4 = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))], b6 = [x9 = Math.max(clipMin, Math.min(clipMax, x9)), y9 = Math.max(clipMin, Math.min(clipMax, y9))];
          if (line_default2(a4, b6, x07, y07, x13, y13)) {
            if (!v_) {
              activeStream.lineStart();
              activeStream.point(a4[0], a4[1]);
            }
            activeStream.point(b6[0], b6[1]);
            if (!v2)
              activeStream.lineEnd();
            clean = false;
          } else if (v2) {
            activeStream.lineStart();
            activeStream.point(x9, y9);
            clean = false;
          }
        }
      }
      x_ = x9, y_ = y9, v_ = v2;
    }
    return clipStream;
  };
}

// node_modules/d3-geo/src/graticule.js
function graticuleX(y07, y13, dy) {
  var y9 = range(y07, y13 - epsilon4, dy).concat(y13);
  return function(x9) {
    return y9.map(function(y10) {
      return [x9, y10];
    });
  };
}
function graticuleY(x07, x13, dx) {
  var x9 = range(x07, x13 - epsilon4, dx).concat(x13);
  return function(y9) {
    return x9.map(function(x10) {
      return [x10, y9];
    });
  };
}
function graticule() {
  var x13, x07, X13, X03, y13, y07, Y13, Y03, dx = 10, dy = dx, DX = 90, DY = 360, x9, y9, X4, Y4, precision = 2.5;
  function graticule2() {
    return { type: "MultiLineString", coordinates: lines() };
  }
  function lines() {
    return range(ceil(X03 / DX) * DX, X13, DX).map(X4).concat(range(ceil(Y03 / DY) * DY, Y13, DY).map(Y4)).concat(range(ceil(x07 / dx) * dx, x13, dx).filter(function(x10) {
      return abs2(x10 % DX) > epsilon4;
    }).map(x9)).concat(range(ceil(y07 / dy) * dy, y13, dy).filter(function(y10) {
      return abs2(y10 % DY) > epsilon4;
    }).map(y9));
  }
  graticule2.lines = function() {
    return lines().map(function(coordinates) {
      return { type: "LineString", coordinates };
    });
  };
  graticule2.outline = function() {
    return {
      type: "Polygon",
      coordinates: [
        X4(X03).concat(
          Y4(Y13).slice(1),
          X4(X13).reverse().slice(1),
          Y4(Y03).reverse().slice(1)
        )
      ]
    };
  };
  graticule2.extent = function(_) {
    if (!arguments.length)
      return graticule2.extentMinor();
    return graticule2.extentMajor(_).extentMinor(_);
  };
  graticule2.extentMajor = function(_) {
    if (!arguments.length)
      return [[X03, Y03], [X13, Y13]];
    X03 = +_[0][0], X13 = +_[1][0];
    Y03 = +_[0][1], Y13 = +_[1][1];
    if (X03 > X13)
      _ = X03, X03 = X13, X13 = _;
    if (Y03 > Y13)
      _ = Y03, Y03 = Y13, Y13 = _;
    return graticule2.precision(precision);
  };
  graticule2.extentMinor = function(_) {
    if (!arguments.length)
      return [[x07, y07], [x13, y13]];
    x07 = +_[0][0], x13 = +_[1][0];
    y07 = +_[0][1], y13 = +_[1][1];
    if (x07 > x13)
      _ = x07, x07 = x13, x13 = _;
    if (y07 > y13)
      _ = y07, y07 = y13, y13 = _;
    return graticule2.precision(precision);
  };
  graticule2.step = function(_) {
    if (!arguments.length)
      return graticule2.stepMinor();
    return graticule2.stepMajor(_).stepMinor(_);
  };
  graticule2.stepMajor = function(_) {
    if (!arguments.length)
      return [DX, DY];
    DX = +_[0], DY = +_[1];
    return graticule2;
  };
  graticule2.stepMinor = function(_) {
    if (!arguments.length)
      return [dx, dy];
    dx = +_[0], dy = +_[1];
    return graticule2;
  };
  graticule2.precision = function(_) {
    if (!arguments.length)
      return precision;
    precision = +_;
    x9 = graticuleX(y07, y13, 90);
    y9 = graticuleY(x07, x13, precision);
    X4 = graticuleX(Y03, Y13, 90);
    Y4 = graticuleY(X03, X13, precision);
    return graticule2;
  };
  return graticule2.extentMajor([[-180, -90 + epsilon4], [180, 90 - epsilon4]]).extentMinor([[-180, -80 - epsilon4], [180, 80 + epsilon4]]);
}

// node_modules/d3-geo/src/identity.js
var identity_default4 = (x9) => x9;

// node_modules/d3-geo/src/path/area.js
var areaSum2 = new Adder();
var areaRingSum2 = new Adder();
var x00;
var y00;
var x02;
var y02;
var areaStream2 = {
  point: noop2,
  lineStart: noop2,
  lineEnd: noop2,
  polygonStart: function() {
    areaStream2.lineStart = areaRingStart2;
    areaStream2.lineEnd = areaRingEnd2;
  },
  polygonEnd: function() {
    areaStream2.lineStart = areaStream2.lineEnd = areaStream2.point = noop2;
    areaSum2.add(abs2(areaRingSum2));
    areaRingSum2 = new Adder();
  },
  result: function() {
    var area8 = areaSum2 / 2;
    areaSum2 = new Adder();
    return area8;
  }
};
function areaRingStart2() {
  areaStream2.point = areaPointFirst2;
}
function areaPointFirst2(x9, y9) {
  areaStream2.point = areaPoint2;
  x00 = x02 = x9, y00 = y02 = y9;
}
function areaPoint2(x9, y9) {
  areaRingSum2.add(y02 * x9 - x02 * y9);
  x02 = x9, y02 = y9;
}
function areaRingEnd2() {
  areaPoint2(x00, y00);
}
var area_default3 = areaStream2;

// node_modules/d3-geo/src/path/bounds.js
var x03 = Infinity;
var y03 = x03;
var x1 = -x03;
var y1 = x1;
var boundsStream2 = {
  point: boundsPoint2,
  lineStart: noop2,
  lineEnd: noop2,
  polygonStart: noop2,
  polygonEnd: noop2,
  result: function() {
    var bounds6 = [[x03, y03], [x1, y1]];
    x1 = y1 = -(y03 = x03 = Infinity);
    return bounds6;
  }
};
function boundsPoint2(x9, y9) {
  if (x9 < x03)
    x03 = x9;
  if (x9 > x1)
    x1 = x9;
  if (y9 < y03)
    y03 = y9;
  if (y9 > y1)
    y1 = y9;
}
var bounds_default2 = boundsStream2;

// node_modules/d3-geo/src/path/centroid.js
var X02 = 0;
var Y02 = 0;
var Z02 = 0;
var X12 = 0;
var Y12 = 0;
var Z12 = 0;
var X22 = 0;
var Y22 = 0;
var Z22 = 0;
var x002;
var y002;
var x04;
var y04;
var centroidStream2 = {
  point: centroidPoint2,
  lineStart: centroidLineStart2,
  lineEnd: centroidLineEnd2,
  polygonStart: function() {
    centroidStream2.lineStart = centroidRingStart2;
    centroidStream2.lineEnd = centroidRingEnd2;
  },
  polygonEnd: function() {
    centroidStream2.point = centroidPoint2;
    centroidStream2.lineStart = centroidLineStart2;
    centroidStream2.lineEnd = centroidLineEnd2;
  },
  result: function() {
    var centroid = Z22 ? [X22 / Z22, Y22 / Z22] : Z12 ? [X12 / Z12, Y12 / Z12] : Z02 ? [X02 / Z02, Y02 / Z02] : [NaN, NaN];
    X02 = Y02 = Z02 = X12 = Y12 = Z12 = X22 = Y22 = Z22 = 0;
    return centroid;
  }
};
function centroidPoint2(x9, y9) {
  X02 += x9;
  Y02 += y9;
  ++Z02;
}
function centroidLineStart2() {
  centroidStream2.point = centroidPointFirstLine;
}
function centroidPointFirstLine(x9, y9) {
  centroidStream2.point = centroidPointLine;
  centroidPoint2(x04 = x9, y04 = y9);
}
function centroidPointLine(x9, y9) {
  var dx = x9 - x04, dy = y9 - y04, z = sqrt4(dx * dx + dy * dy);
  X12 += z * (x04 + x9) / 2;
  Y12 += z * (y04 + y9) / 2;
  Z12 += z;
  centroidPoint2(x04 = x9, y04 = y9);
}
function centroidLineEnd2() {
  centroidStream2.point = centroidPoint2;
}
function centroidRingStart2() {
  centroidStream2.point = centroidPointFirstRing;
}
function centroidRingEnd2() {
  centroidPointRing(x002, y002);
}
function centroidPointFirstRing(x9, y9) {
  centroidStream2.point = centroidPointRing;
  centroidPoint2(x002 = x04 = x9, y002 = y04 = y9);
}
function centroidPointRing(x9, y9) {
  var dx = x9 - x04, dy = y9 - y04, z = sqrt4(dx * dx + dy * dy);
  X12 += z * (x04 + x9) / 2;
  Y12 += z * (y04 + y9) / 2;
  Z12 += z;
  z = y04 * x9 - x04 * y9;
  X22 += z * (x04 + x9);
  Y22 += z * (y04 + y9);
  Z22 += z * 3;
  centroidPoint2(x04 = x9, y04 = y9);
}
var centroid_default2 = centroidStream2;

// node_modules/d3-geo/src/path/context.js
function PathContext(context7) {
  this._context = context7;
}
PathContext.prototype = {
  _radius: 4.5,
  pointRadius: function(_) {
    return this._radius = _, this;
  },
  polygonStart: function() {
    this._line = 0;
  },
  polygonEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line === 0)
      this._context.closePath();
    this._point = NaN;
  },
  point: function(x9, y9) {
    switch (this._point) {
      case 0: {
        this._context.moveTo(x9, y9);
        this._point = 1;
        break;
      }
      case 1: {
        this._context.lineTo(x9, y9);
        break;
      }
      default: {
        this._context.moveTo(x9 + this._radius, y9);
        this._context.arc(x9, y9, this._radius, 0, tau3);
        break;
      }
    }
  },
  result: noop2
};

// node_modules/d3-geo/src/path/measure.js
var lengthSum = new Adder();
var lengthRing;
var x003;
var y003;
var x05;
var y05;
var lengthStream = {
  point: noop2,
  lineStart: function() {
    lengthStream.point = lengthPointFirst;
  },
  lineEnd: function() {
    if (lengthRing)
      lengthPoint(x003, y003);
    lengthStream.point = noop2;
  },
  polygonStart: function() {
    lengthRing = true;
  },
  polygonEnd: function() {
    lengthRing = null;
  },
  result: function() {
    var length2 = +lengthSum;
    lengthSum = new Adder();
    return length2;
  }
};
function lengthPointFirst(x9, y9) {
  lengthStream.point = lengthPoint;
  x003 = x05 = x9, y003 = y05 = y9;
}
function lengthPoint(x9, y9) {
  x05 -= x9, y05 -= y9;
  lengthSum.add(sqrt4(x05 * x05 + y05 * y05));
  x05 = x9, y05 = y9;
}
var measure_default = lengthStream;

// node_modules/d3-geo/src/path/string.js
var cacheDigits;
var cacheAppend;
var cacheRadius;
var cacheCircle;
var PathString = class {
  constructor(digits) {
    this._append = digits == null ? append2 : appendRound2(digits);
    this._radius = 4.5;
    this._ = "";
  }
  pointRadius(_) {
    this._radius = +_;
    return this;
  }
  polygonStart() {
    this._line = 0;
  }
  polygonEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._point = 0;
  }
  lineEnd() {
    if (this._line === 0)
      this._ += "Z";
    this._point = NaN;
  }
  point(x9, y9) {
    switch (this._point) {
      case 0: {
        this._append`M${x9},${y9}`;
        this._point = 1;
        break;
      }
      case 1: {
        this._append`L${x9},${y9}`;
        break;
      }
      default: {
        this._append`M${x9},${y9}`;
        if (this._radius !== cacheRadius || this._append !== cacheAppend) {
          const r = this._radius;
          const s2 = this._;
          this._ = "";
          this._append`m0,${r}a${r},${r} 0 1,1 0,${-2 * r}a${r},${r} 0 1,1 0,${2 * r}z`;
          cacheRadius = r;
          cacheAppend = this._append;
          cacheCircle = this._;
          this._ = s2;
        }
        this._ += cacheCircle;
        break;
      }
    }
  }
  result() {
    const result = this._;
    this._ = "";
    return result.length ? result : null;
  }
};
function append2(strings) {
  let i = 1;
  this._ += strings[0];
  for (const j = strings.length; i < j; ++i) {
    this._ += arguments[i] + strings[i];
  }
}
function appendRound2(digits) {
  const d = Math.floor(digits);
  if (!(d >= 0))
    throw new RangeError(`invalid digits: ${digits}`);
  if (d > 15)
    return append2;
  if (d !== cacheDigits) {
    const k3 = 10 ** d;
    cacheDigits = d;
    cacheAppend = function append3(strings) {
      let i = 1;
      this._ += strings[0];
      for (const j = strings.length; i < j; ++i) {
        this._ += Math.round(arguments[i] * k3) / k3 + strings[i];
      }
    };
  }
  return cacheAppend;
}

// node_modules/d3-geo/src/path/index.js
function path_default(projection3, context7) {
  let digits = 3, pointRadius = 4.5, projectionStream, contextStream;
  function path7(object2) {
    if (object2) {
      if (typeof pointRadius === "function")
        contextStream.pointRadius(+pointRadius.apply(this, arguments));
      stream_default(object2, projectionStream(contextStream));
    }
    return contextStream.result();
  }
  path7.area = function(object2) {
    stream_default(object2, projectionStream(area_default3));
    return area_default3.result();
  };
  path7.measure = function(object2) {
    stream_default(object2, projectionStream(measure_default));
    return measure_default.result();
  };
  path7.bounds = function(object2) {
    stream_default(object2, projectionStream(bounds_default2));
    return bounds_default2.result();
  };
  path7.centroid = function(object2) {
    stream_default(object2, projectionStream(centroid_default2));
    return centroid_default2.result();
  };
  path7.projection = function(_) {
    if (!arguments.length)
      return projection3;
    projectionStream = _ == null ? (projection3 = null, identity_default4) : (projection3 = _).stream;
    return path7;
  };
  path7.context = function(_) {
    if (!arguments.length)
      return context7;
    contextStream = _ == null ? (context7 = null, new PathString(digits)) : new PathContext(context7 = _);
    if (typeof pointRadius !== "function")
      contextStream.pointRadius(pointRadius);
    return path7;
  };
  path7.pointRadius = function(_) {
    if (!arguments.length)
      return pointRadius;
    pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
    return path7;
  };
  path7.digits = function(_) {
    if (!arguments.length)
      return digits;
    if (_ == null)
      digits = null;
    else {
      const d = Math.floor(_);
      if (!(d >= 0))
        throw new RangeError(`invalid digits: ${_}`);
      digits = d;
    }
    if (context7 === null)
      contextStream = new PathString(digits);
    return path7;
  };
  return path7.projection(projection3).digits(digits).context(context7);
}

// node_modules/d3-geo/src/transform.js
function transformer4(methods2) {
  return function(stream2) {
    var s2 = new TransformStream();
    for (var key4 in methods2)
      s2[key4] = methods2[key4];
    s2.stream = stream2;
    return s2;
  };
}
function TransformStream() {
}
TransformStream.prototype = {
  constructor: TransformStream,
  point: function(x9, y9) {
    this.stream.point(x9, y9);
  },
  sphere: function() {
    this.stream.sphere();
  },
  lineStart: function() {
    this.stream.lineStart();
  },
  lineEnd: function() {
    this.stream.lineEnd();
  },
  polygonStart: function() {
    this.stream.polygonStart();
  },
  polygonEnd: function() {
    this.stream.polygonEnd();
  }
};

// node_modules/d3-geo/src/projection/fit.js
function fit(projection3, fitBounds, object2) {
  var clip7 = projection3.clipExtent && projection3.clipExtent();
  projection3.scale(150).translate([0, 0]);
  if (clip7 != null)
    projection3.clipExtent(null);
  stream_default(object2, projection3.stream(bounds_default2));
  fitBounds(bounds_default2.result());
  if (clip7 != null)
    projection3.clipExtent(clip7);
  return projection3;
}
function fitExtent(projection3, extent8, object2) {
  return fit(projection3, function(b6) {
    var w8 = extent8[1][0] - extent8[0][0], h6 = extent8[1][1] - extent8[0][1], k3 = Math.min(w8 / (b6[1][0] - b6[0][0]), h6 / (b6[1][1] - b6[0][1])), x9 = +extent8[0][0] + (w8 - k3 * (b6[1][0] + b6[0][0])) / 2, y9 = +extent8[0][1] + (h6 - k3 * (b6[1][1] + b6[0][1])) / 2;
    projection3.scale(150 * k3).translate([x9, y9]);
  }, object2);
}
function fitSize(projection3, size, object2) {
  return fitExtent(projection3, [[0, 0], size], object2);
}
function fitWidth(projection3, width2, object2) {
  return fit(projection3, function(b6) {
    var w8 = +width2, k3 = w8 / (b6[1][0] - b6[0][0]), x9 = (w8 - k3 * (b6[1][0] + b6[0][0])) / 2, y9 = -k3 * b6[0][1];
    projection3.scale(150 * k3).translate([x9, y9]);
  }, object2);
}
function fitHeight(projection3, height2, object2) {
  return fit(projection3, function(b6) {
    var h6 = +height2, k3 = h6 / (b6[1][1] - b6[0][1]), x9 = -k3 * b6[0][0], y9 = (h6 - k3 * (b6[1][1] + b6[0][1])) / 2;
    projection3.scale(150 * k3).translate([x9, y9]);
  }, object2);
}

// node_modules/d3-geo/src/projection/resample.js
var maxDepth = 16;
var cosMinDistance = cos2(30 * radians2);
function resample_default(project3, delta2) {
  return +delta2 ? resample(project3, delta2) : resampleNone(project3);
}
function resampleNone(project3) {
  return transformer4({
    point: function(x9, y9) {
      x9 = project3(x9, y9);
      this.stream.point(x9[0], x9[1]);
    }
  });
}
function resample(project3, delta2) {
  function resampleLineTo(x07, y07, lambda03, a0, b0, c0, x13, y13, lambda12, a1, b1, c1, depth, stream2) {
    var dx = x13 - x07, dy = y13 - y07, d2 = dx * dx + dy * dy;
    if (d2 > 4 * delta2 && depth--) {
      var a4 = a0 + a1, b6 = b0 + b1, c5 = c0 + c1, m3 = sqrt4(a4 * a4 + b6 * b6 + c5 * c5), phi2 = asin2(c5 /= m3), lambda22 = abs2(abs2(c5) - 1) < epsilon4 || abs2(lambda03 - lambda12) < epsilon4 ? (lambda03 + lambda12) / 2 : atan22(b6, a4), p = project3(lambda22, phi2), x22 = p[0], y22 = p[1], dx2 = x22 - x07, dy2 = y22 - y07, dz = dy * dx2 - dx * dy2;
      if (dz * dz / d2 > delta2 || abs2((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {
        resampleLineTo(x07, y07, lambda03, a0, b0, c0, x22, y22, lambda22, a4 /= m3, b6 /= m3, c5, depth, stream2);
        stream2.point(x22, y22);
        resampleLineTo(x22, y22, lambda22, a4, b6, c5, x13, y13, lambda12, a1, b1, c1, depth, stream2);
      }
    }
  }
  return function(stream2) {
    var lambda004, x004, y004, a00, b00, c00, lambda03, x07, y07, a0, b0, c0;
    var resampleStream = {
      point: point21,
      lineStart,
      lineEnd,
      polygonStart: function() {
        stream2.polygonStart();
        resampleStream.lineStart = ringStart;
      },
      polygonEnd: function() {
        stream2.polygonEnd();
        resampleStream.lineStart = lineStart;
      }
    };
    function point21(x9, y9) {
      x9 = project3(x9, y9);
      stream2.point(x9[0], x9[1]);
    }
    function lineStart() {
      x07 = NaN;
      resampleStream.point = linePoint2;
      stream2.lineStart();
    }
    function linePoint2(lambda, phi2) {
      var c5 = cartesian([lambda, phi2]), p = project3(lambda, phi2);
      resampleLineTo(x07, y07, lambda03, a0, b0, c0, x07 = p[0], y07 = p[1], lambda03 = lambda, a0 = c5[0], b0 = c5[1], c0 = c5[2], maxDepth, stream2);
      stream2.point(x07, y07);
    }
    function lineEnd() {
      resampleStream.point = point21;
      stream2.lineEnd();
    }
    function ringStart() {
      lineStart();
      resampleStream.point = ringPoint;
      resampleStream.lineEnd = ringEnd;
    }
    function ringPoint(lambda, phi2) {
      linePoint2(lambda004 = lambda, phi2), x004 = x07, y004 = y07, a00 = a0, b00 = b0, c00 = c0;
      resampleStream.point = linePoint2;
    }
    function ringEnd() {
      resampleLineTo(x07, y07, lambda03, a0, b0, c0, x004, y004, lambda004, a00, b00, c00, maxDepth, stream2);
      resampleStream.lineEnd = lineEnd;
      lineEnd();
    }
    return resampleStream;
  };
}

// node_modules/d3-geo/src/projection/index.js
var transformRadians = transformer4({
  point: function(x9, y9) {
    this.stream.point(x9 * radians2, y9 * radians2);
  }
});
function transformRotate(rotate6) {
  return transformer4({
    point: function(x9, y9) {
      var r = rotate6(x9, y9);
      return this.stream.point(r[0], r[1]);
    }
  });
}
function scaleTranslate(k3, dx, dy, sx, sy) {
  function transform4(x9, y9) {
    x9 *= sx;
    y9 *= sy;
    return [dx + k3 * x9, dy - k3 * y9];
  }
  transform4.invert = function(x9, y9) {
    return [(x9 - dx) / k3 * sx, (dy - y9) / k3 * sy];
  };
  return transform4;
}
function scaleTranslateRotate(k3, dx, dy, sx, sy, alpha) {
  if (!alpha)
    return scaleTranslate(k3, dx, dy, sx, sy);
  var cosAlpha = cos2(alpha), sinAlpha = sin2(alpha), a4 = cosAlpha * k3, b6 = sinAlpha * k3, ai = cosAlpha / k3, bi = sinAlpha / k3, ci = (sinAlpha * dy - cosAlpha * dx) / k3, fi = (sinAlpha * dx + cosAlpha * dy) / k3;
  function transform4(x9, y9) {
    x9 *= sx;
    y9 *= sy;
    return [a4 * x9 - b6 * y9 + dx, dy - b6 * x9 - a4 * y9];
  }
  transform4.invert = function(x9, y9) {
    return [sx * (ai * x9 - bi * y9 + ci), sy * (fi - bi * x9 - ai * y9)];
  };
  return transform4;
}
function projection(project3) {
  return projectionMutator(function() {
    return project3;
  })();
}
function projectionMutator(projectAt) {
  var project3, k3 = 150, x9 = 480, y9 = 250, lambda = 0, phi2 = 0, deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate6, alpha = 0, sx = 1, sy = 1, theta = null, preclip = antimeridian_default, x07 = null, y07, x13, y13, postclip = identity_default4, delta2 = 0.5, projectResample, projectTransform, projectRotateTransform, cache2, cacheStream;
  function projection3(point21) {
    return projectRotateTransform(point21[0] * radians2, point21[1] * radians2);
  }
  function invert2(point21) {
    point21 = projectRotateTransform.invert(point21[0], point21[1]);
    return point21 && [point21[0] * degrees3, point21[1] * degrees3];
  }
  projection3.stream = function(stream2) {
    return cache2 && cacheStream === stream2 ? cache2 : cache2 = transformRadians(transformRotate(rotate6)(preclip(projectResample(postclip(cacheStream = stream2)))));
  };
  projection3.preclip = function(_) {
    return arguments.length ? (preclip = _, theta = void 0, reset3()) : preclip;
  };
  projection3.postclip = function(_) {
    return arguments.length ? (postclip = _, x07 = y07 = x13 = y13 = null, reset3()) : postclip;
  };
  projection3.clipAngle = function(_) {
    return arguments.length ? (preclip = +_ ? circle_default2(theta = _ * radians2) : (theta = null, antimeridian_default), reset3()) : theta * degrees3;
  };
  projection3.clipExtent = function(_) {
    return arguments.length ? (postclip = _ == null ? (x07 = y07 = x13 = y13 = null, identity_default4) : clipRectangle(x07 = +_[0][0], y07 = +_[0][1], x13 = +_[1][0], y13 = +_[1][1]), reset3()) : x07 == null ? null : [[x07, y07], [x13, y13]];
  };
  projection3.scale = function(_) {
    return arguments.length ? (k3 = +_, recenter()) : k3;
  };
  projection3.translate = function(_) {
    return arguments.length ? (x9 = +_[0], y9 = +_[1], recenter()) : [x9, y9];
  };
  projection3.center = function(_) {
    return arguments.length ? (lambda = _[0] % 360 * radians2, phi2 = _[1] % 360 * radians2, recenter()) : [lambda * degrees3, phi2 * degrees3];
  };
  projection3.rotate = function(_) {
    return arguments.length ? (deltaLambda = _[0] % 360 * radians2, deltaPhi = _[1] % 360 * radians2, deltaGamma = _.length > 2 ? _[2] % 360 * radians2 : 0, recenter()) : [deltaLambda * degrees3, deltaPhi * degrees3, deltaGamma * degrees3];
  };
  projection3.angle = function(_) {
    return arguments.length ? (alpha = _ % 360 * radians2, recenter()) : alpha * degrees3;
  };
  projection3.reflectX = function(_) {
    return arguments.length ? (sx = _ ? -1 : 1, recenter()) : sx < 0;
  };
  projection3.reflectY = function(_) {
    return arguments.length ? (sy = _ ? -1 : 1, recenter()) : sy < 0;
  };
  projection3.precision = function(_) {
    return arguments.length ? (projectResample = resample_default(projectTransform, delta2 = _ * _), reset3()) : sqrt4(delta2);
  };
  projection3.fitExtent = function(extent8, object2) {
    return fitExtent(projection3, extent8, object2);
  };
  projection3.fitSize = function(size, object2) {
    return fitSize(projection3, size, object2);
  };
  projection3.fitWidth = function(width2, object2) {
    return fitWidth(projection3, width2, object2);
  };
  projection3.fitHeight = function(height2, object2) {
    return fitHeight(projection3, height2, object2);
  };
  function recenter() {
    var center = scaleTranslateRotate(k3, 0, 0, sx, sy, alpha).apply(null, project3(lambda, phi2)), transform4 = scaleTranslateRotate(k3, x9 - center[0], y9 - center[1], sx, sy, alpha);
    rotate6 = rotateRadians(deltaLambda, deltaPhi, deltaGamma);
    projectTransform = compose_default(project3, transform4);
    projectRotateTransform = compose_default(rotate6, projectTransform);
    projectResample = resample_default(projectTransform, delta2);
    return reset3();
  }
  function reset3() {
    cache2 = cacheStream = null;
    return projection3;
  }
  return function() {
    project3 = projectAt.apply(this, arguments);
    projection3.invert = project3.invert && invert2;
    return recenter();
  };
}

// node_modules/d3-geo/src/projection/conic.js
function conicProjection(projectAt) {
  var phi03 = 0, phi12 = pi3 / 3, m3 = projectionMutator(projectAt), p = m3(phi03, phi12);
  p.parallels = function(_) {
    return arguments.length ? m3(phi03 = _[0] * radians2, phi12 = _[1] * radians2) : [phi03 * degrees3, phi12 * degrees3];
  };
  return p;
}

// node_modules/d3-geo/src/projection/cylindricalEqualArea.js
function cylindricalEqualAreaRaw(phi03) {
  var cosPhi02 = cos2(phi03);
  function forward(lambda, phi2) {
    return [lambda * cosPhi02, sin2(phi2) / cosPhi02];
  }
  forward.invert = function(x9, y9) {
    return [x9 / cosPhi02, asin2(y9 * cosPhi02)];
  };
  return forward;
}

// node_modules/d3-geo/src/projection/conicEqualArea.js
function conicEqualAreaRaw(y07, y13) {
  var sy0 = sin2(y07), n = (sy0 + sin2(y13)) / 2;
  if (abs2(n) < epsilon4)
    return cylindricalEqualAreaRaw(y07);
  var c5 = 1 + sy0 * (2 * n - sy0), r0 = sqrt4(c5) / n;
  function project3(x9, y9) {
    var r = sqrt4(c5 - 2 * n * sin2(y9)) / n;
    return [r * sin2(x9 *= n), r0 - r * cos2(x9)];
  }
  project3.invert = function(x9, y9) {
    var r0y = r0 - y9, l = atan22(x9, abs2(r0y)) * sign2(r0y);
    if (r0y * n < 0)
      l -= pi3 * sign2(x9) * sign2(r0y);
    return [l / n, asin2((c5 - (x9 * x9 + r0y * r0y) * n * n) / (2 * n))];
  };
  return project3;
}
function conicEqualArea_default() {
  return conicProjection(conicEqualAreaRaw).scale(155.424).center([0, 33.6442]);
}

// node_modules/d3-geo/src/projection/albers.js
function albers_default() {
  return conicEqualArea_default().parallels([29.5, 45.5]).scale(1070).translate([480, 250]).rotate([96, 0]).center([-0.6, 38.7]);
}

// node_modules/d3-geo/src/projection/albersUsa.js
function multiplex(streams) {
  var n = streams.length;
  return {
    point: function(x9, y9) {
      var i = -1;
      while (++i < n)
        streams[i].point(x9, y9);
    },
    sphere: function() {
      var i = -1;
      while (++i < n)
        streams[i].sphere();
    },
    lineStart: function() {
      var i = -1;
      while (++i < n)
        streams[i].lineStart();
    },
    lineEnd: function() {
      var i = -1;
      while (++i < n)
        streams[i].lineEnd();
    },
    polygonStart: function() {
      var i = -1;
      while (++i < n)
        streams[i].polygonStart();
    },
    polygonEnd: function() {
      var i = -1;
      while (++i < n)
        streams[i].polygonEnd();
    }
  };
}
function albersUsa_default() {
  var cache2, cacheStream, lower48 = albers_default(), lower48Point, alaska = conicEqualArea_default().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), alaskaPoint, hawaii = conicEqualArea_default().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), hawaiiPoint, point21, pointStream = { point: function(x9, y9) {
    point21 = [x9, y9];
  } };
  function albersUsa(coordinates) {
    var x9 = coordinates[0], y9 = coordinates[1];
    return point21 = null, (lower48Point.point(x9, y9), point21) || (alaskaPoint.point(x9, y9), point21) || (hawaiiPoint.point(x9, y9), point21);
  }
  albersUsa.invert = function(coordinates) {
    var k3 = lower48.scale(), t = lower48.translate(), x9 = (coordinates[0] - t[0]) / k3, y9 = (coordinates[1] - t[1]) / k3;
    return (y9 >= 0.12 && y9 < 0.234 && x9 >= -0.425 && x9 < -0.214 ? alaska : y9 >= 0.166 && y9 < 0.234 && x9 >= -0.214 && x9 < -0.115 ? hawaii : lower48).invert(coordinates);
  };
  albersUsa.stream = function(stream2) {
    return cache2 && cacheStream === stream2 ? cache2 : cache2 = multiplex([lower48.stream(cacheStream = stream2), alaska.stream(stream2), hawaii.stream(stream2)]);
  };
  albersUsa.precision = function(_) {
    if (!arguments.length)
      return lower48.precision();
    lower48.precision(_), alaska.precision(_), hawaii.precision(_);
    return reset3();
  };
  albersUsa.scale = function(_) {
    if (!arguments.length)
      return lower48.scale();
    lower48.scale(_), alaska.scale(_ * 0.35), hawaii.scale(_);
    return albersUsa.translate(lower48.translate());
  };
  albersUsa.translate = function(_) {
    if (!arguments.length)
      return lower48.translate();
    var k3 = lower48.scale(), x9 = +_[0], y9 = +_[1];
    lower48Point = lower48.translate(_).clipExtent([[x9 - 0.455 * k3, y9 - 0.238 * k3], [x9 + 0.455 * k3, y9 + 0.238 * k3]]).stream(pointStream);
    alaskaPoint = alaska.translate([x9 - 0.307 * k3, y9 + 0.201 * k3]).clipExtent([[x9 - 0.425 * k3 + epsilon4, y9 + 0.12 * k3 + epsilon4], [x9 - 0.214 * k3 - epsilon4, y9 + 0.234 * k3 - epsilon4]]).stream(pointStream);
    hawaiiPoint = hawaii.translate([x9 - 0.205 * k3, y9 + 0.212 * k3]).clipExtent([[x9 - 0.214 * k3 + epsilon4, y9 + 0.166 * k3 + epsilon4], [x9 - 0.115 * k3 - epsilon4, y9 + 0.234 * k3 - epsilon4]]).stream(pointStream);
    return reset3();
  };
  albersUsa.fitExtent = function(extent8, object2) {
    return fitExtent(albersUsa, extent8, object2);
  };
  albersUsa.fitSize = function(size, object2) {
    return fitSize(albersUsa, size, object2);
  };
  albersUsa.fitWidth = function(width2, object2) {
    return fitWidth(albersUsa, width2, object2);
  };
  albersUsa.fitHeight = function(height2, object2) {
    return fitHeight(albersUsa, height2, object2);
  };
  function reset3() {
    cache2 = cacheStream = null;
    return albersUsa;
  }
  return albersUsa.scale(1070);
}

// node_modules/d3-geo/src/projection/azimuthal.js
function azimuthalRaw(scale19) {
  return function(x9, y9) {
    var cx = cos2(x9), cy = cos2(y9), k3 = scale19(cx * cy);
    if (k3 === Infinity)
      return [2, 0];
    return [
      k3 * cy * sin2(x9),
      k3 * sin2(y9)
    ];
  };
}
function azimuthalInvert(angle2) {
  return function(x9, y9) {
    var z = sqrt4(x9 * x9 + y9 * y9), c5 = angle2(z), sc = sin2(c5), cc2 = cos2(c5);
    return [
      atan22(x9 * sc, z * cc2),
      asin2(z && y9 * sc / z)
    ];
  };
}

// node_modules/d3-geo/src/projection/azimuthalEqualArea.js
var azimuthalEqualAreaRaw = azimuthalRaw(function(cxcy) {
  return sqrt4(2 / (1 + cxcy));
});
azimuthalEqualAreaRaw.invert = azimuthalInvert(function(z) {
  return 2 * asin2(z / 2);
});
function azimuthalEqualArea_default() {
  return projection(azimuthalEqualAreaRaw).scale(124.75).clipAngle(180 - 1e-3);
}

// node_modules/d3-geo/src/projection/azimuthalEquidistant.js
var azimuthalEquidistantRaw = azimuthalRaw(function(c5) {
  return (c5 = acos2(c5)) && c5 / sin2(c5);
});
azimuthalEquidistantRaw.invert = azimuthalInvert(function(z) {
  return z;
});
function azimuthalEquidistant_default() {
  return projection(azimuthalEquidistantRaw).scale(79.4188).clipAngle(180 - 1e-3);
}

// node_modules/d3-geo/src/projection/mercator.js
function mercatorRaw(lambda, phi2) {
  return [lambda, log5(tan((halfPi2 + phi2) / 2))];
}
mercatorRaw.invert = function(x9, y9) {
  return [x9, 2 * atan(exp4(y9)) - halfPi2];
};
function mercator_default() {
  return mercatorProjection(mercatorRaw).scale(961 / tau3);
}
function mercatorProjection(project3) {
  var m3 = projection(project3), center = m3.center, scale19 = m3.scale, translate8 = m3.translate, clipExtent = m3.clipExtent, x07 = null, y07, x13, y13;
  m3.scale = function(_) {
    return arguments.length ? (scale19(_), reclip()) : scale19();
  };
  m3.translate = function(_) {
    return arguments.length ? (translate8(_), reclip()) : translate8();
  };
  m3.center = function(_) {
    return arguments.length ? (center(_), reclip()) : center();
  };
  m3.clipExtent = function(_) {
    return arguments.length ? (_ == null ? x07 = y07 = x13 = y13 = null : (x07 = +_[0][0], y07 = +_[0][1], x13 = +_[1][0], y13 = +_[1][1]), reclip()) : x07 == null ? null : [[x07, y07], [x13, y13]];
  };
  function reclip() {
    var k3 = pi3 * scale19(), t = m3(rotation_default(m3.rotate()).invert([0, 0]));
    return clipExtent(x07 == null ? [[t[0] - k3, t[1] - k3], [t[0] + k3, t[1] + k3]] : project3 === mercatorRaw ? [[Math.max(t[0] - k3, x07), y07], [Math.min(t[0] + k3, x13), y13]] : [[x07, Math.max(t[1] - k3, y07)], [x13, Math.min(t[1] + k3, y13)]]);
  }
  return reclip();
}

// node_modules/d3-geo/src/projection/conicConformal.js
function tany(y9) {
  return tan((halfPi2 + y9) / 2);
}
function conicConformalRaw(y07, y13) {
  var cy0 = cos2(y07), n = y07 === y13 ? sin2(y07) : log5(cy0 / cos2(y13)) / log5(tany(y13) / tany(y07)), f = cy0 * pow5(tany(y07), n) / n;
  if (!n)
    return mercatorRaw;
  function project3(x9, y9) {
    if (f > 0) {
      if (y9 < -halfPi2 + epsilon4)
        y9 = -halfPi2 + epsilon4;
    } else {
      if (y9 > halfPi2 - epsilon4)
        y9 = halfPi2 - epsilon4;
    }
    var r = f / pow5(tany(y9), n);
    return [r * sin2(n * x9), f - r * cos2(n * x9)];
  }
  project3.invert = function(x9, y9) {
    var fy = f - y9, r = sign2(n) * sqrt4(x9 * x9 + fy * fy), l = atan22(x9, abs2(fy)) * sign2(fy);
    if (fy * n < 0)
      l -= pi3 * sign2(x9) * sign2(fy);
    return [l / n, 2 * atan(pow5(f / r, 1 / n)) - halfPi2];
  };
  return project3;
}
function conicConformal_default() {
  return conicProjection(conicConformalRaw).scale(109.5).parallels([30, 30]);
}

// node_modules/d3-geo/src/projection/equirectangular.js
function equirectangularRaw(lambda, phi2) {
  return [lambda, phi2];
}
equirectangularRaw.invert = equirectangularRaw;
function equirectangular_default() {
  return projection(equirectangularRaw).scale(152.63);
}

// node_modules/d3-geo/src/projection/conicEquidistant.js
function conicEquidistantRaw(y07, y13) {
  var cy0 = cos2(y07), n = y07 === y13 ? sin2(y07) : (cy0 - cos2(y13)) / (y13 - y07), g = cy0 / n + y07;
  if (abs2(n) < epsilon4)
    return equirectangularRaw;
  function project3(x9, y9) {
    var gy = g - y9, nx = n * x9;
    return [gy * sin2(nx), g - gy * cos2(nx)];
  }
  project3.invert = function(x9, y9) {
    var gy = g - y9, l = atan22(x9, abs2(gy)) * sign2(gy);
    if (gy * n < 0)
      l -= pi3 * sign2(x9) * sign2(gy);
    return [l / n, g - sign2(n) * sqrt4(x9 * x9 + gy * gy)];
  };
  return project3;
}
function conicEquidistant_default() {
  return conicProjection(conicEquidistantRaw).scale(131.154).center([0, 13.9389]);
}

// node_modules/d3-geo/src/projection/equalEarth.js
var A1 = 1.340264;
var A2 = -0.081106;
var A3 = 893e-6;
var A4 = 3796e-6;
var M = sqrt4(3) / 2;
var iterations = 12;
function equalEarthRaw(lambda, phi2) {
  var l = asin2(M * sin2(phi2)), l2 = l * l, l6 = l2 * l2 * l2;
  return [
    lambda * cos2(l) / (M * (A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2))),
    l * (A1 + A2 * l2 + l6 * (A3 + A4 * l2))
  ];
}
equalEarthRaw.invert = function(x9, y9) {
  var l = y9, l2 = l * l, l6 = l2 * l2 * l2;
  for (var i = 0, delta, fy, fpy; i < iterations; ++i) {
    fy = l * (A1 + A2 * l2 + l6 * (A3 + A4 * l2)) - y9;
    fpy = A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2);
    l -= delta = fy / fpy, l2 = l * l, l6 = l2 * l2 * l2;
    if (abs2(delta) < epsilon23)
      break;
  }
  return [
    M * x9 * (A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2)) / cos2(l),
    asin2(sin2(l) / M)
  ];
};
function equalEarth_default() {
  return projection(equalEarthRaw).scale(177.158);
}

// node_modules/d3-geo/src/projection/gnomonic.js
function gnomonicRaw(x9, y9) {
  var cy = cos2(y9), k3 = cos2(x9) * cy;
  return [cy * sin2(x9) / k3, sin2(y9) / k3];
}
gnomonicRaw.invert = azimuthalInvert(atan);
function gnomonic_default() {
  return projection(gnomonicRaw).scale(144.049).clipAngle(60);
}

// node_modules/d3-geo/src/projection/identity.js
function identity_default5() {
  var k3 = 1, tx = 0, ty = 0, sx = 1, sy = 1, alpha = 0, ca3, sa6, x07 = null, y07, x13, y13, kx3 = 1, ky2 = 1, transform4 = transformer4({
    point: function(x9, y9) {
      var p = projection3([x9, y9]);
      this.stream.point(p[0], p[1]);
    }
  }), postclip = identity_default4, cache2, cacheStream;
  function reset3() {
    kx3 = k3 * sx;
    ky2 = k3 * sy;
    cache2 = cacheStream = null;
    return projection3;
  }
  function projection3(p) {
    var x9 = p[0] * kx3, y9 = p[1] * ky2;
    if (alpha) {
      var t = y9 * ca3 - x9 * sa6;
      x9 = x9 * ca3 + y9 * sa6;
      y9 = t;
    }
    return [x9 + tx, y9 + ty];
  }
  projection3.invert = function(p) {
    var x9 = p[0] - tx, y9 = p[1] - ty;
    if (alpha) {
      var t = y9 * ca3 + x9 * sa6;
      x9 = x9 * ca3 - y9 * sa6;
      y9 = t;
    }
    return [x9 / kx3, y9 / ky2];
  };
  projection3.stream = function(stream2) {
    return cache2 && cacheStream === stream2 ? cache2 : cache2 = transform4(postclip(cacheStream = stream2));
  };
  projection3.postclip = function(_) {
    return arguments.length ? (postclip = _, x07 = y07 = x13 = y13 = null, reset3()) : postclip;
  };
  projection3.clipExtent = function(_) {
    return arguments.length ? (postclip = _ == null ? (x07 = y07 = x13 = y13 = null, identity_default4) : clipRectangle(x07 = +_[0][0], y07 = +_[0][1], x13 = +_[1][0], y13 = +_[1][1]), reset3()) : x07 == null ? null : [[x07, y07], [x13, y13]];
  };
  projection3.scale = function(_) {
    return arguments.length ? (k3 = +_, reset3()) : k3;
  };
  projection3.translate = function(_) {
    return arguments.length ? (tx = +_[0], ty = +_[1], reset3()) : [tx, ty];
  };
  projection3.angle = function(_) {
    return arguments.length ? (alpha = _ % 360 * radians2, sa6 = sin2(alpha), ca3 = cos2(alpha), reset3()) : alpha * degrees3;
  };
  projection3.reflectX = function(_) {
    return arguments.length ? (sx = _ ? -1 : 1, reset3()) : sx < 0;
  };
  projection3.reflectY = function(_) {
    return arguments.length ? (sy = _ ? -1 : 1, reset3()) : sy < 0;
  };
  projection3.fitExtent = function(extent8, object2) {
    return fitExtent(projection3, extent8, object2);
  };
  projection3.fitSize = function(size, object2) {
    return fitSize(projection3, size, object2);
  };
  projection3.fitWidth = function(width2, object2) {
    return fitWidth(projection3, width2, object2);
  };
  projection3.fitHeight = function(height2, object2) {
    return fitHeight(projection3, height2, object2);
  };
  return projection3;
}

// node_modules/d3-geo/src/projection/naturalEarth1.js
function naturalEarth1Raw(lambda, phi2) {
  var phi22 = phi2 * phi2, phi4 = phi22 * phi22;
  return [
    lambda * (0.8707 - 0.131979 * phi22 + phi4 * (-0.013791 + phi4 * (3971e-6 * phi22 - 1529e-6 * phi4))),
    phi2 * (1.007226 + phi22 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi22 - 5916e-6 * phi4)))
  ];
}
naturalEarth1Raw.invert = function(x9, y9) {
  var phi2 = y9, i = 25, delta;
  do {
    var phi22 = phi2 * phi2, phi4 = phi22 * phi22;
    phi2 -= delta = (phi2 * (1.007226 + phi22 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi22 - 5916e-6 * phi4))) - y9) / (1.007226 + phi22 * (0.015085 * 3 + phi4 * (-0.044475 * 7 + 0.028874 * 9 * phi22 - 5916e-6 * 11 * phi4)));
  } while (abs2(delta) > epsilon4 && --i > 0);
  return [
    x9 / (0.8707 + (phi22 = phi2 * phi2) * (-0.131979 + phi22 * (-0.013791 + phi22 * phi22 * phi22 * (3971e-6 - 1529e-6 * phi22)))),
    phi2
  ];
};
function naturalEarth1_default() {
  return projection(naturalEarth1Raw).scale(175.295);
}

// node_modules/d3-geo/src/projection/orthographic.js
function orthographicRaw(x9, y9) {
  return [cos2(y9) * sin2(x9), sin2(y9)];
}
orthographicRaw.invert = azimuthalInvert(asin2);
function orthographic_default() {
  return projection(orthographicRaw).scale(249.5).clipAngle(90 + epsilon4);
}

// node_modules/d3-geo/src/projection/stereographic.js
function stereographicRaw(x9, y9) {
  var cy = cos2(y9), k3 = 1 + cos2(x9) * cy;
  return [cy * sin2(x9) / k3, sin2(y9) / k3];
}
stereographicRaw.invert = azimuthalInvert(function(z) {
  return 2 * atan(z);
});
function stereographic_default() {
  return projection(stereographicRaw).scale(250).clipAngle(142);
}

// node_modules/d3-geo/src/projection/transverseMercator.js
function transverseMercatorRaw(lambda, phi2) {
  return [log5(tan((halfPi2 + phi2) / 2)), -lambda];
}
transverseMercatorRaw.invert = function(x9, y9) {
  return [-y9, 2 * atan(exp4(x9)) - halfPi2];
};
function transverseMercator_default() {
  var m3 = mercatorProjection(transverseMercatorRaw), center = m3.center, rotate6 = m3.rotate;
  m3.center = function(_) {
    return arguments.length ? center([-_[1], _[0]]) : (_ = center(), [_[1], -_[0]]);
  };
  m3.rotate = function(_) {
    return arguments.length ? rotate6([_[0], _[1], _.length > 2 ? _[2] + 90 : 90]) : (_ = rotate6(), [_[0], _[1], _[2] - 90]);
  };
  return rotate6([0, 0, 90]).scale(159.155);
}

// node_modules/d3-geo-projection/src/math.js
var abs3 = Math.abs;
var atan3 = Math.atan;
var atan23 = Math.atan2;
var cos3 = Math.cos;
var exp5 = Math.exp;
var floor2 = Math.floor;
var log6 = Math.log;
var max4 = Math.max;
var min4 = Math.min;
var pow6 = Math.pow;
var sign3 = Math.sign || function(x9) {
  return x9 > 0 ? 1 : x9 < 0 ? -1 : 0;
};
var sin3 = Math.sin;
var tan2 = Math.tan;
var epsilon5 = 1e-6;
var epsilon24 = 1e-12;
var pi4 = Math.PI;
var halfPi3 = pi4 / 2;
var quarterPi2 = pi4 / 4;
var sqrt1_2 = Math.SQRT1_2;
var sqrt22 = sqrt5(2);
var sqrtPi = sqrt5(pi4);
var tau4 = pi4 * 2;
var degrees4 = 180 / pi4;
var radians3 = pi4 / 180;
function sinci(x9) {
  return x9 ? x9 / Math.sin(x9) : 1;
}
function asin3(x9) {
  return x9 > 1 ? halfPi3 : x9 < -1 ? -halfPi3 : Math.asin(x9);
}
function acos3(x9) {
  return x9 > 1 ? 0 : x9 < -1 ? pi4 : Math.acos(x9);
}
function sqrt5(x9) {
  return x9 > 0 ? Math.sqrt(x9) : 0;
}
function tanh2(x9) {
  x9 = exp5(2 * x9);
  return (x9 - 1) / (x9 + 1);
}
function sinh2(x9) {
  return (exp5(x9) - exp5(-x9)) / 2;
}
function cosh2(x9) {
  return (exp5(x9) + exp5(-x9)) / 2;
}
function arsinh(x9) {
  return log6(x9 + sqrt5(x9 * x9 + 1));
}
function arcosh(x9) {
  return log6(x9 + sqrt5(x9 * x9 - 1));
}

// node_modules/d3-geo-projection/src/aitoff.js
function aitoffRaw(x9, y9) {
  var cosy = cos3(y9), sincia = sinci(acos3(cosy * cos3(x9 /= 2)));
  return [2 * cosy * sin3(x9) * sincia, sin3(y9) * sincia];
}
aitoffRaw.invert = function(x9, y9) {
  if (x9 * x9 + 4 * y9 * y9 > pi4 * pi4 + epsilon5)
    return;
  var x13 = x9, y13 = y9, i = 25;
  do {
    var sinx = sin3(x13), sinx_2 = sin3(x13 / 2), cosx_2 = cos3(x13 / 2), siny = sin3(y13), cosy = cos3(y13), sin_2y = sin3(2 * y13), sin2y = siny * siny, cos2y = cosy * cosy, sin2x_2 = sinx_2 * sinx_2, c5 = 1 - cos2y * cosx_2 * cosx_2, e3 = c5 ? acos3(cosy * cosx_2) * sqrt5(f = 1 / c5) : f = 0, f, fx = 2 * e3 * cosy * sinx_2 - x9, fy = e3 * siny - y9, dxdx = f * (cos2y * sin2x_2 + e3 * cosy * cosx_2 * sin2y), dxdy = f * (0.5 * sinx * sin_2y - e3 * 2 * siny * sinx_2), dydx = f * 0.25 * (sin_2y * sinx_2 - e3 * siny * cos2y * sinx), dydy = f * (sin2y * cosx_2 + e3 * sin2x_2 * cosy), z = dxdy * dydx - dydy * dxdx;
    if (!z)
      break;
    var dx = (fy * dxdy - fx * dydy) / z, dy = (fx * dydx - fy * dxdx) / z;
    x13 -= dx, y13 -= dy;
  } while ((abs3(dx) > epsilon5 || abs3(dy) > epsilon5) && --i > 0);
  return [x13, y13];
};

// node_modules/d3-geo-projection/src/august.js
function augustRaw(lambda, phi2) {
  var tanPhi = tan2(phi2 / 2), k3 = sqrt5(1 - tanPhi * tanPhi), c5 = 1 + k3 * cos3(lambda /= 2), x9 = sin3(lambda) * k3 / c5, y9 = tanPhi / c5, x22 = x9 * x9, y22 = y9 * y9;
  return [
    4 / 3 * x9 * (3 + x22 - 3 * y22),
    4 / 3 * y9 * (3 + 3 * x22 - y22)
  ];
}
augustRaw.invert = function(x9, y9) {
  x9 *= 3 / 8, y9 *= 3 / 8;
  if (!x9 && abs3(y9) > 1)
    return null;
  var x22 = x9 * x9, y22 = y9 * y9, s2 = 1 + x22 + y22, sin3Eta = sqrt5((s2 - sqrt5(s2 * s2 - 4 * y9 * y9)) / 2), eta = asin3(sin3Eta) / 3, xi = sin3Eta ? arcosh(abs3(y9 / sin3Eta)) / 3 : arsinh(abs3(x9)) / 3, cosEta = cos3(eta), coshXi = cosh2(xi), d = coshXi * coshXi - cosEta * cosEta;
  return [
    sign3(x9) * 2 * atan23(sinh2(xi) * cosEta, 0.25 - d),
    sign3(y9) * 2 * atan23(coshXi * sin3(eta), 0.25 + d)
  ];
};

// node_modules/d3-geo-projection/src/baker.js
var sqrt8 = sqrt5(8);
var phi02 = log6(1 + sqrt22);
function bakerRaw(lambda, phi2) {
  var phi03 = abs3(phi2);
  return phi03 < quarterPi2 ? [lambda, log6(tan2(quarterPi2 + phi2 / 2))] : [lambda * cos3(phi03) * (2 * sqrt22 - 1 / sin3(phi03)), sign3(phi2) * (2 * sqrt22 * (phi03 - quarterPi2) - log6(tan2(phi03 / 2)))];
}
bakerRaw.invert = function(x9, y9) {
  if ((y07 = abs3(y9)) < phi02)
    return [x9, 2 * atan3(exp5(y9)) - halfPi3];
  var phi2 = quarterPi2, i = 25, delta, y07;
  do {
    var cosPhi_2 = cos3(phi2 / 2), tanPhi_2 = tan2(phi2 / 2);
    phi2 -= delta = (sqrt8 * (phi2 - quarterPi2) - log6(tanPhi_2) - y07) / (sqrt8 - cosPhi_2 * cosPhi_2 / (2 * tanPhi_2));
  } while (abs3(delta) > epsilon24 && --i > 0);
  return [x9 / (cos3(phi2) * (sqrt8 - 1 / sin3(phi2))), sign3(y9) * phi2];
};

// node_modules/d3-geo-projection/src/hammer.js
function hammerQuarticAuthalicRaw(lambda, phi2) {
  return [
    lambda * cos3(phi2) / cos3(phi2 /= 2),
    2 * sin3(phi2)
  ];
}
hammerQuarticAuthalicRaw.invert = function(x9, y9) {
  var phi2 = 2 * asin3(y9 / 2);
  return [
    x9 * cos3(phi2 / 2) / cos3(phi2),
    phi2
  ];
};

// node_modules/d3-geo-projection/src/newton.js
function solve(f, y9, x9) {
  var steps = 100, delta, f0, f1;
  x9 = x9 === void 0 ? 0 : +x9;
  y9 = +y9;
  do {
    f0 = f(x9);
    f1 = f(x9 + epsilon5);
    if (f0 === f1)
      f1 = f0 + epsilon5;
    x9 -= delta = -1 * epsilon5 * (f0 - y9) / (f0 - f1);
  } while (steps-- > 0 && abs3(delta) > epsilon5);
  return steps < 0 ? NaN : x9;
}

// node_modules/d3-geo-projection/src/mollweide.js
function mollweideBromleyTheta(cp, phi2) {
  var cpsinPhi = cp * sin3(phi2), i = 30, delta;
  do
    phi2 -= delta = (phi2 + sin3(phi2) - cpsinPhi) / (1 + cos3(phi2));
  while (abs3(delta) > epsilon5 && --i > 0);
  return phi2 / 2;
}
function mollweideBromleyRaw(cx, cy, cp) {
  function forward(lambda, phi2) {
    return [cx * lambda * cos3(phi2 = mollweideBromleyTheta(cp, phi2)), cy * sin3(phi2)];
  }
  forward.invert = function(x9, y9) {
    return y9 = asin3(y9 / cy), [x9 / (cx * cos3(y9)), asin3((2 * y9 + sin3(2 * y9)) / cp)];
  };
  return forward;
}
var mollweideRaw = mollweideBromleyRaw(sqrt22 / halfPi3, sqrt22, pi4);
function mollweide_default() {
  return projection(mollweideRaw).scale(169.529);
}

// node_modules/d3-geo-projection/src/boggs.js
var k2 = 2.00276;
var w2 = 1.11072;
function boggsRaw(lambda, phi2) {
  var theta = mollweideBromleyTheta(pi4, phi2);
  return [k2 * lambda / (1 / cos3(phi2) + w2 / cos3(theta)), (phi2 + sqrt22 * sin3(theta)) / k2];
}
boggsRaw.invert = function(x9, y9) {
  var ky2 = k2 * y9, theta = y9 < 0 ? -quarterPi2 : quarterPi2, i = 25, delta, phi2;
  do {
    phi2 = ky2 - sqrt22 * sin3(theta);
    theta -= delta = (sin3(2 * theta) + 2 * theta - pi4 * sin3(phi2)) / (2 * cos3(2 * theta) + 2 + pi4 * cos3(phi2) * sqrt22 * cos3(theta));
  } while (abs3(delta) > epsilon5 && --i > 0);
  phi2 = ky2 - sqrt22 * sin3(theta);
  return [x9 * (1 / cos3(phi2) + w2 / cos3(theta)) / k2, phi2];
};

// node_modules/d3-geo-projection/src/sinusoidal.js
function sinusoidalRaw(lambda, phi2) {
  return [lambda * cos3(phi2), phi2];
}
sinusoidalRaw.invert = function(x9, y9) {
  return [x9 / cos3(y9), y9];
};

// node_modules/d3-geo-projection/src/bromley.js
var bromleyRaw = mollweideBromleyRaw(1, 4 / pi4, pi4);

// node_modules/d3-geo-projection/src/collignon.js
function collignonRaw(lambda, phi2) {
  var alpha = sqrt5(1 - sin3(phi2));
  return [2 / sqrtPi * lambda * alpha, sqrtPi * (1 - alpha)];
}
collignonRaw.invert = function(x9, y9) {
  var lambda = (lambda = y9 / sqrtPi - 1) * lambda;
  return [lambda > 0 ? x9 * sqrt5(pi4 / lambda) / 2 : 0, asin3(1 - lambda)];
};

// node_modules/d3-geo-projection/src/craster.js
var sqrt34 = sqrt5(3);
function crasterRaw(lambda, phi2) {
  return [sqrt34 * lambda * (2 * cos3(2 * phi2 / 3) - 1) / sqrtPi, sqrt34 * sqrtPi * sin3(phi2 / 3)];
}
crasterRaw.invert = function(x9, y9) {
  var phi2 = 3 * asin3(y9 / (sqrt34 * sqrtPi));
  return [sqrtPi * x9 / (sqrt34 * (2 * cos3(2 * phi2 / 3) - 1)), phi2];
};

// node_modules/d3-geo-projection/src/cylindricalEqualArea.js
function cylindricalEqualAreaRaw2(phi03) {
  var cosPhi02 = cos3(phi03);
  function forward(lambda, phi2) {
    return [lambda * cosPhi02, sin3(phi2) / cosPhi02];
  }
  forward.invert = function(x9, y9) {
    return [x9 / cosPhi02, asin3(y9 * cosPhi02)];
  };
  return forward;
}

// node_modules/d3-geo-projection/src/eckert1.js
function eckert1Raw(lambda, phi2) {
  var alpha = sqrt5(8 / (3 * pi4));
  return [
    alpha * lambda * (1 - abs3(phi2) / pi4),
    alpha * phi2
  ];
}
eckert1Raw.invert = function(x9, y9) {
  var alpha = sqrt5(8 / (3 * pi4)), phi2 = y9 / alpha;
  return [
    x9 / (alpha * (1 - abs3(phi2) / pi4)),
    phi2
  ];
};

// node_modules/d3-geo-projection/src/eckert2.js
function eckert2Raw(lambda, phi2) {
  var alpha = sqrt5(4 - 3 * sin3(abs3(phi2)));
  return [
    2 / sqrt5(6 * pi4) * lambda * alpha,
    sign3(phi2) * sqrt5(2 * pi4 / 3) * (2 - alpha)
  ];
}
eckert2Raw.invert = function(x9, y9) {
  var alpha = 2 - abs3(y9) / sqrt5(2 * pi4 / 3);
  return [
    x9 * sqrt5(6 * pi4) / (2 * alpha),
    sign3(y9) * asin3((4 - alpha * alpha) / 3)
  ];
};

// node_modules/d3-geo-projection/src/eckert3.js
function eckert3Raw(lambda, phi2) {
  var k3 = sqrt5(pi4 * (4 + pi4));
  return [
    2 / k3 * lambda * (1 + sqrt5(1 - 4 * phi2 * phi2 / (pi4 * pi4))),
    4 / k3 * phi2
  ];
}
eckert3Raw.invert = function(x9, y9) {
  var k3 = sqrt5(pi4 * (4 + pi4)) / 2;
  return [
    x9 * k3 / (1 + sqrt5(1 - y9 * y9 * (4 + pi4) / (4 * pi4))),
    y9 * k3 / 2
  ];
};

// node_modules/d3-geo-projection/src/eckert4.js
function eckert4Raw(lambda, phi2) {
  var k3 = (2 + halfPi3) * sin3(phi2);
  phi2 /= 2;
  for (var i = 0, delta = Infinity; i < 10 && abs3(delta) > epsilon5; i++) {
    var cosPhi = cos3(phi2);
    phi2 -= delta = (phi2 + sin3(phi2) * (cosPhi + 2) - k3) / (2 * cosPhi * (1 + cosPhi));
  }
  return [
    2 / sqrt5(pi4 * (4 + pi4)) * lambda * (1 + cos3(phi2)),
    2 * sqrt5(pi4 / (4 + pi4)) * sin3(phi2)
  ];
}
eckert4Raw.invert = function(x9, y9) {
  var A6 = y9 * sqrt5((4 + pi4) / pi4) / 2, k3 = asin3(A6), c5 = cos3(k3);
  return [
    x9 / (2 / sqrt5(pi4 * (4 + pi4)) * (1 + c5)),
    asin3((k3 + A6 * (c5 + 2)) / (2 + halfPi3))
  ];
};

// node_modules/d3-geo-projection/src/eckert5.js
function eckert5Raw(lambda, phi2) {
  return [
    lambda * (1 + cos3(phi2)) / sqrt5(2 + pi4),
    2 * phi2 / sqrt5(2 + pi4)
  ];
}
eckert5Raw.invert = function(x9, y9) {
  var k3 = sqrt5(2 + pi4), phi2 = y9 * k3 / 2;
  return [
    k3 * x9 / (1 + cos3(phi2)),
    phi2
  ];
};

// node_modules/d3-geo-projection/src/eckert6.js
function eckert6Raw(lambda, phi2) {
  var k3 = (1 + halfPi3) * sin3(phi2);
  for (var i = 0, delta = Infinity; i < 10 && abs3(delta) > epsilon5; i++) {
    phi2 -= delta = (phi2 + sin3(phi2) - k3) / (1 + cos3(phi2));
  }
  k3 = sqrt5(2 + pi4);
  return [
    lambda * (1 + cos3(phi2)) / k3,
    2 * phi2 / k3
  ];
}
eckert6Raw.invert = function(x9, y9) {
  var j = 1 + halfPi3, k3 = sqrt5(j / 2);
  return [
    x9 * 2 * k3 / (1 + cos3(y9 *= k3)),
    asin3((y9 + sin3(y9)) / j)
  ];
};

// node_modules/d3-geo-projection/src/eisenlohr.js
var eisenlohrK = 3 + 2 * sqrt22;
function eisenlohrRaw(lambda, phi2) {
  var s0 = sin3(lambda /= 2), c0 = cos3(lambda), k3 = sqrt5(cos3(phi2)), c1 = cos3(phi2 /= 2), t = sin3(phi2) / (c1 + sqrt22 * c0 * k3), c5 = sqrt5(2 / (1 + t * t)), v2 = sqrt5((sqrt22 * c1 + (c0 + s0) * k3) / (sqrt22 * c1 + (c0 - s0) * k3));
  return [
    eisenlohrK * (c5 * (v2 - 1 / v2) - 2 * log6(v2)),
    eisenlohrK * (c5 * t * (v2 + 1 / v2) - 2 * atan3(t))
  ];
}
eisenlohrRaw.invert = function(x9, y9) {
  if (!(p = augustRaw.invert(x9 / 1.2, y9 * 1.065)))
    return null;
  var lambda = p[0], phi2 = p[1], i = 20, p;
  x9 /= eisenlohrK, y9 /= eisenlohrK;
  do {
    var _0 = lambda / 2, _1 = phi2 / 2, s0 = sin3(_0), c0 = cos3(_0), s1 = sin3(_1), c1 = cos3(_1), cos1 = cos3(phi2), k3 = sqrt5(cos1), t = s1 / (c1 + sqrt22 * c0 * k3), t22 = t * t, c5 = sqrt5(2 / (1 + t22)), v0 = sqrt22 * c1 + (c0 + s0) * k3, v1 = sqrt22 * c1 + (c0 - s0) * k3, v2 = v0 / v1, v3 = sqrt5(v2), vm1v = v3 - 1 / v3, vp1v = v3 + 1 / v3, fx = c5 * vm1v - 2 * log6(v3) - x9, fy = c5 * t * vp1v - 2 * atan3(t) - y9, deltatDeltaLambda = s1 && sqrt1_2 * k3 * s0 * t22 / s1, deltatDeltaPhi = (sqrt22 * c0 * c1 + k3) / (2 * (c1 + sqrt22 * c0 * k3) * (c1 + sqrt22 * c0 * k3) * k3), deltacDeltat = -0.5 * t * c5 * c5 * c5, deltacDeltaLambda = deltacDeltat * deltatDeltaLambda, deltacDeltaPhi = deltacDeltat * deltatDeltaPhi, A6 = (A6 = 2 * c1 + sqrt22 * k3 * (c0 - s0)) * A6 * v3, deltavDeltaLambda = (sqrt22 * c0 * c1 * k3 + cos1) / A6, deltavDeltaPhi = -(sqrt22 * s0 * s1) / (k3 * A6), deltaxDeltaLambda = vm1v * deltacDeltaLambda - 2 * deltavDeltaLambda / v3 + c5 * (deltavDeltaLambda + deltavDeltaLambda / v2), deltaxDeltaPhi = vm1v * deltacDeltaPhi - 2 * deltavDeltaPhi / v3 + c5 * (deltavDeltaPhi + deltavDeltaPhi / v2), deltayDeltaLambda = t * vp1v * deltacDeltaLambda - 2 * deltatDeltaLambda / (1 + t22) + c5 * vp1v * deltatDeltaLambda + c5 * t * (deltavDeltaLambda - deltavDeltaLambda / v2), deltayDeltaPhi = t * vp1v * deltacDeltaPhi - 2 * deltatDeltaPhi / (1 + t22) + c5 * vp1v * deltatDeltaPhi + c5 * t * (deltavDeltaPhi - deltavDeltaPhi / v2), denominator = deltaxDeltaPhi * deltayDeltaLambda - deltayDeltaPhi * deltaxDeltaLambda;
    if (!denominator)
      break;
    var deltaLambda = (fy * deltaxDeltaPhi - fx * deltayDeltaPhi) / denominator, deltaPhi = (fx * deltayDeltaLambda - fy * deltaxDeltaLambda) / denominator;
    lambda -= deltaLambda;
    phi2 = max4(-halfPi3, min4(halfPi3, phi2 - deltaPhi));
  } while ((abs3(deltaLambda) > epsilon5 || abs3(deltaPhi) > epsilon5) && --i > 0);
  return abs3(abs3(phi2) - halfPi3) < epsilon5 ? [0, phi2] : i && [lambda, phi2];
};

// node_modules/d3-geo-projection/src/fahey.js
var faheyK = cos3(35 * radians3);
function faheyRaw(lambda, phi2) {
  var t = tan2(phi2 / 2);
  return [lambda * faheyK * sqrt5(1 - t * t), (1 + faheyK) * t];
}
faheyRaw.invert = function(x9, y9) {
  var t = y9 / (1 + faheyK);
  return [x9 && x9 / (faheyK * sqrt5(1 - t * t)), 2 * atan3(t)];
};

// node_modules/d3-geo-projection/src/foucaut.js
function foucautRaw(lambda, phi2) {
  var k3 = phi2 / 2, cosk = cos3(k3);
  return [2 * lambda / sqrtPi * cos3(phi2) * cosk * cosk, sqrtPi * tan2(k3)];
}
foucautRaw.invert = function(x9, y9) {
  var k3 = atan3(y9 / sqrtPi), cosk = cos3(k3), phi2 = 2 * k3;
  return [x9 * sqrtPi / 2 / (cos3(phi2) * cosk * cosk), phi2];
};

// node_modules/d3-geo-projection/src/ginzburgPolyconic.js
function ginzburgPolyconic_default(a4, b6, c5, d, e3, f, g, h6) {
  if (arguments.length < 8)
    h6 = 0;
  function forward(lambda, phi2) {
    if (!phi2)
      return [a4 * lambda / pi4, 0];
    var phi22 = phi2 * phi2, xB = a4 + phi22 * (b6 + phi22 * (c5 + phi22 * d)), yB = phi2 * (e3 - 1 + phi22 * (f - h6 + phi22 * g)), m3 = (xB * xB + yB * yB) / (2 * yB), alpha = lambda * asin3(xB / m3) / pi4;
    return [m3 * sin3(alpha), phi2 * (1 + phi22 * h6) + m3 * (1 - cos3(alpha))];
  }
  forward.invert = function(x9, y9) {
    var lambda = pi4 * x9 / a4, phi2 = y9, deltaLambda, deltaPhi, i = 50;
    do {
      var phi22 = phi2 * phi2, xB = a4 + phi22 * (b6 + phi22 * (c5 + phi22 * d)), yB = phi2 * (e3 - 1 + phi22 * (f - h6 + phi22 * g)), p = xB * xB + yB * yB, q = 2 * yB, m3 = p / q, m22 = m3 * m3, dAlphadLambda = asin3(xB / m3) / pi4, alpha = lambda * dAlphadLambda, xB2 = xB * xB, dxBdPhi = (2 * b6 + phi22 * (4 * c5 + phi22 * 6 * d)) * phi2, dyBdPhi = e3 + phi22 * (3 * f + phi22 * 5 * g), dpdPhi = 2 * (xB * dxBdPhi + yB * (dyBdPhi - 1)), dqdPhi = 2 * (dyBdPhi - 1), dmdPhi = (dpdPhi * q - p * dqdPhi) / (q * q), cosAlpha = cos3(alpha), sinAlpha = sin3(alpha), mcosAlpha = m3 * cosAlpha, msinAlpha = m3 * sinAlpha, dAlphadPhi = lambda / pi4 * (1 / sqrt5(1 - xB2 / m22)) * (dxBdPhi * m3 - xB * dmdPhi) / m22, fx = msinAlpha - x9, fy = phi2 * (1 + phi22 * h6) + m3 - mcosAlpha - y9, deltaxDeltaPhi = dmdPhi * sinAlpha + mcosAlpha * dAlphadPhi, deltaxDeltaLambda = mcosAlpha * dAlphadLambda, deltayDeltaPhi = 1 + dmdPhi - (dmdPhi * cosAlpha - msinAlpha * dAlphadPhi), deltayDeltaLambda = msinAlpha * dAlphadLambda, denominator = deltaxDeltaPhi * deltayDeltaLambda - deltayDeltaPhi * deltaxDeltaLambda;
      if (!denominator)
        break;
      lambda -= deltaLambda = (fy * deltaxDeltaPhi - fx * deltayDeltaPhi) / denominator;
      phi2 -= deltaPhi = (fx * deltayDeltaLambda - fy * deltaxDeltaLambda) / denominator;
    } while ((abs3(deltaLambda) > epsilon5 || abs3(deltaPhi) > epsilon5) && --i > 0);
    return [lambda, phi2];
  };
  return forward;
}

// node_modules/d3-geo-projection/src/ginzburg4.js
var ginzburg4Raw = ginzburgPolyconic_default(2.8284, -1.6988, 0.75432, -0.18071, 1.76003, -0.38914, 0.042555);

// node_modules/d3-geo-projection/src/ginzburg5.js
var ginzburg5Raw = ginzburgPolyconic_default(2.583819, -0.835827, 0.170354, -0.038094, 1.543313, -0.411435, 0.082742);

// node_modules/d3-geo-projection/src/ginzburg6.js
var ginzburg6Raw = ginzburgPolyconic_default(5 / 6 * pi4, -0.62636, -0.0344, 0, 1.3493, -0.05524, 0, 0.045);

// node_modules/d3-geo-projection/src/ginzburg8.js
function ginzburg8Raw(lambda, phi2) {
  var lambda22 = lambda * lambda, phi22 = phi2 * phi2;
  return [
    lambda * (1 - 0.162388 * phi22) * (0.87 - 952426e-9 * lambda22 * lambda22),
    phi2 * (1 + phi22 / 12)
  ];
}
ginzburg8Raw.invert = function(x9, y9) {
  var lambda = x9, phi2 = y9, i = 50, delta;
  do {
    var phi22 = phi2 * phi2;
    phi2 -= delta = (phi2 * (1 + phi22 / 12) - y9) / (1 + phi22 / 4);
  } while (abs3(delta) > epsilon5 && --i > 0);
  i = 50;
  x9 /= 1 - 0.162388 * phi22;
  do {
    var lambda4 = (lambda4 = lambda * lambda) * lambda4;
    lambda -= delta = (lambda * (0.87 - 952426e-9 * lambda4) - x9) / (0.87 - 476213e-8 * lambda4);
  } while (abs3(delta) > epsilon5 && --i > 0);
  return [lambda, phi2];
};

// node_modules/d3-geo-projection/src/ginzburg9.js
var ginzburg9Raw = ginzburgPolyconic_default(2.6516, -0.76534, 0.19123, -0.047094, 1.36289, -0.13965, 0.031762);

// node_modules/d3-geo-projection/src/gringorten.js
function gringortenRaw(lambda, phi2) {
  var sLambda = sign3(lambda), sPhi = sign3(phi2), cosPhi = cos3(phi2), x9 = cos3(lambda) * cosPhi, y9 = sin3(lambda) * cosPhi, z = sin3(sPhi * phi2);
  lambda = abs3(atan23(y9, z));
  phi2 = asin3(x9);
  if (abs3(lambda - halfPi3) > epsilon5)
    lambda %= halfPi3;
  var point21 = gringortenHexadecant(lambda > pi4 / 4 ? halfPi3 - lambda : lambda, phi2);
  if (lambda > pi4 / 4)
    z = point21[0], point21[0] = -point21[1], point21[1] = -z;
  return point21[0] *= sLambda, point21[1] *= -sPhi, point21;
}
gringortenRaw.invert = function(x9, y9) {
  if (abs3(x9) > 1)
    x9 = sign3(x9) * 2 - x9;
  if (abs3(y9) > 1)
    y9 = sign3(y9) * 2 - y9;
  var sx = sign3(x9), sy = sign3(y9), x07 = -sx * x9, y07 = -sy * y9, t = y07 / x07 < 1, p = gringortenHexadecantInvert(t ? y07 : x07, t ? x07 : y07), lambda = p[0], phi2 = p[1], cosPhi = cos3(phi2);
  if (t)
    lambda = -halfPi3 - lambda;
  return [sx * (atan23(sin3(lambda) * cosPhi, -sin3(phi2)) + pi4), sy * asin3(cos3(lambda) * cosPhi)];
};
function gringortenHexadecant(lambda, phi2) {
  if (phi2 === halfPi3)
    return [0, 0];
  var sinPhi = sin3(phi2), r = sinPhi * sinPhi, r2 = r * r, j = 1 + r2, k3 = 1 + 3 * r2, q = 1 - r2, z = asin3(1 / sqrt5(j)), v2 = q + r * j * z, p2 = (1 - sinPhi) / v2, p = sqrt5(p2), a22 = p2 * j, a4 = sqrt5(a22), h6 = p * q, x9, i;
  if (lambda === 0)
    return [0, -(h6 + r * a4)];
  var cosPhi = cos3(phi2), secPhi = 1 / cosPhi, drdPhi = 2 * sinPhi * cosPhi, dvdPhi = (-3 * r + z * k3) * drdPhi, dp2dPhi = (-v2 * cosPhi - (1 - sinPhi) * dvdPhi) / (v2 * v2), dpdPhi = 0.5 * dp2dPhi / p, dhdPhi = q * dpdPhi - 2 * r * p * drdPhi, dra2dPhi = r * j * dp2dPhi + p2 * k3 * drdPhi, mu = -secPhi * drdPhi, nu = -secPhi * dra2dPhi, zeta = -2 * secPhi * dhdPhi, lambda12 = 4 * lambda / pi4, delta;
  if (lambda > 0.222 * pi4 || phi2 < pi4 / 4 && lambda > 0.175 * pi4) {
    x9 = (h6 + r * sqrt5(a22 * (1 + r2) - h6 * h6)) / (1 + r2);
    if (lambda > pi4 / 4)
      return [x9, x9];
    var x13 = x9, x07 = 0.5 * x9;
    x9 = 0.5 * (x07 + x13), i = 50;
    do {
      var g = sqrt5(a22 - x9 * x9), f = x9 * (zeta + mu * g) + nu * asin3(x9 / a4) - lambda12;
      if (!f)
        break;
      if (f < 0)
        x07 = x9;
      else
        x13 = x9;
      x9 = 0.5 * (x07 + x13);
    } while (abs3(x13 - x07) > epsilon5 && --i > 0);
  } else {
    x9 = epsilon5, i = 25;
    do {
      var x22 = x9 * x9, g2 = sqrt5(a22 - x22), zetaMug = zeta + mu * g2, f2 = x9 * zetaMug + nu * asin3(x9 / a4) - lambda12, df = zetaMug + (nu - mu * x22) / g2;
      x9 -= delta = g2 ? f2 / df : 0;
    } while (abs3(delta) > epsilon5 && --i > 0);
  }
  return [x9, -h6 - r * sqrt5(a22 - x9 * x9)];
}
function gringortenHexadecantInvert(x9, y9) {
  var x07 = 0, x13 = 1, r = 0.5, i = 50;
  while (true) {
    var r2 = r * r, sinPhi = sqrt5(r), z = asin3(1 / sqrt5(1 + r2)), v2 = 1 - r2 + r * (1 + r2) * z, p2 = (1 - sinPhi) / v2, p = sqrt5(p2), a22 = p2 * (1 + r2), h6 = p * (1 - r2), g2 = a22 - x9 * x9, g = sqrt5(g2), y07 = y9 + h6 + r * g;
    if (abs3(x13 - x07) < epsilon24 || --i === 0 || y07 === 0)
      break;
    if (y07 > 0)
      x07 = r;
    else
      x13 = r;
    r = 0.5 * (x07 + x13);
  }
  if (!i)
    return null;
  var phi2 = asin3(sinPhi), cosPhi = cos3(phi2), secPhi = 1 / cosPhi, drdPhi = 2 * sinPhi * cosPhi, dvdPhi = (-3 * r + z * (1 + 3 * r2)) * drdPhi, dp2dPhi = (-v2 * cosPhi - (1 - sinPhi) * dvdPhi) / (v2 * v2), dpdPhi = 0.5 * dp2dPhi / p, dhdPhi = (1 - r2) * dpdPhi - 2 * r * p * drdPhi, zeta = -2 * secPhi * dhdPhi, mu = -secPhi * drdPhi, nu = -secPhi * (r * (1 + r2) * dp2dPhi + p2 * (1 + 3 * r2) * drdPhi);
  return [pi4 / 4 * (x9 * (zeta + mu * g) + nu * asin3(x9 / sqrt5(a22))), phi2];
}

// node_modules/d3-geo-projection/src/elliptic.js
function ellipticJi(u4, v2, m3) {
  var a4, b6, c5;
  if (!u4) {
    b6 = ellipticJ(v2, 1 - m3);
    return [
      [0, b6[0] / b6[1]],
      [1 / b6[1], 0],
      [b6[2] / b6[1], 0]
    ];
  }
  a4 = ellipticJ(u4, m3);
  if (!v2)
    return [[a4[0], 0], [a4[1], 0], [a4[2], 0]];
  b6 = ellipticJ(v2, 1 - m3);
  c5 = b6[1] * b6[1] + m3 * a4[0] * a4[0] * b6[0] * b6[0];
  return [
    [a4[0] * b6[2] / c5, a4[1] * a4[2] * b6[0] * b6[1] / c5],
    [a4[1] * b6[1] / c5, -a4[0] * a4[2] * b6[0] * b6[2] / c5],
    [a4[2] * b6[1] * b6[2] / c5, -m3 * a4[0] * a4[1] * b6[0] / c5]
  ];
}
function ellipticJ(u4, m3) {
  var ai, b6, phi2, t, twon;
  if (m3 < epsilon5) {
    t = sin3(u4);
    b6 = cos3(u4);
    ai = m3 * (u4 - t * b6) / 4;
    return [
      t - ai * b6,
      b6 + ai * t,
      1 - m3 * t * t / 2,
      u4 - ai
    ];
  }
  if (m3 >= 1 - epsilon5) {
    ai = (1 - m3) / 4;
    b6 = cosh2(u4);
    t = tanh2(u4);
    phi2 = 1 / b6;
    twon = b6 * sinh2(u4);
    return [
      t + ai * (twon - u4) / (b6 * b6),
      phi2 - ai * t * phi2 * (twon - u4),
      phi2 + ai * t * phi2 * (twon + u4),
      2 * atan3(exp5(u4)) - halfPi3 + ai * (twon - u4) / b6
    ];
  }
  var a4 = [1, 0, 0, 0, 0, 0, 0, 0, 0], c5 = [sqrt5(m3), 0, 0, 0, 0, 0, 0, 0, 0], i = 0;
  b6 = sqrt5(1 - m3);
  twon = 1;
  while (abs3(c5[i] / a4[i]) > epsilon5 && i < 8) {
    ai = a4[i++];
    c5[i] = (ai - b6) / 2;
    a4[i] = (ai + b6) / 2;
    b6 = sqrt5(ai * b6);
    twon *= 2;
  }
  phi2 = twon * a4[i] * u4;
  do {
    t = c5[i] * sin3(b6 = phi2) / a4[i];
    phi2 = (asin3(t) + phi2) / 2;
  } while (--i);
  return [sin3(phi2), t = cos3(phi2), t / cos3(phi2 - b6), phi2];
}
function ellipticFi(phi2, psi, m3) {
  var r = abs3(phi2), i = abs3(psi), sinhPsi = sinh2(i);
  if (r) {
    var cscPhi = 1 / sin3(r), cotPhi2 = 1 / (tan2(r) * tan2(r)), b6 = -(cotPhi2 + m3 * (sinhPsi * sinhPsi * cscPhi * cscPhi) - 1 + m3), c5 = (m3 - 1) * cotPhi2, cotLambda2 = (-b6 + sqrt5(b6 * b6 - 4 * c5)) / 2;
    return [
      ellipticF(atan3(1 / sqrt5(cotLambda2)), m3) * sign3(phi2),
      ellipticF(atan3(sqrt5((cotLambda2 / cotPhi2 - 1) / m3)), 1 - m3) * sign3(psi)
    ];
  }
  return [
    0,
    ellipticF(atan3(sinhPsi), 1 - m3) * sign3(psi)
  ];
}
function ellipticF(phi2, m3) {
  if (!m3)
    return phi2;
  if (m3 === 1)
    return log6(tan2(phi2 / 2 + quarterPi2));
  var a4 = 1, b6 = sqrt5(1 - m3), c5 = sqrt5(m3);
  for (var i = 0; abs3(c5) > epsilon5; i++) {
    if (phi2 % pi4) {
      var dPhi = atan3(b6 * tan2(phi2) / a4);
      if (dPhi < 0)
        dPhi += pi4;
      phi2 += dPhi + ~~(phi2 / pi4) * pi4;
    } else
      phi2 += phi2;
    c5 = (a4 + b6) / 2;
    b6 = sqrt5(a4 * b6);
    c5 = ((a4 = c5) - b6) / 2;
  }
  return phi2 / (pow6(2, i) * a4);
}

// node_modules/d3-geo-projection/src/guyou.js
function guyouRaw(lambda, phi2) {
  var k_ = (sqrt22 - 1) / (sqrt22 + 1), k3 = sqrt5(1 - k_ * k_), K4 = ellipticF(halfPi3, k3 * k3), f = -1, psi = log6(tan2(pi4 / 4 + abs3(phi2) / 2)), r = exp5(f * psi) / sqrt5(k_), at = guyouComplexAtan(r * cos3(f * lambda), r * sin3(f * lambda)), t = ellipticFi(at[0], at[1], k3 * k3);
  return [-t[1], (phi2 >= 0 ? 1 : -1) * (0.5 * K4 - t[0])];
}
function guyouComplexAtan(x9, y9) {
  var x22 = x9 * x9, y_1 = y9 + 1, t = 1 - x22 - y9 * y9;
  return [
    0.5 * ((x9 >= 0 ? halfPi3 : -halfPi3) - atan23(t, 2 * x9)),
    -0.25 * log6(t * t + 4 * x22) + 0.5 * log6(y_1 * y_1 + x22)
  ];
}
function guyouComplexDivide(a4, b6) {
  var denominator = b6[0] * b6[0] + b6[1] * b6[1];
  return [
    (a4[0] * b6[0] + a4[1] * b6[1]) / denominator,
    (a4[1] * b6[0] - a4[0] * b6[1]) / denominator
  ];
}
guyouRaw.invert = function(x9, y9) {
  var k_ = (sqrt22 - 1) / (sqrt22 + 1), k3 = sqrt5(1 - k_ * k_), K4 = ellipticF(halfPi3, k3 * k3), f = -1, j = ellipticJi(0.5 * K4 - y9, -x9, k3 * k3), tn = guyouComplexDivide(j[0], j[1]), lambda = atan23(tn[1], tn[0]) / f;
  return [
    lambda,
    2 * atan3(exp5(0.5 / f * log6(k_ * tn[0] * tn[0] + k_ * tn[1] * tn[1]))) - halfPi3
  ];
};

// node_modules/d3-geo-projection/src/healpix.js
var K2 = 3;
var healpixParallel = asin3(1 - 1 / K2) * degrees4;
var healpixLambert = cylindricalEqualAreaRaw2(0);

// node_modules/d3-geo-projection/src/sinuMollweide.js
var sinuMollweidePhi = 0.7109889596207567;
var sinuMollweideY = 0.0528035274542;
function sinuMollweideRaw(lambda, phi2) {
  return phi2 > -sinuMollweidePhi ? (lambda = mollweideRaw(lambda, phi2), lambda[1] += sinuMollweideY, lambda) : sinusoidalRaw(lambda, phi2);
}
sinuMollweideRaw.invert = function(x9, y9) {
  return y9 > -sinuMollweidePhi ? mollweideRaw.invert(x9, y9 - sinuMollweideY) : sinusoidalRaw.invert(x9, y9);
};

// node_modules/d3-geo-projection/src/homolosine.js
function homolosineRaw(lambda, phi2) {
  return abs3(phi2) > sinuMollweidePhi ? (lambda = mollweideRaw(lambda, phi2), lambda[1] -= phi2 > 0 ? sinuMollweideY : -sinuMollweideY, lambda) : sinusoidalRaw(lambda, phi2);
}
homolosineRaw.invert = function(x9, y9) {
  return abs3(y9) > sinuMollweidePhi ? mollweideRaw.invert(x9, y9 + (y9 > 0 ? sinuMollweideY : -sinuMollweideY)) : sinusoidalRaw.invert(x9, y9);
};

// node_modules/d3-geo-projection/src/kavrayskiy7.js
function kavrayskiy7Raw(lambda, phi2) {
  return [3 / tau4 * lambda * sqrt5(pi4 * pi4 / 3 - phi2 * phi2), phi2];
}
kavrayskiy7Raw.invert = function(x9, y9) {
  return [tau4 / 3 * x9 / sqrt5(pi4 * pi4 / 3 - y9 * y9), y9];
};

// node_modules/d3-geo-projection/src/larrivee.js
var pi_sqrt2 = pi4 / sqrt22;
function larriveeRaw(lambda, phi2) {
  return [
    lambda * (1 + sqrt5(cos3(phi2))) / 2,
    phi2 / (cos3(phi2 / 2) * cos3(lambda / 6))
  ];
}
larriveeRaw.invert = function(x9, y9) {
  var x07 = abs3(x9), y07 = abs3(y9), lambda = epsilon5, phi2 = halfPi3;
  if (y07 < pi_sqrt2)
    phi2 *= y07 / pi_sqrt2;
  else
    lambda += 6 * acos3(pi_sqrt2 / y07);
  for (var i = 0; i < 25; i++) {
    var sinPhi = sin3(phi2), sqrtcosPhi = sqrt5(cos3(phi2)), sinPhi_2 = sin3(phi2 / 2), cosPhi_2 = cos3(phi2 / 2), sinLambda_6 = sin3(lambda / 6), cosLambda_6 = cos3(lambda / 6), f0 = 0.5 * lambda * (1 + sqrtcosPhi) - x07, f1 = phi2 / (cosPhi_2 * cosLambda_6) - y07, df0dPhi = sqrtcosPhi ? -0.25 * lambda * sinPhi / sqrtcosPhi : 0, df0dLambda = 0.5 * (1 + sqrtcosPhi), df1dPhi = (1 + 0.5 * phi2 * sinPhi_2 / cosPhi_2) / (cosPhi_2 * cosLambda_6), df1dLambda = phi2 / cosPhi_2 * (sinLambda_6 / 6) / (cosLambda_6 * cosLambda_6), denom = df0dPhi * df1dLambda - df1dPhi * df0dLambda, dPhi = (f0 * df1dLambda - f1 * df0dLambda) / denom, dLambda = (f1 * df0dPhi - f0 * df1dPhi) / denom;
    phi2 -= dPhi;
    lambda -= dLambda;
    if (abs3(dPhi) < epsilon5 && abs3(dLambda) < epsilon5)
      break;
  }
  return [x9 < 0 ? -lambda : lambda, y9 < 0 ? -phi2 : phi2];
};

// node_modules/d3-geo-projection/src/laskowski.js
function laskowskiRaw(lambda, phi2) {
  var lambda22 = lambda * lambda, phi22 = phi2 * phi2;
  return [
    lambda * (0.975534 + phi22 * (-0.119161 + lambda22 * -0.0143059 + phi22 * -0.0547009)),
    phi2 * (1.00384 + lambda22 * (0.0802894 + phi22 * -0.02855 + lambda22 * 199025e-9) + phi22 * (0.0998909 + phi22 * -0.0491032))
  ];
}
laskowskiRaw.invert = function(x9, y9) {
  var lambda = sign3(x9) * pi4, phi2 = y9 / 2, i = 50;
  do {
    var lambda22 = lambda * lambda, phi22 = phi2 * phi2, lambdaPhi = lambda * phi2, fx = lambda * (0.975534 + phi22 * (-0.119161 + lambda22 * -0.0143059 + phi22 * -0.0547009)) - x9, fy = phi2 * (1.00384 + lambda22 * (0.0802894 + phi22 * -0.02855 + lambda22 * 199025e-9) + phi22 * (0.0998909 + phi22 * -0.0491032)) - y9, deltaxDeltaLambda = 0.975534 - phi22 * (0.119161 + 3 * lambda22 * 0.0143059 + phi22 * 0.0547009), deltaxDeltaPhi = -lambdaPhi * (2 * 0.119161 + 4 * 0.0547009 * phi22 + 2 * 0.0143059 * lambda22), deltayDeltaLambda = lambdaPhi * (2 * 0.0802894 + 4 * 199025e-9 * lambda22 + 2 * -0.02855 * phi22), deltayDeltaPhi = 1.00384 + lambda22 * (0.0802894 + 199025e-9 * lambda22) + phi22 * (3 * (0.0998909 - 0.02855 * lambda22) - 5 * 0.0491032 * phi22), denominator = deltaxDeltaPhi * deltayDeltaLambda - deltayDeltaPhi * deltaxDeltaLambda, deltaLambda = (fy * deltaxDeltaPhi - fx * deltayDeltaPhi) / denominator, deltaPhi = (fx * deltayDeltaLambda - fy * deltaxDeltaLambda) / denominator;
    lambda -= deltaLambda, phi2 -= deltaPhi;
  } while ((abs3(deltaLambda) > epsilon5 || abs3(deltaPhi) > epsilon5) && --i > 0);
  return i && [lambda, phi2];
};

// node_modules/d3-geo-projection/src/littrow.js
function littrowRaw(lambda, phi2) {
  return [
    sin3(lambda) / cos3(phi2),
    tan2(phi2) * cos3(lambda)
  ];
}
littrowRaw.invert = function(x9, y9) {
  var x22 = x9 * x9, y22 = y9 * y9, y2_1 = y22 + 1, x2_y2_1 = x22 + y2_1, cosPhi = x9 ? sqrt1_2 * sqrt5((x2_y2_1 - sqrt5(x2_y2_1 * x2_y2_1 - 4 * x22)) / x22) : 1 / sqrt5(y2_1);
  return [
    asin3(x9 * cosPhi),
    sign3(y9) * acos3(cosPhi)
  ];
};

// node_modules/d3-geo-projection/src/miller.js
function millerRaw(lambda, phi2) {
  return [lambda, 1.25 * log6(tan2(quarterPi2 + 0.4 * phi2))];
}
millerRaw.invert = function(x9, y9) {
  return [x9, 2.5 * atan3(exp5(0.8 * y9)) - 0.625 * pi4];
};

// node_modules/d3-geo-projection/src/mtFlatPolarParabolic.js
var sqrt6 = sqrt5(6);
var sqrt7 = sqrt5(7);
function mtFlatPolarParabolicRaw(lambda, phi2) {
  var theta = asin3(7 * sin3(phi2) / (3 * sqrt6));
  return [
    sqrt6 * lambda * (2 * cos3(2 * theta / 3) - 1) / sqrt7,
    9 * sin3(theta / 3) / sqrt7
  ];
}
mtFlatPolarParabolicRaw.invert = function(x9, y9) {
  var theta = 3 * asin3(y9 * sqrt7 / 9);
  return [
    x9 * sqrt7 / (sqrt6 * (2 * cos3(2 * theta / 3) - 1)),
    asin3(sin3(theta) * 3 * sqrt6 / 7)
  ];
};

// node_modules/d3-geo-projection/src/mtFlatPolarQuartic.js
function mtFlatPolarQuarticRaw(lambda, phi2) {
  var k3 = (1 + sqrt1_2) * sin3(phi2), theta = phi2;
  for (var i = 0, delta; i < 25; i++) {
    theta -= delta = (sin3(theta / 2) + sin3(theta) - k3) / (0.5 * cos3(theta / 2) + cos3(theta));
    if (abs3(delta) < epsilon5)
      break;
  }
  return [
    lambda * (1 + 2 * cos3(theta) / cos3(theta / 2)) / (3 * sqrt22),
    2 * sqrt5(3) * sin3(theta / 2) / sqrt5(2 + sqrt22)
  ];
}
mtFlatPolarQuarticRaw.invert = function(x9, y9) {
  var sinTheta_2 = y9 * sqrt5(2 + sqrt22) / (2 * sqrt5(3)), theta = 2 * asin3(sinTheta_2);
  return [
    3 * sqrt22 * x9 / (1 + 2 * cos3(theta) / cos3(theta / 2)),
    asin3((sinTheta_2 + sin3(theta)) / (1 + sqrt1_2))
  ];
};

// node_modules/d3-geo-projection/src/mtFlatPolarSinusoidal.js
function mtFlatPolarSinusoidalRaw(lambda, phi2) {
  var A6 = sqrt5(6 / (4 + pi4)), k3 = (1 + pi4 / 4) * sin3(phi2), theta = phi2 / 2;
  for (var i = 0, delta; i < 25; i++) {
    theta -= delta = (theta / 2 + sin3(theta) - k3) / (0.5 + cos3(theta));
    if (abs3(delta) < epsilon5)
      break;
  }
  return [
    A6 * (0.5 + cos3(theta)) * lambda / 1.5,
    A6 * theta
  ];
}
mtFlatPolarSinusoidalRaw.invert = function(x9, y9) {
  var A6 = sqrt5(6 / (4 + pi4)), theta = y9 / A6;
  if (abs3(abs3(theta) - halfPi3) < epsilon5)
    theta = theta < 0 ? -halfPi3 : halfPi3;
  return [
    1.5 * x9 / (A6 * (0.5 + cos3(theta))),
    asin3((theta / 2 + sin3(theta)) / (1 + pi4 / 4))
  ];
};

// node_modules/d3-geo-projection/src/naturalEarth2.js
function naturalEarth2Raw(lambda, phi2) {
  var phi22 = phi2 * phi2, phi4 = phi22 * phi22, phi6 = phi22 * phi4;
  return [
    lambda * (0.84719 - 0.13063 * phi22 + phi6 * phi6 * (-0.04515 + 0.05494 * phi22 - 0.02326 * phi4 + 331e-5 * phi6)),
    phi2 * (1.01183 + phi4 * phi4 * (-0.02625 + 0.01926 * phi22 - 396e-5 * phi4))
  ];
}
naturalEarth2Raw.invert = function(x9, y9) {
  var phi2 = y9, i = 25, delta, phi22, phi4, phi6;
  do {
    phi22 = phi2 * phi2;
    phi4 = phi22 * phi22;
    phi2 -= delta = (phi2 * (1.01183 + phi4 * phi4 * (-0.02625 + 0.01926 * phi22 - 396e-5 * phi4)) - y9) / (1.01183 + phi4 * phi4 * (9 * -0.02625 + 11 * 0.01926 * phi22 + 13 * -396e-5 * phi4));
  } while (abs3(delta) > epsilon24 && --i > 0);
  phi22 = phi2 * phi2;
  phi4 = phi22 * phi22;
  phi6 = phi22 * phi4;
  return [
    x9 / (0.84719 - 0.13063 * phi22 + phi6 * phi6 * (-0.04515 + 0.05494 * phi22 - 0.02326 * phi4 + 331e-5 * phi6)),
    phi2
  ];
};

// node_modules/d3-geo-projection/src/nellHammer.js
function nellHammerRaw(lambda, phi2) {
  return [
    lambda * (1 + cos3(phi2)) / 2,
    2 * (phi2 - tan2(phi2 / 2))
  ];
}
nellHammerRaw.invert = function(x9, y9) {
  var p = y9 / 2;
  for (var i = 0, delta = Infinity; i < 10 && abs3(delta) > epsilon5; ++i) {
    var c5 = cos3(y9 / 2);
    y9 -= delta = (y9 - tan2(y9 / 2) - p) / (1 - 0.5 / (c5 * c5));
  }
  return [
    2 * x9 / (1 + cos3(y9)),
    y9
  ];
};

// node_modules/d3-geo-projection/src/nicolosi.js
function nicolosiRaw(lambda, phi2) {
  var sinPhi = sin3(phi2), q = cos3(phi2), s2 = sign3(lambda);
  if (lambda === 0 || abs3(phi2) === halfPi3)
    return [0, phi2];
  else if (phi2 === 0)
    return [lambda, 0];
  else if (abs3(lambda) === halfPi3)
    return [lambda * q, halfPi3 * sinPhi];
  var b6 = pi4 / (2 * lambda) - 2 * lambda / pi4, c5 = 2 * phi2 / pi4, d = (1 - c5 * c5) / (sinPhi - c5);
  var b22 = b6 * b6, d2 = d * d, b2d2 = 1 + b22 / d2, d2b2 = 1 + d2 / b22;
  var M2 = (b6 * sinPhi / d - b6 / 2) / b2d2, N = (d2 * sinPhi / b22 + d / 2) / d2b2, m3 = M2 * M2 + q * q / b2d2, n = N * N - (d2 * sinPhi * sinPhi / b22 + d * sinPhi - 1) / d2b2;
  return [
    halfPi3 * (M2 + sqrt5(m3) * s2),
    halfPi3 * (N + sqrt5(n < 0 ? 0 : n) * sign3(-phi2 * b6) * s2)
  ];
}
nicolosiRaw.invert = function(x9, y9) {
  x9 /= halfPi3;
  y9 /= halfPi3;
  var x22 = x9 * x9, y22 = y9 * y9, x2y2 = x22 + y22, pi22 = pi4 * pi4;
  return [
    x9 ? (x2y2 - 1 + sqrt5((1 - x2y2) * (1 - x2y2) + 4 * x22)) / (2 * x9) * halfPi3 : 0,
    solve(function(phi2) {
      return x2y2 * (pi4 * sin3(phi2) - 2 * phi2) * pi4 + 4 * phi2 * phi2 * (y9 - sin3(phi2)) + 2 * pi4 * phi2 - pi22 * y9;
    }, 0)
  ];
};

// node_modules/d3-geo-projection/src/patterson.js
var pattersonK1 = 1.0148;
var pattersonK2 = 0.23185;
var pattersonK3 = -0.14499;
var pattersonK4 = 0.02406;
var pattersonC1 = pattersonK1;
var pattersonC2 = 5 * pattersonK2;
var pattersonC3 = 7 * pattersonK3;
var pattersonC4 = 9 * pattersonK4;
var pattersonYmax = 1.790857183;
function pattersonRaw(lambda, phi2) {
  var phi22 = phi2 * phi2;
  return [
    lambda,
    phi2 * (pattersonK1 + phi22 * phi22 * (pattersonK2 + phi22 * (pattersonK3 + pattersonK4 * phi22)))
  ];
}
pattersonRaw.invert = function(x9, y9) {
  if (y9 > pattersonYmax)
    y9 = pattersonYmax;
  else if (y9 < -pattersonYmax)
    y9 = -pattersonYmax;
  var yc = y9, delta;
  do {
    var y22 = yc * yc;
    yc -= delta = (yc * (pattersonK1 + y22 * y22 * (pattersonK2 + y22 * (pattersonK3 + pattersonK4 * y22))) - y9) / (pattersonC1 + y22 * y22 * (pattersonC2 + y22 * (pattersonC3 + pattersonC4 * y22)));
  } while (abs3(delta) > epsilon5);
  return [x9, yc];
};

// node_modules/d3-geo-projection/src/polyconic.js
function polyconicRaw(lambda, phi2) {
  if (abs3(phi2) < epsilon5)
    return [lambda, 0];
  var tanPhi = tan2(phi2), k3 = lambda * sin3(phi2);
  return [
    sin3(k3) / tanPhi,
    phi2 + (1 - cos3(k3)) / tanPhi
  ];
}
polyconicRaw.invert = function(x9, y9) {
  if (abs3(y9) < epsilon5)
    return [x9, 0];
  var k3 = x9 * x9 + y9 * y9, phi2 = y9 * 0.5, i = 10, delta;
  do {
    var tanPhi = tan2(phi2), secPhi = 1 / cos3(phi2), j = k3 - 2 * y9 * phi2 + phi2 * phi2;
    phi2 -= delta = (tanPhi * j + 2 * (phi2 - y9)) / (2 + j * secPhi * secPhi + 2 * (phi2 - y9) * tanPhi);
  } while (abs3(delta) > epsilon5 && --i > 0);
  tanPhi = tan2(phi2);
  return [
    (abs3(y9) < abs3(phi2 + 1 / tanPhi) ? asin3(x9 * tanPhi) : sign3(y9) * sign3(x9) * (acos3(abs3(x9 * tanPhi)) + halfPi3)) / sin3(phi2),
    phi2
  ];
};

// node_modules/d3-geo-projection/src/polyhedral/octahedron.js
var octahedron = [
  [0, 90],
  [-90, 0],
  [0, 0],
  [90, 0],
  [180, 0],
  [0, -90]
];
var octahedron_default = [
  [0, 2, 1],
  [0, 3, 2],
  [5, 1, 2],
  [5, 2, 3],
  [0, 1, 4],
  [0, 4, 3],
  [5, 4, 1],
  [5, 3, 4]
].map(function(face) {
  return face.map(function(i) {
    return octahedron[i];
  });
});

// node_modules/d3-geo-projection/src/polyhedral/collignon.js
var kx2 = 2 / sqrt5(3);
function collignonK(a4, b6) {
  var p = collignonRaw(a4, b6);
  return [p[0] * kx2, p[1]];
}
collignonK.invert = function(x9, y9) {
  return collignonRaw.invert(x9 / kx2, y9);
};

// node_modules/d3-geo-projection/src/robinson.js
var K3 = [
  [0.9986, -0.062],
  [1, 0],
  [0.9986, 0.062],
  [0.9954, 0.124],
  [0.99, 0.186],
  [0.9822, 0.248],
  [0.973, 0.31],
  [0.96, 0.372],
  [0.9427, 0.434],
  [0.9216, 0.4958],
  [0.8962, 0.5571],
  [0.8679, 0.6176],
  [0.835, 0.6769],
  [0.7986, 0.7346],
  [0.7597, 0.7903],
  [0.7186, 0.8435],
  [0.6732, 0.8936],
  [0.6213, 0.9394],
  [0.5722, 0.9761],
  [0.5322, 1]
];
K3.forEach(function(d) {
  d[1] *= 1.593415793900743;
});
function robinsonRaw(lambda, phi2) {
  var i = min4(18, abs3(phi2) * 36 / pi4), i0 = floor2(i), di = i - i0, ax = (k3 = K3[i0])[0], ay = k3[1], bx = (k3 = K3[++i0])[0], by = k3[1], cx = (k3 = K3[min4(19, ++i0)])[0], cy = k3[1], k3;
  return [
    lambda * (bx + di * (cx - ax) / 2 + di * di * (cx - 2 * bx + ax) / 2),
    sign3(phi2) * (by + di * (cy - ay) / 2 + di * di * (cy - 2 * by + ay) / 2)
  ];
}
robinsonRaw.invert = function(x9, y9) {
  var phi2 = y9 * 90, i = min4(18, abs3(phi2 / 5)), i0 = max4(0, floor2(i));
  do {
    var ay = K3[i0][1], by = K3[i0 + 1][1], cy = K3[min4(19, i0 + 2)][1], u4 = cy - ay, v2 = cy - 2 * by + ay, t = 2 * (abs3(y9) - by) / u4, c5 = v2 / u4, di = t * (1 - c5 * t * (1 - 2 * c5 * t));
    if (di >= 0 || i0 === 1) {
      phi2 = (y9 >= 0 ? 5 : -5) * (di + i);
      var j = 50, delta;
      do {
        i = min4(18, abs3(phi2) / 5);
        i0 = floor2(i);
        di = i - i0;
        ay = K3[i0][1];
        by = K3[i0 + 1][1];
        cy = K3[min4(19, i0 + 2)][1];
        phi2 -= (delta = sign3(y9) * (by + di * (cy - ay) / 2 + di * di * (cy - 2 * by + ay) / 2) - y9) * degrees4;
      } while (abs3(delta) > epsilon24 && --j > 0);
      break;
    }
  } while (--i0 >= 0);
  var ax = K3[i0][0], bx = K3[i0 + 1][0], cx = K3[min4(19, i0 + 2)][0];
  return [
    x9 / (bx + di * (cx - ax) / 2 + di * di * (cx - 2 * bx + ax) / 2),
    phi2 * radians3
  ];
};

// node_modules/d3-geo-projection/src/stitch.js
var epsilon6 = 1e-4;
var x06 = -180;
var x0e = x06 + epsilon6;
var x12 = 180;
var x1e = x12 - epsilon6;
var y06 = -90;
var y0e = y06 + epsilon6;
var y12 = 90;
var y1e = y12 - epsilon6;

// node_modules/d3-geo-projection/src/times.js
function timesRaw(lambda, phi2) {
  var t = tan2(phi2 / 2), s2 = sin3(quarterPi2 * t);
  return [
    lambda * (0.74482 - 0.34588 * s2 * s2),
    1.70711 * t
  ];
}
timesRaw.invert = function(x9, y9) {
  var t = y9 / 1.70711, s2 = sin3(quarterPi2 * t);
  return [
    x9 / (0.74482 - 0.34588 * s2 * s2),
    2 * atan3(t)
  ];
};

// node_modules/d3-geo-projection/src/vanDerGrinten.js
function vanDerGrintenRaw(lambda, phi2) {
  if (abs3(phi2) < epsilon5)
    return [lambda, 0];
  var sinTheta = abs3(phi2 / halfPi3), theta = asin3(sinTheta);
  if (abs3(lambda) < epsilon5 || abs3(abs3(phi2) - halfPi3) < epsilon5)
    return [0, sign3(phi2) * pi4 * tan2(theta / 2)];
  var cosTheta = cos3(theta), A6 = abs3(pi4 / lambda - lambda / pi4) / 2, A22 = A6 * A6, G = cosTheta / (sinTheta + cosTheta - 1), P = G * (2 / sinTheta - 1), P2 = P * P, P2_A2 = P2 + A22, G_P2 = G - P2, Q = A22 + G;
  return [
    sign3(lambda) * pi4 * (A6 * G_P2 + sqrt5(A22 * G_P2 * G_P2 - P2_A2 * (G * G - P2))) / P2_A2,
    sign3(phi2) * pi4 * (P * Q - A6 * sqrt5((A22 + 1) * P2_A2 - Q * Q)) / P2_A2
  ];
}
vanDerGrintenRaw.invert = function(x9, y9) {
  if (abs3(y9) < epsilon5)
    return [x9, 0];
  if (abs3(x9) < epsilon5)
    return [0, halfPi3 * sin3(2 * atan3(y9 / pi4))];
  var x22 = (x9 /= pi4) * x9, y22 = (y9 /= pi4) * y9, x2_y2 = x22 + y22, z = x2_y2 * x2_y2, c1 = -abs3(y9) * (1 + x2_y2), c22 = c1 - 2 * y22 + x22, c32 = -2 * c1 + 1 + 2 * y22 + z, d = y22 / c32 + (2 * c22 * c22 * c22 / (c32 * c32 * c32) - 9 * c1 * c22 / (c32 * c32)) / 27, a1 = (c1 - c22 * c22 / (3 * c32)) / c32, m1 = 2 * sqrt5(-a1 / 3), theta1 = acos3(3 * d / (a1 * m1)) / 3;
  return [
    pi4 * (x2_y2 - 1 + sqrt5(1 + 2 * (x22 - y22) + z)) / (2 * x9),
    sign3(y9) * pi4 * (-m1 * cos3(theta1 + pi4 / 3) - c22 / (3 * c32))
  ];
};

// node_modules/d3-geo-projection/src/vanDerGrinten2.js
function vanDerGrinten2Raw(lambda, phi2) {
  if (abs3(phi2) < epsilon5)
    return [lambda, 0];
  var sinTheta = abs3(phi2 / halfPi3), theta = asin3(sinTheta);
  if (abs3(lambda) < epsilon5 || abs3(abs3(phi2) - halfPi3) < epsilon5)
    return [0, sign3(phi2) * pi4 * tan2(theta / 2)];
  var cosTheta = cos3(theta), A6 = abs3(pi4 / lambda - lambda / pi4) / 2, A22 = A6 * A6, x13 = cosTheta * (sqrt5(1 + A22) - A6 * cosTheta) / (1 + A22 * sinTheta * sinTheta);
  return [
    sign3(lambda) * pi4 * x13,
    sign3(phi2) * pi4 * sqrt5(1 - x13 * (2 * A6 + x13))
  ];
}
vanDerGrinten2Raw.invert = function(x9, y9) {
  if (!x9)
    return [0, halfPi3 * sin3(2 * atan3(y9 / pi4))];
  var x13 = abs3(x9 / pi4), A6 = (1 - x13 * x13 - (y9 /= pi4) * y9) / (2 * x13), A22 = A6 * A6, B4 = sqrt5(A22 + 1);
  return [
    sign3(x9) * pi4 * (B4 - A6),
    sign3(y9) * halfPi3 * sin3(2 * atan23(sqrt5((1 - 2 * A6 * x13) * (A6 + B4) - x13), sqrt5(B4 + A6 + x13)))
  ];
};

// node_modules/d3-geo-projection/src/vanDerGrinten3.js
function vanDerGrinten3Raw(lambda, phi2) {
  if (abs3(phi2) < epsilon5)
    return [lambda, 0];
  var sinTheta = phi2 / halfPi3, theta = asin3(sinTheta);
  if (abs3(lambda) < epsilon5 || abs3(abs3(phi2) - halfPi3) < epsilon5)
    return [0, pi4 * tan2(theta / 2)];
  var A6 = (pi4 / lambda - lambda / pi4) / 2, y13 = sinTheta / (1 + cos3(theta));
  return [
    pi4 * (sign3(lambda) * sqrt5(A6 * A6 + 1 - y13 * y13) - A6),
    pi4 * y13
  ];
}
vanDerGrinten3Raw.invert = function(x9, y9) {
  if (!y9)
    return [x9, 0];
  var y13 = y9 / pi4, A6 = (pi4 * pi4 * (1 - y13 * y13) - x9 * x9) / (2 * pi4 * x9);
  return [
    x9 ? pi4 * (sign3(x9) * sqrt5(A6 * A6 + 1) - A6) : 0,
    halfPi3 * sin3(2 * atan3(y13))
  ];
};

// node_modules/d3-geo-projection/src/vanDerGrinten4.js
function vanDerGrinten4Raw(lambda, phi2) {
  if (!phi2)
    return [lambda, 0];
  var phi03 = abs3(phi2);
  if (!lambda || phi03 === halfPi3)
    return [0, phi2];
  var B4 = phi03 / halfPi3, B22 = B4 * B4, C7 = (8 * B4 - B22 * (B22 + 2) - 5) / (2 * B22 * (B4 - 1)), C23 = C7 * C7, BC = B4 * C7, B_C2 = B22 + C23 + 2 * BC, B_3C = B4 + 3 * C7, lambda03 = lambda / halfPi3, lambda12 = lambda03 + 1 / lambda03, D3 = sign3(abs3(lambda) - halfPi3) * sqrt5(lambda12 * lambda12 - 4), D22 = D3 * D3, F = B_C2 * (B22 + C23 * D22 - 1) + (1 - B22) * (B22 * (B_3C * B_3C + 4 * C23) + 12 * BC * C23 + 4 * C23 * C23), x13 = (D3 * (B_C2 + C23 - 1) + 2 * sqrt5(F)) / (4 * B_C2 + D22);
  return [
    sign3(lambda) * halfPi3 * x13,
    sign3(phi2) * halfPi3 * sqrt5(1 + D3 * abs3(x13) - x13 * x13)
  ];
}
vanDerGrinten4Raw.invert = function(x9, y9) {
  var delta;
  if (!x9 || !y9)
    return [x9, y9];
  var sy = sign3(y9);
  y9 = abs3(y9) / pi4;
  var x13 = sign3(x9) * x9 / halfPi3, D3 = (x13 * x13 - 1 + 4 * y9 * y9) / abs3(x13), D22 = D3 * D3, B4 = y9 * (2 - (y9 > 0.5 ? min4(y9, abs3(x9)) : 0)), r = x9 * x9 + y9 * y9, i = 50;
  do {
    var B22 = B4 * B4, C7 = (8 * B4 - B22 * (B22 + 2) - 5) / (2 * B22 * (B4 - 1)), C_ = (3 * B4 - B22 * B4 - 10) / (2 * B22 * B4), C23 = C7 * C7, BC = B4 * C7, B_C = B4 + C7, B_C2 = B_C * B_C, B_3C = B4 + 3 * C7, F = B_C2 * (B22 + C23 * D22 - 1) + (1 - B22) * (B22 * (B_3C * B_3C + 4 * C23) + C23 * (12 * BC + 4 * C23)), F_ = -2 * B_C * (4 * BC * C23 + (1 - 4 * B22 + 3 * B22 * B22) * (1 + C_) + C23 * (-6 + 14 * B22 - D22 + (-8 + 8 * B22 - 2 * D22) * C_) + BC * (-8 + 12 * B22 + (-10 + 10 * B22 - D22) * C_)), sqrtF = sqrt5(F), f = D3 * (B_C2 + C23 - 1) + 2 * sqrtF - x13 * (4 * B_C2 + D22), f_ = D3 * (2 * C7 * C_ + 2 * B_C * (1 + C_)) + F_ / sqrtF - 8 * B_C * (D3 * (-1 + C23 + B_C2) + 2 * sqrtF) * (1 + C_) / (D22 + 4 * B_C2);
    B4 -= delta = f / f_;
  } while (delta * r * r > epsilon5 && --i > 0);
  return [
    sign3(x9) * (sqrt5(D3 * D3 + 4) + D3) * pi4 / 4,
    sy * halfPi3 * B4
  ];
};

// node_modules/d3-geo-projection/src/wagner4.js
var A5 = 4 * pi4 + 3 * sqrt5(3);
var B2 = 2 * sqrt5(2 * pi4 * sqrt5(3) / A5);
var wagner4Raw = mollweideBromleyRaw(B2 * sqrt5(3) / pi4, B2, A5 / 6);

// node_modules/d3-geo-projection/src/wagner6.js
function wagner6Raw(lambda, phi2) {
  return [lambda * sqrt5(1 - 3 * phi2 * phi2 / (pi4 * pi4)), phi2];
}
wagner6Raw.invert = function(x9, y9) {
  return [x9 / sqrt5(1 - 3 * y9 * y9 / (pi4 * pi4)), y9];
};

// node_modules/d3-geo-projection/src/wiechel.js
function wiechelRaw(lambda, phi2) {
  var cosPhi = cos3(phi2), sinPhi = cos3(lambda) * cosPhi, sin1_Phi = 1 - sinPhi, cosLambda = cos3(lambda = atan23(sin3(lambda) * cosPhi, -sin3(phi2))), sinLambda = sin3(lambda);
  cosPhi = sqrt5(1 - sinPhi * sinPhi);
  return [
    sinLambda * cosPhi - cosLambda * sin1_Phi,
    -cosLambda * cosPhi - sinLambda * sin1_Phi
  ];
}
wiechelRaw.invert = function(x9, y9) {
  var w8 = (x9 * x9 + y9 * y9) / -2, k3 = sqrt5(-w8 * (2 + w8)), b6 = y9 * w8 + x9 * k3, a4 = x9 * w8 - y9 * k3, D3 = sqrt5(a4 * a4 + b6 * b6);
  return [
    atan23(k3 * b6, D3 * (1 + w8)),
    D3 ? -asin3(k3 * a4 / D3) : 0
  ];
};

// node_modules/d3-geo-projection/src/winkel3.js
function winkel3Raw(lambda, phi2) {
  var coordinates = aitoffRaw(lambda, phi2);
  return [
    (coordinates[0] + lambda / halfPi3) / 2,
    (coordinates[1] + phi2) / 2
  ];
}
winkel3Raw.invert = function(x9, y9) {
  var lambda = x9, phi2 = y9, i = 25;
  do {
    var cosphi = cos3(phi2), sinphi = sin3(phi2), sin_2phi = sin3(2 * phi2), sin2phi = sinphi * sinphi, cos2phi = cosphi * cosphi, sinlambda = sin3(lambda), coslambda_2 = cos3(lambda / 2), sinlambda_2 = sin3(lambda / 2), sin2lambda_2 = sinlambda_2 * sinlambda_2, C7 = 1 - cos2phi * coslambda_2 * coslambda_2, E2 = C7 ? acos3(cosphi * coslambda_2) * sqrt5(F = 1 / C7) : F = 0, F, fx = 0.5 * (2 * E2 * cosphi * sinlambda_2 + lambda / halfPi3) - x9, fy = 0.5 * (E2 * sinphi + phi2) - y9, dxdlambda = 0.5 * F * (cos2phi * sin2lambda_2 + E2 * cosphi * coslambda_2 * sin2phi) + 0.5 / halfPi3, dxdphi = F * (sinlambda * sin_2phi / 4 - E2 * sinphi * sinlambda_2), dydlambda = 0.125 * F * (sin_2phi * sinlambda_2 - E2 * sinphi * cos2phi * sinlambda), dydphi = 0.5 * F * (sin2phi * coslambda_2 + E2 * sin2lambda_2 * cosphi) + 0.5, denominator = dxdphi * dydlambda - dydphi * dxdlambda, dlambda = (fy * dxdphi - fx * dydphi) / denominator, dphi = (fx * dydlambda - fy * dxdlambda) / denominator;
    lambda -= dlambda, phi2 -= dphi;
  } while ((abs3(dlambda) > epsilon5 || abs3(dphi) > epsilon5) && --i > 0);
  return [lambda, phi2];
};

// node_modules/vega-projection/node_modules/vega-util/build/vega-util.js
function accessor7(fn, fields, name) {
  fn.fields = fields || [];
  fn.fname = name;
  return fn;
}
function getter7(path7) {
  return path7.length === 1 ? get17(path7[0]) : getN7(path7);
}
var get17 = (field25) => function(obj) {
  return obj[field25];
};
var getN7 = (path7) => {
  const len = path7.length;
  return function(obj) {
    for (let i = 0; i < len; ++i) {
      obj = obj[path7[i]];
    }
    return obj;
  };
};
function error7(message) {
  throw Error(message);
}
function splitAccessPath7(p) {
  const path7 = [], n = p.length;
  let q = null, b6 = 0, s2 = "", i, j, c5;
  p = p + "";
  function push() {
    path7.push(s2 + p.substring(i, j));
    s2 = "";
    i = j + 1;
  }
  for (i = j = 0; j < n; ++j) {
    c5 = p[j];
    if (c5 === "\\") {
      s2 += p.substring(i, j++);
      i = j;
    } else if (c5 === q) {
      push();
      q = null;
      b6 = -1;
    } else if (q) {
      continue;
    } else if (i === b6 && c5 === '"') {
      i = j + 1;
      q = c5;
    } else if (i === b6 && c5 === "'") {
      i = j + 1;
      q = c5;
    } else if (c5 === "." && !b6) {
      if (j > i) {
        push();
      } else {
        i = j + 1;
      }
    } else if (c5 === "[") {
      if (j > i)
        push();
      b6 = i = j + 1;
    } else if (c5 === "]") {
      if (!b6)
        error7("Access path missing open bracket: " + p);
      if (b6 > 0)
        push();
      b6 = 0;
      i = j + 1;
    }
  }
  if (b6)
    error7("Access path missing closing bracket: " + p);
  if (q)
    error7("Access path missing closing quote: " + p);
  if (j > i) {
    j++;
    push();
  }
  return path7;
}
function field7(field25, name, opt) {
  const path7 = splitAccessPath7(field25);
  field25 = path7.length === 1 ? path7[0] : field25;
  return accessor7((opt && opt.get || getter7)(path7), [field25], name || field25);
}
var id7 = field7("id");
var identity11 = accessor7((_) => _, [], "identity");
var zero9 = accessor7(() => 0, [], "zero");
var one8 = accessor7(() => 1, [], "one");
var truthy7 = accessor7(() => true, [], "true");
var falsy7 = accessor7(() => false, [], "false");
var DisallowedObjectProperties7 = /* @__PURE__ */ new Set([...Object.getOwnPropertyNames(Object.prototype).filter((name) => typeof Object.prototype[name] === "function"), "__proto__"]);
var isArray7 = Array.isArray;
function peek6(array22) {
  return array22[array22.length - 1];
}
function toNumber6(_) {
  return _ == null || _ === "" ? null : +_;
}
function array8(_) {
  return _ != null ? isArray7(_) ? _ : [_] : [];
}
function toSet7(_) {
  const s2 = {}, n = _.length;
  for (let i = 0; i < n; ++i)
    s2[_[i]] = true;
  return s2;
}

// node_modules/vega-projection/node_modules/vega-time/build/vega-time.js
var YEAR5 = "year";
var QUARTER5 = "quarter";
var MONTH5 = "month";
var WEEK5 = "week";
var DATE5 = "date";
var DAY5 = "day";
var DAYOFYEAR5 = "dayofyear";
var HOURS5 = "hours";
var MINUTES5 = "minutes";
var SECONDS5 = "seconds";
var MILLISECONDS5 = "milliseconds";
var TIME_UNITS5 = [YEAR5, QUARTER5, MONTH5, WEEK5, DATE5, DAY5, DAYOFYEAR5, HOURS5, MINUTES5, SECONDS5, MILLISECONDS5];
var UNITS5 = TIME_UNITS5.reduce((o, u4, i) => (o[u4] = 1 + i, o), {});
var defaultSpecifiers5 = {
  [YEAR5]: "%Y ",
  [QUARTER5]: "Q%q ",
  [MONTH5]: "%b ",
  [DATE5]: "%d ",
  [WEEK5]: "W%U ",
  [DAY5]: "%a ",
  [DAYOFYEAR5]: "%j ",
  [HOURS5]: "%H:00",
  [MINUTES5]: "00:%M",
  [SECONDS5]: ":%S",
  [MILLISECONDS5]: ".%L",
  [`${YEAR5}-${MONTH5}`]: "%Y-%m ",
  [`${YEAR5}-${MONTH5}-${DATE5}`]: "%Y-%m-%d ",
  [`${HOURS5}-${MINUTES5}`]: "%H:%M"
};
var t07 = /* @__PURE__ */ new Date();
function localYear5(y9) {
  t07.setFullYear(y9);
  t07.setMonth(0);
  t07.setDate(1);
  t07.setHours(0, 0, 0, 0);
  return t07;
}
function localDayOfYear5(d) {
  return timeDay.count(localYear5(d.getFullYear()) - 1, d);
}
function localWeekNum5(d) {
  return timeSunday.count(localYear5(d.getFullYear()) - 1, d);
}
function localFirst5(y9) {
  return localYear5(y9).getDay();
}
function utcDayOfYear5(d) {
  const y9 = Date.UTC(d.getUTCFullYear(), 0, 1);
  return utcDay.count(y9 - 1, d);
}
function utcWeekNum5(d) {
  const y9 = Date.UTC(d.getUTCFullYear(), 0, 1);
  return utcSunday.count(y9 - 1, d);
}
function utcFirst5(y9) {
  t07.setTime(Date.UTC(y9, 0, 1));
  return t07.getUTCDay();
}
function weekday5(week3, day, firstDay) {
  return day + week3 * 7 - (firstDay + 6) % 7;
}
var localGet5 = {
  [YEAR5]: (d) => d.getFullYear(),
  [QUARTER5]: (d) => Math.floor(d.getMonth() / 3),
  [MONTH5]: (d) => d.getMonth(),
  [DATE5]: (d) => d.getDate(),
  [HOURS5]: (d) => d.getHours(),
  [MINUTES5]: (d) => d.getMinutes(),
  [SECONDS5]: (d) => d.getSeconds(),
  [MILLISECONDS5]: (d) => d.getMilliseconds(),
  [DAYOFYEAR5]: (d) => localDayOfYear5(d),
  [WEEK5]: (d) => localWeekNum5(d),
  [WEEK5 + DAY5]: (d, y9) => weekday5(localWeekNum5(d), d.getDay(), localFirst5(y9)),
  [DAY5]: (d, y9) => weekday5(1, d.getDay(), localFirst5(y9))
};
var localInv5 = {
  [QUARTER5]: (q) => 3 * q,
  [WEEK5]: (w8, y9) => weekday5(w8, 0, localFirst5(y9))
};
var utcGet5 = {
  [YEAR5]: (d) => d.getUTCFullYear(),
  [QUARTER5]: (d) => Math.floor(d.getUTCMonth() / 3),
  [MONTH5]: (d) => d.getUTCMonth(),
  [DATE5]: (d) => d.getUTCDate(),
  [HOURS5]: (d) => d.getUTCHours(),
  [MINUTES5]: (d) => d.getUTCMinutes(),
  [SECONDS5]: (d) => d.getUTCSeconds(),
  [MILLISECONDS5]: (d) => d.getUTCMilliseconds(),
  [DAYOFYEAR5]: (d) => utcDayOfYear5(d),
  [WEEK5]: (d) => utcWeekNum5(d),
  [DAY5]: (d, y9) => weekday5(1, d.getUTCDay(), utcFirst5(y9)),
  [WEEK5 + DAY5]: (d, y9) => weekday5(utcWeekNum5(d), d.getUTCDay(), utcFirst5(y9))
};
var utcInv5 = {
  [QUARTER5]: (q) => 3 * q,
  [WEEK5]: (w8, y9) => weekday5(w8, 0, utcFirst5(y9))
};
var timeIntervals5 = {
  [YEAR5]: timeYear,
  [QUARTER5]: timeMonth.every(3),
  [MONTH5]: timeMonth,
  [WEEK5]: timeSunday,
  [DATE5]: timeDay,
  [DAY5]: timeDay,
  [DAYOFYEAR5]: timeDay,
  [HOURS5]: timeHour,
  [MINUTES5]: timeMinute,
  [SECONDS5]: second,
  [MILLISECONDS5]: millisecond
};
var utcIntervals5 = {
  [YEAR5]: utcYear,
  [QUARTER5]: utcMonth.every(3),
  [MONTH5]: utcMonth,
  [WEEK5]: utcSunday,
  [DATE5]: utcDay,
  [DAY5]: utcDay,
  [DAYOFYEAR5]: utcDay,
  [HOURS5]: utcHour,
  [MINUTES5]: utcMinute,
  [SECONDS5]: second,
  [MILLISECONDS5]: millisecond
};
var durationSecond6 = 1e3;
var durationMinute6 = durationSecond6 * 60;
var durationHour6 = durationMinute6 * 60;
var durationDay6 = durationHour6 * 24;
var durationWeek6 = durationDay6 * 7;
var durationMonth6 = durationDay6 * 30;
var durationYear6 = durationDay6 * 365;
var Milli5 = [YEAR5, MONTH5, DATE5, HOURS5, MINUTES5, SECONDS5, MILLISECONDS5];
var Seconds5 = Milli5.slice(0, -1);
var Minutes5 = Seconds5.slice(0, -1);
var Hours5 = Minutes5.slice(0, -1);
var Day5 = Hours5.slice(0, -1);
var Week5 = [YEAR5, WEEK5];
var Month5 = [YEAR5, MONTH5];
var Year5 = [YEAR5];
var intervals5 = [[Seconds5, 1, durationSecond6], [Seconds5, 5, 5 * durationSecond6], [Seconds5, 15, 15 * durationSecond6], [Seconds5, 30, 30 * durationSecond6], [Minutes5, 1, durationMinute6], [Minutes5, 5, 5 * durationMinute6], [Minutes5, 15, 15 * durationMinute6], [Minutes5, 30, 30 * durationMinute6], [Hours5, 1, durationHour6], [Hours5, 3, 3 * durationHour6], [Hours5, 6, 6 * durationHour6], [Hours5, 12, 12 * durationHour6], [Day5, 1, durationDay6], [Week5, 1, durationWeek6], [Month5, 1, durationMonth6], [Month5, 3, 3 * durationMonth6], [Year5, 1, durationYear6]];

// node_modules/vega-projection/node_modules/vega-scale/build/vega-scale.js
function bandSpace3(count3, paddingInner2, paddingOuter2) {
  const space = count3 - paddingInner2 + paddingOuter2 * 2;
  return count3 ? space > 0 ? space : 1 : 0;
}
var Identity3 = "identity";
var Linear4 = "linear";
var Log3 = "log";
var Pow3 = "pow";
var Sqrt3 = "sqrt";
var Symlog3 = "symlog";
var Time3 = "time";
var UTC3 = "utc";
var Sequential3 = "sequential";
var Diverging3 = "diverging";
var Quantile4 = "quantile";
var Quantize3 = "quantize";
var Threshold3 = "threshold";
var Ordinal3 = "ordinal";
var Point3 = "point";
var Band3 = "band";
var BinOrdinal3 = "bin-ordinal";
var Continuous3 = "continuous";
var Discrete3 = "discrete";
var Discretizing3 = "discretizing";
var Interpolating3 = "interpolating";
var Temporal3 = "temporal";
function invertRange3(scale19) {
  return function(_) {
    let lo = _[0], hi = _[1], t;
    if (hi < lo) {
      t = lo;
      lo = hi;
      hi = t;
    }
    return [scale19.invert(lo), scale19.invert(hi)];
  };
}
function invertRangeExtent3(scale19) {
  return function(_) {
    const range7 = scale19.range();
    let lo = _[0], hi = _[1], min5 = -1, max5, t, i, n;
    if (hi < lo) {
      t = lo;
      lo = hi;
      hi = t;
    }
    for (i = 0, n = range7.length; i < n; ++i) {
      if (range7[i] >= lo && range7[i] <= hi) {
        if (min5 < 0)
          min5 = i;
        max5 = i;
      }
    }
    if (min5 < 0)
      return void 0;
    lo = scale19.invertExtent(range7[min5]);
    hi = scale19.invertExtent(range7[max5]);
    return [lo[0] === void 0 ? lo[1] : lo[0], hi[1] === void 0 ? hi[0] : hi[1]];
  };
}
function band4() {
  const scale19 = ordinal().unknown(void 0), domain3 = scale19.domain, ordinalRange = scale19.range;
  let range$1 = [0, 1], step, bandwidth2, round2 = false, paddingInner2 = 0, paddingOuter2 = 0, align2 = 0.5;
  delete scale19.unknown;
  function rescale() {
    const n = domain3().length, reverse4 = range$1[1] < range$1[0], stop2 = range$1[1 - reverse4], space = bandSpace3(n, paddingInner2, paddingOuter2);
    let start = range$1[reverse4 - 0];
    step = (stop2 - start) / (space || 1);
    if (round2) {
      step = Math.floor(step);
    }
    start += (stop2 - start - step * (n - paddingInner2)) * align2;
    bandwidth2 = step * (1 - paddingInner2);
    if (round2) {
      start = Math.round(start);
      bandwidth2 = Math.round(bandwidth2);
    }
    const values7 = range(n).map((i) => start + step * i);
    return ordinalRange(reverse4 ? values7.reverse() : values7);
  }
  scale19.domain = function(_) {
    if (arguments.length) {
      domain3(_);
      return rescale();
    } else {
      return domain3();
    }
  };
  scale19.range = function(_) {
    if (arguments.length) {
      range$1 = [+_[0], +_[1]];
      return rescale();
    } else {
      return range$1.slice();
    }
  };
  scale19.rangeRound = function(_) {
    range$1 = [+_[0], +_[1]];
    round2 = true;
    return rescale();
  };
  scale19.bandwidth = function() {
    return bandwidth2;
  };
  scale19.step = function() {
    return step;
  };
  scale19.round = function(_) {
    if (arguments.length) {
      round2 = !!_;
      return rescale();
    } else {
      return round2;
    }
  };
  scale19.padding = function(_) {
    if (arguments.length) {
      paddingOuter2 = Math.max(0, Math.min(1, _));
      paddingInner2 = paddingOuter2;
      return rescale();
    } else {
      return paddingInner2;
    }
  };
  scale19.paddingInner = function(_) {
    if (arguments.length) {
      paddingInner2 = Math.max(0, Math.min(1, _));
      return rescale();
    } else {
      return paddingInner2;
    }
  };
  scale19.paddingOuter = function(_) {
    if (arguments.length) {
      paddingOuter2 = Math.max(0, Math.min(1, _));
      return rescale();
    } else {
      return paddingOuter2;
    }
  };
  scale19.align = function(_) {
    if (arguments.length) {
      align2 = Math.max(0, Math.min(1, _));
      return rescale();
    } else {
      return align2;
    }
  };
  scale19.invertRange = function(_) {
    if (_[0] == null || _[1] == null)
      return;
    const reverse4 = range$1[1] < range$1[0], values7 = reverse4 ? ordinalRange().reverse() : ordinalRange(), n = values7.length - 1;
    let lo = +_[0], hi = +_[1], a4, b6, t;
    if (lo !== lo || hi !== hi)
      return;
    if (hi < lo) {
      t = lo;
      lo = hi;
      hi = t;
    }
    if (hi < values7[0] || lo > range$1[1 - reverse4])
      return;
    a4 = Math.max(0, bisectRight(values7, lo) - 1);
    b6 = lo === hi ? a4 : bisectRight(values7, hi) - 1;
    if (lo - values7[a4] > bandwidth2 + 1e-10)
      ++a4;
    if (reverse4) {
      t = a4;
      a4 = n - b6;
      b6 = n - t;
    }
    return a4 > b6 ? void 0 : domain3().slice(a4, b6 + 1);
  };
  scale19.invert = function(_) {
    const value7 = scale19.invertRange([_, _]);
    return value7 ? value7[0] : value7;
  };
  scale19.copy = function() {
    return band4().domain(domain3()).range(range$1).round(round2).paddingInner(paddingInner2).paddingOuter(paddingOuter2).align(align2);
  };
  return rescale();
}
function pointish3(scale19) {
  const copy4 = scale19.copy;
  scale19.padding = scale19.paddingOuter;
  delete scale19.paddingInner;
  scale19.copy = function() {
    return pointish3(copy4());
  };
  return scale19;
}
function point9() {
  return pointish3(band4().paddingInner(1));
}
var map6 = Array.prototype.map;
function numbers5(_) {
  return map6.call(_, toNumber6);
}
var slice5 = Array.prototype.slice;
function scaleBinOrdinal3() {
  let domain3 = [], range7 = [];
  function scale19(x9) {
    return x9 == null || x9 !== x9 ? void 0 : range7[(bisect_default2(domain3, x9) - 1) % range7.length];
  }
  scale19.domain = function(_) {
    if (arguments.length) {
      domain3 = numbers5(_);
      return scale19;
    } else {
      return domain3.slice();
    }
  };
  scale19.range = function(_) {
    if (arguments.length) {
      range7 = slice5.call(_);
      return scale19;
    } else {
      return range7.slice();
    }
  };
  scale19.tickFormat = function(count3, specifier) {
    return tickFormat(domain3[0], peek6(domain3), count3 == null ? 10 : count3, specifier);
  };
  scale19.copy = function() {
    return scaleBinOrdinal3().domain(scale19.domain()).range(scale19.range());
  };
  return scale19;
}
var scales3 = /* @__PURE__ */ new Map();
var VEGA_SCALE3 = Symbol("vega_scale");
function registerScale3(scale19) {
  scale19[VEGA_SCALE3] = true;
  return scale19;
}
function create3(type7, constructor, metadata6) {
  const ctr = function scale19() {
    const s2 = constructor();
    if (!s2.invertRange) {
      s2.invertRange = s2.invert ? invertRange3(s2) : s2.invertExtent ? invertRangeExtent3(s2) : void 0;
    }
    s2.type = type7;
    return registerScale3(s2);
  };
  ctr.metadata = toSet7(array8(metadata6));
  return ctr;
}
function scale4(type7, scale19, metadata6) {
  if (arguments.length > 1) {
    scales3.set(type7, create3(type7, scale19, metadata6));
    return this;
  } else {
    return isValidScaleType3(type7) ? scales3.get(type7) : void 0;
  }
}
scale4(Identity3, identity8);
scale4(Linear4, linear3, Continuous3);
scale4(Log3, log3, [Continuous3, Log3]);
scale4(Pow3, pow3, Continuous3);
scale4(Sqrt3, sqrt2, Continuous3);
scale4(Symlog3, symlog2, Continuous3);
scale4(Time3, time, [Continuous3, Temporal3]);
scale4(UTC3, utcTime, [Continuous3, Temporal3]);
scale4(Sequential3, sequential, [Continuous3, Interpolating3]);
scale4(`${Sequential3}-${Linear4}`, sequential, [Continuous3, Interpolating3]);
scale4(`${Sequential3}-${Log3}`, sequentialLog, [Continuous3, Interpolating3, Log3]);
scale4(`${Sequential3}-${Pow3}`, sequentialPow, [Continuous3, Interpolating3]);
scale4(`${Sequential3}-${Sqrt3}`, sequentialSqrt, [Continuous3, Interpolating3]);
scale4(`${Sequential3}-${Symlog3}`, sequentialSymlog, [Continuous3, Interpolating3]);
scale4(`${Diverging3}-${Linear4}`, diverging, [Continuous3, Interpolating3]);
scale4(`${Diverging3}-${Log3}`, divergingLog, [Continuous3, Interpolating3, Log3]);
scale4(`${Diverging3}-${Pow3}`, divergingPow, [Continuous3, Interpolating3]);
scale4(`${Diverging3}-${Sqrt3}`, divergingSqrt, [Continuous3, Interpolating3]);
scale4(`${Diverging3}-${Symlog3}`, divergingSymlog, [Continuous3, Interpolating3]);
scale4(Quantile4, quantile2, [Discretizing3, Quantile4]);
scale4(Quantize3, quantize, Discretizing3);
scale4(Threshold3, threshold, Discretizing3);
scale4(BinOrdinal3, scaleBinOrdinal3, [Discrete3, Discretizing3]);
scale4(Ordinal3, ordinal, Discrete3);
scale4(Band3, band4, Discrete3);
scale4(Point3, point9, Discrete3);
function isValidScaleType3(type7) {
  return scales3.has(type7);
}
function interpolateColors3(colors10, type7, gamma2) {
  return piecewise(interpolate3(type7 || "rgb", gamma2), colors10);
}
function interpolate3(type7, gamma2) {
  const interp = src_exports[method3(type7)];
  return gamma2 != null && interp && interp.gamma ? interp.gamma(gamma2) : interp;
}
function method3(type7) {
  return "interpolate" + type7.toLowerCase().split("-").map((s2) => s2[0].toUpperCase() + s2.slice(1)).join("");
}
var continuous4 = {
  blues: "cfe1f2bed8eca8cee58fc1de74b2d75ba3cf4592c63181bd206fb2125ca40a4a90",
  greens: "d3eecdc0e6baabdda594d3917bc77d60ba6c46ab5e329a512089430e7735036429",
  greys: "e2e2e2d4d4d4c4c4c4b1b1b19d9d9d8888887575756262624d4d4d3535351e1e1e",
  oranges: "fdd8b3fdc998fdb87bfda55efc9244f87f2cf06b18e4580bd14904b93d029f3303",
  purples: "e2e1efd4d4e8c4c5e0b4b3d6a3a0cc928ec3827cb97566ae684ea25c3696501f8c",
  reds: "fdc9b4fcb49afc9e80fc8767fa7051f6573fec3f2fdc2a25c81b1db21218970b13",
  blueGreen: "d5efedc1e8e0a7ddd18bd2be70c6a958ba9144ad77319c5d2089460e7736036429",
  bluePurple: "ccddecbad0e4a8c2dd9ab0d4919cc98d85be8b6db28a55a6873c99822287730f71",
  greenBlue: "d3eecec5e8c3b1e1bb9bd8bb82cec269c2ca51b2cd3c9fc7288abd1675b10b60a1",
  orangeRed: "fddcaffdcf9bfdc18afdad77fb9562f67d53ee6545e24932d32d1ebf130da70403",
  purpleBlue: "dbdaebc8cee4b1c3de97b7d87bacd15b9fc93a90c01e7fb70b70ab056199045281",
  purpleBlueGreen: "dbd8eac8cee4b0c3de93b7d872acd1549fc83892bb1c88a3097f8702736b016353",
  purpleRed: "dcc9e2d3b3d7ce9eccd186c0da6bb2e14da0e23189d91e6fc61159ab07498f023a",
  redPurple: "fccfccfcbec0faa9b8f98faff571a5ec539ddb3695c41b8aa908808d0179700174",
  yellowGreen: "e4f4acd1eca0b9e2949ed68880c97c62bb6e47aa5e3297502083440e723b036034",
  yellowOrangeBrown: "feeaa1fedd84fecc63feb746fca031f68921eb7215db5e0bc54c05ab3d038f3204",
  yellowOrangeRed: "fee087fed16ffebd59fea849fd903efc7335f9522bee3423de1b20ca0b22af0225",
  blueOrange: "134b852f78b35da2cb9dcae1d2e5eff2f0ebfce0bafbbf74e8932fc5690d994a07",
  brownBlueGreen: "704108a0651ac79548e3c78af3e6c6eef1eac9e9e48ed1c74da79e187a72025147",
  purpleGreen: "5b1667834792a67fb6c9aed3e6d6e8eff0efd9efd5aedda971bb75368e490e5e29",
  purpleOrange: "4114696647968f83b7b9b4d6dadbebf3eeeafce0bafbbf74e8932fc5690d994a07",
  redBlue: "8c0d25bf363adf745ef4ae91fbdbc9f2efeed2e5ef9dcae15da2cb2f78b3134b85",
  redGrey: "8c0d25bf363adf745ef4ae91fcdccbfaf4f1e2e2e2c0c0c0969696646464343434",
  yellowGreenBlue: "eff9bddbf1b4bde5b594d5b969c5be45b4c22c9ec02182b82163aa23479c1c3185",
  redYellowBlue: "a50026d4322cf16e43fcac64fedd90faf8c1dcf1ecabd6e875abd04a74b4313695",
  redYellowGreen: "a50026d4322cf16e43fcac63fedd8df9f7aed7ee8ea4d86e64bc6122964f006837",
  pinkYellowGreen: "8e0152c0267edd72adf0b3d6faddedf5f3efe1f2cab6de8780bb474f9125276419",
  spectral: "9e0142d13c4bf0704afcac63fedd8dfbf8b0e0f3a1a9dda269bda94288b55e4fa2",
  viridis: "440154470e61481a6c482575472f7d443a834144873d4e8a39568c35608d31688e2d708e2a788e27818e23888e21918d1f988b1fa08822a8842ab07f35b77943bf7154c56866cc5d7ad1518fd744a5db36bcdf27d2e21be9e51afde725",
  magma: "0000040404130b0924150e3720114b2c11603b0f704a107957157e651a80721f817f24828c29819a2e80a8327db6377ac43c75d1426fde4968e95462f1605df76f5cfa7f5efc8f65fe9f6dfeaf78febf84fece91fddea0fcedaffcfdbf",
  inferno: "0000040403130c0826170c3b240c4f330a5f420a68500d6c5d126e6b176e781c6d86216b932667a12b62ae305cbb3755c73e4cd24644dd513ae65c30ed6925f3771af8850ffb9506fca50afcb519fac62df6d645f2e661f3f484fcffa4",
  plasma: "0d088723069033059742039d5002a25d01a66a00a87801a88405a7900da49c179ea72198b12a90ba3488c33d80cb4779d35171da5a69e16462e76e5bed7953f2834cf68f44fa9a3dfca636fdb32ffec029fcce25f9dc24f5ea27f0f921",
  cividis: "00205100235800265d002961012b65042e670831690d346b11366c16396d1c3c6e213f6e26426e2c456e31476e374a6e3c4d6e42506e47536d4c566d51586e555b6e5a5e6e5e616e62646f66676f6a6a706e6d717270717573727976737c79747f7c75827f758682768985778c8877908b78938e789691789a94789e9778a19b78a59e77a9a177aea575b2a874b6ab73bbaf71c0b26fc5b66dc9b96acebd68d3c065d8c462ddc85fe2cb5ce7cf58ebd355f0d652f3da4ff7de4cfae249fce647",
  rainbow: "6e40aa883eb1a43db3bf3cafd83fa4ee4395fe4b83ff576eff6659ff7847ff8c38f3a130e2b72fcfcc36bee044aff05b8ff4576ff65b52f6673af27828ea8d1ddfa319d0b81cbecb23abd82f96e03d82e14c6edb5a5dd0664dbf6e40aa",
  sinebow: "ff4040fc582af47218e78d0bd5a703bfbf00a7d5038de70b72f41858fc2a40ff402afc5818f4720be78d03d5a700bfbf03a7d50b8de71872f42a58fc4040ff582afc7218f48d0be7a703d5bf00bfd503a7e70b8df41872fc2a58ff4040",
  turbo: "23171b32204a3e2a71453493493eae4b49c54a53d7485ee44569ee4074f53c7ff8378af93295f72e9ff42ba9ef28b3e926bce125c5d925cdcf27d5c629dcbc2de3b232e9a738ee9d3ff39347f68950f9805afc7765fd6e70fe667cfd5e88fc5795fb51a1f84badf545b9f140c5ec3cd0e637dae034e4d931ecd12ef4c92bfac029ffb626ffad24ffa223ff9821ff8d1fff821dff771cfd6c1af76118f05616e84b14df4111d5380fcb2f0dc0260ab61f07ac1805a313029b0f00950c00910b00",
  browns: "eedbbdecca96e9b97ae4a865dc9856d18954c7784cc0673fb85536ad44339f3632",
  tealBlues: "bce4d89dd3d181c3cb65b3c245a2b9368fae347da0306a932c5985",
  teals: "bbdfdfa2d4d58ac9c975bcbb61b0af4da5a43799982b8b8c1e7f7f127273006667",
  warmGreys: "dcd4d0cec5c1c0b8b4b3aaa7a59c9998908c8b827f7e7673726866665c5a59504e",
  goldGreen: "f4d166d5ca60b6c35c98bb597cb25760a6564b9c533f8f4f33834a257740146c36",
  goldOrange: "f4d166f8be5cf8aa4cf5983bf3852aef701be2621fd65322c54923b142239e3a26",
  goldRed: "f4d166f6be59f9aa51fc964ef6834bee734ae56249db5247cf4244c43141b71d3e",
  lightGreyRed: "efe9e6e1dad7d5cbc8c8bdb9bbaea9cd967ddc7b43e15f19df4011dc000b",
  lightGreyTeal: "e4eaead6dcddc8ced2b7c2c7a6b4bc64b0bf22a6c32295c11f85be1876bc",
  lightMulti: "e0f1f2c4e9d0b0de9fd0e181f6e072f6c053f3993ef77440ef4a3c",
  lightOrange: "f2e7daf7d5baf9c499fab184fa9c73f68967ef7860e8645bde515bd43d5b",
  lightTealBlue: "e3e9e0c0dccf9aceca7abfc859afc0389fb9328dad2f7ca0276b95255988",
  darkBlue: "3232322d46681a5c930074af008cbf05a7ce25c0dd38daed50f3faffffff",
  darkGold: "3c3c3c584b37725e348c7631ae8b2bcfa424ecc31ef9de30fff184ffffff",
  darkGreen: "3a3a3a215748006f4d048942489e4276b340a6c63dd2d836ffeb2cffffaa",
  darkMulti: "3737371f5287197d8c29a86995ce3fffe800ffffff",
  darkRed: "3434347036339e3c38cc4037e75d1eec8620eeab29f0ce32ffeb2c"
};
var discrete3 = {
  accent: Accent_default,
  category10: category10_default,
  category20: "1f77b4aec7e8ff7f0effbb782ca02c98df8ad62728ff98969467bdc5b0d58c564bc49c94e377c2f7b6d27f7f7fc7c7c7bcbd22dbdb8d17becf9edae5",
  category20b: "393b795254a36b6ecf9c9ede6379398ca252b5cf6bcedb9c8c6d31bd9e39e7ba52e7cb94843c39ad494ad6616be7969c7b4173a55194ce6dbdde9ed6",
  category20c: "3182bd6baed69ecae1c6dbefe6550dfd8d3cfdae6bfdd0a231a35474c476a1d99bc7e9c0756bb19e9ac8bcbddcdadaeb636363969696bdbdbdd9d9d9",
  dark2: Dark2_default,
  observable10: observable10_default,
  paired: Paired_default,
  pastel1: Pastel1_default,
  pastel2: Pastel2_default,
  set1: Set1_default,
  set2: Set2_default,
  set3: Set3_default,
  tableau10: "4c78a8f58518e4575672b7b254a24beeca3bb279a2ff9da69d755dbab0ac",
  tableau20: "4c78a89ecae9f58518ffbf7954a24b88d27ab79a20f2cf5b43989483bcb6e45756ff9d9879706ebab0acd67195fcbfd2b279a2d6a5c99e765fd8b5a5"
};
function colors3(palette) {
  if (isArray7(palette))
    return palette;
  const n = palette.length / 6 | 0, c5 = new Array(n);
  for (let i = 0; i < n; ) {
    c5[i] = "#" + palette.slice(i * 6, ++i * 6);
  }
  return c5;
}
function apply3(_, f) {
  for (const k3 in _)
    scheme30(k3, f(_[k3]));
}
var schemes3 = {};
apply3(discrete3, colors3);
apply3(continuous4, (_) => interpolateColors3(colors3(_)));
function scheme30(name, scheme38) {
  name = name && name.toLowerCase();
  if (arguments.length > 1) {
    schemes3[name] = scheme38;
    return this;
  } else {
    return schemes3[name];
  }
}
var symbols4 = {
  [Quantile4]: "quantiles",
  [Quantize3]: "thresholds",
  [Threshold3]: "domain"
};
var formats4 = {
  [Quantile4]: "quantiles",
  [Quantize3]: "domain"
};

// node_modules/vega-projection/build/vega-projection.js
var defaultPath = path_default();
var projectionProperties = [
  // standard properties in d3-geo
  "clipAngle",
  "clipExtent",
  "scale",
  "translate",
  "center",
  "rotate",
  "parallels",
  "precision",
  "reflectX",
  "reflectY",
  // extended properties in d3-geo-projections
  "coefficient",
  "distance",
  "fraction",
  "lobes",
  "parallel",
  "radius",
  "ratio",
  "spacing",
  "tilt"
];
function create4(type7, constructor) {
  return function projection3() {
    const p = constructor();
    p.type = type7;
    p.path = path_default().projection(p);
    p.copy = p.copy || function() {
      const c5 = projection3();
      projectionProperties.forEach((prop) => {
        if (p[prop])
          c5[prop](p[prop]());
      });
      c5.path.pointRadius(p.path.pointRadius());
      return c5;
    };
    return registerScale3(p);
  };
}
function projection2(type7, proj) {
  if (!type7 || typeof type7 !== "string") {
    throw new Error("Projection type must be a name string.");
  }
  type7 = type7.toLowerCase();
  if (arguments.length > 1) {
    projections[type7] = create4(type7, proj);
    return this;
  } else {
    return projections[type7] || null;
  }
}
function getProjectionPath(proj) {
  return proj && proj.path || defaultPath;
}
var projections = {
  // base d3-geo projection types
  albers: albers_default,
  albersusa: albersUsa_default,
  azimuthalequalarea: azimuthalEqualArea_default,
  azimuthalequidistant: azimuthalEquidistant_default,
  conicconformal: conicConformal_default,
  conicequalarea: conicEqualArea_default,
  conicequidistant: conicEquidistant_default,
  equalEarth: equalEarth_default,
  equirectangular: equirectangular_default,
  gnomonic: gnomonic_default,
  identity: identity_default5,
  mercator: mercator_default,
  mollweide: mollweide_default,
  naturalEarth1: naturalEarth1_default,
  orthographic: orthographic_default,
  stereographic: stereographic_default,
  transversemercator: transverseMercator_default
};
for (const key4 in projections) {
  projection2(key4, projections[key4]);
}

// node_modules/vega-geo/node_modules/vega-canvas/build/vega-canvas.browser.js
function domCanvas2(w8, h6) {
  if (typeof document !== "undefined" && document.createElement) {
    const c5 = document.createElement("canvas");
    if (c5 && c5.getContext) {
      c5.width = w8;
      c5.height = h6;
      return c5;
    }
  }
  return null;
}

// node_modules/vega-geo/build/vega-geo.js
function noop3() {
}
var cases = [[], [[[1, 1.5], [0.5, 1]]], [[[1.5, 1], [1, 1.5]]], [[[1.5, 1], [0.5, 1]]], [[[1, 0.5], [1.5, 1]]], [[[1, 1.5], [0.5, 1]], [[1, 0.5], [1.5, 1]]], [[[1, 0.5], [1, 1.5]]], [[[1, 0.5], [0.5, 1]]], [[[0.5, 1], [1, 0.5]]], [[[1, 1.5], [1, 0.5]]], [[[0.5, 1], [1, 0.5]], [[1.5, 1], [1, 1.5]]], [[[1.5, 1], [1, 0.5]]], [[[0.5, 1], [1.5, 1]]], [[[1, 1.5], [1.5, 1]]], [[[0.5, 1], [1, 1.5]]], []];
function contours() {
  var dx = 1, dy = 1, smooth = smoothLinear;
  function contours2(values7, tz) {
    return tz.map((value7) => contour(values7, value7));
  }
  function contour(values7, value7) {
    var polygons = [], holes = [];
    isorings(values7, value7, (ring) => {
      smooth(ring, values7, value7);
      if (area2(ring) > 0)
        polygons.push([ring]);
      else
        holes.push(ring);
    });
    holes.forEach((hole) => {
      for (var i = 0, n = polygons.length, polygon; i < n; ++i) {
        if (contains((polygon = polygons[i])[0], hole) !== -1) {
          polygon.push(hole);
          return;
        }
      }
    });
    return {
      type: "MultiPolygon",
      value: value7,
      coordinates: polygons
    };
  }
  function isorings(values7, value7, callback) {
    var fragmentByStart = [], fragmentByEnd = [], x9, y9, t014, t13, t22, t32;
    x9 = y9 = -1;
    t13 = values7[0] >= value7;
    cases[t13 << 1].forEach(stitch);
    while (++x9 < dx - 1) {
      t014 = t13, t13 = values7[x9 + 1] >= value7;
      cases[t014 | t13 << 1].forEach(stitch);
    }
    cases[t13 << 0].forEach(stitch);
    while (++y9 < dy - 1) {
      x9 = -1;
      t13 = values7[y9 * dx + dx] >= value7;
      t22 = values7[y9 * dx] >= value7;
      cases[t13 << 1 | t22 << 2].forEach(stitch);
      while (++x9 < dx - 1) {
        t014 = t13, t13 = values7[y9 * dx + dx + x9 + 1] >= value7;
        t32 = t22, t22 = values7[y9 * dx + x9 + 1] >= value7;
        cases[t014 | t13 << 1 | t22 << 2 | t32 << 3].forEach(stitch);
      }
      cases[t13 | t22 << 3].forEach(stitch);
    }
    x9 = -1;
    t22 = values7[y9 * dx] >= value7;
    cases[t22 << 2].forEach(stitch);
    while (++x9 < dx - 1) {
      t32 = t22, t22 = values7[y9 * dx + x9 + 1] >= value7;
      cases[t22 << 2 | t32 << 3].forEach(stitch);
    }
    cases[t22 << 3].forEach(stitch);
    function stitch(line8) {
      var start = [line8[0][0] + x9, line8[0][1] + y9], end = [line8[1][0] + x9, line8[1][1] + y9], startIndex = index4(start), endIndex = index4(end), f, g;
      if (f = fragmentByEnd[startIndex]) {
        if (g = fragmentByStart[endIndex]) {
          delete fragmentByEnd[f.end];
          delete fragmentByStart[g.start];
          if (f === g) {
            f.ring.push(end);
            callback(f.ring);
          } else {
            fragmentByStart[f.start] = fragmentByEnd[g.end] = {
              start: f.start,
              end: g.end,
              ring: f.ring.concat(g.ring)
            };
          }
        } else {
          delete fragmentByEnd[f.end];
          f.ring.push(end);
          fragmentByEnd[f.end = endIndex] = f;
        }
      } else if (f = fragmentByStart[endIndex]) {
        if (g = fragmentByEnd[startIndex]) {
          delete fragmentByStart[f.start];
          delete fragmentByEnd[g.end];
          if (f === g) {
            f.ring.push(end);
            callback(f.ring);
          } else {
            fragmentByStart[g.start] = fragmentByEnd[f.end] = {
              start: g.start,
              end: f.end,
              ring: g.ring.concat(f.ring)
            };
          }
        } else {
          delete fragmentByStart[f.start];
          f.ring.unshift(start);
          fragmentByStart[f.start = startIndex] = f;
        }
      } else {
        fragmentByStart[startIndex] = fragmentByEnd[endIndex] = {
          start: startIndex,
          end: endIndex,
          ring: [start, end]
        };
      }
    }
  }
  function index4(point21) {
    return point21[0] * 2 + point21[1] * (dx + 1) * 4;
  }
  function smoothLinear(ring, values7, value7) {
    ring.forEach((point21) => {
      var x9 = point21[0], y9 = point21[1], xt = x9 | 0, yt = y9 | 0, v0, v1 = values7[yt * dx + xt];
      if (x9 > 0 && x9 < dx && xt === x9) {
        v0 = values7[yt * dx + xt - 1];
        point21[0] = x9 + (value7 - v0) / (v1 - v0) - 0.5;
      }
      if (y9 > 0 && y9 < dy && yt === y9) {
        v0 = values7[(yt - 1) * dx + xt];
        point21[1] = y9 + (value7 - v0) / (v1 - v0) - 0.5;
      }
    });
  }
  contours2.contour = contour;
  contours2.size = function(_) {
    if (!arguments.length)
      return [dx, dy];
    var _0 = Math.floor(_[0]), _1 = Math.floor(_[1]);
    if (!(_0 >= 0 && _1 >= 0))
      error6("invalid size");
    return dx = _0, dy = _1, contours2;
  };
  contours2.smooth = function(_) {
    return arguments.length ? (smooth = _ ? smoothLinear : noop3, contours2) : smooth === smoothLinear;
  };
  return contours2;
}
function area2(ring) {
  var i = 0, n = ring.length, area8 = ring[n - 1][1] * ring[0][0] - ring[n - 1][0] * ring[0][1];
  while (++i < n)
    area8 += ring[i - 1][1] * ring[i][0] - ring[i - 1][0] * ring[i][1];
  return area8;
}
function contains(ring, hole) {
  var i = -1, n = hole.length, c5;
  while (++i < n)
    if (c5 = ringContains(ring, hole[i]))
      return c5;
  return 0;
}
function ringContains(ring, point21) {
  var x9 = point21[0], y9 = point21[1], contains3 = -1;
  for (var i = 0, n = ring.length, j = n - 1; i < n; j = i++) {
    var pi5 = ring[i], xi = pi5[0], yi = pi5[1], pj = ring[j], xj = pj[0], yj = pj[1];
    if (segmentContains(pi5, pj, point21))
      return 0;
    if (yi > y9 !== yj > y9 && x9 < (xj - xi) * (y9 - yi) / (yj - yi) + xi)
      contains3 = -contains3;
  }
  return contains3;
}
function segmentContains(a4, b6, c5) {
  var i;
  return collinear(a4, b6, c5) && within(a4[i = +(a4[0] === b6[0])], c5[i], b6[i]);
}
function collinear(a4, b6, c5) {
  return (b6[0] - a4[0]) * (c5[1] - a4[1]) === (c5[0] - a4[0]) * (b6[1] - a4[1]);
}
function within(p, q, r) {
  return p <= q && q <= r || r <= q && q <= p;
}
function quantize2(k3, nice4, zero28) {
  return function(values7) {
    var ex = extent4(values7), start = zero28 ? Math.min(ex[0], 0) : ex[0], stop2 = ex[1], span12 = stop2 - start, step = nice4 ? tickStep(start, stop2, k3) : span12 / (k3 + 1);
    return range(start + step, stop2, step);
  };
}
function Isocontour(params2) {
  Transform.call(this, null, params2);
}
Isocontour.Definition = {
  "type": "Isocontour",
  "metadata": {
    "generates": true
  },
  "params": [{
    "name": "field",
    "type": "field"
  }, {
    "name": "thresholds",
    "type": "number",
    "array": true
  }, {
    "name": "levels",
    "type": "number"
  }, {
    "name": "nice",
    "type": "boolean",
    "default": false
  }, {
    "name": "resolve",
    "type": "enum",
    "values": ["shared", "independent"],
    "default": "independent"
  }, {
    "name": "zero",
    "type": "boolean",
    "default": true
  }, {
    "name": "smooth",
    "type": "boolean",
    "default": true
  }, {
    "name": "scale",
    "type": "number",
    "expr": true
  }, {
    "name": "translate",
    "type": "number",
    "array": true,
    "expr": true
  }, {
    "name": "as",
    "type": "string",
    "null": true,
    "default": "contour"
  }]
};
inherits6(Isocontour, Transform, {
  transform(_, pulse2) {
    if (this.value && !pulse2.changed() && !_.modified()) {
      return pulse2.StopPropagation;
    }
    var out = pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS), source3 = pulse2.materialize(pulse2.SOURCE).source, field25 = _.field || identity10, contour = contours().smooth(_.smooth !== false), tz = _.thresholds || levels(source3, field25, _), as = _.as === null ? null : _.as || "contour", values7 = [];
    source3.forEach((t) => {
      const grid = field25(t);
      const paths = contour.size([grid.width, grid.height])(grid.values, isArray6(tz) ? tz : tz(grid.values));
      transformPaths(paths, grid, t, _);
      paths.forEach((p) => {
        values7.push(rederive(t, ingest$1(as != null ? {
          [as]: p
        } : p)));
      });
    });
    if (this.value)
      out.rem = this.value;
    this.value = out.source = out.add = values7;
    return out;
  }
});
function levels(values7, f, _) {
  const q = quantize2(_.levels || 10, _.nice, _.zero !== false);
  return _.resolve !== "shared" ? q : q(values7.map((t) => max(f(t).values)));
}
function transformPaths(paths, grid, datum2, _) {
  let s2 = _.scale || grid.scale, t = _.translate || grid.translate;
  if (isFunction6(s2))
    s2 = s2(datum2, _);
  if (isFunction6(t))
    t = t(datum2, _);
  if ((s2 === 1 || s2 == null) && !t)
    return;
  const sx = (isNumber6(s2) ? s2 : s2[0]) || 1, sy = (isNumber6(s2) ? s2 : s2[1]) || 1, tx = t && t[0] || 0, ty = t && t[1] || 0;
  paths.forEach(transform2(grid, sx, sy, tx, ty));
}
function transform2(grid, sx, sy, tx, ty) {
  const x13 = grid.x1 || 0, y13 = grid.y1 || 0, flip2 = sx * sy < 0;
  function transformPolygon(coordinates) {
    coordinates.forEach(transformRing);
  }
  function transformRing(coordinates) {
    if (flip2)
      coordinates.reverse();
    coordinates.forEach(transformPoint);
  }
  function transformPoint(coordinates) {
    coordinates[0] = (coordinates[0] - x13) * sx + tx;
    coordinates[1] = (coordinates[1] - y13) * sy + ty;
  }
  return function(geometry) {
    geometry.coordinates.forEach(transformPolygon);
    return geometry;
  };
}
function radius(bw, data3, f) {
  const v2 = bw >= 0 ? bw : estimateBandwidth(data3, f);
  return Math.round((Math.sqrt(4 * v2 * v2 + 1) - 1) / 2);
}
function number5(_) {
  return isFunction6(_) ? _ : constant8(+_);
}
function density2D() {
  var x9 = (d) => d[0], y9 = (d) => d[1], weight = one7, bandwidth2 = [-1, -1], dx = 960, dy = 500, k3 = 2;
  function density(data3, counts) {
    const rx = radius(bandwidth2[0], data3, x9) >> k3, ry = radius(bandwidth2[1], data3, y9) >> k3, ox = rx ? rx + 2 : 0, oy = ry ? ry + 2 : 0, n = 2 * ox + (dx >> k3), m3 = 2 * oy + (dy >> k3), values0 = new Float32Array(n * m3), values1 = new Float32Array(n * m3);
    let values7 = values0;
    data3.forEach((d) => {
      const xi = ox + (+x9(d) >> k3), yi = oy + (+y9(d) >> k3);
      if (xi >= 0 && xi < n && yi >= 0 && yi < m3) {
        values0[xi + yi * n] += +weight(d);
      }
    });
    if (rx > 0 && ry > 0) {
      blurX(n, m3, values0, values1, rx);
      blurY(n, m3, values1, values0, ry);
      blurX(n, m3, values0, values1, rx);
      blurY(n, m3, values1, values0, ry);
      blurX(n, m3, values0, values1, rx);
      blurY(n, m3, values1, values0, ry);
    } else if (rx > 0) {
      blurX(n, m3, values0, values1, rx);
      blurX(n, m3, values1, values0, rx);
      blurX(n, m3, values0, values1, rx);
      values7 = values1;
    } else if (ry > 0) {
      blurY(n, m3, values0, values1, ry);
      blurY(n, m3, values1, values0, ry);
      blurY(n, m3, values0, values1, ry);
      values7 = values1;
    }
    const s2 = counts ? Math.pow(2, -2 * k3) : 1 / sum(values7);
    for (let i = 0, sz6 = n * m3; i < sz6; ++i)
      values7[i] *= s2;
    return {
      values: values7,
      scale: 1 << k3,
      width: n,
      height: m3,
      x1: ox,
      y1: oy,
      x2: ox + (dx >> k3),
      y2: oy + (dy >> k3)
    };
  }
  density.x = function(_) {
    return arguments.length ? (x9 = number5(_), density) : x9;
  };
  density.y = function(_) {
    return arguments.length ? (y9 = number5(_), density) : y9;
  };
  density.weight = function(_) {
    return arguments.length ? (weight = number5(_), density) : weight;
  };
  density.size = function(_) {
    if (!arguments.length)
      return [dx, dy];
    var _0 = +_[0], _1 = +_[1];
    if (!(_0 >= 0 && _1 >= 0))
      error6("invalid size");
    return dx = _0, dy = _1, density;
  };
  density.cellSize = function(_) {
    if (!arguments.length)
      return 1 << k3;
    if (!((_ = +_) >= 1))
      error6("invalid cell size");
    k3 = Math.floor(Math.log(_) / Math.LN2);
    return density;
  };
  density.bandwidth = function(_) {
    if (!arguments.length)
      return bandwidth2;
    _ = array7(_);
    if (_.length === 1)
      _ = [+_[0], +_[0]];
    if (_.length !== 2)
      error6("invalid bandwidth");
    return bandwidth2 = _, density;
  };
  return density;
}
function blurX(n, m3, source3, target2, r) {
  const w8 = (r << 1) + 1;
  for (let j = 0; j < m3; ++j) {
    for (let i = 0, sr = 0; i < n + r; ++i) {
      if (i < n) {
        sr += source3[i + j * n];
      }
      if (i >= r) {
        if (i >= w8) {
          sr -= source3[i - w8 + j * n];
        }
        target2[i - r + j * n] = sr / Math.min(i + 1, n - 1 + w8 - i, w8);
      }
    }
  }
}
function blurY(n, m3, source3, target2, r) {
  const w8 = (r << 1) + 1;
  for (let i = 0; i < n; ++i) {
    for (let j = 0, sr = 0; j < m3 + r; ++j) {
      if (j < m3) {
        sr += source3[i + j * n];
      }
      if (j >= r) {
        if (j >= w8) {
          sr -= source3[i + (j - w8) * n];
        }
        target2[i + (j - r) * n] = sr / Math.min(j + 1, m3 - 1 + w8 - j, w8);
      }
    }
  }
}
function KDE2D(params2) {
  Transform.call(this, null, params2);
}
KDE2D.Definition = {
  "type": "KDE2D",
  "metadata": {
    "generates": true
  },
  "params": [{
    "name": "size",
    "type": "number",
    "array": true,
    "length": 2,
    "required": true
  }, {
    "name": "x",
    "type": "field",
    "required": true
  }, {
    "name": "y",
    "type": "field",
    "required": true
  }, {
    "name": "weight",
    "type": "field"
  }, {
    "name": "groupby",
    "type": "field",
    "array": true
  }, {
    "name": "cellSize",
    "type": "number"
  }, {
    "name": "bandwidth",
    "type": "number",
    "array": true,
    "length": 2
  }, {
    "name": "counts",
    "type": "boolean",
    "default": false
  }, {
    "name": "as",
    "type": "string",
    "default": "grid"
  }]
};
var PARAMS = ["x", "y", "weight", "size", "cellSize", "bandwidth"];
function params(obj, _) {
  PARAMS.forEach((param2) => _[param2] != null ? obj[param2](_[param2]) : 0);
  return obj;
}
inherits6(KDE2D, Transform, {
  transform(_, pulse2) {
    if (this.value && !pulse2.changed() && !_.modified())
      return pulse2.StopPropagation;
    var out = pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS), source3 = pulse2.materialize(pulse2.SOURCE).source, groups2 = partition3(source3, _.groupby), names = (_.groupby || []).map(accessorName3), kde2 = params(density2D(), _), as = _.as || "grid", values7 = [];
    function set7(t, vals2) {
      for (let i = 0; i < names.length; ++i)
        t[names[i]] = vals2[i];
      return t;
    }
    values7 = groups2.map((g) => ingest$1(set7({
      [as]: kde2(g, _.counts)
    }, g.dims)));
    if (this.value)
      out.rem = this.value;
    this.value = out.source = out.add = values7;
    return out;
  }
});
function partition3(data3, groupby) {
  var groups2 = [], get23 = (f) => f(t), map13, i, n, t, k3, g;
  if (groupby == null) {
    groups2.push(data3);
  } else {
    for (map13 = {}, i = 0, n = data3.length; i < n; ++i) {
      t = data3[i];
      k3 = groupby.map(get23);
      g = map13[k3];
      if (!g) {
        map13[k3] = g = [];
        g.dims = k3;
        groups2.push(g);
      }
      g.push(t);
    }
  }
  return groups2;
}
function Contour(params2) {
  Transform.call(this, null, params2);
}
Contour.Definition = {
  "type": "Contour",
  "metadata": {
    "generates": true
  },
  "params": [{
    "name": "size",
    "type": "number",
    "array": true,
    "length": 2,
    "required": true
  }, {
    "name": "values",
    "type": "number",
    "array": true
  }, {
    "name": "x",
    "type": "field"
  }, {
    "name": "y",
    "type": "field"
  }, {
    "name": "weight",
    "type": "field"
  }, {
    "name": "cellSize",
    "type": "number"
  }, {
    "name": "bandwidth",
    "type": "number"
  }, {
    "name": "count",
    "type": "number"
  }, {
    "name": "nice",
    "type": "boolean",
    "default": false
  }, {
    "name": "thresholds",
    "type": "number",
    "array": true
  }, {
    "name": "smooth",
    "type": "boolean",
    "default": true
  }]
};
inherits6(Contour, Transform, {
  transform(_, pulse2) {
    if (this.value && !pulse2.changed() && !_.modified()) {
      return pulse2.StopPropagation;
    }
    var out = pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS), contour = contours().smooth(_.smooth !== false), values7 = _.values, thresh = _.thresholds || quantize2(_.count || 10, _.nice, !!values7), size = _.size, grid, post2;
    if (!values7) {
      values7 = pulse2.materialize(pulse2.SOURCE).source;
      grid = params(density2D(), _)(values7, true);
      post2 = transform2(grid, grid.scale || 1, grid.scale || 1, 0, 0);
      size = [grid.width, grid.height];
      values7 = grid.values;
    }
    thresh = isArray6(thresh) ? thresh : thresh(values7);
    values7 = contour.size(size)(values7, thresh);
    if (post2)
      values7.forEach(post2);
    if (this.value)
      out.rem = this.value;
    this.value = out.source = out.add = (values7 || []).map(ingest$1);
    return out;
  }
});
var Feature = "Feature";
var FeatureCollection = "FeatureCollection";
var MultiPoint = "MultiPoint";
function GeoJSON(params2) {
  Transform.call(this, null, params2);
}
GeoJSON.Definition = {
  "type": "GeoJSON",
  "metadata": {},
  "params": [{
    "name": "fields",
    "type": "field",
    "array": true,
    "length": 2
  }, {
    "name": "geojson",
    "type": "field"
  }]
};
inherits6(GeoJSON, Transform, {
  transform(_, pulse2) {
    var features = this._features, points2 = this._points, fields = _.fields, lon = fields && fields[0], lat = fields && fields[1], geojson = _.geojson || !fields && identity10, flag2 = pulse2.ADD, mod;
    mod = _.modified() || pulse2.changed(pulse2.REM) || pulse2.modified(accessorFields3(geojson)) || lon && pulse2.modified(accessorFields3(lon)) || lat && pulse2.modified(accessorFields3(lat));
    if (!this.value || mod) {
      flag2 = pulse2.SOURCE;
      this._features = features = [];
      this._points = points2 = [];
    }
    if (geojson) {
      pulse2.visit(flag2, (t) => features.push(geojson(t)));
    }
    if (lon && lat) {
      pulse2.visit(flag2, (t) => {
        var x9 = lon(t), y9 = lat(t);
        if (x9 != null && y9 != null && (x9 = +x9) === x9 && (y9 = +y9) === y9) {
          points2.push([x9, y9]);
        }
      });
      features = features.concat({
        type: Feature,
        geometry: {
          type: MultiPoint,
          coordinates: points2
        }
      });
    }
    this.value = {
      type: FeatureCollection,
      features
    };
  }
});
function GeoPath(params2) {
  Transform.call(this, null, params2);
}
GeoPath.Definition = {
  "type": "GeoPath",
  "metadata": {
    "modifies": true
  },
  "params": [{
    "name": "projection",
    "type": "projection"
  }, {
    "name": "field",
    "type": "field"
  }, {
    "name": "pointRadius",
    "type": "number",
    "expr": true
  }, {
    "name": "as",
    "type": "string",
    "default": "path"
  }]
};
inherits6(GeoPath, Transform, {
  transform(_, pulse2) {
    var out = pulse2.fork(pulse2.ALL), path7 = this.value, field25 = _.field || identity10, as = _.as || "path", flag2 = out.SOURCE;
    if (!path7 || _.modified()) {
      this.value = path7 = getProjectionPath(_.projection);
      out.materialize().reflow();
    } else {
      flag2 = field25 === identity10 || pulse2.modified(field25.fields) ? out.ADD_MOD : out.ADD;
    }
    const prev = initPath(path7, _.pointRadius);
    out.visit(flag2, (t) => t[as] = path7(field25(t)));
    path7.pointRadius(prev);
    return out.modifies(as);
  }
});
function initPath(path7, pointRadius) {
  const prev = path7.pointRadius();
  path7.context(null);
  if (pointRadius != null) {
    path7.pointRadius(pointRadius);
  }
  return prev;
}
function GeoPoint(params2) {
  Transform.call(this, null, params2);
}
GeoPoint.Definition = {
  "type": "GeoPoint",
  "metadata": {
    "modifies": true
  },
  "params": [{
    "name": "projection",
    "type": "projection",
    "required": true
  }, {
    "name": "fields",
    "type": "field",
    "array": true,
    "required": true,
    "length": 2
  }, {
    "name": "as",
    "type": "string",
    "array": true,
    "length": 2,
    "default": ["x", "y"]
  }]
};
inherits6(GeoPoint, Transform, {
  transform(_, pulse2) {
    var proj = _.projection, lon = _.fields[0], lat = _.fields[1], as = _.as || ["x", "y"], x9 = as[0], y9 = as[1], mod;
    function set7(t) {
      const xy = proj([lon(t), lat(t)]);
      if (xy) {
        t[x9] = xy[0];
        t[y9] = xy[1];
      } else {
        t[x9] = void 0;
        t[y9] = void 0;
      }
    }
    if (_.modified()) {
      pulse2 = pulse2.materialize().reflow(true).visit(pulse2.SOURCE, set7);
    } else {
      mod = pulse2.modified(lon.fields) || pulse2.modified(lat.fields);
      pulse2.visit(mod ? pulse2.ADD_MOD : pulse2.ADD, set7);
    }
    return pulse2.modifies(as);
  }
});
function GeoShape(params2) {
  Transform.call(this, null, params2);
}
GeoShape.Definition = {
  "type": "GeoShape",
  "metadata": {
    "modifies": true,
    "nomod": true
  },
  "params": [{
    "name": "projection",
    "type": "projection"
  }, {
    "name": "field",
    "type": "field",
    "default": "datum"
  }, {
    "name": "pointRadius",
    "type": "number",
    "expr": true
  }, {
    "name": "as",
    "type": "string",
    "default": "shape"
  }]
};
inherits6(GeoShape, Transform, {
  transform(_, pulse2) {
    var out = pulse2.fork(pulse2.ALL), shape6 = this.value, as = _.as || "shape", flag2 = out.ADD;
    if (!shape6 || _.modified()) {
      this.value = shape6 = shapeGenerator(getProjectionPath(_.projection), _.field || field6("datum"), _.pointRadius);
      out.materialize().reflow();
      flag2 = out.SOURCE;
    }
    out.visit(flag2, (t) => t[as] = shape6);
    return out.modifies(as);
  }
});
function shapeGenerator(path7, field25, pointRadius) {
  const shape6 = pointRadius == null ? (_) => path7(field25(_)) : (_) => {
    var prev = path7.pointRadius(), value7 = path7.pointRadius(pointRadius)(field25(_));
    path7.pointRadius(prev);
    return value7;
  };
  shape6.context = (_) => {
    path7.context(_);
    return shape6;
  };
  return shape6;
}
function Graticule(params2) {
  Transform.call(this, [], params2);
  this.generator = graticule();
}
Graticule.Definition = {
  "type": "Graticule",
  "metadata": {
    "changes": true,
    "generates": true
  },
  "params": [{
    "name": "extent",
    "type": "array",
    "array": true,
    "length": 2,
    "content": {
      "type": "number",
      "array": true,
      "length": 2
    }
  }, {
    "name": "extentMajor",
    "type": "array",
    "array": true,
    "length": 2,
    "content": {
      "type": "number",
      "array": true,
      "length": 2
    }
  }, {
    "name": "extentMinor",
    "type": "array",
    "array": true,
    "length": 2,
    "content": {
      "type": "number",
      "array": true,
      "length": 2
    }
  }, {
    "name": "step",
    "type": "number",
    "array": true,
    "length": 2
  }, {
    "name": "stepMajor",
    "type": "number",
    "array": true,
    "length": 2,
    "default": [90, 360]
  }, {
    "name": "stepMinor",
    "type": "number",
    "array": true,
    "length": 2,
    "default": [10, 10]
  }, {
    "name": "precision",
    "type": "number",
    "default": 2.5
  }]
};
inherits6(Graticule, Transform, {
  transform(_, pulse2) {
    var src = this.value, gen = this.generator, t;
    if (!src.length || _.modified()) {
      for (const prop in _) {
        if (isFunction6(gen[prop])) {
          gen[prop](_[prop]);
        }
      }
    }
    t = gen();
    if (src.length) {
      pulse2.mod.push(replace(src[0], t));
    } else {
      pulse2.add.push(ingest$1(t));
    }
    src[0] = t;
    return pulse2;
  }
});
function Heatmap(params2) {
  Transform.call(this, null, params2);
}
Heatmap.Definition = {
  "type": "heatmap",
  "metadata": {
    "modifies": true
  },
  "params": [{
    "name": "field",
    "type": "field"
  }, {
    "name": "color",
    "type": "string",
    "expr": true
  }, {
    "name": "opacity",
    "type": "number",
    "expr": true
  }, {
    "name": "resolve",
    "type": "enum",
    "values": ["shared", "independent"],
    "default": "independent"
  }, {
    "name": "as",
    "type": "string",
    "default": "image"
  }]
};
inherits6(Heatmap, Transform, {
  transform(_, pulse2) {
    if (!pulse2.changed() && !_.modified()) {
      return pulse2.StopPropagation;
    }
    var source3 = pulse2.materialize(pulse2.SOURCE).source, shared = _.resolve === "shared", field25 = _.field || identity10, opacity2 = opacity_(_.opacity, _), color9 = color_(_.color, _), as = _.as || "image", obj = {
      $x: 0,
      $y: 0,
      $value: 0,
      $max: shared ? max(source3.map((t) => max(field25(t).values))) : 0
    };
    source3.forEach((t) => {
      const v2 = field25(t);
      const o = extend7({}, t, obj);
      if (!shared)
        o.$max = max(v2.values || []);
      t[as] = toCanvas(v2, o, color9.dep ? color9 : constant8(color9(o)), opacity2.dep ? opacity2 : constant8(opacity2(o)));
    });
    return pulse2.reflow(true).modifies(as);
  }
});
function color_(color9, _) {
  let f;
  if (isFunction6(color9)) {
    f = (obj) => rgb(color9(obj, _));
    f.dep = dependency(color9);
  } else {
    f = constant8(rgb(color9 || "#888"));
  }
  return f;
}
function opacity_(opacity2, _) {
  let f;
  if (isFunction6(opacity2)) {
    f = (obj) => opacity2(obj, _);
    f.dep = dependency(opacity2);
  } else if (opacity2) {
    f = constant8(opacity2);
  } else {
    f = (obj) => obj.$value / obj.$max || 0;
    f.dep = true;
  }
  return f;
}
function dependency(f) {
  if (!isFunction6(f))
    return false;
  const set7 = toSet6(accessorFields3(f));
  return set7.$x || set7.$y || set7.$value || set7.$max;
}
function toCanvas(grid, obj, color9, opacity2) {
  const n = grid.width, m3 = grid.height, x13 = grid.x1 || 0, y13 = grid.y1 || 0, x22 = grid.x2 || n, y22 = grid.y2 || m3, val = grid.values, value7 = val ? (i) => val[i] : zero8, can = domCanvas2(x22 - x13, y22 - y13), ctx = can.getContext("2d"), img = ctx.getImageData(0, 0, x22 - x13, y22 - y13), pix = img.data;
  for (let j = y13, k3 = 0; j < y22; ++j) {
    obj.$y = j - y13;
    for (let i = x13, r = j * n; i < x22; ++i, k3 += 4) {
      obj.$x = i - x13;
      obj.$value = value7(i + r);
      const v2 = color9(obj);
      pix[k3 + 0] = v2.r;
      pix[k3 + 1] = v2.g;
      pix[k3 + 2] = v2.b;
      pix[k3 + 3] = ~~(255 * opacity2(obj));
    }
  }
  ctx.putImageData(img, 0, 0);
  return can;
}
function Projection(params2) {
  Transform.call(this, null, params2);
  this.modified(true);
}
inherits6(Projection, Transform, {
  transform(_, pulse2) {
    let proj = this.value;
    if (!proj || _.modified("type")) {
      this.value = proj = create5(_.type);
      projectionProperties.forEach((prop) => {
        if (_[prop] != null)
          set4(proj, prop, _[prop]);
      });
    } else {
      projectionProperties.forEach((prop) => {
        if (_.modified(prop))
          set4(proj, prop, _[prop]);
      });
    }
    if (_.pointRadius != null)
      proj.path.pointRadius(_.pointRadius);
    if (_.fit)
      fit2(proj, _);
    return pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS);
  }
});
function fit2(proj, _) {
  const data3 = collectGeoJSON(_.fit);
  _.extent ? proj.fitExtent(_.extent, data3) : _.size ? proj.fitSize(_.size, data3) : 0;
}
function create5(type7) {
  const constructor = projection2((type7 || "mercator").toLowerCase());
  if (!constructor)
    error6("Unrecognized projection type: " + type7);
  return constructor();
}
function set4(proj, key4, value7) {
  if (isFunction6(proj[key4]))
    proj[key4](value7);
}
function collectGeoJSON(data3) {
  data3 = array7(data3);
  return data3.length === 1 ? data3[0] : {
    type: FeatureCollection,
    features: data3.reduce((a4, f) => a4.concat(featurize(f)), [])
  };
}
function featurize(f) {
  return f.type === FeatureCollection ? f.features : array7(f).filter((d) => d != null).map((d) => d.type === Feature ? d : {
    type: Feature,
    geometry: d
  });
}

// node_modules/vega-force/build/vega-force.js
var vega_force_exports = {};
__export(vega_force_exports, {
  force: () => Force
});

// node_modules/vega-force/node_modules/vega-util/build/vega-util.js
function accessor8(fn, fields, name) {
  fn.fields = fields || [];
  fn.fname = name;
  return fn;
}
function accessorFields4(fn) {
  return fn == null ? null : fn.fields;
}
function getter8(path7) {
  return path7.length === 1 ? get18(path7[0]) : getN8(path7);
}
var get18 = (field25) => function(obj) {
  return obj[field25];
};
var getN8 = (path7) => {
  const len = path7.length;
  return function(obj) {
    for (let i = 0; i < len; ++i) {
      obj = obj[path7[i]];
    }
    return obj;
  };
};
function error8(message) {
  throw Error(message);
}
function splitAccessPath8(p) {
  const path7 = [], n = p.length;
  let q = null, b6 = 0, s2 = "", i, j, c5;
  p = p + "";
  function push() {
    path7.push(s2 + p.substring(i, j));
    s2 = "";
    i = j + 1;
  }
  for (i = j = 0; j < n; ++j) {
    c5 = p[j];
    if (c5 === "\\") {
      s2 += p.substring(i, j++);
      i = j;
    } else if (c5 === q) {
      push();
      q = null;
      b6 = -1;
    } else if (q) {
      continue;
    } else if (i === b6 && c5 === '"') {
      i = j + 1;
      q = c5;
    } else if (i === b6 && c5 === "'") {
      i = j + 1;
      q = c5;
    } else if (c5 === "." && !b6) {
      if (j > i) {
        push();
      } else {
        i = j + 1;
      }
    } else if (c5 === "[") {
      if (j > i)
        push();
      b6 = i = j + 1;
    } else if (c5 === "]") {
      if (!b6)
        error8("Access path missing open bracket: " + p);
      if (b6 > 0)
        push();
      b6 = 0;
      i = j + 1;
    }
  }
  if (b6)
    error8("Access path missing closing bracket: " + p);
  if (q)
    error8("Access path missing closing quote: " + p);
  if (j > i) {
    j++;
    push();
  }
  return path7;
}
function field8(field25, name, opt) {
  const path7 = splitAccessPath8(field25);
  field25 = path7.length === 1 ? path7[0] : field25;
  return accessor8((opt && opt.get || getter8)(path7), [field25], name || field25);
}
var id8 = field8("id");
var identity12 = accessor8((_) => _, [], "identity");
var zero10 = accessor8(() => 0, [], "zero");
var one9 = accessor8(() => 1, [], "one");
var truthy8 = accessor8(() => true, [], "true");
var falsy8 = accessor8(() => false, [], "false");
var DisallowedObjectProperties8 = /* @__PURE__ */ new Set([...Object.getOwnPropertyNames(Object.prototype).filter((name) => typeof Object.prototype[name] === "function"), "__proto__"]);
var isArray8 = Array.isArray;
function array9(_) {
  return _ != null ? isArray8(_) ? _ : [_] : [];
}
function isFunction7(_) {
  return typeof _ === "function";
}
function extend9(_) {
  for (let x9, k3, i = 1, len = arguments.length; i < len; ++i) {
    x9 = arguments[i];
    for (k3 in x9) {
      _[k3] = x9[k3];
    }
  }
  return _;
}
function has7(object2, property2) {
  return Object.hasOwn(object2, property2);
}
function inherits7(child, parent, members) {
  const proto = child.prototype = Object.create(parent.prototype);
  Object.defineProperty(proto, "constructor", {
    value: child,
    writable: true,
    enumerable: true,
    configurable: true
  });
  return extend9(proto, members);
}

// node_modules/d3-force/src/center.js
function center_default(x9, y9) {
  var nodes, strength = 1;
  if (x9 == null)
    x9 = 0;
  if (y9 == null)
    y9 = 0;
  function force() {
    var i, n = nodes.length, node, sx = 0, sy = 0;
    for (i = 0; i < n; ++i) {
      node = nodes[i], sx += node.x, sy += node.y;
    }
    for (sx = (sx / n - x9) * strength, sy = (sy / n - y9) * strength, i = 0; i < n; ++i) {
      node = nodes[i], node.x -= sx, node.y -= sy;
    }
  }
  force.initialize = function(_) {
    nodes = _;
  };
  force.x = function(_) {
    return arguments.length ? (x9 = +_, force) : x9;
  };
  force.y = function(_) {
    return arguments.length ? (y9 = +_, force) : y9;
  };
  force.strength = function(_) {
    return arguments.length ? (strength = +_, force) : strength;
  };
  return force;
}

// node_modules/d3-quadtree/src/add.js
function add_default(d) {
  const x9 = +this._x.call(null, d), y9 = +this._y.call(null, d);
  return add4(this.cover(x9, y9), x9, y9, d);
}
function add4(tree, x9, y9, d) {
  if (isNaN(x9) || isNaN(y9))
    return tree;
  var parent, node = tree._root, leaf = { data: d }, x07 = tree._x0, y07 = tree._y0, x13 = tree._x1, y13 = tree._y1, xm, ym, xp, yp, right, bottom, i, j;
  if (!node)
    return tree._root = leaf, tree;
  while (node.length) {
    if (right = x9 >= (xm = (x07 + x13) / 2))
      x07 = xm;
    else
      x13 = xm;
    if (bottom = y9 >= (ym = (y07 + y13) / 2))
      y07 = ym;
    else
      y13 = ym;
    if (parent = node, !(node = node[i = bottom << 1 | right]))
      return parent[i] = leaf, tree;
  }
  xp = +tree._x.call(null, node.data);
  yp = +tree._y.call(null, node.data);
  if (x9 === xp && y9 === yp)
    return leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree;
  do {
    parent = parent ? parent[i] = new Array(4) : tree._root = new Array(4);
    if (right = x9 >= (xm = (x07 + x13) / 2))
      x07 = xm;
    else
      x13 = xm;
    if (bottom = y9 >= (ym = (y07 + y13) / 2))
      y07 = ym;
    else
      y13 = ym;
  } while ((i = bottom << 1 | right) === (j = (yp >= ym) << 1 | xp >= xm));
  return parent[j] = node, parent[i] = leaf, tree;
}
function addAll(data3) {
  var d, i, n = data3.length, x9, y9, xz = new Array(n), yz = new Array(n), x07 = Infinity, y07 = Infinity, x13 = -Infinity, y13 = -Infinity;
  for (i = 0; i < n; ++i) {
    if (isNaN(x9 = +this._x.call(null, d = data3[i])) || isNaN(y9 = +this._y.call(null, d)))
      continue;
    xz[i] = x9;
    yz[i] = y9;
    if (x9 < x07)
      x07 = x9;
    if (x9 > x13)
      x13 = x9;
    if (y9 < y07)
      y07 = y9;
    if (y9 > y13)
      y13 = y9;
  }
  if (x07 > x13 || y07 > y13)
    return this;
  this.cover(x07, y07).cover(x13, y13);
  for (i = 0; i < n; ++i) {
    add4(this, xz[i], yz[i], data3[i]);
  }
  return this;
}

// node_modules/d3-quadtree/src/cover.js
function cover_default(x9, y9) {
  if (isNaN(x9 = +x9) || isNaN(y9 = +y9))
    return this;
  var x07 = this._x0, y07 = this._y0, x13 = this._x1, y13 = this._y1;
  if (isNaN(x07)) {
    x13 = (x07 = Math.floor(x9)) + 1;
    y13 = (y07 = Math.floor(y9)) + 1;
  } else {
    var z = x13 - x07 || 1, node = this._root, parent, i;
    while (x07 > x9 || x9 >= x13 || y07 > y9 || y9 >= y13) {
      i = (y9 < y07) << 1 | x9 < x07;
      parent = new Array(4), parent[i] = node, node = parent, z *= 2;
      switch (i) {
        case 0:
          x13 = x07 + z, y13 = y07 + z;
          break;
        case 1:
          x07 = x13 - z, y13 = y07 + z;
          break;
        case 2:
          x13 = x07 + z, y07 = y13 - z;
          break;
        case 3:
          x07 = x13 - z, y07 = y13 - z;
          break;
      }
    }
    if (this._root && this._root.length)
      this._root = node;
  }
  this._x0 = x07;
  this._y0 = y07;
  this._x1 = x13;
  this._y1 = y13;
  return this;
}

// node_modules/d3-quadtree/src/data.js
function data_default() {
  var data3 = [];
  this.visit(function(node) {
    if (!node.length)
      do
        data3.push(node.data);
      while (node = node.next);
  });
  return data3;
}

// node_modules/d3-quadtree/src/extent.js
function extent_default2(_) {
  return arguments.length ? this.cover(+_[0][0], +_[0][1]).cover(+_[1][0], +_[1][1]) : isNaN(this._x0) ? void 0 : [[this._x0, this._y0], [this._x1, this._y1]];
}

// node_modules/d3-quadtree/src/quad.js
function quad_default(node, x07, y07, x13, y13) {
  this.node = node;
  this.x0 = x07;
  this.y0 = y07;
  this.x1 = x13;
  this.y1 = y13;
}

// node_modules/d3-quadtree/src/find.js
function find_default(x9, y9, radius2) {
  var data3, x07 = this._x0, y07 = this._y0, x13, y13, x22, y22, x32 = this._x1, y32 = this._y1, quads = [], node = this._root, q, i;
  if (node)
    quads.push(new quad_default(node, x07, y07, x32, y32));
  if (radius2 == null)
    radius2 = Infinity;
  else {
    x07 = x9 - radius2, y07 = y9 - radius2;
    x32 = x9 + radius2, y32 = y9 + radius2;
    radius2 *= radius2;
  }
  while (q = quads.pop()) {
    if (!(node = q.node) || (x13 = q.x0) > x32 || (y13 = q.y0) > y32 || (x22 = q.x1) < x07 || (y22 = q.y1) < y07)
      continue;
    if (node.length) {
      var xm = (x13 + x22) / 2, ym = (y13 + y22) / 2;
      quads.push(
        new quad_default(node[3], xm, ym, x22, y22),
        new quad_default(node[2], x13, ym, xm, y22),
        new quad_default(node[1], xm, y13, x22, ym),
        new quad_default(node[0], x13, y13, xm, ym)
      );
      if (i = (y9 >= ym) << 1 | x9 >= xm) {
        q = quads[quads.length - 1];
        quads[quads.length - 1] = quads[quads.length - 1 - i];
        quads[quads.length - 1 - i] = q;
      }
    } else {
      var dx = x9 - +this._x.call(null, node.data), dy = y9 - +this._y.call(null, node.data), d2 = dx * dx + dy * dy;
      if (d2 < radius2) {
        var d = Math.sqrt(radius2 = d2);
        x07 = x9 - d, y07 = y9 - d;
        x32 = x9 + d, y32 = y9 + d;
        data3 = node.data;
      }
    }
  }
  return data3;
}

// node_modules/d3-quadtree/src/remove.js
function remove_default(d) {
  if (isNaN(x9 = +this._x.call(null, d)) || isNaN(y9 = +this._y.call(null, d)))
    return this;
  var parent, node = this._root, retainer, previous, next, x07 = this._x0, y07 = this._y0, x13 = this._x1, y13 = this._y1, x9, y9, xm, ym, right, bottom, i, j;
  if (!node)
    return this;
  if (node.length)
    while (true) {
      if (right = x9 >= (xm = (x07 + x13) / 2))
        x07 = xm;
      else
        x13 = xm;
      if (bottom = y9 >= (ym = (y07 + y13) / 2))
        y07 = ym;
      else
        y13 = ym;
      if (!(parent = node, node = node[i = bottom << 1 | right]))
        return this;
      if (!node.length)
        break;
      if (parent[i + 1 & 3] || parent[i + 2 & 3] || parent[i + 3 & 3])
        retainer = parent, j = i;
    }
  while (node.data !== d)
    if (!(previous = node, node = node.next))
      return this;
  if (next = node.next)
    delete node.next;
  if (previous)
    return next ? previous.next = next : delete previous.next, this;
  if (!parent)
    return this._root = next, this;
  next ? parent[i] = next : delete parent[i];
  if ((node = parent[0] || parent[1] || parent[2] || parent[3]) && node === (parent[3] || parent[2] || parent[1] || parent[0]) && !node.length) {
    if (retainer)
      retainer[j] = node;
    else
      this._root = node;
  }
  return this;
}
function removeAll(data3) {
  for (var i = 0, n = data3.length; i < n; ++i)
    this.remove(data3[i]);
  return this;
}

// node_modules/d3-quadtree/src/root.js
function root_default() {
  return this._root;
}

// node_modules/d3-quadtree/src/size.js
function size_default() {
  var size = 0;
  this.visit(function(node) {
    if (!node.length)
      do
        ++size;
      while (node = node.next);
  });
  return size;
}

// node_modules/d3-quadtree/src/visit.js
function visit_default(callback) {
  var quads = [], q, node = this._root, child, x07, y07, x13, y13;
  if (node)
    quads.push(new quad_default(node, this._x0, this._y0, this._x1, this._y1));
  while (q = quads.pop()) {
    if (!callback(node = q.node, x07 = q.x0, y07 = q.y0, x13 = q.x1, y13 = q.y1) && node.length) {
      var xm = (x07 + x13) / 2, ym = (y07 + y13) / 2;
      if (child = node[3])
        quads.push(new quad_default(child, xm, ym, x13, y13));
      if (child = node[2])
        quads.push(new quad_default(child, x07, ym, xm, y13));
      if (child = node[1])
        quads.push(new quad_default(child, xm, y07, x13, ym));
      if (child = node[0])
        quads.push(new quad_default(child, x07, y07, xm, ym));
    }
  }
  return this;
}

// node_modules/d3-quadtree/src/visitAfter.js
function visitAfter_default(callback) {
  var quads = [], next = [], q;
  if (this._root)
    quads.push(new quad_default(this._root, this._x0, this._y0, this._x1, this._y1));
  while (q = quads.pop()) {
    var node = q.node;
    if (node.length) {
      var child, x07 = q.x0, y07 = q.y0, x13 = q.x1, y13 = q.y1, xm = (x07 + x13) / 2, ym = (y07 + y13) / 2;
      if (child = node[0])
        quads.push(new quad_default(child, x07, y07, xm, ym));
      if (child = node[1])
        quads.push(new quad_default(child, xm, y07, x13, ym));
      if (child = node[2])
        quads.push(new quad_default(child, x07, ym, xm, y13));
      if (child = node[3])
        quads.push(new quad_default(child, xm, ym, x13, y13));
    }
    next.push(q);
  }
  while (q = next.pop()) {
    callback(q.node, q.x0, q.y0, q.x1, q.y1);
  }
  return this;
}

// node_modules/d3-quadtree/src/x.js
function defaultX(d) {
  return d[0];
}
function x_default(_) {
  return arguments.length ? (this._x = _, this) : this._x;
}

// node_modules/d3-quadtree/src/y.js
function defaultY(d) {
  return d[1];
}
function y_default(_) {
  return arguments.length ? (this._y = _, this) : this._y;
}

// node_modules/d3-quadtree/src/quadtree.js
function quadtree(nodes, x9, y9) {
  var tree = new Quadtree(x9 == null ? defaultX : x9, y9 == null ? defaultY : y9, NaN, NaN, NaN, NaN);
  return nodes == null ? tree : tree.addAll(nodes);
}
function Quadtree(x9, y9, x07, y07, x13, y13) {
  this._x = x9;
  this._y = y9;
  this._x0 = x07;
  this._y0 = y07;
  this._x1 = x13;
  this._y1 = y13;
  this._root = void 0;
}
function leaf_copy(leaf) {
  var copy4 = { data: leaf.data }, next = copy4;
  while (leaf = leaf.next)
    next = next.next = { data: leaf.data };
  return copy4;
}
var treeProto = quadtree.prototype = Quadtree.prototype;
treeProto.copy = function() {
  var copy4 = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1), node = this._root, nodes, child;
  if (!node)
    return copy4;
  if (!node.length)
    return copy4._root = leaf_copy(node), copy4;
  nodes = [{ source: node, target: copy4._root = new Array(4) }];
  while (node = nodes.pop()) {
    for (var i = 0; i < 4; ++i) {
      if (child = node.source[i]) {
        if (child.length)
          nodes.push({ source: child, target: node.target[i] = new Array(4) });
        else
          node.target[i] = leaf_copy(child);
      }
    }
  }
  return copy4;
};
treeProto.add = add_default;
treeProto.addAll = addAll;
treeProto.cover = cover_default;
treeProto.data = data_default;
treeProto.extent = extent_default2;
treeProto.find = find_default;
treeProto.remove = remove_default;
treeProto.removeAll = removeAll;
treeProto.root = root_default;
treeProto.size = size_default;
treeProto.visit = visit_default;
treeProto.visitAfter = visitAfter_default;
treeProto.x = x_default;
treeProto.y = y_default;

// node_modules/d3-force/src/constant.js
function constant_default4(x9) {
  return function() {
    return x9;
  };
}

// node_modules/d3-force/src/jiggle.js
function jiggle_default(random2) {
  return (random2() - 0.5) * 1e-6;
}

// node_modules/d3-force/src/collide.js
function x3(d) {
  return d.x + d.vx;
}
function y3(d) {
  return d.y + d.vy;
}
function collide_default(radius2) {
  var nodes, radii, random2, strength = 1, iterations2 = 1;
  if (typeof radius2 !== "function")
    radius2 = constant_default4(radius2 == null ? 1 : +radius2);
  function force() {
    var i, n = nodes.length, tree, node, xi, yi, ri, ri2;
    for (var k3 = 0; k3 < iterations2; ++k3) {
      tree = quadtree(nodes, x3, y3).visitAfter(prepare2);
      for (i = 0; i < n; ++i) {
        node = nodes[i];
        ri = radii[node.index], ri2 = ri * ri;
        xi = node.x + node.vx;
        yi = node.y + node.vy;
        tree.visit(apply11);
      }
    }
    function apply11(quad2, x07, y07, x13, y13) {
      var data3 = quad2.data, rj = quad2.r, r = ri + rj;
      if (data3) {
        if (data3.index > node.index) {
          var x9 = xi - data3.x - data3.vx, y9 = yi - data3.y - data3.vy, l = x9 * x9 + y9 * y9;
          if (l < r * r) {
            if (x9 === 0)
              x9 = jiggle_default(random2), l += x9 * x9;
            if (y9 === 0)
              y9 = jiggle_default(random2), l += y9 * y9;
            l = (r - (l = Math.sqrt(l))) / l * strength;
            node.vx += (x9 *= l) * (r = (rj *= rj) / (ri2 + rj));
            node.vy += (y9 *= l) * r;
            data3.vx -= x9 * (r = 1 - r);
            data3.vy -= y9 * r;
          }
        }
        return;
      }
      return x07 > xi + r || x13 < xi - r || y07 > yi + r || y13 < yi - r;
    }
  }
  function prepare2(quad2) {
    if (quad2.data)
      return quad2.r = radii[quad2.data.index];
    for (var i = quad2.r = 0; i < 4; ++i) {
      if (quad2[i] && quad2[i].r > quad2.r) {
        quad2.r = quad2[i].r;
      }
    }
  }
  function initialize4() {
    if (!nodes)
      return;
    var i, n = nodes.length, node;
    radii = new Array(n);
    for (i = 0; i < n; ++i)
      node = nodes[i], radii[node.index] = +radius2(node, i, nodes);
  }
  force.initialize = function(_nodes, _random) {
    nodes = _nodes;
    random2 = _random;
    initialize4();
  };
  force.iterations = function(_) {
    return arguments.length ? (iterations2 = +_, force) : iterations2;
  };
  force.strength = function(_) {
    return arguments.length ? (strength = +_, force) : strength;
  };
  force.radius = function(_) {
    return arguments.length ? (radius2 = typeof _ === "function" ? _ : constant_default4(+_), initialize4(), force) : radius2;
  };
  return force;
}

// node_modules/d3-force/src/link.js
function index2(d) {
  return d.index;
}
function find2(nodeById, nodeId) {
  var node = nodeById.get(nodeId);
  if (!node)
    throw new Error("node not found: " + nodeId);
  return node;
}
function link_default(links) {
  var id24 = index2, strength = defaultStrength, strengths, distance = constant_default4(30), distances, nodes, count3, bias, random2, iterations2 = 1;
  if (links == null)
    links = [];
  function defaultStrength(link3) {
    return 1 / Math.min(count3[link3.source.index], count3[link3.target.index]);
  }
  function force(alpha) {
    for (var k3 = 0, n = links.length; k3 < iterations2; ++k3) {
      for (var i = 0, link3, source3, target2, x9, y9, l, b6; i < n; ++i) {
        link3 = links[i], source3 = link3.source, target2 = link3.target;
        x9 = target2.x + target2.vx - source3.x - source3.vx || jiggle_default(random2);
        y9 = target2.y + target2.vy - source3.y - source3.vy || jiggle_default(random2);
        l = Math.sqrt(x9 * x9 + y9 * y9);
        l = (l - distances[i]) / l * alpha * strengths[i];
        x9 *= l, y9 *= l;
        target2.vx -= x9 * (b6 = bias[i]);
        target2.vy -= y9 * b6;
        source3.vx += x9 * (b6 = 1 - b6);
        source3.vy += y9 * b6;
      }
    }
  }
  function initialize4() {
    if (!nodes)
      return;
    var i, n = nodes.length, m3 = links.length, nodeById = new Map(nodes.map((d, i2) => [id24(d, i2, nodes), d])), link3;
    for (i = 0, count3 = new Array(n); i < m3; ++i) {
      link3 = links[i], link3.index = i;
      if (typeof link3.source !== "object")
        link3.source = find2(nodeById, link3.source);
      if (typeof link3.target !== "object")
        link3.target = find2(nodeById, link3.target);
      count3[link3.source.index] = (count3[link3.source.index] || 0) + 1;
      count3[link3.target.index] = (count3[link3.target.index] || 0) + 1;
    }
    for (i = 0, bias = new Array(m3); i < m3; ++i) {
      link3 = links[i], bias[i] = count3[link3.source.index] / (count3[link3.source.index] + count3[link3.target.index]);
    }
    strengths = new Array(m3), initializeStrength();
    distances = new Array(m3), initializeDistance();
  }
  function initializeStrength() {
    if (!nodes)
      return;
    for (var i = 0, n = links.length; i < n; ++i) {
      strengths[i] = +strength(links[i], i, links);
    }
  }
  function initializeDistance() {
    if (!nodes)
      return;
    for (var i = 0, n = links.length; i < n; ++i) {
      distances[i] = +distance(links[i], i, links);
    }
  }
  force.initialize = function(_nodes, _random) {
    nodes = _nodes;
    random2 = _random;
    initialize4();
  };
  force.links = function(_) {
    return arguments.length ? (links = _, initialize4(), force) : links;
  };
  force.id = function(_) {
    return arguments.length ? (id24 = _, force) : id24;
  };
  force.iterations = function(_) {
    return arguments.length ? (iterations2 = +_, force) : iterations2;
  };
  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : constant_default4(+_), initializeStrength(), force) : strength;
  };
  force.distance = function(_) {
    return arguments.length ? (distance = typeof _ === "function" ? _ : constant_default4(+_), initializeDistance(), force) : distance;
  };
  return force;
}

// node_modules/d3-dispatch/src/dispatch.js
var noop4 = { value: () => {
} };
function dispatch() {
  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
    if (!(t = arguments[i] + "") || t in _ || /[\s.]/.test(t))
      throw new Error("illegal type: " + t);
    _[t] = [];
  }
  return new Dispatch(_);
}
function Dispatch(_) {
  this._ = _;
}
function parseTypenames(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0)
      name = t.slice(i + 1), t = t.slice(0, i);
    if (t && !types.hasOwnProperty(t))
      throw new Error("unknown type: " + t);
    return { type: t, name };
  });
}
Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function(typename, callback) {
    var _ = this._, T = parseTypenames(typename + "", _), t, i = -1, n = T.length;
    if (arguments.length < 2) {
      while (++i < n)
        if ((t = (typename = T[i]).type) && (t = get6(_[t], typename.name)))
          return t;
      return;
    }
    if (callback != null && typeof callback !== "function")
      throw new Error("invalid callback: " + callback);
    while (++i < n) {
      if (t = (typename = T[i]).type)
        _[t] = set5(_[t], typename.name, callback);
      else if (callback == null)
        for (t in _)
          _[t] = set5(_[t], typename.name, null);
    }
    return this;
  },
  copy: function() {
    var copy4 = {}, _ = this._;
    for (var t in _)
      copy4[t] = _[t].slice();
    return new Dispatch(copy4);
  },
  call: function(type7, that) {
    if ((n = arguments.length - 2) > 0)
      for (var args = new Array(n), i = 0, n, t; i < n; ++i)
        args[i] = arguments[i + 2];
    if (!this._.hasOwnProperty(type7))
      throw new Error("unknown type: " + type7);
    for (t = this._[type7], i = 0, n = t.length; i < n; ++i)
      t[i].value.apply(that, args);
  },
  apply: function(type7, that, args) {
    if (!this._.hasOwnProperty(type7))
      throw new Error("unknown type: " + type7);
    for (var t = this._[type7], i = 0, n = t.length; i < n; ++i)
      t[i].value.apply(that, args);
  }
};
function get6(type7, name) {
  for (var i = 0, n = type7.length, c5; i < n; ++i) {
    if ((c5 = type7[i]).name === name) {
      return c5.value;
    }
  }
}
function set5(type7, name, callback) {
  for (var i = 0, n = type7.length; i < n; ++i) {
    if (type7[i].name === name) {
      type7[i] = noop4, type7 = type7.slice(0, i).concat(type7.slice(i + 1));
      break;
    }
  }
  if (callback != null)
    type7.push({ name, value: callback });
  return type7;
}
var dispatch_default = dispatch;

// node_modules/d3-timer/src/timer.js
var frame = 0;
var timeout = 0;
var interval = 0;
var pokeDelay = 1e3;
var taskHead;
var taskTail;
var clockLast = 0;
var clockNow = 0;
var clockSkew = 0;
var clock = typeof performance === "object" && performance.now ? performance : Date;
var setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) {
  setTimeout(f, 17);
};
function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}
function clearNow() {
  clockNow = 0;
}
function Timer() {
  this._call = this._time = this._next = null;
}
Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function(callback, delay, time3) {
    if (typeof callback !== "function")
      throw new TypeError("callback is not a function");
    time3 = (time3 == null ? now() : +time3) + (delay == null ? 0 : +delay);
    if (!this._next && taskTail !== this) {
      if (taskTail)
        taskTail._next = this;
      else
        taskHead = this;
      taskTail = this;
    }
    this._call = callback;
    this._time = time3;
    sleep();
  },
  stop: function() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep();
    }
  }
};
function timer(callback, delay, time3) {
  var t = new Timer();
  t.restart(callback, delay, time3);
  return t;
}
function timerFlush() {
  now();
  ++frame;
  var t = taskHead, e3;
  while (t) {
    if ((e3 = clockNow - t._time) >= 0)
      t._call.call(void 0, e3);
    t = t._next;
  }
  --frame;
}
function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  frame = timeout = 0;
  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}
function poke() {
  var now2 = clock.now(), delay = now2 - clockLast;
  if (delay > pokeDelay)
    clockSkew -= delay, clockLast = now2;
}
function nap() {
  var t014, t13 = taskHead, t22, time3 = Infinity;
  while (t13) {
    if (t13._call) {
      if (time3 > t13._time)
        time3 = t13._time;
      t014 = t13, t13 = t13._next;
    } else {
      t22 = t13._next, t13._next = null;
      t13 = t014 ? t014._next = t22 : taskHead = t22;
    }
  }
  taskTail = t014;
  sleep(time3);
}
function sleep(time3) {
  if (frame)
    return;
  if (timeout)
    timeout = clearTimeout(timeout);
  var delay = time3 - clockNow;
  if (delay > 24) {
    if (time3 < Infinity)
      timeout = setTimeout(wake, time3 - clock.now() - clockSkew);
    if (interval)
      interval = clearInterval(interval);
  } else {
    if (!interval)
      clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}

// node_modules/d3-timer/src/interval.js
function interval_default(callback, delay, time3) {
  var t = new Timer(), total = delay;
  if (delay == null)
    return t.restart(callback, delay, time3), t;
  t._restart = t.restart;
  t.restart = function(callback2, delay2, time4) {
    delay2 = +delay2, time4 = time4 == null ? now() : +time4;
    t._restart(function tick2(elapsed) {
      elapsed += total;
      t._restart(tick2, total += delay2, time4);
      callback2(elapsed);
    }, delay2, time4);
  };
  t.restart(callback, delay, time3);
  return t;
}

// node_modules/d3-force/src/lcg.js
var a2 = 1664525;
var c3 = 1013904223;
var m = 4294967296;
function lcg_default() {
  let s2 = 1;
  return () => (s2 = (a2 * s2 + c3) % m) / m;
}

// node_modules/d3-force/src/simulation.js
function x4(d) {
  return d.x;
}
function y4(d) {
  return d.y;
}
var initialRadius = 10;
var initialAngle = Math.PI * (3 - Math.sqrt(5));
function simulation_default(nodes) {
  var simulation2, alpha = 1, alphaMin = 1e-3, alphaDecay = 1 - Math.pow(alphaMin, 1 / 300), alphaTarget = 0, velocityDecay = 0.6, forces = /* @__PURE__ */ new Map(), stepper = timer(step), event2 = dispatch_default("tick", "end"), random2 = lcg_default();
  if (nodes == null)
    nodes = [];
  function step() {
    tick2();
    event2.call("tick", simulation2);
    if (alpha < alphaMin) {
      stepper.stop();
      event2.call("end", simulation2);
    }
  }
  function tick2(iterations2) {
    var i, n = nodes.length, node;
    if (iterations2 === void 0)
      iterations2 = 1;
    for (var k3 = 0; k3 < iterations2; ++k3) {
      alpha += (alphaTarget - alpha) * alphaDecay;
      forces.forEach(function(force) {
        force(alpha);
      });
      for (i = 0; i < n; ++i) {
        node = nodes[i];
        if (node.fx == null)
          node.x += node.vx *= velocityDecay;
        else
          node.x = node.fx, node.vx = 0;
        if (node.fy == null)
          node.y += node.vy *= velocityDecay;
        else
          node.y = node.fy, node.vy = 0;
      }
    }
    return simulation2;
  }
  function initializeNodes() {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.index = i;
      if (node.fx != null)
        node.x = node.fx;
      if (node.fy != null)
        node.y = node.fy;
      if (isNaN(node.x) || isNaN(node.y)) {
        var radius2 = initialRadius * Math.sqrt(0.5 + i), angle2 = i * initialAngle;
        node.x = radius2 * Math.cos(angle2);
        node.y = radius2 * Math.sin(angle2);
      }
      if (isNaN(node.vx) || isNaN(node.vy)) {
        node.vx = node.vy = 0;
      }
    }
  }
  function initializeForce(force) {
    if (force.initialize)
      force.initialize(nodes, random2);
    return force;
  }
  initializeNodes();
  return simulation2 = {
    tick: tick2,
    restart: function() {
      return stepper.restart(step), simulation2;
    },
    stop: function() {
      return stepper.stop(), simulation2;
    },
    nodes: function(_) {
      return arguments.length ? (nodes = _, initializeNodes(), forces.forEach(initializeForce), simulation2) : nodes;
    },
    alpha: function(_) {
      return arguments.length ? (alpha = +_, simulation2) : alpha;
    },
    alphaMin: function(_) {
      return arguments.length ? (alphaMin = +_, simulation2) : alphaMin;
    },
    alphaDecay: function(_) {
      return arguments.length ? (alphaDecay = +_, simulation2) : +alphaDecay;
    },
    alphaTarget: function(_) {
      return arguments.length ? (alphaTarget = +_, simulation2) : alphaTarget;
    },
    velocityDecay: function(_) {
      return arguments.length ? (velocityDecay = 1 - _, simulation2) : 1 - velocityDecay;
    },
    randomSource: function(_) {
      return arguments.length ? (random2 = _, forces.forEach(initializeForce), simulation2) : random2;
    },
    force: function(name, _) {
      return arguments.length > 1 ? (_ == null ? forces.delete(name) : forces.set(name, initializeForce(_)), simulation2) : forces.get(name);
    },
    find: function(x9, y9, radius2) {
      var i = 0, n = nodes.length, dx, dy, d2, node, closest;
      if (radius2 == null)
        radius2 = Infinity;
      else
        radius2 *= radius2;
      for (i = 0; i < n; ++i) {
        node = nodes[i];
        dx = x9 - node.x;
        dy = y9 - node.y;
        d2 = dx * dx + dy * dy;
        if (d2 < radius2)
          closest = node, radius2 = d2;
      }
      return closest;
    },
    on: function(name, _) {
      return arguments.length > 1 ? (event2.on(name, _), simulation2) : event2.on(name);
    }
  };
}

// node_modules/d3-force/src/manyBody.js
function manyBody_default() {
  var nodes, node, random2, alpha, strength = constant_default4(-30), strengths, distanceMin2 = 1, distanceMax2 = Infinity, theta2 = 0.81;
  function force(_) {
    var i, n = nodes.length, tree = quadtree(nodes, x4, y4).visitAfter(accumulate);
    for (alpha = _, i = 0; i < n; ++i)
      node = nodes[i], tree.visit(apply11);
  }
  function initialize4() {
    if (!nodes)
      return;
    var i, n = nodes.length, node2;
    strengths = new Array(n);
    for (i = 0; i < n; ++i)
      node2 = nodes[i], strengths[node2.index] = +strength(node2, i, nodes);
  }
  function accumulate(quad2) {
    var strength2 = 0, q, c5, weight = 0, x9, y9, i;
    if (quad2.length) {
      for (x9 = y9 = i = 0; i < 4; ++i) {
        if ((q = quad2[i]) && (c5 = Math.abs(q.value))) {
          strength2 += q.value, weight += c5, x9 += c5 * q.x, y9 += c5 * q.y;
        }
      }
      quad2.x = x9 / weight;
      quad2.y = y9 / weight;
    } else {
      q = quad2;
      q.x = q.data.x;
      q.y = q.data.y;
      do
        strength2 += strengths[q.data.index];
      while (q = q.next);
    }
    quad2.value = strength2;
  }
  function apply11(quad2, x13, _, x22) {
    if (!quad2.value)
      return true;
    var x9 = quad2.x - node.x, y9 = quad2.y - node.y, w8 = x22 - x13, l = x9 * x9 + y9 * y9;
    if (w8 * w8 / theta2 < l) {
      if (l < distanceMax2) {
        if (x9 === 0)
          x9 = jiggle_default(random2), l += x9 * x9;
        if (y9 === 0)
          y9 = jiggle_default(random2), l += y9 * y9;
        if (l < distanceMin2)
          l = Math.sqrt(distanceMin2 * l);
        node.vx += x9 * quad2.value * alpha / l;
        node.vy += y9 * quad2.value * alpha / l;
      }
      return true;
    } else if (quad2.length || l >= distanceMax2)
      return;
    if (quad2.data !== node || quad2.next) {
      if (x9 === 0)
        x9 = jiggle_default(random2), l += x9 * x9;
      if (y9 === 0)
        y9 = jiggle_default(random2), l += y9 * y9;
      if (l < distanceMin2)
        l = Math.sqrt(distanceMin2 * l);
    }
    do
      if (quad2.data !== node) {
        w8 = strengths[quad2.data.index] * alpha / l;
        node.vx += x9 * w8;
        node.vy += y9 * w8;
      }
    while (quad2 = quad2.next);
  }
  force.initialize = function(_nodes, _random) {
    nodes = _nodes;
    random2 = _random;
    initialize4();
  };
  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : constant_default4(+_), initialize4(), force) : strength;
  };
  force.distanceMin = function(_) {
    return arguments.length ? (distanceMin2 = _ * _, force) : Math.sqrt(distanceMin2);
  };
  force.distanceMax = function(_) {
    return arguments.length ? (distanceMax2 = _ * _, force) : Math.sqrt(distanceMax2);
  };
  force.theta = function(_) {
    return arguments.length ? (theta2 = _ * _, force) : Math.sqrt(theta2);
  };
  return force;
}

// node_modules/d3-force/src/x.js
function x_default2(x9) {
  var strength = constant_default4(0.1), nodes, strengths, xz;
  if (typeof x9 !== "function")
    x9 = constant_default4(x9 == null ? 0 : +x9);
  function force(alpha) {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.vx += (xz[i] - node.x) * strengths[i] * alpha;
    }
  }
  function initialize4() {
    if (!nodes)
      return;
    var i, n = nodes.length;
    strengths = new Array(n);
    xz = new Array(n);
    for (i = 0; i < n; ++i) {
      strengths[i] = isNaN(xz[i] = +x9(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
    }
  }
  force.initialize = function(_) {
    nodes = _;
    initialize4();
  };
  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : constant_default4(+_), initialize4(), force) : strength;
  };
  force.x = function(_) {
    return arguments.length ? (x9 = typeof _ === "function" ? _ : constant_default4(+_), initialize4(), force) : x9;
  };
  return force;
}

// node_modules/d3-force/src/y.js
function y_default2(y9) {
  var strength = constant_default4(0.1), nodes, strengths, yz;
  if (typeof y9 !== "function")
    y9 = constant_default4(y9 == null ? 0 : +y9);
  function force(alpha) {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.vy += (yz[i] - node.y) * strengths[i] * alpha;
    }
  }
  function initialize4() {
    if (!nodes)
      return;
    var i, n = nodes.length;
    strengths = new Array(n);
    yz = new Array(n);
    for (i = 0; i < n; ++i) {
      strengths[i] = isNaN(yz[i] = +y9(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
    }
  }
  force.initialize = function(_) {
    nodes = _;
    initialize4();
  };
  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : constant_default4(+_), initialize4(), force) : strength;
  };
  force.y = function(_) {
    return arguments.length ? (y9 = typeof _ === "function" ? _ : constant_default4(+_), initialize4(), force) : y9;
  };
  return force;
}

// node_modules/vega-force/build/vega-force.js
var ForceMap = {
  center: center_default,
  collide: collide_default,
  nbody: manyBody_default,
  link: link_default,
  x: x_default2,
  y: y_default2
};
var Forces = "forces";
var ForceParams = ["alpha", "alphaMin", "alphaTarget", "velocityDecay", "forces"];
var ForceConfig = ["static", "iterations"];
var ForceOutput = ["x", "y", "vx", "vy"];
function Force(params2) {
  Transform.call(this, null, params2);
}
Force.Definition = {
  "type": "Force",
  "metadata": {
    "modifies": true
  },
  "params": [{
    "name": "static",
    "type": "boolean",
    "default": false
  }, {
    "name": "restart",
    "type": "boolean",
    "default": false
  }, {
    "name": "iterations",
    "type": "number",
    "default": 300
  }, {
    "name": "alpha",
    "type": "number",
    "default": 1
  }, {
    "name": "alphaMin",
    "type": "number",
    "default": 1e-3
  }, {
    "name": "alphaTarget",
    "type": "number",
    "default": 0
  }, {
    "name": "velocityDecay",
    "type": "number",
    "default": 0.4
  }, {
    "name": "forces",
    "type": "param",
    "array": true,
    "params": [{
      "key": {
        "force": "center"
      },
      "params": [{
        "name": "x",
        "type": "number",
        "default": 0
      }, {
        "name": "y",
        "type": "number",
        "default": 0
      }]
    }, {
      "key": {
        "force": "collide"
      },
      "params": [{
        "name": "radius",
        "type": "number",
        "expr": true
      }, {
        "name": "strength",
        "type": "number",
        "default": 0.7
      }, {
        "name": "iterations",
        "type": "number",
        "default": 1
      }]
    }, {
      "key": {
        "force": "nbody"
      },
      "params": [{
        "name": "strength",
        "type": "number",
        "default": -30,
        "expr": true
      }, {
        "name": "theta",
        "type": "number",
        "default": 0.9
      }, {
        "name": "distanceMin",
        "type": "number",
        "default": 1
      }, {
        "name": "distanceMax",
        "type": "number"
      }]
    }, {
      "key": {
        "force": "link"
      },
      "params": [{
        "name": "links",
        "type": "data"
      }, {
        "name": "id",
        "type": "field"
      }, {
        "name": "distance",
        "type": "number",
        "default": 30,
        "expr": true
      }, {
        "name": "strength",
        "type": "number",
        "expr": true
      }, {
        "name": "iterations",
        "type": "number",
        "default": 1
      }]
    }, {
      "key": {
        "force": "x"
      },
      "params": [{
        "name": "strength",
        "type": "number",
        "default": 0.1
      }, {
        "name": "x",
        "type": "field"
      }]
    }, {
      "key": {
        "force": "y"
      },
      "params": [{
        "name": "strength",
        "type": "number",
        "default": 0.1
      }, {
        "name": "y",
        "type": "field"
      }]
    }]
  }, {
    "name": "as",
    "type": "string",
    "array": true,
    "modify": false,
    "default": ForceOutput
  }]
};
inherits7(Force, Transform, {
  transform(_, pulse2) {
    var sim = this.value, change2 = pulse2.changed(pulse2.ADD_REM), params2 = _.modified(ForceParams), iters = _.iterations || 300;
    if (!sim) {
      this.value = sim = simulation(pulse2.source, _);
      sim.on("tick", rerun(pulse2.dataflow, this));
      if (!_.static) {
        change2 = true;
        sim.tick();
      }
      pulse2.modifies("index");
    } else {
      if (change2) {
        pulse2.modifies("index");
        sim.nodes(pulse2.source);
      }
      if (params2 || pulse2.changed(pulse2.MOD)) {
        setup(sim, _, 0, pulse2);
      }
    }
    if (params2 || change2 || _.modified(ForceConfig) || pulse2.changed() && _.restart) {
      sim.alpha(Math.max(sim.alpha(), _.alpha || 1)).alphaDecay(1 - Math.pow(sim.alphaMin(), 1 / iters));
      if (_.static) {
        for (sim.stop(); --iters >= 0; )
          sim.tick();
      } else {
        if (sim.stopped())
          sim.restart();
        if (!change2)
          return pulse2.StopPropagation;
      }
    }
    return this.finish(_, pulse2);
  },
  finish(_, pulse2) {
    const dataflow = pulse2.dataflow;
    for (let args = this._argops, j = 0, m3 = args.length, arg; j < m3; ++j) {
      arg = args[j];
      if (arg.name !== Forces || arg.op._argval.force !== "link") {
        continue;
      }
      for (var ops2 = arg.op._argops, i = 0, n = ops2.length, op; i < n; ++i) {
        if (ops2[i].name === "links" && (op = ops2[i].op.source)) {
          dataflow.pulse(op, dataflow.changeset().reflow());
          break;
        }
      }
    }
    return pulse2.reflow(_.modified()).modifies(ForceOutput);
  }
});
function rerun(df, op) {
  return () => df.touch(op).run();
}
function simulation(nodes, _) {
  const sim = simulation_default(nodes), stop2 = sim.stop, restart = sim.restart;
  let stopped = false;
  sim.stopped = () => stopped;
  sim.restart = () => (stopped = false, restart());
  sim.stop = () => (stopped = true, stop2());
  return setup(sim, _, true).on("end", () => stopped = true);
}
function setup(sim, _, init2, pulse2) {
  var f = array9(_.forces), i, n, p, name;
  for (i = 0, n = ForceParams.length; i < n; ++i) {
    p = ForceParams[i];
    if (p !== Forces && _.modified(p))
      sim[p](_[p]);
  }
  for (i = 0, n = f.length; i < n; ++i) {
    name = Forces + i;
    p = init2 || _.modified(Forces, i) ? getForce(f[i]) : pulse2 && modified(f[i], pulse2) ? sim.force(name) : null;
    if (p)
      sim.force(name, p);
  }
  for (n = sim.numForces || 0; i < n; ++i) {
    sim.force(Forces + i, null);
  }
  sim.numForces = f.length;
  return sim;
}
function modified(f, pulse2) {
  var k3, v2;
  for (k3 in f) {
    if (isFunction7(v2 = f[k3]) && pulse2.modified(accessorFields4(v2)))
      return 1;
  }
  return 0;
}
function getForce(_) {
  var f, p;
  if (!has7(ForceMap, _.force)) {
    error8("Unrecognized force: " + _.force);
  }
  f = ForceMap[_.force]();
  for (p in _) {
    if (isFunction7(f[p]))
      setForceParam(f[p], _[p], _);
  }
  return f;
}
function setForceParam(f, v2, _) {
  f(isFunction7(v2) ? (d) => v2(d, _) : v2);
}

// node_modules/vega-hierarchy/build/vega-hierarchy.js
var vega_hierarchy_exports = {};
__export(vega_hierarchy_exports, {
  nest: () => Nest,
  pack: () => Pack,
  partition: () => Partition,
  stratify: () => Stratify,
  tree: () => Tree,
  treelinks: () => TreeLinks,
  treemap: () => Treemap
});

// node_modules/vega-hierarchy/node_modules/vega-util/build/vega-util.js
function accessor9(fn, fields, name) {
  fn.fields = fields || [];
  fn.fname = name;
  return fn;
}
function getter9(path7) {
  return path7.length === 1 ? get19(path7[0]) : getN9(path7);
}
var get19 = (field25) => function(obj) {
  return obj[field25];
};
var getN9 = (path7) => {
  const len = path7.length;
  return function(obj) {
    for (let i = 0; i < len; ++i) {
      obj = obj[path7[i]];
    }
    return obj;
  };
};
function error9(message) {
  throw Error(message);
}
function splitAccessPath9(p) {
  const path7 = [], n = p.length;
  let q = null, b6 = 0, s2 = "", i, j, c5;
  p = p + "";
  function push() {
    path7.push(s2 + p.substring(i, j));
    s2 = "";
    i = j + 1;
  }
  for (i = j = 0; j < n; ++j) {
    c5 = p[j];
    if (c5 === "\\") {
      s2 += p.substring(i, j++);
      i = j;
    } else if (c5 === q) {
      push();
      q = null;
      b6 = -1;
    } else if (q) {
      continue;
    } else if (i === b6 && c5 === '"') {
      i = j + 1;
      q = c5;
    } else if (i === b6 && c5 === "'") {
      i = j + 1;
      q = c5;
    } else if (c5 === "." && !b6) {
      if (j > i) {
        push();
      } else {
        i = j + 1;
      }
    } else if (c5 === "[") {
      if (j > i)
        push();
      b6 = i = j + 1;
    } else if (c5 === "]") {
      if (!b6)
        error9("Access path missing open bracket: " + p);
      if (b6 > 0)
        push();
      b6 = 0;
      i = j + 1;
    }
  }
  if (b6)
    error9("Access path missing closing bracket: " + p);
  if (q)
    error9("Access path missing closing quote: " + p);
  if (j > i) {
    j++;
    push();
  }
  return path7;
}
function field9(field25, name, opt) {
  const path7 = splitAccessPath9(field25);
  field25 = path7.length === 1 ? path7[0] : field25;
  return accessor9((opt && opt.get || getter9)(path7), [field25], name || field25);
}
var id9 = field9("id");
var identity13 = accessor9((_) => _, [], "identity");
var zero11 = accessor9(() => 0, [], "zero");
var one10 = accessor9(() => 1, [], "one");
var truthy9 = accessor9(() => true, [], "true");
var falsy9 = accessor9(() => false, [], "false");
var DisallowedObjectProperties9 = /* @__PURE__ */ new Set([...Object.getOwnPropertyNames(Object.prototype).filter((name) => typeof Object.prototype[name] === "function"), "__proto__"]);
var isArray9 = Array.isArray;
function array10(_) {
  return _ != null ? isArray9(_) ? _ : [_] : [];
}
function extend10(_) {
  for (let x9, k3, i = 1, len = arguments.length; i < len; ++i) {
    x9 = arguments[i];
    for (k3 in x9) {
      _[k3] = x9[k3];
    }
  }
  return _;
}
function has8(object2, property2) {
  return Object.hasOwn(object2, property2);
}
function inherits8(child, parent, members) {
  const proto = child.prototype = Object.create(parent.prototype);
  Object.defineProperty(proto, "constructor", {
    value: child,
    writable: true,
    enumerable: true,
    configurable: true
  });
  return extend10(proto, members);
}

// node_modules/d3-hierarchy/src/cluster.js
function defaultSeparation(a4, b6) {
  return a4.parent === b6.parent ? 1 : 2;
}
function meanX(children3) {
  return children3.reduce(meanXReduce, 0) / children3.length;
}
function meanXReduce(x9, c5) {
  return x9 + c5.x;
}
function maxY(children3) {
  return 1 + children3.reduce(maxYReduce, 0);
}
function maxYReduce(y9, c5) {
  return Math.max(y9, c5.y);
}
function leafLeft(node) {
  var children3;
  while (children3 = node.children)
    node = children3[0];
  return node;
}
function leafRight(node) {
  var children3;
  while (children3 = node.children)
    node = children3[children3.length - 1];
  return node;
}
function cluster_default() {
  var separation = defaultSeparation, dx = 1, dy = 1, nodeSize = false;
  function cluster(root) {
    var previousNode, x9 = 0;
    root.eachAfter(function(node) {
      var children3 = node.children;
      if (children3) {
        node.x = meanX(children3);
        node.y = maxY(children3);
      } else {
        node.x = previousNode ? x9 += separation(node, previousNode) : 0;
        node.y = 0;
        previousNode = node;
      }
    });
    var left = leafLeft(root), right = leafRight(root), x07 = left.x - separation(left, right) / 2, x13 = right.x + separation(right, left) / 2;
    return root.eachAfter(nodeSize ? function(node) {
      node.x = (node.x - root.x) * dx;
      node.y = (root.y - node.y) * dy;
    } : function(node) {
      node.x = (node.x - x07) / (x13 - x07) * dx;
      node.y = (1 - (root.y ? node.y / root.y : 1)) * dy;
    });
  }
  cluster.separation = function(x9) {
    return arguments.length ? (separation = x9, cluster) : separation;
  };
  cluster.size = function(x9) {
    return arguments.length ? (nodeSize = false, dx = +x9[0], dy = +x9[1], cluster) : nodeSize ? null : [dx, dy];
  };
  cluster.nodeSize = function(x9) {
    return arguments.length ? (nodeSize = true, dx = +x9[0], dy = +x9[1], cluster) : nodeSize ? [dx, dy] : null;
  };
  return cluster;
}

// node_modules/d3-hierarchy/src/hierarchy/count.js
function count2(node) {
  var sum4 = 0, children3 = node.children, i = children3 && children3.length;
  if (!i)
    sum4 = 1;
  else
    while (--i >= 0)
      sum4 += children3[i].value;
  node.value = sum4;
}
function count_default() {
  return this.eachAfter(count2);
}

// node_modules/d3-hierarchy/src/hierarchy/each.js
function each_default(callback, that) {
  let index4 = -1;
  for (const node of this) {
    callback.call(that, node, ++index4, this);
  }
  return this;
}

// node_modules/d3-hierarchy/src/hierarchy/eachBefore.js
function eachBefore_default(callback, that) {
  var node = this, nodes = [node], children3, i, index4 = -1;
  while (node = nodes.pop()) {
    callback.call(that, node, ++index4, this);
    if (children3 = node.children) {
      for (i = children3.length - 1; i >= 0; --i) {
        nodes.push(children3[i]);
      }
    }
  }
  return this;
}

// node_modules/d3-hierarchy/src/hierarchy/eachAfter.js
function eachAfter_default(callback, that) {
  var node = this, nodes = [node], next = [], children3, i, n, index4 = -1;
  while (node = nodes.pop()) {
    next.push(node);
    if (children3 = node.children) {
      for (i = 0, n = children3.length; i < n; ++i) {
        nodes.push(children3[i]);
      }
    }
  }
  while (node = next.pop()) {
    callback.call(that, node, ++index4, this);
  }
  return this;
}

// node_modules/d3-hierarchy/src/hierarchy/find.js
function find_default2(callback, that) {
  let index4 = -1;
  for (const node of this) {
    if (callback.call(that, node, ++index4, this)) {
      return node;
    }
  }
}

// node_modules/d3-hierarchy/src/hierarchy/sum.js
function sum_default(value7) {
  return this.eachAfter(function(node) {
    var sum4 = +value7(node.data) || 0, children3 = node.children, i = children3 && children3.length;
    while (--i >= 0)
      sum4 += children3[i].value;
    node.value = sum4;
  });
}

// node_modules/d3-hierarchy/src/hierarchy/sort.js
function sort_default(compare10) {
  return this.eachBefore(function(node) {
    if (node.children) {
      node.children.sort(compare10);
    }
  });
}

// node_modules/d3-hierarchy/src/hierarchy/path.js
function path_default2(end) {
  var start = this, ancestor = leastCommonAncestor(start, end), nodes = [start];
  while (start !== ancestor) {
    start = start.parent;
    nodes.push(start);
  }
  var k3 = nodes.length;
  while (end !== ancestor) {
    nodes.splice(k3, 0, end);
    end = end.parent;
  }
  return nodes;
}
function leastCommonAncestor(a4, b6) {
  if (a4 === b6)
    return a4;
  var aNodes = a4.ancestors(), bNodes = b6.ancestors(), c5 = null;
  a4 = aNodes.pop();
  b6 = bNodes.pop();
  while (a4 === b6) {
    c5 = a4;
    a4 = aNodes.pop();
    b6 = bNodes.pop();
  }
  return c5;
}

// node_modules/d3-hierarchy/src/hierarchy/ancestors.js
function ancestors_default() {
  var node = this, nodes = [node];
  while (node = node.parent) {
    nodes.push(node);
  }
  return nodes;
}

// node_modules/d3-hierarchy/src/hierarchy/descendants.js
function descendants_default() {
  return Array.from(this);
}

// node_modules/d3-hierarchy/src/hierarchy/leaves.js
function leaves_default() {
  var leaves = [];
  this.eachBefore(function(node) {
    if (!node.children) {
      leaves.push(node);
    }
  });
  return leaves;
}

// node_modules/d3-hierarchy/src/hierarchy/links.js
function links_default() {
  var root = this, links = [];
  root.each(function(node) {
    if (node !== root) {
      links.push({ source: node.parent, target: node });
    }
  });
  return links;
}

// node_modules/d3-hierarchy/src/hierarchy/iterator.js
function* iterator_default() {
  var node = this, current2, next = [node], children3, i, n;
  do {
    current2 = next.reverse(), next = [];
    while (node = current2.pop()) {
      yield node;
      if (children3 = node.children) {
        for (i = 0, n = children3.length; i < n; ++i) {
          next.push(children3[i]);
        }
      }
    }
  } while (next.length);
}

// node_modules/d3-hierarchy/src/hierarchy/index.js
function hierarchy(data3, children3) {
  if (data3 instanceof Map) {
    data3 = [void 0, data3];
    if (children3 === void 0)
      children3 = mapChildren;
  } else if (children3 === void 0) {
    children3 = objectChildren;
  }
  var root = new Node(data3), node, nodes = [root], child, childs, i, n;
  while (node = nodes.pop()) {
    if ((childs = children3(node.data)) && (n = (childs = Array.from(childs)).length)) {
      node.children = childs;
      for (i = n - 1; i >= 0; --i) {
        nodes.push(child = childs[i] = new Node(childs[i]));
        child.parent = node;
        child.depth = node.depth + 1;
      }
    }
  }
  return root.eachBefore(computeHeight);
}
function node_copy() {
  return hierarchy(this).eachBefore(copyData);
}
function objectChildren(d) {
  return d.children;
}
function mapChildren(d) {
  return Array.isArray(d) ? d[1] : null;
}
function copyData(node) {
  if (node.data.value !== void 0)
    node.value = node.data.value;
  node.data = node.data.data;
}
function computeHeight(node) {
  var height2 = 0;
  do
    node.height = height2;
  while ((node = node.parent) && node.height < ++height2);
}
function Node(data3) {
  this.data = data3;
  this.depth = this.height = 0;
  this.parent = null;
}
Node.prototype = hierarchy.prototype = {
  constructor: Node,
  count: count_default,
  each: each_default,
  eachAfter: eachAfter_default,
  eachBefore: eachBefore_default,
  find: find_default2,
  sum: sum_default,
  sort: sort_default,
  path: path_default2,
  ancestors: ancestors_default,
  descendants: descendants_default,
  leaves: leaves_default,
  links: links_default,
  copy: node_copy,
  [Symbol.iterator]: iterator_default
};

// node_modules/d3-hierarchy/src/accessors.js
function optional(f) {
  return f == null ? null : required(f);
}
function required(f) {
  if (typeof f !== "function")
    throw new Error();
  return f;
}

// node_modules/d3-hierarchy/src/constant.js
function constantZero() {
  return 0;
}
function constant_default5(x9) {
  return function() {
    return x9;
  };
}

// node_modules/d3-hierarchy/src/lcg.js
var a3 = 1664525;
var c4 = 1013904223;
var m2 = 4294967296;
function lcg_default2() {
  let s2 = 1;
  return () => (s2 = (a3 * s2 + c4) % m2) / m2;
}

// node_modules/d3-hierarchy/src/array.js
function array_default3(x9) {
  return typeof x9 === "object" && "length" in x9 ? x9 : Array.from(x9);
}
function shuffle(array22, random2) {
  let m3 = array22.length, t, i;
  while (m3) {
    i = random2() * m3-- | 0;
    t = array22[m3];
    array22[m3] = array22[i];
    array22[i] = t;
  }
  return array22;
}

// node_modules/d3-hierarchy/src/pack/enclose.js
function packEncloseRandom(circles, random2) {
  var i = 0, n = (circles = shuffle(Array.from(circles), random2)).length, B4 = [], p, e3;
  while (i < n) {
    p = circles[i];
    if (e3 && enclosesWeak(e3, p))
      ++i;
    else
      e3 = encloseBasis(B4 = extendBasis(B4, p)), i = 0;
  }
  return e3;
}
function extendBasis(B4, p) {
  var i, j;
  if (enclosesWeakAll(p, B4))
    return [p];
  for (i = 0; i < B4.length; ++i) {
    if (enclosesNot(p, B4[i]) && enclosesWeakAll(encloseBasis2(B4[i], p), B4)) {
      return [B4[i], p];
    }
  }
  for (i = 0; i < B4.length - 1; ++i) {
    for (j = i + 1; j < B4.length; ++j) {
      if (enclosesNot(encloseBasis2(B4[i], B4[j]), p) && enclosesNot(encloseBasis2(B4[i], p), B4[j]) && enclosesNot(encloseBasis2(B4[j], p), B4[i]) && enclosesWeakAll(encloseBasis3(B4[i], B4[j], p), B4)) {
        return [B4[i], B4[j], p];
      }
    }
  }
  throw new Error();
}
function enclosesNot(a4, b6) {
  var dr = a4.r - b6.r, dx = b6.x - a4.x, dy = b6.y - a4.y;
  return dr < 0 || dr * dr < dx * dx + dy * dy;
}
function enclosesWeak(a4, b6) {
  var dr = a4.r - b6.r + Math.max(a4.r, b6.r, 1) * 1e-9, dx = b6.x - a4.x, dy = b6.y - a4.y;
  return dr > 0 && dr * dr > dx * dx + dy * dy;
}
function enclosesWeakAll(a4, B4) {
  for (var i = 0; i < B4.length; ++i) {
    if (!enclosesWeak(a4, B4[i])) {
      return false;
    }
  }
  return true;
}
function encloseBasis(B4) {
  switch (B4.length) {
    case 1:
      return encloseBasis1(B4[0]);
    case 2:
      return encloseBasis2(B4[0], B4[1]);
    case 3:
      return encloseBasis3(B4[0], B4[1], B4[2]);
  }
}
function encloseBasis1(a4) {
  return {
    x: a4.x,
    y: a4.y,
    r: a4.r
  };
}
function encloseBasis2(a4, b6) {
  var x13 = a4.x, y13 = a4.y, r1 = a4.r, x22 = b6.x, y22 = b6.y, r2 = b6.r, x21 = x22 - x13, y21 = y22 - y13, r21 = r2 - r1, l = Math.sqrt(x21 * x21 + y21 * y21);
  return {
    x: (x13 + x22 + x21 / l * r21) / 2,
    y: (y13 + y22 + y21 / l * r21) / 2,
    r: (l + r1 + r2) / 2
  };
}
function encloseBasis3(a4, b6, c5) {
  var x13 = a4.x, y13 = a4.y, r1 = a4.r, x22 = b6.x, y22 = b6.y, r2 = b6.r, x32 = c5.x, y32 = c5.y, r3 = c5.r, a22 = x13 - x22, a32 = x13 - x32, b22 = y13 - y22, b32 = y13 - y32, c22 = r2 - r1, c32 = r3 - r1, d1 = x13 * x13 + y13 * y13 - r1 * r1, d2 = d1 - x22 * x22 - y22 * y22 + r2 * r2, d3 = d1 - x32 * x32 - y32 * y32 + r3 * r3, ab4 = a32 * b22 - a22 * b32, xa = (b22 * d3 - b32 * d2) / (ab4 * 2) - x13, xb = (b32 * c22 - b22 * c32) / ab4, ya = (a32 * d2 - a22 * d3) / (ab4 * 2) - y13, yb = (a22 * c32 - a32 * c22) / ab4, A6 = xb * xb + yb * yb - 1, B4 = 2 * (r1 + xa * xb + ya * yb), C7 = xa * xa + ya * ya - r1 * r1, r = -(Math.abs(A6) > 1e-6 ? (B4 + Math.sqrt(B4 * B4 - 4 * A6 * C7)) / (2 * A6) : C7 / B4);
  return {
    x: x13 + xa + xb * r,
    y: y13 + ya + yb * r,
    r
  };
}

// node_modules/d3-hierarchy/src/pack/siblings.js
function place(b6, a4, c5) {
  var dx = b6.x - a4.x, x9, a22, dy = b6.y - a4.y, y9, b22, d2 = dx * dx + dy * dy;
  if (d2) {
    a22 = a4.r + c5.r, a22 *= a22;
    b22 = b6.r + c5.r, b22 *= b22;
    if (a22 > b22) {
      x9 = (d2 + b22 - a22) / (2 * d2);
      y9 = Math.sqrt(Math.max(0, b22 / d2 - x9 * x9));
      c5.x = b6.x - x9 * dx - y9 * dy;
      c5.y = b6.y - x9 * dy + y9 * dx;
    } else {
      x9 = (d2 + a22 - b22) / (2 * d2);
      y9 = Math.sqrt(Math.max(0, a22 / d2 - x9 * x9));
      c5.x = a4.x + x9 * dx - y9 * dy;
      c5.y = a4.y + x9 * dy + y9 * dx;
    }
  } else {
    c5.x = a4.x + c5.r;
    c5.y = a4.y;
  }
}
function intersects(a4, b6) {
  var dr = a4.r + b6.r - 1e-6, dx = b6.x - a4.x, dy = b6.y - a4.y;
  return dr > 0 && dr * dr > dx * dx + dy * dy;
}
function score(node) {
  var a4 = node._, b6 = node.next._, ab4 = a4.r + b6.r, dx = (a4.x * b6.r + b6.x * a4.r) / ab4, dy = (a4.y * b6.r + b6.y * a4.r) / ab4;
  return dx * dx + dy * dy;
}
function Node2(circle2) {
  this._ = circle2;
  this.next = null;
  this.previous = null;
}
function packSiblingsRandom(circles, random2) {
  if (!(n = (circles = array_default3(circles)).length))
    return 0;
  var a4, b6, c5, n, aa2, ca3, i, j, k3, sj, sk;
  a4 = circles[0], a4.x = 0, a4.y = 0;
  if (!(n > 1))
    return a4.r;
  b6 = circles[1], a4.x = -b6.r, b6.x = a4.r, b6.y = 0;
  if (!(n > 2))
    return a4.r + b6.r;
  place(b6, a4, c5 = circles[2]);
  a4 = new Node2(a4), b6 = new Node2(b6), c5 = new Node2(c5);
  a4.next = c5.previous = b6;
  b6.next = a4.previous = c5;
  c5.next = b6.previous = a4;
  pack:
    for (i = 3; i < n; ++i) {
      place(a4._, b6._, c5 = circles[i]), c5 = new Node2(c5);
      j = b6.next, k3 = a4.previous, sj = b6._.r, sk = a4._.r;
      do {
        if (sj <= sk) {
          if (intersects(j._, c5._)) {
            b6 = j, a4.next = b6, b6.previous = a4, --i;
            continue pack;
          }
          sj += j._.r, j = j.next;
        } else {
          if (intersects(k3._, c5._)) {
            a4 = k3, a4.next = b6, b6.previous = a4, --i;
            continue pack;
          }
          sk += k3._.r, k3 = k3.previous;
        }
      } while (j !== k3.next);
      c5.previous = a4, c5.next = b6, a4.next = b6.previous = b6 = c5;
      aa2 = score(a4);
      while ((c5 = c5.next) !== b6) {
        if ((ca3 = score(c5)) < aa2) {
          a4 = c5, aa2 = ca3;
        }
      }
      b6 = a4.next;
    }
  a4 = [b6._], c5 = b6;
  while ((c5 = c5.next) !== b6)
    a4.push(c5._);
  c5 = packEncloseRandom(a4, random2);
  for (i = 0; i < n; ++i)
    a4 = circles[i], a4.x -= c5.x, a4.y -= c5.y;
  return c5.r;
}

// node_modules/d3-hierarchy/src/pack/index.js
function defaultRadius(d) {
  return Math.sqrt(d.value);
}
function pack_default() {
  var radius2 = null, dx = 1, dy = 1, padding3 = constantZero;
  function pack(root) {
    const random2 = lcg_default2();
    root.x = dx / 2, root.y = dy / 2;
    if (radius2) {
      root.eachBefore(radiusLeaf(radius2)).eachAfter(packChildrenRandom(padding3, 0.5, random2)).eachBefore(translateChild(1));
    } else {
      root.eachBefore(radiusLeaf(defaultRadius)).eachAfter(packChildrenRandom(constantZero, 1, random2)).eachAfter(packChildrenRandom(padding3, root.r / Math.min(dx, dy), random2)).eachBefore(translateChild(Math.min(dx, dy) / (2 * root.r)));
    }
    return root;
  }
  pack.radius = function(x9) {
    return arguments.length ? (radius2 = optional(x9), pack) : radius2;
  };
  pack.size = function(x9) {
    return arguments.length ? (dx = +x9[0], dy = +x9[1], pack) : [dx, dy];
  };
  pack.padding = function(x9) {
    return arguments.length ? (padding3 = typeof x9 === "function" ? x9 : constant_default5(+x9), pack) : padding3;
  };
  return pack;
}
function radiusLeaf(radius2) {
  return function(node) {
    if (!node.children) {
      node.r = Math.max(0, +radius2(node) || 0);
    }
  };
}
function packChildrenRandom(padding3, k3, random2) {
  return function(node) {
    if (children3 = node.children) {
      var children3, i, n = children3.length, r = padding3(node) * k3 || 0, e3;
      if (r)
        for (i = 0; i < n; ++i)
          children3[i].r += r;
      e3 = packSiblingsRandom(children3, random2);
      if (r)
        for (i = 0; i < n; ++i)
          children3[i].r -= r;
      node.r = e3 + r;
    }
  };
}
function translateChild(k3) {
  return function(node) {
    var parent = node.parent;
    node.r *= k3;
    if (parent) {
      node.x = parent.x + k3 * node.x;
      node.y = parent.y + k3 * node.y;
    }
  };
}

// node_modules/d3-hierarchy/src/treemap/round.js
function round_default2(node) {
  node.x0 = Math.round(node.x0);
  node.y0 = Math.round(node.y0);
  node.x1 = Math.round(node.x1);
  node.y1 = Math.round(node.y1);
}

// node_modules/d3-hierarchy/src/treemap/dice.js
function dice_default(parent, x07, y07, x13, y13) {
  var nodes = parent.children, node, i = -1, n = nodes.length, k3 = parent.value && (x13 - x07) / parent.value;
  while (++i < n) {
    node = nodes[i], node.y0 = y07, node.y1 = y13;
    node.x0 = x07, node.x1 = x07 += node.value * k3;
  }
}

// node_modules/d3-hierarchy/src/partition.js
function partition_default() {
  var dx = 1, dy = 1, padding3 = 0, round2 = false;
  function partition5(root) {
    var n = root.height + 1;
    root.x0 = root.y0 = padding3;
    root.x1 = dx;
    root.y1 = dy / n;
    root.eachBefore(positionNode(dy, n));
    if (round2)
      root.eachBefore(round_default2);
    return root;
  }
  function positionNode(dy2, n) {
    return function(node) {
      if (node.children) {
        dice_default(node, node.x0, dy2 * (node.depth + 1) / n, node.x1, dy2 * (node.depth + 2) / n);
      }
      var x07 = node.x0, y07 = node.y0, x13 = node.x1 - padding3, y13 = node.y1 - padding3;
      if (x13 < x07)
        x07 = x13 = (x07 + x13) / 2;
      if (y13 < y07)
        y07 = y13 = (y07 + y13) / 2;
      node.x0 = x07;
      node.y0 = y07;
      node.x1 = x13;
      node.y1 = y13;
    };
  }
  partition5.round = function(x9) {
    return arguments.length ? (round2 = !!x9, partition5) : round2;
  };
  partition5.size = function(x9) {
    return arguments.length ? (dx = +x9[0], dy = +x9[1], partition5) : [dx, dy];
  };
  partition5.padding = function(x9) {
    return arguments.length ? (padding3 = +x9, partition5) : padding3;
  };
  return partition5;
}

// node_modules/d3-hierarchy/src/stratify.js
var preroot = { depth: -1 };
var ambiguous = {};
var imputed = {};
function defaultId(d) {
  return d.id;
}
function defaultParentId(d) {
  return d.parentId;
}
function stratify_default() {
  var id24 = defaultId, parentId = defaultParentId, path7;
  function stratify(data3) {
    var nodes = Array.from(data3), currentId = id24, currentParentId = parentId, n, d, i, root, parent, node, nodeId, nodeKey, nodeByKey = /* @__PURE__ */ new Map();
    if (path7 != null) {
      const I = nodes.map((d2, i2) => normalize2(path7(d2, i2, data3)));
      const P = I.map(parentof);
      const S = new Set(I).add("");
      for (const i2 of P) {
        if (!S.has(i2)) {
          S.add(i2);
          I.push(i2);
          P.push(parentof(i2));
          nodes.push(imputed);
        }
      }
      currentId = (_, i2) => I[i2];
      currentParentId = (_, i2) => P[i2];
    }
    for (i = 0, n = nodes.length; i < n; ++i) {
      d = nodes[i], node = nodes[i] = new Node(d);
      if ((nodeId = currentId(d, i, data3)) != null && (nodeId += "")) {
        nodeKey = node.id = nodeId;
        nodeByKey.set(nodeKey, nodeByKey.has(nodeKey) ? ambiguous : node);
      }
      if ((nodeId = currentParentId(d, i, data3)) != null && (nodeId += "")) {
        node.parent = nodeId;
      }
    }
    for (i = 0; i < n; ++i) {
      node = nodes[i];
      if (nodeId = node.parent) {
        parent = nodeByKey.get(nodeId);
        if (!parent)
          throw new Error("missing: " + nodeId);
        if (parent === ambiguous)
          throw new Error("ambiguous: " + nodeId);
        if (parent.children)
          parent.children.push(node);
        else
          parent.children = [node];
        node.parent = parent;
      } else {
        if (root)
          throw new Error("multiple roots");
        root = node;
      }
    }
    if (!root)
      throw new Error("no root");
    if (path7 != null) {
      while (root.data === imputed && root.children.length === 1) {
        root = root.children[0], --n;
      }
      for (let i2 = nodes.length - 1; i2 >= 0; --i2) {
        node = nodes[i2];
        if (node.data !== imputed)
          break;
        node.data = null;
      }
    }
    root.parent = preroot;
    root.eachBefore(function(node2) {
      node2.depth = node2.parent.depth + 1;
      --n;
    }).eachBefore(computeHeight);
    root.parent = null;
    if (n > 0)
      throw new Error("cycle");
    return root;
  }
  stratify.id = function(x9) {
    return arguments.length ? (id24 = optional(x9), stratify) : id24;
  };
  stratify.parentId = function(x9) {
    return arguments.length ? (parentId = optional(x9), stratify) : parentId;
  };
  stratify.path = function(x9) {
    return arguments.length ? (path7 = optional(x9), stratify) : path7;
  };
  return stratify;
}
function normalize2(path7) {
  path7 = `${path7}`;
  let i = path7.length;
  if (slash(path7, i - 1) && !slash(path7, i - 2))
    path7 = path7.slice(0, -1);
  return path7[0] === "/" ? path7 : `/${path7}`;
}
function parentof(path7) {
  let i = path7.length;
  if (i < 2)
    return "";
  while (--i > 1)
    if (slash(path7, i))
      break;
  return path7.slice(0, i);
}
function slash(path7, i) {
  if (path7[i] === "/") {
    let k3 = 0;
    while (i > 0 && path7[--i] === "\\")
      ++k3;
    if ((k3 & 1) === 0)
      return true;
  }
  return false;
}

// node_modules/d3-hierarchy/src/tree.js
function defaultSeparation2(a4, b6) {
  return a4.parent === b6.parent ? 1 : 2;
}
function nextLeft(v2) {
  var children3 = v2.children;
  return children3 ? children3[0] : v2.t;
}
function nextRight(v2) {
  var children3 = v2.children;
  return children3 ? children3[children3.length - 1] : v2.t;
}
function moveSubtree(wm, wp, shift) {
  var change2 = shift / (wp.i - wm.i);
  wp.c -= change2;
  wp.s += shift;
  wm.c += change2;
  wp.z += shift;
  wp.m += shift;
}
function executeShifts(v2) {
  var shift = 0, change2 = 0, children3 = v2.children, i = children3.length, w8;
  while (--i >= 0) {
    w8 = children3[i];
    w8.z += shift;
    w8.m += shift;
    shift += w8.s + (change2 += w8.c);
  }
}
function nextAncestor(vim, v2, ancestor) {
  return vim.a.parent === v2.parent ? vim.a : ancestor;
}
function TreeNode(node, i) {
  this._ = node;
  this.parent = null;
  this.children = null;
  this.A = null;
  this.a = this;
  this.z = 0;
  this.m = 0;
  this.c = 0;
  this.s = 0;
  this.t = null;
  this.i = i;
}
TreeNode.prototype = Object.create(Node.prototype);
function treeRoot(root) {
  var tree = new TreeNode(root, 0), node, nodes = [tree], child, children3, i, n;
  while (node = nodes.pop()) {
    if (children3 = node._.children) {
      node.children = new Array(n = children3.length);
      for (i = n - 1; i >= 0; --i) {
        nodes.push(child = node.children[i] = new TreeNode(children3[i], i));
        child.parent = node;
      }
    }
  }
  (tree.parent = new TreeNode(null, 0)).children = [tree];
  return tree;
}
function tree_default() {
  var separation = defaultSeparation2, dx = 1, dy = 1, nodeSize = null;
  function tree(root) {
    var t = treeRoot(root);
    t.eachAfter(firstWalk), t.parent.m = -t.z;
    t.eachBefore(secondWalk);
    if (nodeSize)
      root.eachBefore(sizeNode);
    else {
      var left = root, right = root, bottom = root;
      root.eachBefore(function(node) {
        if (node.x < left.x)
          left = node;
        if (node.x > right.x)
          right = node;
        if (node.depth > bottom.depth)
          bottom = node;
      });
      var s2 = left === right ? 1 : separation(left, right) / 2, tx = s2 - left.x, kx3 = dx / (right.x + s2 + tx), ky2 = dy / (bottom.depth || 1);
      root.eachBefore(function(node) {
        node.x = (node.x + tx) * kx3;
        node.y = node.depth * ky2;
      });
    }
    return root;
  }
  function firstWalk(v2) {
    var children3 = v2.children, siblings = v2.parent.children, w8 = v2.i ? siblings[v2.i - 1] : null;
    if (children3) {
      executeShifts(v2);
      var midpoint = (children3[0].z + children3[children3.length - 1].z) / 2;
      if (w8) {
        v2.z = w8.z + separation(v2._, w8._);
        v2.m = v2.z - midpoint;
      } else {
        v2.z = midpoint;
      }
    } else if (w8) {
      v2.z = w8.z + separation(v2._, w8._);
    }
    v2.parent.A = apportion(v2, w8, v2.parent.A || siblings[0]);
  }
  function secondWalk(v2) {
    v2._.x = v2.z + v2.parent.m;
    v2.m += v2.parent.m;
  }
  function apportion(v2, w8, ancestor) {
    if (w8) {
      var vip = v2, vop = v2, vim = w8, vom = vip.parent.children[0], sip = vip.m, sop = vop.m, sim = vim.m, som = vom.m, shift;
      while (vim = nextRight(vim), vip = nextLeft(vip), vim && vip) {
        vom = nextLeft(vom);
        vop = nextRight(vop);
        vop.a = v2;
        shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
        if (shift > 0) {
          moveSubtree(nextAncestor(vim, v2, ancestor), v2, shift);
          sip += shift;
          sop += shift;
        }
        sim += vim.m;
        sip += vip.m;
        som += vom.m;
        sop += vop.m;
      }
      if (vim && !nextRight(vop)) {
        vop.t = vim;
        vop.m += sim - sop;
      }
      if (vip && !nextLeft(vom)) {
        vom.t = vip;
        vom.m += sip - som;
        ancestor = v2;
      }
    }
    return ancestor;
  }
  function sizeNode(node) {
    node.x *= dx;
    node.y = node.depth * dy;
  }
  tree.separation = function(x9) {
    return arguments.length ? (separation = x9, tree) : separation;
  };
  tree.size = function(x9) {
    return arguments.length ? (nodeSize = false, dx = +x9[0], dy = +x9[1], tree) : nodeSize ? null : [dx, dy];
  };
  tree.nodeSize = function(x9) {
    return arguments.length ? (nodeSize = true, dx = +x9[0], dy = +x9[1], tree) : nodeSize ? [dx, dy] : null;
  };
  return tree;
}

// node_modules/d3-hierarchy/src/treemap/slice.js
function slice_default(parent, x07, y07, x13, y13) {
  var nodes = parent.children, node, i = -1, n = nodes.length, k3 = parent.value && (y13 - y07) / parent.value;
  while (++i < n) {
    node = nodes[i], node.x0 = x07, node.x1 = x13;
    node.y0 = y07, node.y1 = y07 += node.value * k3;
  }
}

// node_modules/d3-hierarchy/src/treemap/squarify.js
var phi = (1 + Math.sqrt(5)) / 2;
function squarifyRatio(ratio, parent, x07, y07, x13, y13) {
  var rows = [], nodes = parent.children, row, nodeValue, i0 = 0, i1 = 0, n = nodes.length, dx, dy, value7 = parent.value, sumValue, minValue, maxValue, newRatio, minRatio, alpha, beta;
  while (i0 < n) {
    dx = x13 - x07, dy = y13 - y07;
    do
      sumValue = nodes[i1++].value;
    while (!sumValue && i1 < n);
    minValue = maxValue = sumValue;
    alpha = Math.max(dy / dx, dx / dy) / (value7 * ratio);
    beta = sumValue * sumValue * alpha;
    minRatio = Math.max(maxValue / beta, beta / minValue);
    for (; i1 < n; ++i1) {
      sumValue += nodeValue = nodes[i1].value;
      if (nodeValue < minValue)
        minValue = nodeValue;
      if (nodeValue > maxValue)
        maxValue = nodeValue;
      beta = sumValue * sumValue * alpha;
      newRatio = Math.max(maxValue / beta, beta / minValue);
      if (newRatio > minRatio) {
        sumValue -= nodeValue;
        break;
      }
      minRatio = newRatio;
    }
    rows.push(row = { value: sumValue, dice: dx < dy, children: nodes.slice(i0, i1) });
    if (row.dice)
      dice_default(row, x07, y07, x13, value7 ? y07 += dy * sumValue / value7 : y13);
    else
      slice_default(row, x07, y07, value7 ? x07 += dx * sumValue / value7 : x13, y13);
    value7 -= sumValue, i0 = i1;
  }
  return rows;
}
var squarify_default = function custom9(ratio) {
  function squarify(parent, x07, y07, x13, y13) {
    squarifyRatio(ratio, parent, x07, y07, x13, y13);
  }
  squarify.ratio = function(x9) {
    return custom9((x9 = +x9) > 1 ? x9 : 1);
  };
  return squarify;
}(phi);

// node_modules/d3-hierarchy/src/treemap/index.js
function treemap_default() {
  var tile = squarify_default, round2 = false, dx = 1, dy = 1, paddingStack = [0], paddingInner2 = constantZero, paddingTop = constantZero, paddingRight = constantZero, paddingBottom = constantZero, paddingLeft = constantZero;
  function treemap(root) {
    root.x0 = root.y0 = 0;
    root.x1 = dx;
    root.y1 = dy;
    root.eachBefore(positionNode);
    paddingStack = [0];
    if (round2)
      root.eachBefore(round_default2);
    return root;
  }
  function positionNode(node) {
    var p = paddingStack[node.depth], x07 = node.x0 + p, y07 = node.y0 + p, x13 = node.x1 - p, y13 = node.y1 - p;
    if (x13 < x07)
      x07 = x13 = (x07 + x13) / 2;
    if (y13 < y07)
      y07 = y13 = (y07 + y13) / 2;
    node.x0 = x07;
    node.y0 = y07;
    node.x1 = x13;
    node.y1 = y13;
    if (node.children) {
      p = paddingStack[node.depth + 1] = paddingInner2(node) / 2;
      x07 += paddingLeft(node) - p;
      y07 += paddingTop(node) - p;
      x13 -= paddingRight(node) - p;
      y13 -= paddingBottom(node) - p;
      if (x13 < x07)
        x07 = x13 = (x07 + x13) / 2;
      if (y13 < y07)
        y07 = y13 = (y07 + y13) / 2;
      tile(node, x07, y07, x13, y13);
    }
  }
  treemap.round = function(x9) {
    return arguments.length ? (round2 = !!x9, treemap) : round2;
  };
  treemap.size = function(x9) {
    return arguments.length ? (dx = +x9[0], dy = +x9[1], treemap) : [dx, dy];
  };
  treemap.tile = function(x9) {
    return arguments.length ? (tile = required(x9), treemap) : tile;
  };
  treemap.padding = function(x9) {
    return arguments.length ? treemap.paddingInner(x9).paddingOuter(x9) : treemap.paddingInner();
  };
  treemap.paddingInner = function(x9) {
    return arguments.length ? (paddingInner2 = typeof x9 === "function" ? x9 : constant_default5(+x9), treemap) : paddingInner2;
  };
  treemap.paddingOuter = function(x9) {
    return arguments.length ? treemap.paddingTop(x9).paddingRight(x9).paddingBottom(x9).paddingLeft(x9) : treemap.paddingTop();
  };
  treemap.paddingTop = function(x9) {
    return arguments.length ? (paddingTop = typeof x9 === "function" ? x9 : constant_default5(+x9), treemap) : paddingTop;
  };
  treemap.paddingRight = function(x9) {
    return arguments.length ? (paddingRight = typeof x9 === "function" ? x9 : constant_default5(+x9), treemap) : paddingRight;
  };
  treemap.paddingBottom = function(x9) {
    return arguments.length ? (paddingBottom = typeof x9 === "function" ? x9 : constant_default5(+x9), treemap) : paddingBottom;
  };
  treemap.paddingLeft = function(x9) {
    return arguments.length ? (paddingLeft = typeof x9 === "function" ? x9 : constant_default5(+x9), treemap) : paddingLeft;
  };
  return treemap;
}

// node_modules/d3-hierarchy/src/treemap/binary.js
function binary_default(parent, x07, y07, x13, y13) {
  var nodes = parent.children, i, n = nodes.length, sum4, sums = new Array(n + 1);
  for (sums[0] = sum4 = i = 0; i < n; ++i) {
    sums[i + 1] = sum4 += nodes[i].value;
  }
  partition5(0, n, parent.value, x07, y07, x13, y13);
  function partition5(i2, j, value7, x08, y08, x14, y14) {
    if (i2 >= j - 1) {
      var node = nodes[i2];
      node.x0 = x08, node.y0 = y08;
      node.x1 = x14, node.y1 = y14;
      return;
    }
    var valueOffset = sums[i2], valueTarget = value7 / 2 + valueOffset, k3 = i2 + 1, hi = j - 1;
    while (k3 < hi) {
      var mid = k3 + hi >>> 1;
      if (sums[mid] < valueTarget)
        k3 = mid + 1;
      else
        hi = mid;
    }
    if (valueTarget - sums[k3 - 1] < sums[k3] - valueTarget && i2 + 1 < k3)
      --k3;
    var valueLeft = sums[k3] - valueOffset, valueRight = value7 - valueLeft;
    if (x14 - x08 > y14 - y08) {
      var xk = value7 ? (x08 * valueRight + x14 * valueLeft) / value7 : x14;
      partition5(i2, k3, valueLeft, x08, y08, xk, y14);
      partition5(k3, j, valueRight, xk, y08, x14, y14);
    } else {
      var yk = value7 ? (y08 * valueRight + y14 * valueLeft) / value7 : y14;
      partition5(i2, k3, valueLeft, x08, y08, x14, yk);
      partition5(k3, j, valueRight, x08, yk, x14, y14);
    }
  }
}

// node_modules/d3-hierarchy/src/treemap/sliceDice.js
function sliceDice_default(parent, x07, y07, x13, y13) {
  (parent.depth & 1 ? slice_default : dice_default)(parent, x07, y07, x13, y13);
}

// node_modules/d3-hierarchy/src/treemap/resquarify.js
var resquarify_default = function custom10(ratio) {
  function resquarify(parent, x07, y07, x13, y13) {
    if ((rows = parent._squarify) && rows.ratio === ratio) {
      var rows, row, nodes, i, j = -1, n, m3 = rows.length, value7 = parent.value;
      while (++j < m3) {
        row = rows[j], nodes = row.children;
        for (i = row.value = 0, n = nodes.length; i < n; ++i)
          row.value += nodes[i].value;
        if (row.dice)
          dice_default(row, x07, y07, x13, value7 ? y07 += (y13 - y07) * row.value / value7 : y13);
        else
          slice_default(row, x07, y07, value7 ? x07 += (x13 - x07) * row.value / value7 : x13, y13);
        value7 -= row.value;
      }
    } else {
      parent._squarify = rows = squarifyRatio(ratio, parent, x07, y07, x13, y13);
      rows.ratio = ratio;
    }
  }
  resquarify.ratio = function(x9) {
    return custom10((x9 = +x9) > 1 ? x9 : 1);
  };
  return resquarify;
}(phi);

// node_modules/vega-hierarchy/build/vega-hierarchy.js
function lookup3(tree, key4, filter4) {
  const map13 = {};
  tree.each((node) => {
    const t = node.data;
    if (filter4(t))
      map13[key4(t)] = node;
  });
  tree.lookup = map13;
  return tree;
}
function Nest(params2) {
  Transform.call(this, null, params2);
}
Nest.Definition = {
  "type": "Nest",
  "metadata": {
    "treesource": true,
    "changes": true
  },
  "params": [{
    "name": "keys",
    "type": "field",
    "array": true
  }, {
    "name": "generate",
    "type": "boolean"
  }]
};
var children = (n) => n.values;
inherits8(Nest, Transform, {
  transform(_, pulse2) {
    if (!pulse2.source) {
      error9("Nest transform requires an upstream data source.");
    }
    var gen = _.generate, mod = _.modified(), out = pulse2.clone(), tree = this.value;
    if (!tree || mod || pulse2.changed()) {
      if (tree) {
        tree.each((node) => {
          if (node.children && isTuple(node.data)) {
            out.rem.push(node.data);
          }
        });
      }
      this.value = tree = hierarchy({
        values: array10(_.keys).reduce((n, k3) => {
          n.key(k3);
          return n;
        }, nest()).entries(out.source)
      }, children);
      if (gen) {
        tree.each((node) => {
          if (node.children) {
            node = ingest$1(node.data);
            out.add.push(node);
            out.source.push(node);
          }
        });
      }
      lookup3(tree, tupleid, tupleid);
    }
    out.source.root = tree;
    return out;
  }
});
function nest() {
  const keys5 = [], nest2 = {
    entries: (array22) => entries2(apply11(array22, 0), 0),
    key: (d) => (keys5.push(d), nest2)
  };
  function apply11(array22, depth) {
    if (depth >= keys5.length) {
      return array22;
    }
    const n = array22.length, key4 = keys5[depth++], valuesByKey = {}, result = {};
    let i = -1, keyValue, value7, values7;
    while (++i < n) {
      keyValue = key4(value7 = array22[i]) + "";
      if (values7 = valuesByKey[keyValue]) {
        values7.push(value7);
      } else {
        valuesByKey[keyValue] = [value7];
      }
    }
    for (keyValue in valuesByKey) {
      result[keyValue] = apply11(valuesByKey[keyValue], depth);
    }
    return result;
  }
  function entries2(map13, depth) {
    if (++depth > keys5.length)
      return map13;
    const array22 = [];
    for (const key4 in map13) {
      array22.push({
        key: key4,
        values: entries2(map13[key4], depth)
      });
    }
    return array22;
  }
  return nest2;
}
function HierarchyLayout(params2) {
  Transform.call(this, null, params2);
}
var defaultSeparation3 = (a4, b6) => a4.parent === b6.parent ? 1 : 2;
inherits8(HierarchyLayout, Transform, {
  transform(_, pulse2) {
    if (!pulse2.source || !pulse2.source.root) {
      error9(this.constructor.name + " transform requires a backing tree data source.");
    }
    const layout = this.layout(_.method), fields = this.fields, root = pulse2.source.root, as = _.as || fields;
    if (_.field)
      root.sum(_.field);
    else
      root.count();
    if (_.sort)
      root.sort(stableCompare(_.sort, (d) => d.data));
    setParams(layout, this.params, _);
    if (layout.separation) {
      layout.separation(_.separation !== false ? defaultSeparation3 : one10);
    }
    try {
      this.value = layout(root);
    } catch (err) {
      error9(err);
    }
    root.each((node) => setFields(node, fields, as));
    return pulse2.reflow(_.modified()).modifies(as).modifies("leaf");
  }
});
function setParams(layout, params2, _) {
  for (let p, i = 0, n = params2.length; i < n; ++i) {
    p = params2[i];
    if (p in _)
      layout[p](_[p]);
  }
}
function setFields(node, fields, as) {
  const t = node.data, n = fields.length - 1;
  for (let i = 0; i < n; ++i) {
    t[as[i]] = node[fields[i]];
  }
  t[as[n]] = node.children ? node.children.length : 0;
}
var Output$3 = ["x", "y", "r", "depth", "children"];
function Pack(params2) {
  HierarchyLayout.call(this, params2);
}
Pack.Definition = {
  "type": "Pack",
  "metadata": {
    "tree": true,
    "modifies": true
  },
  "params": [{
    "name": "field",
    "type": "field"
  }, {
    "name": "sort",
    "type": "compare"
  }, {
    "name": "padding",
    "type": "number",
    "default": 0
  }, {
    "name": "radius",
    "type": "field",
    "default": null
  }, {
    "name": "size",
    "type": "number",
    "array": true,
    "length": 2
  }, {
    "name": "as",
    "type": "string",
    "array": true,
    "length": Output$3.length,
    "default": Output$3
  }]
};
inherits8(Pack, HierarchyLayout, {
  layout: pack_default,
  params: ["radius", "size", "padding"],
  fields: Output$3
});
var Output$2 = ["x0", "y0", "x1", "y1", "depth", "children"];
function Partition(params2) {
  HierarchyLayout.call(this, params2);
}
Partition.Definition = {
  "type": "Partition",
  "metadata": {
    "tree": true,
    "modifies": true
  },
  "params": [{
    "name": "field",
    "type": "field"
  }, {
    "name": "sort",
    "type": "compare"
  }, {
    "name": "padding",
    "type": "number",
    "default": 0
  }, {
    "name": "round",
    "type": "boolean",
    "default": false
  }, {
    "name": "size",
    "type": "number",
    "array": true,
    "length": 2
  }, {
    "name": "as",
    "type": "string",
    "array": true,
    "length": Output$2.length,
    "default": Output$2
  }]
};
inherits8(Partition, HierarchyLayout, {
  layout: partition_default,
  params: ["size", "round", "padding"],
  fields: Output$2
});
function Stratify(params2) {
  Transform.call(this, null, params2);
}
Stratify.Definition = {
  "type": "Stratify",
  "metadata": {
    "treesource": true
  },
  "params": [{
    "name": "key",
    "type": "field",
    "required": true
  }, {
    "name": "parentKey",
    "type": "field",
    "required": true
  }]
};
inherits8(Stratify, Transform, {
  transform(_, pulse2) {
    if (!pulse2.source) {
      error9("Stratify transform requires an upstream data source.");
    }
    let tree = this.value;
    const mod = _.modified(), out = pulse2.fork(pulse2.ALL).materialize(pulse2.SOURCE), run2 = !tree || mod || pulse2.changed(pulse2.ADD_REM) || pulse2.modified(_.key.fields) || pulse2.modified(_.parentKey.fields);
    out.source = out.source.slice();
    if (run2) {
      tree = out.source.length ? lookup3(stratify_default().id(_.key).parentId(_.parentKey)(out.source), _.key, truthy9) : lookup3(stratify_default()([{}]), _.key, _.key);
    }
    out.source.root = this.value = tree;
    return out;
  }
});
var Layouts = {
  tidy: tree_default,
  cluster: cluster_default
};
var Output$1 = ["x", "y", "depth", "children"];
function Tree(params2) {
  HierarchyLayout.call(this, params2);
}
Tree.Definition = {
  "type": "Tree",
  "metadata": {
    "tree": true,
    "modifies": true
  },
  "params": [{
    "name": "field",
    "type": "field"
  }, {
    "name": "sort",
    "type": "compare"
  }, {
    "name": "method",
    "type": "enum",
    "default": "tidy",
    "values": ["tidy", "cluster"]
  }, {
    "name": "size",
    "type": "number",
    "array": true,
    "length": 2
  }, {
    "name": "nodeSize",
    "type": "number",
    "array": true,
    "length": 2
  }, {
    "name": "separation",
    "type": "boolean",
    "default": true
  }, {
    "name": "as",
    "type": "string",
    "array": true,
    "length": Output$1.length,
    "default": Output$1
  }]
};
inherits8(Tree, HierarchyLayout, {
  /**
   * Tree layout generator. Supports both 'tidy' and 'cluster' layouts.
   */
  layout(method10) {
    const m3 = method10 || "tidy";
    if (has8(Layouts, m3))
      return Layouts[m3]();
    else
      error9("Unrecognized Tree layout method: " + m3);
  },
  params: ["size", "nodeSize"],
  fields: Output$1
});
function TreeLinks(params2) {
  Transform.call(this, [], params2);
}
TreeLinks.Definition = {
  "type": "TreeLinks",
  "metadata": {
    "tree": true,
    "generates": true,
    "changes": true
  },
  "params": []
};
inherits8(TreeLinks, Transform, {
  transform(_, pulse2) {
    const links = this.value, tree = pulse2.source && pulse2.source.root, out = pulse2.fork(pulse2.NO_SOURCE), lut = {};
    if (!tree)
      error9("TreeLinks transform requires a tree data source.");
    if (pulse2.changed(pulse2.ADD_REM)) {
      out.rem = links;
      pulse2.visit(pulse2.SOURCE, (t) => lut[tupleid(t)] = 1);
      tree.each((node) => {
        const t = node.data, p = node.parent && node.parent.data;
        if (p && lut[tupleid(t)] && lut[tupleid(p)]) {
          out.add.push(ingest$1({
            source: p,
            target: t
          }));
        }
      });
      this.value = out.add;
    } else if (pulse2.changed(pulse2.MOD)) {
      pulse2.visit(pulse2.MOD, (t) => lut[tupleid(t)] = 1);
      links.forEach((link3) => {
        if (lut[tupleid(link3.source)] || lut[tupleid(link3.target)]) {
          out.mod.push(link3);
        }
      });
    }
    return out;
  }
});
var Tiles = {
  binary: binary_default,
  dice: dice_default,
  slice: slice_default,
  slicedice: sliceDice_default,
  squarify: squarify_default,
  resquarify: resquarify_default
};
var Output2 = ["x0", "y0", "x1", "y1", "depth", "children"];
function Treemap(params2) {
  HierarchyLayout.call(this, params2);
}
Treemap.Definition = {
  "type": "Treemap",
  "metadata": {
    "tree": true,
    "modifies": true
  },
  "params": [{
    "name": "field",
    "type": "field"
  }, {
    "name": "sort",
    "type": "compare"
  }, {
    "name": "method",
    "type": "enum",
    "default": "squarify",
    "values": ["squarify", "resquarify", "binary", "dice", "slice", "slicedice"]
  }, {
    "name": "padding",
    "type": "number",
    "default": 0
  }, {
    "name": "paddingInner",
    "type": "number",
    "default": 0
  }, {
    "name": "paddingOuter",
    "type": "number",
    "default": 0
  }, {
    "name": "paddingTop",
    "type": "number",
    "default": 0
  }, {
    "name": "paddingRight",
    "type": "number",
    "default": 0
  }, {
    "name": "paddingBottom",
    "type": "number",
    "default": 0
  }, {
    "name": "paddingLeft",
    "type": "number",
    "default": 0
  }, {
    "name": "ratio",
    "type": "number",
    "default": 1.618033988749895
  }, {
    "name": "round",
    "type": "boolean",
    "default": false
  }, {
    "name": "size",
    "type": "number",
    "array": true,
    "length": 2
  }, {
    "name": "as",
    "type": "string",
    "array": true,
    "length": Output2.length,
    "default": Output2
  }]
};
inherits8(Treemap, HierarchyLayout, {
  /**
   * Treemap layout generator. Adds 'method' and 'ratio' parameters
   * to configure the underlying tile method.
   */
  layout() {
    const x9 = treemap_default();
    x9.ratio = (_) => {
      const t = x9.tile();
      if (t.ratio)
        x9.tile(t.ratio(_));
    };
    x9.method = (_) => {
      if (has8(Tiles, _))
        x9.tile(Tiles[_]);
      else
        error9("Unrecognized Treemap layout method: " + _);
    };
    return x9;
  },
  params: ["method", "ratio", "size", "round", "padding", "paddingInner", "paddingOuter", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft"],
  fields: Output2
});

// node_modules/vega-label/build/vega-label.js
var vega_label_exports = {};
__export(vega_label_exports, {
  label: () => Label
});

// node_modules/vega-label/node_modules/vega-util/build/vega-util.js
function accessor10(fn, fields, name) {
  fn.fields = fields || [];
  fn.fname = name;
  return fn;
}
function getter10(path7) {
  return path7.length === 1 ? get110(path7[0]) : getN10(path7);
}
var get110 = (field25) => function(obj) {
  return obj[field25];
};
var getN10 = (path7) => {
  const len = path7.length;
  return function(obj) {
    for (let i = 0; i < len; ++i) {
      obj = obj[path7[i]];
    }
    return obj;
  };
};
function error10(message) {
  throw Error(message);
}
function splitAccessPath10(p) {
  const path7 = [], n = p.length;
  let q = null, b6 = 0, s2 = "", i, j, c5;
  p = p + "";
  function push() {
    path7.push(s2 + p.substring(i, j));
    s2 = "";
    i = j + 1;
  }
  for (i = j = 0; j < n; ++j) {
    c5 = p[j];
    if (c5 === "\\") {
      s2 += p.substring(i, j++);
      i = j;
    } else if (c5 === q) {
      push();
      q = null;
      b6 = -1;
    } else if (q) {
      continue;
    } else if (i === b6 && c5 === '"') {
      i = j + 1;
      q = c5;
    } else if (i === b6 && c5 === "'") {
      i = j + 1;
      q = c5;
    } else if (c5 === "." && !b6) {
      if (j > i) {
        push();
      } else {
        i = j + 1;
      }
    } else if (c5 === "[") {
      if (j > i)
        push();
      b6 = i = j + 1;
    } else if (c5 === "]") {
      if (!b6)
        error10("Access path missing open bracket: " + p);
      if (b6 > 0)
        push();
      b6 = 0;
      i = j + 1;
    }
  }
  if (b6)
    error10("Access path missing closing bracket: " + p);
  if (q)
    error10("Access path missing closing quote: " + p);
  if (j > i) {
    j++;
    push();
  }
  return path7;
}
function field10(field25, name, opt) {
  const path7 = splitAccessPath10(field25);
  field25 = path7.length === 1 ? path7[0] : field25;
  return accessor10((opt && opt.get || getter10)(path7), [field25], name || field25);
}
var id10 = field10("id");
var identity14 = accessor10((_) => _, [], "identity");
var zero12 = accessor10(() => 0, [], "zero");
var one11 = accessor10(() => 1, [], "one");
var truthy10 = accessor10(() => true, [], "true");
var falsy10 = accessor10(() => false, [], "false");
var DisallowedObjectProperties10 = /* @__PURE__ */ new Set([...Object.getOwnPropertyNames(Object.prototype).filter((name) => typeof Object.prototype[name] === "function"), "__proto__"]);
var isArray10 = Array.isArray;
function isObject6(_) {
  return _ === Object(_);
}
function peek7(array22) {
  return array22[array22.length - 1];
}
function toNumber7(_) {
  return _ == null || _ === "" ? null : +_;
}
function array11(_) {
  return _ != null ? isArray10(_) ? _ : [_] : [];
}
function isFunction8(_) {
  return typeof _ === "function";
}
function extend11(_) {
  for (let x9, k3, i = 1, len = arguments.length; i < len; ++i) {
    x9 = arguments[i];
    for (k3 in x9) {
      _[k3] = x9[k3];
    }
  }
  return _;
}
function has9(object2, property2) {
  return Object.hasOwn(object2, property2);
}
function inherits9(child, parent, members) {
  const proto = child.prototype = Object.create(parent.prototype);
  Object.defineProperty(proto, "constructor", {
    value: child,
    writable: true,
    enumerable: true,
    configurable: true
  });
  return extend11(proto, members);
}
function isIterable4(_) {
  return _ && isFunction8(_[Symbol.iterator]);
}
function isString6(_) {
  return typeof _ === "string";
}
var DEFAULT_MAX_SIZE3 = 1e4;
function lruCache3(maxsize) {
  maxsize = +maxsize || DEFAULT_MAX_SIZE3;
  let curr, prev, size;
  const clear2 = () => {
    curr = {};
    prev = {};
    size = 0;
  };
  const update3 = (key4, value7) => {
    if (++size > maxsize) {
      prev = curr;
      curr = {};
      size = 1;
    }
    return curr[key4] = value7;
  };
  clear2();
  return {
    clear: clear2,
    has: (key4) => has9(curr, key4) || has9(prev, key4),
    get: (key4) => has9(curr, key4) ? curr[key4] : has9(prev, key4) ? update3(key4, prev[key4]) : void 0,
    set: (key4, value7) => has9(curr, key4) ? curr[key4] = value7 : update3(key4, value7)
  };
}
function $5(x9) {
  return isArray10(x9) ? `[${x9.map((v2) => v2 === null ? "null" : $5(v2))}]` : isObject6(x9) || isString6(x9) ? (
    // Output valid JSON and JS source strings.
    // See https://github.com/judofyr/timeless/blob/master/posts/json-isnt-a-javascript-subset.md
    JSON.stringify(x9).replaceAll("\u2028", "\\u2028").replaceAll("\u2029", "\\u2029")
  ) : x9;
}
function toSet8(_) {
  const s2 = {}, n = _.length;
  for (let i = 0; i < n; ++i)
    s2[_[i]] = true;
  return s2;
}

// node_modules/vega-label/node_modules/vega-canvas/build/vega-canvas.browser.js
function domCanvas3(w8, h6) {
  if (typeof document !== "undefined" && document.createElement) {
    const c5 = document.createElement("canvas");
    if (c5 && c5.getContext) {
      c5.width = w8;
      c5.height = h6;
      return c5;
    }
  }
  return null;
}
var domImage2 = () => typeof Image !== "undefined" ? Image : null;

// node_modules/vega-label/node_modules/vega-time/build/vega-time.js
var YEAR6 = "year";
var QUARTER6 = "quarter";
var MONTH6 = "month";
var WEEK6 = "week";
var DATE6 = "date";
var DAY6 = "day";
var DAYOFYEAR6 = "dayofyear";
var HOURS6 = "hours";
var MINUTES6 = "minutes";
var SECONDS6 = "seconds";
var MILLISECONDS6 = "milliseconds";
var TIME_UNITS6 = [YEAR6, QUARTER6, MONTH6, WEEK6, DATE6, DAY6, DAYOFYEAR6, HOURS6, MINUTES6, SECONDS6, MILLISECONDS6];
var UNITS6 = TIME_UNITS6.reduce((o, u4, i) => (o[u4] = 1 + i, o), {});
var defaultSpecifiers6 = {
  [YEAR6]: "%Y ",
  [QUARTER6]: "Q%q ",
  [MONTH6]: "%b ",
  [DATE6]: "%d ",
  [WEEK6]: "W%U ",
  [DAY6]: "%a ",
  [DAYOFYEAR6]: "%j ",
  [HOURS6]: "%H:00",
  [MINUTES6]: "00:%M",
  [SECONDS6]: ":%S",
  [MILLISECONDS6]: ".%L",
  [`${YEAR6}-${MONTH6}`]: "%Y-%m ",
  [`${YEAR6}-${MONTH6}-${DATE6}`]: "%Y-%m-%d ",
  [`${HOURS6}-${MINUTES6}`]: "%H:%M"
};
var t08 = /* @__PURE__ */ new Date();
function localYear6(y9) {
  t08.setFullYear(y9);
  t08.setMonth(0);
  t08.setDate(1);
  t08.setHours(0, 0, 0, 0);
  return t08;
}
function localDayOfYear6(d) {
  return timeDay.count(localYear6(d.getFullYear()) - 1, d);
}
function localWeekNum6(d) {
  return timeSunday.count(localYear6(d.getFullYear()) - 1, d);
}
function localFirst6(y9) {
  return localYear6(y9).getDay();
}
function utcDayOfYear6(d) {
  const y9 = Date.UTC(d.getUTCFullYear(), 0, 1);
  return utcDay.count(y9 - 1, d);
}
function utcWeekNum6(d) {
  const y9 = Date.UTC(d.getUTCFullYear(), 0, 1);
  return utcSunday.count(y9 - 1, d);
}
function utcFirst6(y9) {
  t08.setTime(Date.UTC(y9, 0, 1));
  return t08.getUTCDay();
}
function weekday6(week3, day, firstDay) {
  return day + week3 * 7 - (firstDay + 6) % 7;
}
var localGet6 = {
  [YEAR6]: (d) => d.getFullYear(),
  [QUARTER6]: (d) => Math.floor(d.getMonth() / 3),
  [MONTH6]: (d) => d.getMonth(),
  [DATE6]: (d) => d.getDate(),
  [HOURS6]: (d) => d.getHours(),
  [MINUTES6]: (d) => d.getMinutes(),
  [SECONDS6]: (d) => d.getSeconds(),
  [MILLISECONDS6]: (d) => d.getMilliseconds(),
  [DAYOFYEAR6]: (d) => localDayOfYear6(d),
  [WEEK6]: (d) => localWeekNum6(d),
  [WEEK6 + DAY6]: (d, y9) => weekday6(localWeekNum6(d), d.getDay(), localFirst6(y9)),
  [DAY6]: (d, y9) => weekday6(1, d.getDay(), localFirst6(y9))
};
var localInv6 = {
  [QUARTER6]: (q) => 3 * q,
  [WEEK6]: (w8, y9) => weekday6(w8, 0, localFirst6(y9))
};
var utcGet6 = {
  [YEAR6]: (d) => d.getUTCFullYear(),
  [QUARTER6]: (d) => Math.floor(d.getUTCMonth() / 3),
  [MONTH6]: (d) => d.getUTCMonth(),
  [DATE6]: (d) => d.getUTCDate(),
  [HOURS6]: (d) => d.getUTCHours(),
  [MINUTES6]: (d) => d.getUTCMinutes(),
  [SECONDS6]: (d) => d.getUTCSeconds(),
  [MILLISECONDS6]: (d) => d.getUTCMilliseconds(),
  [DAYOFYEAR6]: (d) => utcDayOfYear6(d),
  [WEEK6]: (d) => utcWeekNum6(d),
  [DAY6]: (d, y9) => weekday6(1, d.getUTCDay(), utcFirst6(y9)),
  [WEEK6 + DAY6]: (d, y9) => weekday6(utcWeekNum6(d), d.getUTCDay(), utcFirst6(y9))
};
var utcInv6 = {
  [QUARTER6]: (q) => 3 * q,
  [WEEK6]: (w8, y9) => weekday6(w8, 0, utcFirst6(y9))
};
var timeIntervals6 = {
  [YEAR6]: timeYear,
  [QUARTER6]: timeMonth.every(3),
  [MONTH6]: timeMonth,
  [WEEK6]: timeSunday,
  [DATE6]: timeDay,
  [DAY6]: timeDay,
  [DAYOFYEAR6]: timeDay,
  [HOURS6]: timeHour,
  [MINUTES6]: timeMinute,
  [SECONDS6]: second,
  [MILLISECONDS6]: millisecond
};
var utcIntervals6 = {
  [YEAR6]: utcYear,
  [QUARTER6]: utcMonth.every(3),
  [MONTH6]: utcMonth,
  [WEEK6]: utcSunday,
  [DATE6]: utcDay,
  [DAY6]: utcDay,
  [DAYOFYEAR6]: utcDay,
  [HOURS6]: utcHour,
  [MINUTES6]: utcMinute,
  [SECONDS6]: second,
  [MILLISECONDS6]: millisecond
};
function timeInterval7(unit2) {
  return timeIntervals6[unit2];
}
function utcInterval6(unit2) {
  return utcIntervals6[unit2];
}
var durationSecond7 = 1e3;
var durationMinute7 = durationSecond7 * 60;
var durationHour7 = durationMinute7 * 60;
var durationDay7 = durationHour7 * 24;
var durationWeek7 = durationDay7 * 7;
var durationMonth7 = durationDay7 * 30;
var durationYear7 = durationDay7 * 365;
var Milli6 = [YEAR6, MONTH6, DATE6, HOURS6, MINUTES6, SECONDS6, MILLISECONDS6];
var Seconds6 = Milli6.slice(0, -1);
var Minutes6 = Seconds6.slice(0, -1);
var Hours6 = Minutes6.slice(0, -1);
var Day6 = Hours6.slice(0, -1);
var Week6 = [YEAR6, WEEK6];
var Month6 = [YEAR6, MONTH6];
var Year6 = [YEAR6];
var intervals6 = [[Seconds6, 1, durationSecond7], [Seconds6, 5, 5 * durationSecond7], [Seconds6, 15, 15 * durationSecond7], [Seconds6, 30, 30 * durationSecond7], [Minutes6, 1, durationMinute7], [Minutes6, 5, 5 * durationMinute7], [Minutes6, 15, 15 * durationMinute7], [Minutes6, 30, 30 * durationMinute7], [Hours6, 1, durationHour7], [Hours6, 3, 3 * durationHour7], [Hours6, 6, 6 * durationHour7], [Hours6, 12, 12 * durationHour7], [Day6, 1, durationDay7], [Week6, 1, durationWeek7], [Month6, 1, durationMonth7], [Month6, 3, 3 * durationMonth7], [Year6, 1, durationYear7]];

// node_modules/vega-label/node_modules/vega-format/build/vega-format.js
function memoize3(method10) {
  const cache2 = {};
  return (spec) => cache2[spec] || (cache2[spec] = method10(spec));
}
function trimZeroes3(numberFormat2, decimalChar) {
  return (x9) => {
    const str = numberFormat2(x9), dec = str.indexOf(decimalChar);
    if (dec < 0)
      return str;
    let idx = rightmostDigit3(str, dec);
    const end = idx < str.length ? str.slice(idx) : "";
    while (--idx > dec)
      if (str[idx] !== "0") {
        ++idx;
        break;
      }
    return str.slice(0, idx) + end;
  };
}
function rightmostDigit3(str, dec) {
  let i = str.lastIndexOf("e"), c5;
  if (i > 0)
    return i;
  for (i = str.length; --i > dec; ) {
    c5 = str.charCodeAt(i);
    if (c5 >= 48 && c5 <= 57)
      return i + 1;
  }
}
function numberLocale3(locale5) {
  const format14 = memoize3(locale5.format), formatPrefix2 = locale5.formatPrefix;
  return {
    format: format14,
    formatPrefix: formatPrefix2,
    formatFloat(spec) {
      const s2 = formatSpecifier(spec || ",");
      if (s2.precision == null) {
        s2.precision = 12;
        switch (s2.type) {
          case "%":
            s2.precision -= 2;
            break;
          case "e":
            s2.precision -= 1;
            break;
        }
        return trimZeroes3(
          format14(s2),
          // number format
          format14(".1f")(1)[1]
          // decimal point character
        );
      } else {
        return format14(s2);
      }
    },
    formatSpan(start, stop2, count3, specifier) {
      specifier = formatSpecifier(specifier == null ? ",f" : specifier);
      const step = tickStep(start, stop2, count3), value7 = Math.max(Math.abs(start), Math.abs(stop2));
      let precision;
      if (specifier.precision == null) {
        switch (specifier.type) {
          case "s": {
            if (!isNaN(precision = precisionPrefix_default(step, value7))) {
              specifier.precision = precision;
            }
            return formatPrefix2(specifier, value7);
          }
          case "":
          case "e":
          case "g":
          case "p":
          case "r": {
            if (!isNaN(precision = precisionRound_default(step, value7))) {
              specifier.precision = precision - (specifier.type === "e");
            }
            break;
          }
          case "f":
          case "%": {
            if (!isNaN(precision = precisionFixed_default(step))) {
              specifier.precision = precision - (specifier.type === "%") * 2;
            }
            break;
          }
        }
      }
      return format14(specifier);
    }
  };
}
var defaultNumberLocale3;
resetNumberFormatDefaultLocale3();
function resetNumberFormatDefaultLocale3() {
  return defaultNumberLocale3 = numberLocale3({
    format,
    formatPrefix
  });
}
function timeMultiFormat3(format14, interval3, spec) {
  spec = spec || {};
  if (!isObject6(spec)) {
    error10(`Invalid time multi-format specifier: ${spec}`);
  }
  const second2 = interval3(SECONDS6), minute = interval3(MINUTES6), hour = interval3(HOURS6), day = interval3(DATE6), week3 = interval3(WEEK6), month = interval3(MONTH6), quarter3 = interval3(QUARTER6), year = interval3(YEAR6), L = format14(spec[MILLISECONDS6] || ".%L"), S = format14(spec[SECONDS6] || ":%S"), M2 = format14(spec[MINUTES6] || "%I:%M"), H = format14(spec[HOURS6] || "%I %p"), d = format14(spec[DATE6] || spec[DAY6] || "%a %d"), w8 = format14(spec[WEEK6] || "%b %d"), m3 = format14(spec[MONTH6] || "%B"), q = format14(spec[QUARTER6] || "%B"), y9 = format14(spec[YEAR6] || "%Y");
  return (date2) => (second2(date2) < date2 ? L : minute(date2) < date2 ? S : hour(date2) < date2 ? M2 : day(date2) < date2 ? H : month(date2) < date2 ? week3(date2) < date2 ? d : w8 : year(date2) < date2 ? quarter3(date2) < date2 ? m3 : q : y9)(date2);
}
function timeLocale3(locale5) {
  const timeFormat4 = memoize3(locale5.format), utcFormat3 = memoize3(locale5.utcFormat);
  return {
    timeFormat: (spec) => isString6(spec) ? timeFormat4(spec) : timeMultiFormat3(timeFormat4, timeInterval7, spec),
    utcFormat: (spec) => isString6(spec) ? utcFormat3(spec) : timeMultiFormat3(utcFormat3, utcInterval6, spec),
    timeParse: memoize3(locale5.parse),
    utcParse: memoize3(locale5.utcParse)
  };
}
var defaultTimeLocale3;
resetTimeFormatDefaultLocale3();
function resetTimeFormatDefaultLocale3() {
  return defaultTimeLocale3 = timeLocale3({
    format: timeFormat,
    parse: timeParse,
    utcFormat,
    utcParse
  });
}

// node_modules/vega-label/node_modules/vega-loader/build/vega-loader.browser.js
var protocol_re3 = /^(data:|([A-Za-z]+:)?\/\/)/;
var allowed_re3 = /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp|file|data):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i;
var whitespace_re3 = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205f\u3000]/g;
var fileProtocol3 = "file://";
function loaderFactory3(fs) {
  return (options) => ({
    options: options || {},
    sanitize: sanitize3,
    load: load3,
    fileAccess: false,
    file: fileLoader3(),
    http: httpLoader3
  });
}
async function load3(uri, options) {
  const opt = await this.sanitize(uri, options), url = opt.href;
  return opt.localFile ? this.file(url) : this.http(url, options == null ? void 0 : options.http);
}
async function sanitize3(uri, options) {
  options = extend11({}, this.options, options);
  const fileAccess = this.fileAccess, result = {
    href: null
  };
  let isFile, loadFile, base;
  const isAllowed = allowed_re3.test(uri.replace(whitespace_re3, ""));
  if (uri == null || typeof uri !== "string" || !isAllowed) {
    error10("Sanitize failure, invalid URI: " + $5(uri));
  }
  const hasProtocol = protocol_re3.test(uri);
  if ((base = options.baseURL) && !hasProtocol) {
    if (!uri.startsWith("/") && !base.endsWith("/")) {
      uri = "/" + uri;
    }
    uri = base + uri;
  }
  loadFile = (isFile = uri.startsWith(fileProtocol3)) || options.mode === "file" || options.mode !== "http" && !hasProtocol && fileAccess;
  if (isFile) {
    uri = uri.slice(fileProtocol3.length);
  } else if (uri.startsWith("//")) {
    if (options.defaultProtocol === "file") {
      uri = uri.slice(2);
      loadFile = true;
    } else {
      uri = (options.defaultProtocol || "http") + ":" + uri;
    }
  }
  Object.defineProperty(result, "localFile", {
    value: !!loadFile
  });
  result.href = uri;
  if (options.target) {
    result.target = options.target + "";
  }
  if (options.rel) {
    result.rel = options.rel + "";
  }
  if (options.context === "image" && options.crossOrigin) {
    result.crossOrigin = options.crossOrigin + "";
  }
  return result;
}
function fileLoader3(fs) {
  return fileReject3;
}
async function fileReject3() {
  error10("No file system access.");
}
async function httpLoader3(url, options) {
  const opt = extend11({}, this.options.http, options), type7 = options && options.response, response = await fetch(url, opt);
  return !response.ok ? error10(response.status + "" + response.statusText) : isFunction8(response[type7]) ? response[type7]() : response.text();
}
function delimitedFormat3(delimiter) {
  const parse12 = function(data3, format14) {
    const delim = {
      delimiter
    };
    return dsv3(data3, format14 ? extend11(format14, delim) : delim);
  };
  parse12.responseType = "text";
  return parse12;
}
function dsv3(data3, format14) {
  if (format14.header) {
    data3 = format14.header.map($5).join(format14.delimiter) + "\n" + data3;
  }
  return dsv_default(format14.delimiter).parse(data3 + "");
}
dsv3.responseType = "text";
function isBuffer3(_) {
  return typeof Buffer === "function" && isFunction8(Buffer.isBuffer) ? Buffer.isBuffer(_) : false;
}
function json3(data3, format14) {
  const prop = format14 && format14.property ? field10(format14.property) : identity14;
  return isObject6(data3) && !isBuffer3(data3) ? parseJSON3(prop(data3), format14) : prop(JSON.parse(data3));
}
json3.responseType = "json";
function parseJSON3(data3, format14) {
  if (!isArray10(data3) && isIterable4(data3)) {
    data3 = [...data3];
  }
  return format14 && format14.copy ? JSON.parse(JSON.stringify(data3)) : data3;
}
var filters3 = {
  interior: (a4, b6) => a4 !== b6,
  exterior: (a4, b6) => a4 === b6
};
function topojson3(data3, format14) {
  let method10, object2, property2, filter4;
  data3 = json3(data3, format14);
  if (format14 && format14.feature) {
    method10 = feature_default;
    property2 = format14.feature;
  } else if (format14 && format14.mesh) {
    method10 = mesh_default;
    property2 = format14.mesh;
    filter4 = filters3[format14.filter];
  } else {
    error10("Missing TopoJSON feature or mesh parameter.");
  }
  object2 = (object2 = data3.objects[property2]) ? method10(data3, object2, filter4) : error10("Invalid TopoJSON object: " + property2);
  return object2 && object2.features || [object2];
}
topojson3.responseType = "json";
var format5 = {
  dsv: dsv3,
  csv: delimitedFormat3(","),
  tsv: delimitedFormat3("	"),
  json: json3,
  topojson: topojson3
};
var loader3 = loaderFactory3();

// node_modules/vega-label/node_modules/vega-scale/build/vega-scale.js
function bandSpace4(count3, paddingInner2, paddingOuter2) {
  const space = count3 - paddingInner2 + paddingOuter2 * 2;
  return count3 ? space > 0 ? space : 1 : 0;
}
var Identity4 = "identity";
var Linear5 = "linear";
var Log4 = "log";
var Pow4 = "pow";
var Sqrt4 = "sqrt";
var Symlog4 = "symlog";
var Time4 = "time";
var UTC4 = "utc";
var Sequential4 = "sequential";
var Diverging4 = "diverging";
var Quantile5 = "quantile";
var Quantize4 = "quantize";
var Threshold4 = "threshold";
var Ordinal4 = "ordinal";
var Point4 = "point";
var Band4 = "band";
var BinOrdinal4 = "bin-ordinal";
var Continuous4 = "continuous";
var Discrete4 = "discrete";
var Discretizing4 = "discretizing";
var Interpolating4 = "interpolating";
var Temporal4 = "temporal";
function invertRange4(scale19) {
  return function(_) {
    let lo = _[0], hi = _[1], t;
    if (hi < lo) {
      t = lo;
      lo = hi;
      hi = t;
    }
    return [scale19.invert(lo), scale19.invert(hi)];
  };
}
function invertRangeExtent4(scale19) {
  return function(_) {
    const range7 = scale19.range();
    let lo = _[0], hi = _[1], min5 = -1, max5, t, i, n;
    if (hi < lo) {
      t = lo;
      lo = hi;
      hi = t;
    }
    for (i = 0, n = range7.length; i < n; ++i) {
      if (range7[i] >= lo && range7[i] <= hi) {
        if (min5 < 0)
          min5 = i;
        max5 = i;
      }
    }
    if (min5 < 0)
      return void 0;
    lo = scale19.invertExtent(range7[min5]);
    hi = scale19.invertExtent(range7[max5]);
    return [lo[0] === void 0 ? lo[1] : lo[0], hi[1] === void 0 ? hi[0] : hi[1]];
  };
}
function band5() {
  const scale19 = ordinal().unknown(void 0), domain3 = scale19.domain, ordinalRange = scale19.range;
  let range$1 = [0, 1], step, bandwidth2, round2 = false, paddingInner2 = 0, paddingOuter2 = 0, align2 = 0.5;
  delete scale19.unknown;
  function rescale() {
    const n = domain3().length, reverse4 = range$1[1] < range$1[0], stop2 = range$1[1 - reverse4], space = bandSpace4(n, paddingInner2, paddingOuter2);
    let start = range$1[reverse4 - 0];
    step = (stop2 - start) / (space || 1);
    if (round2) {
      step = Math.floor(step);
    }
    start += (stop2 - start - step * (n - paddingInner2)) * align2;
    bandwidth2 = step * (1 - paddingInner2);
    if (round2) {
      start = Math.round(start);
      bandwidth2 = Math.round(bandwidth2);
    }
    const values7 = range(n).map((i) => start + step * i);
    return ordinalRange(reverse4 ? values7.reverse() : values7);
  }
  scale19.domain = function(_) {
    if (arguments.length) {
      domain3(_);
      return rescale();
    } else {
      return domain3();
    }
  };
  scale19.range = function(_) {
    if (arguments.length) {
      range$1 = [+_[0], +_[1]];
      return rescale();
    } else {
      return range$1.slice();
    }
  };
  scale19.rangeRound = function(_) {
    range$1 = [+_[0], +_[1]];
    round2 = true;
    return rescale();
  };
  scale19.bandwidth = function() {
    return bandwidth2;
  };
  scale19.step = function() {
    return step;
  };
  scale19.round = function(_) {
    if (arguments.length) {
      round2 = !!_;
      return rescale();
    } else {
      return round2;
    }
  };
  scale19.padding = function(_) {
    if (arguments.length) {
      paddingOuter2 = Math.max(0, Math.min(1, _));
      paddingInner2 = paddingOuter2;
      return rescale();
    } else {
      return paddingInner2;
    }
  };
  scale19.paddingInner = function(_) {
    if (arguments.length) {
      paddingInner2 = Math.max(0, Math.min(1, _));
      return rescale();
    } else {
      return paddingInner2;
    }
  };
  scale19.paddingOuter = function(_) {
    if (arguments.length) {
      paddingOuter2 = Math.max(0, Math.min(1, _));
      return rescale();
    } else {
      return paddingOuter2;
    }
  };
  scale19.align = function(_) {
    if (arguments.length) {
      align2 = Math.max(0, Math.min(1, _));
      return rescale();
    } else {
      return align2;
    }
  };
  scale19.invertRange = function(_) {
    if (_[0] == null || _[1] == null)
      return;
    const reverse4 = range$1[1] < range$1[0], values7 = reverse4 ? ordinalRange().reverse() : ordinalRange(), n = values7.length - 1;
    let lo = +_[0], hi = +_[1], a4, b6, t;
    if (lo !== lo || hi !== hi)
      return;
    if (hi < lo) {
      t = lo;
      lo = hi;
      hi = t;
    }
    if (hi < values7[0] || lo > range$1[1 - reverse4])
      return;
    a4 = Math.max(0, bisectRight(values7, lo) - 1);
    b6 = lo === hi ? a4 : bisectRight(values7, hi) - 1;
    if (lo - values7[a4] > bandwidth2 + 1e-10)
      ++a4;
    if (reverse4) {
      t = a4;
      a4 = n - b6;
      b6 = n - t;
    }
    return a4 > b6 ? void 0 : domain3().slice(a4, b6 + 1);
  };
  scale19.invert = function(_) {
    const value7 = scale19.invertRange([_, _]);
    return value7 ? value7[0] : value7;
  };
  scale19.copy = function() {
    return band5().domain(domain3()).range(range$1).round(round2).paddingInner(paddingInner2).paddingOuter(paddingOuter2).align(align2);
  };
  return rescale();
}
function pointish4(scale19) {
  const copy4 = scale19.copy;
  scale19.padding = scale19.paddingOuter;
  delete scale19.paddingInner;
  scale19.copy = function() {
    return pointish4(copy4());
  };
  return scale19;
}
function point10() {
  return pointish4(band5().paddingInner(1));
}
var map7 = Array.prototype.map;
function numbers6(_) {
  return map7.call(_, toNumber7);
}
var slice6 = Array.prototype.slice;
function scaleBinOrdinal4() {
  let domain3 = [], range7 = [];
  function scale19(x9) {
    return x9 == null || x9 !== x9 ? void 0 : range7[(bisect_default2(domain3, x9) - 1) % range7.length];
  }
  scale19.domain = function(_) {
    if (arguments.length) {
      domain3 = numbers6(_);
      return scale19;
    } else {
      return domain3.slice();
    }
  };
  scale19.range = function(_) {
    if (arguments.length) {
      range7 = slice6.call(_);
      return scale19;
    } else {
      return range7.slice();
    }
  };
  scale19.tickFormat = function(count3, specifier) {
    return tickFormat(domain3[0], peek7(domain3), count3 == null ? 10 : count3, specifier);
  };
  scale19.copy = function() {
    return scaleBinOrdinal4().domain(scale19.domain()).range(scale19.range());
  };
  return scale19;
}
var scales4 = /* @__PURE__ */ new Map();
var VEGA_SCALE4 = Symbol("vega_scale");
function registerScale4(scale19) {
  scale19[VEGA_SCALE4] = true;
  return scale19;
}
function create6(type7, constructor, metadata6) {
  const ctr = function scale19() {
    const s2 = constructor();
    if (!s2.invertRange) {
      s2.invertRange = s2.invert ? invertRange4(s2) : s2.invertExtent ? invertRangeExtent4(s2) : void 0;
    }
    s2.type = type7;
    return registerScale4(s2);
  };
  ctr.metadata = toSet8(array11(metadata6));
  return ctr;
}
function scale5(type7, scale19, metadata6) {
  if (arguments.length > 1) {
    scales4.set(type7, create6(type7, scale19, metadata6));
    return this;
  } else {
    return isValidScaleType4(type7) ? scales4.get(type7) : void 0;
  }
}
scale5(Identity4, identity8);
scale5(Linear5, linear3, Continuous4);
scale5(Log4, log3, [Continuous4, Log4]);
scale5(Pow4, pow3, Continuous4);
scale5(Sqrt4, sqrt2, Continuous4);
scale5(Symlog4, symlog2, Continuous4);
scale5(Time4, time, [Continuous4, Temporal4]);
scale5(UTC4, utcTime, [Continuous4, Temporal4]);
scale5(Sequential4, sequential, [Continuous4, Interpolating4]);
scale5(`${Sequential4}-${Linear5}`, sequential, [Continuous4, Interpolating4]);
scale5(`${Sequential4}-${Log4}`, sequentialLog, [Continuous4, Interpolating4, Log4]);
scale5(`${Sequential4}-${Pow4}`, sequentialPow, [Continuous4, Interpolating4]);
scale5(`${Sequential4}-${Sqrt4}`, sequentialSqrt, [Continuous4, Interpolating4]);
scale5(`${Sequential4}-${Symlog4}`, sequentialSymlog, [Continuous4, Interpolating4]);
scale5(`${Diverging4}-${Linear5}`, diverging, [Continuous4, Interpolating4]);
scale5(`${Diverging4}-${Log4}`, divergingLog, [Continuous4, Interpolating4, Log4]);
scale5(`${Diverging4}-${Pow4}`, divergingPow, [Continuous4, Interpolating4]);
scale5(`${Diverging4}-${Sqrt4}`, divergingSqrt, [Continuous4, Interpolating4]);
scale5(`${Diverging4}-${Symlog4}`, divergingSymlog, [Continuous4, Interpolating4]);
scale5(Quantile5, quantile2, [Discretizing4, Quantile5]);
scale5(Quantize4, quantize, Discretizing4);
scale5(Threshold4, threshold, Discretizing4);
scale5(BinOrdinal4, scaleBinOrdinal4, [Discrete4, Discretizing4]);
scale5(Ordinal4, ordinal, Discrete4);
scale5(Band4, band5, Discrete4);
scale5(Point4, point10, Discrete4);
function isValidScaleType4(type7) {
  return scales4.has(type7);
}
function hasType3(key4, type7) {
  const s2 = scales4.get(key4);
  return s2 && s2.metadata[type7];
}
function isDiscrete2(key4) {
  return hasType3(key4, Discrete4);
}
function isDiscretizing2(key4) {
  return hasType3(key4, Discretizing4);
}
function isLogarithmic3(key4) {
  return hasType3(key4, Log4);
}
function isTemporal2(key4) {
  return hasType3(key4, Temporal4);
}
function interpolateColors4(colors10, type7, gamma2) {
  return piecewise(interpolate4(type7 || "rgb", gamma2), colors10);
}
function interpolate4(type7, gamma2) {
  const interp = src_exports[method4(type7)];
  return gamma2 != null && interp && interp.gamma ? interp.gamma(gamma2) : interp;
}
function method4(type7) {
  return "interpolate" + type7.toLowerCase().split("-").map((s2) => s2[0].toUpperCase() + s2.slice(1)).join("");
}
var continuous5 = {
  blues: "cfe1f2bed8eca8cee58fc1de74b2d75ba3cf4592c63181bd206fb2125ca40a4a90",
  greens: "d3eecdc0e6baabdda594d3917bc77d60ba6c46ab5e329a512089430e7735036429",
  greys: "e2e2e2d4d4d4c4c4c4b1b1b19d9d9d8888887575756262624d4d4d3535351e1e1e",
  oranges: "fdd8b3fdc998fdb87bfda55efc9244f87f2cf06b18e4580bd14904b93d029f3303",
  purples: "e2e1efd4d4e8c4c5e0b4b3d6a3a0cc928ec3827cb97566ae684ea25c3696501f8c",
  reds: "fdc9b4fcb49afc9e80fc8767fa7051f6573fec3f2fdc2a25c81b1db21218970b13",
  blueGreen: "d5efedc1e8e0a7ddd18bd2be70c6a958ba9144ad77319c5d2089460e7736036429",
  bluePurple: "ccddecbad0e4a8c2dd9ab0d4919cc98d85be8b6db28a55a6873c99822287730f71",
  greenBlue: "d3eecec5e8c3b1e1bb9bd8bb82cec269c2ca51b2cd3c9fc7288abd1675b10b60a1",
  orangeRed: "fddcaffdcf9bfdc18afdad77fb9562f67d53ee6545e24932d32d1ebf130da70403",
  purpleBlue: "dbdaebc8cee4b1c3de97b7d87bacd15b9fc93a90c01e7fb70b70ab056199045281",
  purpleBlueGreen: "dbd8eac8cee4b0c3de93b7d872acd1549fc83892bb1c88a3097f8702736b016353",
  purpleRed: "dcc9e2d3b3d7ce9eccd186c0da6bb2e14da0e23189d91e6fc61159ab07498f023a",
  redPurple: "fccfccfcbec0faa9b8f98faff571a5ec539ddb3695c41b8aa908808d0179700174",
  yellowGreen: "e4f4acd1eca0b9e2949ed68880c97c62bb6e47aa5e3297502083440e723b036034",
  yellowOrangeBrown: "feeaa1fedd84fecc63feb746fca031f68921eb7215db5e0bc54c05ab3d038f3204",
  yellowOrangeRed: "fee087fed16ffebd59fea849fd903efc7335f9522bee3423de1b20ca0b22af0225",
  blueOrange: "134b852f78b35da2cb9dcae1d2e5eff2f0ebfce0bafbbf74e8932fc5690d994a07",
  brownBlueGreen: "704108a0651ac79548e3c78af3e6c6eef1eac9e9e48ed1c74da79e187a72025147",
  purpleGreen: "5b1667834792a67fb6c9aed3e6d6e8eff0efd9efd5aedda971bb75368e490e5e29",
  purpleOrange: "4114696647968f83b7b9b4d6dadbebf3eeeafce0bafbbf74e8932fc5690d994a07",
  redBlue: "8c0d25bf363adf745ef4ae91fbdbc9f2efeed2e5ef9dcae15da2cb2f78b3134b85",
  redGrey: "8c0d25bf363adf745ef4ae91fcdccbfaf4f1e2e2e2c0c0c0969696646464343434",
  yellowGreenBlue: "eff9bddbf1b4bde5b594d5b969c5be45b4c22c9ec02182b82163aa23479c1c3185",
  redYellowBlue: "a50026d4322cf16e43fcac64fedd90faf8c1dcf1ecabd6e875abd04a74b4313695",
  redYellowGreen: "a50026d4322cf16e43fcac63fedd8df9f7aed7ee8ea4d86e64bc6122964f006837",
  pinkYellowGreen: "8e0152c0267edd72adf0b3d6faddedf5f3efe1f2cab6de8780bb474f9125276419",
  spectral: "9e0142d13c4bf0704afcac63fedd8dfbf8b0e0f3a1a9dda269bda94288b55e4fa2",
  viridis: "440154470e61481a6c482575472f7d443a834144873d4e8a39568c35608d31688e2d708e2a788e27818e23888e21918d1f988b1fa08822a8842ab07f35b77943bf7154c56866cc5d7ad1518fd744a5db36bcdf27d2e21be9e51afde725",
  magma: "0000040404130b0924150e3720114b2c11603b0f704a107957157e651a80721f817f24828c29819a2e80a8327db6377ac43c75d1426fde4968e95462f1605df76f5cfa7f5efc8f65fe9f6dfeaf78febf84fece91fddea0fcedaffcfdbf",
  inferno: "0000040403130c0826170c3b240c4f330a5f420a68500d6c5d126e6b176e781c6d86216b932667a12b62ae305cbb3755c73e4cd24644dd513ae65c30ed6925f3771af8850ffb9506fca50afcb519fac62df6d645f2e661f3f484fcffa4",
  plasma: "0d088723069033059742039d5002a25d01a66a00a87801a88405a7900da49c179ea72198b12a90ba3488c33d80cb4779d35171da5a69e16462e76e5bed7953f2834cf68f44fa9a3dfca636fdb32ffec029fcce25f9dc24f5ea27f0f921",
  cividis: "00205100235800265d002961012b65042e670831690d346b11366c16396d1c3c6e213f6e26426e2c456e31476e374a6e3c4d6e42506e47536d4c566d51586e555b6e5a5e6e5e616e62646f66676f6a6a706e6d717270717573727976737c79747f7c75827f758682768985778c8877908b78938e789691789a94789e9778a19b78a59e77a9a177aea575b2a874b6ab73bbaf71c0b26fc5b66dc9b96acebd68d3c065d8c462ddc85fe2cb5ce7cf58ebd355f0d652f3da4ff7de4cfae249fce647",
  rainbow: "6e40aa883eb1a43db3bf3cafd83fa4ee4395fe4b83ff576eff6659ff7847ff8c38f3a130e2b72fcfcc36bee044aff05b8ff4576ff65b52f6673af27828ea8d1ddfa319d0b81cbecb23abd82f96e03d82e14c6edb5a5dd0664dbf6e40aa",
  sinebow: "ff4040fc582af47218e78d0bd5a703bfbf00a7d5038de70b72f41858fc2a40ff402afc5818f4720be78d03d5a700bfbf03a7d50b8de71872f42a58fc4040ff582afc7218f48d0be7a703d5bf00bfd503a7e70b8df41872fc2a58ff4040",
  turbo: "23171b32204a3e2a71453493493eae4b49c54a53d7485ee44569ee4074f53c7ff8378af93295f72e9ff42ba9ef28b3e926bce125c5d925cdcf27d5c629dcbc2de3b232e9a738ee9d3ff39347f68950f9805afc7765fd6e70fe667cfd5e88fc5795fb51a1f84badf545b9f140c5ec3cd0e637dae034e4d931ecd12ef4c92bfac029ffb626ffad24ffa223ff9821ff8d1fff821dff771cfd6c1af76118f05616e84b14df4111d5380fcb2f0dc0260ab61f07ac1805a313029b0f00950c00910b00",
  browns: "eedbbdecca96e9b97ae4a865dc9856d18954c7784cc0673fb85536ad44339f3632",
  tealBlues: "bce4d89dd3d181c3cb65b3c245a2b9368fae347da0306a932c5985",
  teals: "bbdfdfa2d4d58ac9c975bcbb61b0af4da5a43799982b8b8c1e7f7f127273006667",
  warmGreys: "dcd4d0cec5c1c0b8b4b3aaa7a59c9998908c8b827f7e7673726866665c5a59504e",
  goldGreen: "f4d166d5ca60b6c35c98bb597cb25760a6564b9c533f8f4f33834a257740146c36",
  goldOrange: "f4d166f8be5cf8aa4cf5983bf3852aef701be2621fd65322c54923b142239e3a26",
  goldRed: "f4d166f6be59f9aa51fc964ef6834bee734ae56249db5247cf4244c43141b71d3e",
  lightGreyRed: "efe9e6e1dad7d5cbc8c8bdb9bbaea9cd967ddc7b43e15f19df4011dc000b",
  lightGreyTeal: "e4eaead6dcddc8ced2b7c2c7a6b4bc64b0bf22a6c32295c11f85be1876bc",
  lightMulti: "e0f1f2c4e9d0b0de9fd0e181f6e072f6c053f3993ef77440ef4a3c",
  lightOrange: "f2e7daf7d5baf9c499fab184fa9c73f68967ef7860e8645bde515bd43d5b",
  lightTealBlue: "e3e9e0c0dccf9aceca7abfc859afc0389fb9328dad2f7ca0276b95255988",
  darkBlue: "3232322d46681a5c930074af008cbf05a7ce25c0dd38daed50f3faffffff",
  darkGold: "3c3c3c584b37725e348c7631ae8b2bcfa424ecc31ef9de30fff184ffffff",
  darkGreen: "3a3a3a215748006f4d048942489e4276b340a6c63dd2d836ffeb2cffffaa",
  darkMulti: "3737371f5287197d8c29a86995ce3fffe800ffffff",
  darkRed: "3434347036339e3c38cc4037e75d1eec8620eeab29f0ce32ffeb2c"
};
var discrete4 = {
  accent: Accent_default,
  category10: category10_default,
  category20: "1f77b4aec7e8ff7f0effbb782ca02c98df8ad62728ff98969467bdc5b0d58c564bc49c94e377c2f7b6d27f7f7fc7c7c7bcbd22dbdb8d17becf9edae5",
  category20b: "393b795254a36b6ecf9c9ede6379398ca252b5cf6bcedb9c8c6d31bd9e39e7ba52e7cb94843c39ad494ad6616be7969c7b4173a55194ce6dbdde9ed6",
  category20c: "3182bd6baed69ecae1c6dbefe6550dfd8d3cfdae6bfdd0a231a35474c476a1d99bc7e9c0756bb19e9ac8bcbddcdadaeb636363969696bdbdbdd9d9d9",
  dark2: Dark2_default,
  observable10: observable10_default,
  paired: Paired_default,
  pastel1: Pastel1_default,
  pastel2: Pastel2_default,
  set1: Set1_default,
  set2: Set2_default,
  set3: Set3_default,
  tableau10: "4c78a8f58518e4575672b7b254a24beeca3bb279a2ff9da69d755dbab0ac",
  tableau20: "4c78a89ecae9f58518ffbf7954a24b88d27ab79a20f2cf5b43989483bcb6e45756ff9d9879706ebab0acd67195fcbfd2b279a2d6a5c99e765fd8b5a5"
};
function colors4(palette) {
  if (isArray10(palette))
    return palette;
  const n = palette.length / 6 | 0, c5 = new Array(n);
  for (let i = 0; i < n; ) {
    c5[i] = "#" + palette.slice(i * 6, ++i * 6);
  }
  return c5;
}
function apply4(_, f) {
  for (const k3 in _)
    scheme31(k3, f(_[k3]));
}
var schemes4 = {};
apply4(discrete4, colors4);
apply4(continuous5, (_) => interpolateColors4(colors4(_)));
function scheme31(name, scheme38) {
  name = name && name.toLowerCase();
  if (arguments.length > 1) {
    schemes4[name] = scheme38;
    return this;
  } else {
    return schemes4[name];
  }
}
var SymbolLegend3 = "symbol";
var DiscreteLegend3 = "discrete";
var defaultFormatter3 = (value7) => isArray10(value7) ? value7.map((v2) => String(v2)) : String(value7);
var ascending6 = (a4, b6) => a4[1] - b6[1];
var descending4 = (a4, b6) => b6[1] - a4[1];
function validTicks3(scale19, ticks2, count3) {
  let range7 = scale19.range(), lo = range7[0], hi = peek7(range7), cmp = ascending6;
  if (lo > hi) {
    range7 = hi;
    hi = lo;
    lo = range7;
    cmp = descending4;
  }
  lo = Math.floor(lo);
  hi = Math.ceil(hi);
  ticks2 = ticks2.map((v2) => [v2, scale19(v2)]).filter((_) => lo <= _[1] && _[1] <= hi).sort(cmp).map((_) => _[0]);
  if (count3 > 0 && ticks2.length > 1) {
    const endpoints = [ticks2[0], peek7(ticks2)];
    while (ticks2.length > count3 && ticks2.length >= 3) {
      ticks2 = ticks2.filter((_, i) => !(i % 2));
    }
    if (ticks2.length < 3) {
      ticks2 = endpoints;
    }
  }
  return ticks2;
}
function tickValues3(scale19, count3) {
  return scale19.bins ? validTicks3(scale19, scale19.bins, count3) : scale19.ticks ? scale19.ticks(count3) : scale19.domain();
}
function tickFormat4(locale5, scale19, count3, specifier, formatType, noSkip) {
  const type7 = scale19.type;
  let format14 = defaultFormatter3;
  if (type7 === Time4 || formatType === Time4) {
    format14 = locale5.timeFormat(specifier);
  } else if (type7 === UTC4 || formatType === UTC4) {
    format14 = locale5.utcFormat(specifier);
  } else if (isLogarithmic3(type7)) {
    const varfmt = locale5.formatFloat(specifier);
    if (noSkip || scale19.bins) {
      format14 = varfmt;
    } else {
      const test2 = tickLog3(scale19, count3, false);
      format14 = (_) => test2(_) ? varfmt(_) : "";
    }
  } else if (scale19.tickFormat) {
    const d = scale19.domain();
    format14 = locale5.formatSpan(d[0], d[d.length - 1], count3, specifier);
  } else if (specifier) {
    format14 = locale5.format(specifier);
  }
  return format14;
}
function tickLog3(scale19, count3, values7) {
  const ticks2 = tickValues3(scale19, count3), base = scale19.base(), logb = Math.log(base), k3 = Math.max(1, base * count3 / ticks2.length);
  const test2 = (d) => {
    let i = d / Math.pow(base, Math.round(Math.log(d) / logb));
    if (i * base < base - 0.5)
      i *= base;
    return i <= k3;
  };
  return values7 ? ticks2.filter(test2) : test2;
}
var symbols5 = {
  [Quantile5]: "quantiles",
  [Quantize4]: "thresholds",
  [Threshold4]: "domain"
};
var formats5 = {
  [Quantile5]: "quantiles",
  [Quantize4]: "domain"
};
function labelValues3(scale19, count3) {
  return scale19.bins ? binValues3(scale19.bins) : scale19.type === Log4 ? tickLog3(scale19, count3, true) : symbols5[scale19.type] ? thresholdValues3(scale19[symbols5[scale19.type]]()) : tickValues3(scale19, count3);
}
function thresholdFormat3(locale5, scale19, specifier) {
  const _ = scale19[formats5[scale19.type]](), n = _.length;
  let d = n > 1 ? _[1] - _[0] : _[0], i;
  for (i = 1; i < n; ++i) {
    d = Math.min(d, _[i] - _[i - 1]);
  }
  return locale5.formatSpan(0, d, 3 * 10, specifier);
}
function thresholdValues3(thresholds) {
  const values7 = [-Infinity].concat(thresholds);
  values7.max = Infinity;
  return values7;
}
function binValues3(bins2) {
  const values7 = bins2.slice(0, -1);
  values7.max = peek7(bins2);
  return values7;
}
var isDiscreteRange3 = (scale19) => symbols5[scale19.type] || scale19.bins;
function labelFormat3(locale5, scale19, count3, type7, specifier, formatType, noSkip) {
  const format14 = formats5[scale19.type] && formatType !== Time4 && formatType !== UTC4 ? thresholdFormat3(locale5, scale19, specifier) : tickFormat4(locale5, scale19, count3, specifier, formatType, noSkip);
  return type7 === SymbolLegend3 && isDiscreteRange3(scale19) ? formatRange3(format14) : type7 === DiscreteLegend3 ? formatDiscrete3(format14) : formatPoint3(format14);
}
var formatRange3 = (format14) => (value7, index4, array22) => {
  const limit = get7(array22[index4 + 1], get7(array22.max, Infinity)), lo = formatValue3(value7, format14), hi = formatValue3(limit, format14);
  return lo && hi ? lo + " – " + hi : hi ? "< " + hi : "≥ " + lo;
};
var get7 = (value7, dflt) => value7 != null ? value7 : dflt;
var formatDiscrete3 = (format14) => (value7, index4) => index4 ? format14(value7) : null;
var formatPoint3 = (format14) => (value7) => format14(value7);
var formatValue3 = (value7, format14) => Number.isFinite(value7) ? format14(value7) : null;
function format6(locale5, scale19, specifier, formatType) {
  const type7 = formatType || scale19.type;
  if (isString6(specifier) && isTemporal2(type7)) {
    specifier = specifier.replace(/%a/g, "%A").replace(/%b/g, "%B");
  }
  return !specifier && type7 === Time4 ? locale5.timeFormat("%A, %d %B %Y, %X") : !specifier && type7 === UTC4 ? locale5.utcFormat("%A, %d %B %Y, %X UTC") : labelFormat3(locale5, scale19, 5, null, specifier, formatType, true);
}
function domainCaption2(locale5, scale19, opt) {
  opt = opt || {};
  const max5 = Math.max(3, opt.maxlen || 7), fmt = format6(locale5, scale19, opt.format, opt.formatType);
  if (isDiscretizing2(scale19.type)) {
    const v2 = labelValues3(scale19).slice(1).map(fmt), n = v2.length;
    return `${n} boundar${n === 1 ? "y" : "ies"}: ${v2.join(", ")}`;
  } else if (isDiscrete2(scale19.type)) {
    const d = scale19.domain(), n = d.length, v2 = n > max5 ? d.slice(0, max5 - 2).map(fmt).join(", ") + ", ending with " + d.slice(-1).map(fmt) : d.map(fmt).join(", ");
    return `${n} value${n === 1 ? "" : "s"}: ${v2}`;
  } else {
    const d = scale19.domain();
    return `values from ${fmt(d[0])} to ${fmt(peek7(d))}`;
  }
}

// node_modules/vega-label/node_modules/vega-scenegraph/build/vega-scenegraph.js
var gradient_id2 = 0;
var patternPrefix2 = "p_";
function isGradient2(value7) {
  return value7 && value7.gradient;
}
function gradientRef2(g, defs, base) {
  const type7 = g.gradient;
  let id24 = g.id, prefix = type7 === "radial" ? patternPrefix2 : "";
  if (!id24) {
    id24 = g.id = "gradient_" + gradient_id2++;
    if (type7 === "radial") {
      g.x1 = get8(g.x1, 0.5);
      g.y1 = get8(g.y1, 0.5);
      g.r1 = get8(g.r1, 0);
      g.x2 = get8(g.x2, 0.5);
      g.y2 = get8(g.y2, 0.5);
      g.r2 = get8(g.r2, 0.5);
      prefix = patternPrefix2;
    } else {
      g.x1 = get8(g.x1, 0);
      g.y1 = get8(g.y1, 0);
      g.x2 = get8(g.x2, 1);
      g.y2 = get8(g.y2, 0);
    }
  }
  defs[id24] = g;
  return "url(" + (base || "") + "#" + prefix + id24 + ")";
}
function get8(val, def6) {
  return val != null ? val : def6;
}
var lookup4 = {
  "basis": {
    curve: basis_default
  },
  "basis-closed": {
    curve: basisClosed_default
  },
  "basis-open": {
    curve: basisOpen_default
  },
  "bundle": {
    curve: bundle_default,
    tension: "beta",
    value: 0.85
  },
  "cardinal": {
    curve: cardinal_default,
    tension: "tension",
    value: 0
  },
  "cardinal-open": {
    curve: cardinalOpen_default,
    tension: "tension",
    value: 0
  },
  "cardinal-closed": {
    curve: cardinalClosed_default,
    tension: "tension",
    value: 0
  },
  "catmull-rom": {
    curve: catmullRom_default,
    tension: "alpha",
    value: 0.5
  },
  "catmull-rom-closed": {
    curve: catmullRomClosed_default,
    tension: "alpha",
    value: 0.5
  },
  "catmull-rom-open": {
    curve: catmullRomOpen_default,
    tension: "alpha",
    value: 0.5
  },
  "linear": {
    curve: linear_default
  },
  "linear-closed": {
    curve: linearClosed_default
  },
  "monotone": {
    horizontal: monotoneY,
    vertical: monotoneX
  },
  "natural": {
    curve: natural_default
  },
  "step": {
    curve: step_default
  },
  "step-after": {
    curve: stepAfter
  },
  "step-before": {
    curve: stepBefore
  }
};
function curves2(type7, orientation, tension) {
  var entry2 = has9(lookup4, type7) && lookup4[type7], curve2 = null;
  if (entry2) {
    curve2 = entry2.curve || entry2[orientation || "vertical"];
    if (entry2.tension && tension != null) {
      curve2 = curve2[entry2.tension](tension);
    }
  }
  return curve2;
}
var paramCounts2 = {
  m: 2,
  l: 2,
  h: 1,
  v: 1,
  z: 0,
  c: 6,
  s: 4,
  q: 4,
  t: 2,
  a: 7
};
var commandPattern2 = /[mlhvzcsqta]([^mlhvzcsqta]+|$)/gi;
var numberPattern2 = /^[+-]?(([0-9]*\.[0-9]+)|([0-9]+\.)|([0-9]+))([eE][+-]?[0-9]+)?/;
var spacePattern2 = /^((\s+,?\s*)|(,\s*))/;
var flagPattern2 = /^[01]/;
function parse5(path7) {
  const commands = [];
  const matches = path7.match(commandPattern2) || [];
  matches.forEach((str) => {
    let cmd = str[0];
    const type7 = cmd.toLowerCase();
    const paramCount = paramCounts2[type7];
    const params2 = parseParams2(type7, paramCount, str.slice(1).trim());
    const count3 = params2.length;
    if (count3 < paramCount || count3 && count3 % paramCount !== 0) {
      throw Error("Invalid SVG path, incorrect parameter count");
    }
    commands.push([cmd, ...params2.slice(0, paramCount)]);
    if (count3 === paramCount) {
      return;
    }
    if (type7 === "m") {
      cmd = cmd === "M" ? "L" : "l";
    }
    for (let i = paramCount; i < count3; i += paramCount) {
      commands.push([cmd, ...params2.slice(i, i + paramCount)]);
    }
  });
  return commands;
}
function parseParams2(type7, paramCount, segment) {
  const params2 = [];
  for (let index4 = 0; paramCount && index4 < segment.length; ) {
    for (let i = 0; i < paramCount; ++i) {
      const pattern = type7 === "a" && (i === 3 || i === 4) ? flagPattern2 : numberPattern2;
      const match2 = segment.slice(index4).match(pattern);
      if (match2 === null) {
        throw Error("Invalid SVG path, incorrect parameter type");
      }
      index4 += match2[0].length;
      params2.push(+match2[0]);
      const ws = segment.slice(index4).match(spacePattern2);
      if (ws !== null) {
        index4 += ws[0].length;
      }
    }
  }
  return params2;
}
var DegToRad2 = Math.PI / 180;
var Epsilon2 = 1e-14;
var HalfPi2 = Math.PI / 2;
var Tau2 = Math.PI * 2;
var HalfSqrt32 = Math.sqrt(3) / 2;
var segmentCache2 = {};
var bezierCache2 = {};
var join2 = [].join;
function segments2(x9, y9, rx, ry, large, sweep, rotateX, ox, oy) {
  const key4 = join2.call(arguments);
  if (segmentCache2[key4]) {
    return segmentCache2[key4];
  }
  const th = rotateX * DegToRad2;
  const sin_th = Math.sin(th);
  const cos_th = Math.cos(th);
  rx = Math.abs(rx);
  ry = Math.abs(ry);
  const px6 = cos_th * (ox - x9) * 0.5 + sin_th * (oy - y9) * 0.5;
  const py6 = cos_th * (oy - y9) * 0.5 - sin_th * (ox - x9) * 0.5;
  let pl = px6 * px6 / (rx * rx) + py6 * py6 / (ry * ry);
  if (pl > 1) {
    pl = Math.sqrt(pl);
    rx *= pl;
    ry *= pl;
  }
  const a00 = cos_th / rx;
  const a01 = sin_th / rx;
  const a10 = -sin_th / ry;
  const a11 = cos_th / ry;
  const x07 = a00 * ox + a01 * oy;
  const y07 = a10 * ox + a11 * oy;
  const x13 = a00 * x9 + a01 * y9;
  const y13 = a10 * x9 + a11 * y9;
  const d = (x13 - x07) * (x13 - x07) + (y13 - y07) * (y13 - y07);
  let sfactor_sq = 1 / d - 0.25;
  if (sfactor_sq < 0)
    sfactor_sq = 0;
  let sfactor = Math.sqrt(sfactor_sq);
  if (sweep == large)
    sfactor = -sfactor;
  const xc = 0.5 * (x07 + x13) - sfactor * (y13 - y07);
  const yc = 0.5 * (y07 + y13) + sfactor * (x13 - x07);
  const th0 = Math.atan2(y07 - yc, x07 - xc);
  const th1 = Math.atan2(y13 - yc, x13 - xc);
  let th_arc = th1 - th0;
  if (th_arc < 0 && sweep === 1) {
    th_arc += Tau2;
  } else if (th_arc > 0 && sweep === 0) {
    th_arc -= Tau2;
  }
  const segs = Math.ceil(Math.abs(th_arc / (HalfPi2 + 1e-3)));
  const result = [];
  for (let i = 0; i < segs; ++i) {
    const th2 = th0 + i * th_arc / segs;
    const th3 = th0 + (i + 1) * th_arc / segs;
    result[i] = [xc, yc, th2, th3, rx, ry, sin_th, cos_th];
  }
  return segmentCache2[key4] = result;
}
function bezier2(params2) {
  const key4 = join2.call(params2);
  if (bezierCache2[key4]) {
    return bezierCache2[key4];
  }
  var cx = params2[0], cy = params2[1], th0 = params2[2], th1 = params2[3], rx = params2[4], ry = params2[5], sin_th = params2[6], cos_th = params2[7];
  const a00 = cos_th * rx;
  const a01 = -sin_th * ry;
  const a10 = sin_th * rx;
  const a11 = cos_th * ry;
  const cos_th0 = Math.cos(th0);
  const sin_th0 = Math.sin(th0);
  const cos_th1 = Math.cos(th1);
  const sin_th1 = Math.sin(th1);
  const th_half = 0.5 * (th1 - th0);
  const sin_th_h2 = Math.sin(th_half * 0.5);
  const t = 8 / 3 * sin_th_h2 * sin_th_h2 / Math.sin(th_half);
  const x13 = cx + cos_th0 - t * sin_th0;
  const y13 = cy + sin_th0 + t * cos_th0;
  const x32 = cx + cos_th1;
  const y32 = cy + sin_th1;
  const x22 = x32 + t * sin_th1;
  const y22 = y32 - t * cos_th1;
  return bezierCache2[key4] = [a00 * x13 + a01 * y13, a10 * x13 + a11 * y13, a00 * x22 + a01 * y22, a10 * x22 + a11 * y22, a00 * x32 + a01 * y32, a10 * x32 + a11 * y32];
}
var temp2 = ["l", 0, 0, 0, 0, 0, 0, 0];
function scale$12(current2, sX, sY) {
  const c5 = temp2[0] = current2[0];
  if (c5 === "a" || c5 === "A") {
    temp2[1] = sX * current2[1];
    temp2[2] = sY * current2[2];
    temp2[3] = current2[3];
    temp2[4] = current2[4];
    temp2[5] = current2[5];
    temp2[6] = sX * current2[6];
    temp2[7] = sY * current2[7];
  } else if (c5 === "h" || c5 === "H") {
    temp2[1] = sX * current2[1];
  } else if (c5 === "v" || c5 === "V") {
    temp2[1] = sY * current2[1];
  } else {
    for (var i = 1, n = current2.length; i < n; ++i) {
      temp2[i] = (i % 2 == 1 ? sX : sY) * current2[i];
    }
  }
  return temp2;
}
function pathRender2(context7, path7, l, t, sX, sY) {
  var current2, previous = null, x9 = 0, y9 = 0, controlX = 0, controlY = 0, tempX, tempY, tempControlX, tempControlY, anchorX = 0, anchorY = 0;
  if (l == null)
    l = 0;
  if (t == null)
    t = 0;
  if (sX == null)
    sX = 1;
  if (sY == null)
    sY = sX;
  if (context7.beginPath)
    context7.beginPath();
  for (var i = 0, len = path7.length; i < len; ++i) {
    current2 = path7[i];
    if (sX !== 1 || sY !== 1) {
      current2 = scale$12(current2, sX, sY);
    }
    switch (current2[0]) {
      case "l":
        x9 += current2[1];
        y9 += current2[2];
        context7.lineTo(x9 + l, y9 + t);
        break;
      case "L":
        x9 = current2[1];
        y9 = current2[2];
        context7.lineTo(x9 + l, y9 + t);
        break;
      case "h":
        x9 += current2[1];
        context7.lineTo(x9 + l, y9 + t);
        break;
      case "H":
        x9 = current2[1];
        context7.lineTo(x9 + l, y9 + t);
        break;
      case "v":
        y9 += current2[1];
        context7.lineTo(x9 + l, y9 + t);
        break;
      case "V":
        y9 = current2[1];
        context7.lineTo(x9 + l, y9 + t);
        break;
      case "m":
        x9 += current2[1];
        y9 += current2[2];
        anchorX = x9;
        anchorY = y9;
        context7.moveTo(x9 + l, y9 + t);
        break;
      case "M":
        x9 = current2[1];
        y9 = current2[2];
        anchorX = x9;
        anchorY = y9;
        context7.moveTo(x9 + l, y9 + t);
        break;
      case "c":
        tempX = x9 + current2[5];
        tempY = y9 + current2[6];
        controlX = x9 + current2[3];
        controlY = y9 + current2[4];
        context7.bezierCurveTo(
          x9 + current2[1] + l,
          // x1
          y9 + current2[2] + t,
          // y1
          controlX + l,
          // x2
          controlY + t,
          // y2
          tempX + l,
          tempY + t
        );
        x9 = tempX;
        y9 = tempY;
        break;
      case "C":
        x9 = current2[5];
        y9 = current2[6];
        controlX = current2[3];
        controlY = current2[4];
        context7.bezierCurveTo(current2[1] + l, current2[2] + t, controlX + l, controlY + t, x9 + l, y9 + t);
        break;
      case "s":
        tempX = x9 + current2[3];
        tempY = y9 + current2[4];
        controlX = 2 * x9 - controlX;
        controlY = 2 * y9 - controlY;
        context7.bezierCurveTo(controlX + l, controlY + t, x9 + current2[1] + l, y9 + current2[2] + t, tempX + l, tempY + t);
        controlX = x9 + current2[1];
        controlY = y9 + current2[2];
        x9 = tempX;
        y9 = tempY;
        break;
      case "S":
        tempX = current2[3];
        tempY = current2[4];
        controlX = 2 * x9 - controlX;
        controlY = 2 * y9 - controlY;
        context7.bezierCurveTo(controlX + l, controlY + t, current2[1] + l, current2[2] + t, tempX + l, tempY + t);
        x9 = tempX;
        y9 = tempY;
        controlX = current2[1];
        controlY = current2[2];
        break;
      case "q":
        tempX = x9 + current2[3];
        tempY = y9 + current2[4];
        controlX = x9 + current2[1];
        controlY = y9 + current2[2];
        context7.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t);
        x9 = tempX;
        y9 = tempY;
        break;
      case "Q":
        tempX = current2[3];
        tempY = current2[4];
        context7.quadraticCurveTo(current2[1] + l, current2[2] + t, tempX + l, tempY + t);
        x9 = tempX;
        y9 = tempY;
        controlX = current2[1];
        controlY = current2[2];
        break;
      case "t":
        tempX = x9 + current2[1];
        tempY = y9 + current2[2];
        if (previous[0].match(/[QqTt]/) === null) {
          controlX = x9;
          controlY = y9;
        } else if (previous[0] === "t") {
          controlX = 2 * x9 - tempControlX;
          controlY = 2 * y9 - tempControlY;
        } else if (previous[0] === "q") {
          controlX = 2 * x9 - controlX;
          controlY = 2 * y9 - controlY;
        }
        tempControlX = controlX;
        tempControlY = controlY;
        context7.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t);
        x9 = tempX;
        y9 = tempY;
        controlX = x9 + current2[1];
        controlY = y9 + current2[2];
        break;
      case "T":
        tempX = current2[1];
        tempY = current2[2];
        controlX = 2 * x9 - controlX;
        controlY = 2 * y9 - controlY;
        context7.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t);
        x9 = tempX;
        y9 = tempY;
        break;
      case "a":
        drawArc2(context7, x9 + l, y9 + t, [current2[1], current2[2], current2[3], current2[4], current2[5], current2[6] + x9 + l, current2[7] + y9 + t]);
        x9 += current2[6];
        y9 += current2[7];
        break;
      case "A":
        drawArc2(context7, x9 + l, y9 + t, [current2[1], current2[2], current2[3], current2[4], current2[5], current2[6] + l, current2[7] + t]);
        x9 = current2[6];
        y9 = current2[7];
        break;
      case "z":
      case "Z":
        x9 = anchorX;
        y9 = anchorY;
        context7.closePath();
        break;
    }
    previous = current2;
  }
}
function drawArc2(context7, x9, y9, coords) {
  const seg = segments2(
    coords[5],
    // end x
    coords[6],
    // end y
    coords[0],
    // radius x
    coords[1],
    // radius y
    coords[3],
    // large flag
    coords[4],
    // sweep flag
    coords[2],
    // rotation
    x9,
    y9
  );
  for (let i = 0; i < seg.length; ++i) {
    const bez = bezier2(seg[i]);
    context7.bezierCurveTo(bez[0], bez[1], bez[2], bez[3], bez[4], bez[5]);
  }
}
var Tan302 = 0.5773502691896257;
var builtins2 = {
  "circle": {
    draw: function(context7, size) {
      const r = Math.sqrt(size) / 2;
      context7.moveTo(r, 0);
      context7.arc(0, 0, r, 0, Tau2);
    }
  },
  "cross": {
    draw: function(context7, size) {
      var r = Math.sqrt(size) / 2, s2 = r / 2.5;
      context7.moveTo(-r, -s2);
      context7.lineTo(-r, s2);
      context7.lineTo(-s2, s2);
      context7.lineTo(-s2, r);
      context7.lineTo(s2, r);
      context7.lineTo(s2, s2);
      context7.lineTo(r, s2);
      context7.lineTo(r, -s2);
      context7.lineTo(s2, -s2);
      context7.lineTo(s2, -r);
      context7.lineTo(-s2, -r);
      context7.lineTo(-s2, -s2);
      context7.closePath();
    }
  },
  "diamond": {
    draw: function(context7, size) {
      const r = Math.sqrt(size) / 2;
      context7.moveTo(-r, 0);
      context7.lineTo(0, -r);
      context7.lineTo(r, 0);
      context7.lineTo(0, r);
      context7.closePath();
    }
  },
  "square": {
    draw: function(context7, size) {
      var w8 = Math.sqrt(size), x9 = -w8 / 2;
      context7.rect(x9, x9, w8, w8);
    }
  },
  "arrow": {
    draw: function(context7, size) {
      var r = Math.sqrt(size) / 2, s2 = r / 7, t = r / 2.5, v2 = r / 8;
      context7.moveTo(-s2, r);
      context7.lineTo(s2, r);
      context7.lineTo(s2, -v2);
      context7.lineTo(t, -v2);
      context7.lineTo(0, -r);
      context7.lineTo(-t, -v2);
      context7.lineTo(-s2, -v2);
      context7.closePath();
    }
  },
  "wedge": {
    draw: function(context7, size) {
      var r = Math.sqrt(size) / 2, h6 = HalfSqrt32 * r, o = h6 - r * Tan302, b6 = r / 4;
      context7.moveTo(0, -h6 - o);
      context7.lineTo(-b6, h6 - o);
      context7.lineTo(b6, h6 - o);
      context7.closePath();
    }
  },
  "triangle": {
    draw: function(context7, size) {
      var r = Math.sqrt(size) / 2, h6 = HalfSqrt32 * r, o = h6 - r * Tan302;
      context7.moveTo(0, -h6 - o);
      context7.lineTo(-r, h6 - o);
      context7.lineTo(r, h6 - o);
      context7.closePath();
    }
  },
  "triangle-up": {
    draw: function(context7, size) {
      var r = Math.sqrt(size) / 2, h6 = HalfSqrt32 * r;
      context7.moveTo(0, -h6);
      context7.lineTo(-r, h6);
      context7.lineTo(r, h6);
      context7.closePath();
    }
  },
  "triangle-down": {
    draw: function(context7, size) {
      var r = Math.sqrt(size) / 2, h6 = HalfSqrt32 * r;
      context7.moveTo(0, h6);
      context7.lineTo(-r, -h6);
      context7.lineTo(r, -h6);
      context7.closePath();
    }
  },
  "triangle-right": {
    draw: function(context7, size) {
      var r = Math.sqrt(size) / 2, h6 = HalfSqrt32 * r;
      context7.moveTo(h6, 0);
      context7.lineTo(-h6, -r);
      context7.lineTo(-h6, r);
      context7.closePath();
    }
  },
  "triangle-left": {
    draw: function(context7, size) {
      var r = Math.sqrt(size) / 2, h6 = HalfSqrt32 * r;
      context7.moveTo(-h6, 0);
      context7.lineTo(h6, -r);
      context7.lineTo(h6, r);
      context7.closePath();
    }
  },
  "stroke": {
    draw: function(context7, size) {
      const r = Math.sqrt(size) / 2;
      context7.moveTo(-r, 0);
      context7.lineTo(r, 0);
    }
  }
};
function symbols6(_) {
  return has9(builtins2, _) ? builtins2[_] : customSymbol2(_);
}
var custom11 = {};
function customSymbol2(path7) {
  if (!has9(custom11, path7)) {
    const parsed = parse5(path7);
    custom11[path7] = {
      draw: function(context7, size) {
        pathRender2(context7, parsed, 0, 0, Math.sqrt(size) / 2);
      }
    };
  }
  return custom11[path7];
}
var C3 = 0.448084975506;
function rectangleX2(d) {
  return d.x;
}
function rectangleY2(d) {
  return d.y;
}
function rectangleWidth2(d) {
  return d.width;
}
function rectangleHeight2(d) {
  return d.height;
}
function number6(_) {
  return typeof _ === "function" ? _ : () => +_;
}
function clamp2(value7, min5, max5) {
  return Math.max(min5, Math.min(value7, max5));
}
function vg_rect2() {
  var x9 = rectangleX2, y9 = rectangleY2, width2 = rectangleWidth2, height2 = rectangleHeight2, crTL = number6(0), crTR = crTL, crBL = crTL, crBR = crTL, context7 = null;
  function rectangle6(_, x07, y07) {
    var buffer, x13 = x07 != null ? x07 : +x9.call(this, _), y13 = y07 != null ? y07 : +y9.call(this, _), w8 = +width2.call(this, _), h6 = +height2.call(this, _), s2 = Math.min(w8, h6) / 2, tl6 = clamp2(+crTL.call(this, _), 0, s2), tr6 = clamp2(+crTR.call(this, _), 0, s2), bl6 = clamp2(+crBL.call(this, _), 0, s2), br6 = clamp2(+crBR.call(this, _), 0, s2);
    if (!context7)
      context7 = buffer = path();
    if (tl6 <= 0 && tr6 <= 0 && bl6 <= 0 && br6 <= 0) {
      context7.rect(x13, y13, w8, h6);
    } else {
      var x22 = x13 + w8, y22 = y13 + h6;
      context7.moveTo(x13 + tl6, y13);
      context7.lineTo(x22 - tr6, y13);
      context7.bezierCurveTo(x22 - C3 * tr6, y13, x22, y13 + C3 * tr6, x22, y13 + tr6);
      context7.lineTo(x22, y22 - br6);
      context7.bezierCurveTo(x22, y22 - C3 * br6, x22 - C3 * br6, y22, x22 - br6, y22);
      context7.lineTo(x13 + bl6, y22);
      context7.bezierCurveTo(x13 + C3 * bl6, y22, x13, y22 - C3 * bl6, x13, y22 - bl6);
      context7.lineTo(x13, y13 + tl6);
      context7.bezierCurveTo(x13, y13 + C3 * tl6, x13 + C3 * tl6, y13, x13 + tl6, y13);
      context7.closePath();
    }
    if (buffer) {
      context7 = null;
      return buffer + "" || null;
    }
  }
  rectangle6.x = function(_) {
    if (arguments.length) {
      x9 = number6(_);
      return rectangle6;
    } else {
      return x9;
    }
  };
  rectangle6.y = function(_) {
    if (arguments.length) {
      y9 = number6(_);
      return rectangle6;
    } else {
      return y9;
    }
  };
  rectangle6.width = function(_) {
    if (arguments.length) {
      width2 = number6(_);
      return rectangle6;
    } else {
      return width2;
    }
  };
  rectangle6.height = function(_) {
    if (arguments.length) {
      height2 = number6(_);
      return rectangle6;
    } else {
      return height2;
    }
  };
  rectangle6.cornerRadius = function(tl6, tr6, br6, bl6) {
    if (arguments.length) {
      crTL = number6(tl6);
      crTR = tr6 != null ? number6(tr6) : crTL;
      crBR = br6 != null ? number6(br6) : crTL;
      crBL = bl6 != null ? number6(bl6) : crTR;
      return rectangle6;
    } else {
      return crTL;
    }
  };
  rectangle6.context = function(_) {
    if (arguments.length) {
      context7 = _ == null ? null : _;
      return rectangle6;
    } else {
      return context7;
    }
  };
  return rectangle6;
}
function vg_trail2() {
  var x9, y9, size, defined2, context7 = null, ready, x13, y13, r1;
  function point21(x22, y22, w22) {
    const r2 = w22 / 2;
    if (ready) {
      var ux = y13 - y22, uy = x22 - x13;
      if (ux || uy) {
        var ud = Math.hypot(ux, uy), rx = (ux /= ud) * r1, ry = (uy /= ud) * r1, t = Math.atan2(uy, ux);
        context7.moveTo(x13 - rx, y13 - ry);
        context7.lineTo(x22 - ux * r2, y22 - uy * r2);
        context7.arc(x22, y22, r2, t - Math.PI, t);
        context7.lineTo(x13 + rx, y13 + ry);
        context7.arc(x13, y13, r1, t, t + Math.PI);
      } else {
        context7.arc(x22, y22, r2, 0, Tau2);
      }
      context7.closePath();
    } else {
      ready = 1;
    }
    x13 = x22;
    y13 = y22;
    r1 = r2;
  }
  function trail7(data3) {
    var i, n = data3.length, d, defined0 = false, buffer;
    if (context7 == null)
      context7 = buffer = path();
    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined2(d = data3[i], i, data3)) === defined0) {
        if (defined0 = !defined0)
          ready = 0;
      }
      if (defined0)
        point21(+x9(d, i, data3), +y9(d, i, data3), +size(d, i, data3));
    }
    if (buffer) {
      context7 = null;
      return buffer + "" || null;
    }
  }
  trail7.x = function(_) {
    if (arguments.length) {
      x9 = _;
      return trail7;
    } else {
      return x9;
    }
  };
  trail7.y = function(_) {
    if (arguments.length) {
      y9 = _;
      return trail7;
    } else {
      return y9;
    }
  };
  trail7.size = function(_) {
    if (arguments.length) {
      size = _;
      return trail7;
    } else {
      return size;
    }
  };
  trail7.defined = function(_) {
    if (arguments.length) {
      defined2 = _;
      return trail7;
    } else {
      return defined2;
    }
  };
  trail7.context = function(_) {
    if (arguments.length) {
      if (_ == null) {
        context7 = null;
      } else {
        context7 = _;
      }
      return trail7;
    } else {
      return context7;
    }
  };
  return trail7;
}
function value$12(a4, b6) {
  return a4 != null ? a4 : b6;
}
var x5 = (item) => item.x || 0;
var y5 = (item) => item.y || 0;
var w3 = (item) => item.width || 0;
var h2 = (item) => item.height || 0;
var xw2 = (item) => (item.x || 0) + (item.width || 0);
var yh2 = (item) => (item.y || 0) + (item.height || 0);
var sa2 = (item) => item.startAngle || 0;
var ea2 = (item) => item.endAngle || 0;
var pa2 = (item) => item.padAngle || 0;
var ir2 = (item) => item.innerRadius || 0;
var or2 = (item) => item.outerRadius || 0;
var cr2 = (item) => item.cornerRadius || 0;
var tl2 = (item) => value$12(item.cornerRadiusTopLeft, item.cornerRadius) || 0;
var tr2 = (item) => value$12(item.cornerRadiusTopRight, item.cornerRadius) || 0;
var br2 = (item) => value$12(item.cornerRadiusBottomRight, item.cornerRadius) || 0;
var bl2 = (item) => value$12(item.cornerRadiusBottomLeft, item.cornerRadius) || 0;
var sz2 = (item) => value$12(item.size, 64);
var ts2 = (item) => item.size || 1;
var def2 = (item) => !(item.defined === false);
var type2 = (item) => symbols6(item.shape || "circle");
var arcShape2 = arc_default().startAngle(sa2).endAngle(ea2).padAngle(pa2).innerRadius(ir2).outerRadius(or2).cornerRadius(cr2);
var areavShape2 = area_default().x(x5).y1(y5).y0(yh2).defined(def2);
var areahShape2 = area_default().y(y5).x1(x5).x0(xw2).defined(def2);
var lineShape2 = line_default().x(x5).y(y5).defined(def2);
var rectShape2 = vg_rect2().x(x5).y(y5).width(w3).height(h2).cornerRadius(tl2, tr2, br2, bl2);
var symbolShape2 = Symbol2().type(type2).size(sz2);
var trailShape2 = vg_trail2().x(x5).y(y5).defined(def2).size(ts2);
function hasCornerRadius2(item) {
  return item.cornerRadius || item.cornerRadiusTopLeft || item.cornerRadiusTopRight || item.cornerRadiusBottomRight || item.cornerRadiusBottomLeft;
}
function arc$12(context7, item) {
  return arcShape2.context(context7)(item);
}
function area$12(context7, items) {
  const item = items[0], interp = item.interpolate || "linear";
  return (item.orient === "horizontal" ? areahShape2 : areavShape2).curve(curves2(interp, item.orient, item.tension)).context(context7)(items);
}
function line$12(context7, items) {
  const item = items[0], interp = item.interpolate || "linear";
  return lineShape2.curve(curves2(interp, item.orient, item.tension)).context(context7)(items);
}
function rectangle2(context7, item, x9, y9) {
  return rectShape2.context(context7)(item, x9, y9);
}
function shape$12(context7, item) {
  return (item.mark.shape || item.shape).context(context7)(item);
}
function symbol$12(context7, item) {
  return symbolShape2.context(context7)(item);
}
function trail$12(context7, items) {
  return trailShape2.context(context7)(items);
}
var clip_id2 = 1;
function clip$12(renderer, item, size) {
  var clip7 = item.clip, defs = renderer._defs, id24 = item.clip_id || (item.clip_id = "clip" + clip_id2++), c5 = defs.clipping[id24] || (defs.clipping[id24] = {
    id: id24
  });
  if (isFunction8(clip7)) {
    c5.path = clip7(null);
  } else if (hasCornerRadius2(size)) {
    c5.path = rectangle2(null, size, 0, 0);
  } else {
    c5.width = size.width || 0;
    c5.height = size.height || 0;
  }
  return "url(#" + id24 + ")";
}
function Bounds2(b6) {
  this.clear();
  if (b6)
    this.union(b6);
}
Bounds2.prototype = {
  clone() {
    return new Bounds2(this);
  },
  clear() {
    this.x1 = +Number.MAX_VALUE;
    this.y1 = +Number.MAX_VALUE;
    this.x2 = -Number.MAX_VALUE;
    this.y2 = -Number.MAX_VALUE;
    return this;
  },
  empty() {
    return this.x1 === +Number.MAX_VALUE && this.y1 === +Number.MAX_VALUE && this.x2 === -Number.MAX_VALUE && this.y2 === -Number.MAX_VALUE;
  },
  equals(b6) {
    return this.x1 === b6.x1 && this.y1 === b6.y1 && this.x2 === b6.x2 && this.y2 === b6.y2;
  },
  set(x13, y13, x22, y22) {
    if (x22 < x13) {
      this.x2 = x13;
      this.x1 = x22;
    } else {
      this.x1 = x13;
      this.x2 = x22;
    }
    if (y22 < y13) {
      this.y2 = y13;
      this.y1 = y22;
    } else {
      this.y1 = y13;
      this.y2 = y22;
    }
    return this;
  },
  add(x9, y9) {
    if (x9 < this.x1)
      this.x1 = x9;
    if (y9 < this.y1)
      this.y1 = y9;
    if (x9 > this.x2)
      this.x2 = x9;
    if (y9 > this.y2)
      this.y2 = y9;
    return this;
  },
  expand(d) {
    this.x1 -= d;
    this.y1 -= d;
    this.x2 += d;
    this.y2 += d;
    return this;
  },
  round() {
    this.x1 = Math.floor(this.x1);
    this.y1 = Math.floor(this.y1);
    this.x2 = Math.ceil(this.x2);
    this.y2 = Math.ceil(this.y2);
    return this;
  },
  scale(s2) {
    this.x1 *= s2;
    this.y1 *= s2;
    this.x2 *= s2;
    this.y2 *= s2;
    return this;
  },
  translate(dx, dy) {
    this.x1 += dx;
    this.x2 += dx;
    this.y1 += dy;
    this.y2 += dy;
    return this;
  },
  rotate(angle2, x9, y9) {
    const p = this.rotatedPoints(angle2, x9, y9);
    return this.clear().add(p[0], p[1]).add(p[2], p[3]).add(p[4], p[5]).add(p[6], p[7]);
  },
  rotatedPoints(angle2, x9, y9) {
    var {
      x1: x13,
      y1: y13,
      x2: x22,
      y2: y22
    } = this, cos4 = Math.cos(angle2), sin4 = Math.sin(angle2), cx = x9 - x9 * cos4 + y9 * sin4, cy = y9 - x9 * sin4 - y9 * cos4;
    return [cos4 * x13 - sin4 * y13 + cx, sin4 * x13 + cos4 * y13 + cy, cos4 * x13 - sin4 * y22 + cx, sin4 * x13 + cos4 * y22 + cy, cos4 * x22 - sin4 * y13 + cx, sin4 * x22 + cos4 * y13 + cy, cos4 * x22 - sin4 * y22 + cx, sin4 * x22 + cos4 * y22 + cy];
  },
  union(b6) {
    if (b6.x1 < this.x1)
      this.x1 = b6.x1;
    if (b6.y1 < this.y1)
      this.y1 = b6.y1;
    if (b6.x2 > this.x2)
      this.x2 = b6.x2;
    if (b6.y2 > this.y2)
      this.y2 = b6.y2;
    return this;
  },
  intersect(b6) {
    if (b6.x1 > this.x1)
      this.x1 = b6.x1;
    if (b6.y1 > this.y1)
      this.y1 = b6.y1;
    if (b6.x2 < this.x2)
      this.x2 = b6.x2;
    if (b6.y2 < this.y2)
      this.y2 = b6.y2;
    return this;
  },
  encloses(b6) {
    return b6 && this.x1 <= b6.x1 && this.x2 >= b6.x2 && this.y1 <= b6.y1 && this.y2 >= b6.y2;
  },
  alignsWith(b6) {
    return b6 && (this.x1 == b6.x1 || this.x2 == b6.x2 || this.y1 == b6.y1 || this.y2 == b6.y2);
  },
  intersects(b6) {
    return b6 && !(this.x2 < b6.x1 || this.x1 > b6.x2 || this.y2 < b6.y1 || this.y1 > b6.y2);
  },
  contains(x9, y9) {
    return !(x9 < this.x1 || x9 > this.x2 || y9 < this.y1 || y9 > this.y2);
  },
  width() {
    return this.x2 - this.x1;
  },
  height() {
    return this.y2 - this.y1;
  }
};
function Item2(mark) {
  this.mark = mark;
  this.bounds = this.bounds || new Bounds2();
}
function GroupItem2(mark) {
  Item2.call(this, mark);
  this.items = this.items || [];
}
inherits9(GroupItem2, Item2);
var ResourceLoader2 = class {
  constructor(customLoader) {
    this._pending = 0;
    this._loader = customLoader || loader3();
  }
  pending() {
    return this._pending;
  }
  sanitizeURL(uri) {
    const loader7 = this;
    increment2(loader7);
    return loader7._loader.sanitize(uri, {
      context: "href"
    }).then((opt) => {
      decrement2(loader7);
      return opt;
    }).catch(() => {
      decrement2(loader7);
      return null;
    });
  }
  loadImage(uri) {
    const loader7 = this, Image2 = domImage2();
    increment2(loader7);
    return loader7._loader.sanitize(uri, {
      context: "image"
    }).then((opt) => {
      const url = opt.href;
      if (!url || !Image2)
        throw {
          url
        };
      const img = new Image2();
      const cors = has9(opt, "crossOrigin") ? opt.crossOrigin : "anonymous";
      if (cors != null)
        img.crossOrigin = cors;
      img.onload = () => decrement2(loader7);
      img.onerror = () => decrement2(loader7);
      img.src = url;
      return img;
    }).catch((e3) => {
      decrement2(loader7);
      return {
        complete: false,
        width: 0,
        height: 0,
        src: e3 && e3.url || ""
      };
    });
  }
  ready() {
    const loader7 = this;
    return new Promise((accept) => {
      function poll(value7) {
        if (!loader7.pending())
          accept(value7);
        else
          setTimeout(() => {
            poll(true);
          }, 10);
      }
      poll(false);
    });
  }
};
function increment2(loader7) {
  loader7._pending += 1;
}
function decrement2(loader7) {
  loader7._pending -= 1;
}
function boundStroke2(bounds6, item, miter) {
  if (item.stroke && item.opacity !== 0 && item.strokeOpacity !== 0) {
    const sw = item.strokeWidth != null ? +item.strokeWidth : 1;
    bounds6.expand(sw + (miter ? miterAdjustment2(item, sw) : 0));
  }
  return bounds6;
}
function miterAdjustment2(item, strokeWidth) {
  return item.strokeJoin && item.strokeJoin !== "miter" ? 0 : strokeWidth;
}
var circleThreshold2 = Tau2 - 1e-8;
var bounds2;
var lx2;
var ly2;
var rot2;
var ma2;
var mb2;
var mc2;
var md2;
var add5 = (x9, y9) => bounds2.add(x9, y9);
var addL2 = (x9, y9) => add5(lx2 = x9, ly2 = y9);
var addX2 = (x9) => add5(x9, bounds2.y1);
var addY2 = (y9) => add5(bounds2.x1, y9);
var px2 = (x9, y9) => ma2 * x9 + mc2 * y9;
var py2 = (x9, y9) => mb2 * x9 + md2 * y9;
var addp2 = (x9, y9) => add5(px2(x9, y9), py2(x9, y9));
var addpL2 = (x9, y9) => addL2(px2(x9, y9), py2(x9, y9));
function boundContext2(_, deg) {
  bounds2 = _;
  if (deg) {
    rot2 = deg * DegToRad2;
    ma2 = md2 = Math.cos(rot2);
    mb2 = Math.sin(rot2);
    mc2 = -mb2;
  } else {
    ma2 = md2 = 1;
    rot2 = mb2 = mc2 = 0;
  }
  return context$12;
}
var context$12 = {
  beginPath() {
  },
  closePath() {
  },
  moveTo: addpL2,
  lineTo: addpL2,
  rect(x9, y9, w8, h6) {
    if (rot2) {
      addp2(x9 + w8, y9);
      addp2(x9 + w8, y9 + h6);
      addp2(x9, y9 + h6);
      addpL2(x9, y9);
    } else {
      add5(x9 + w8, y9 + h6);
      addL2(x9, y9);
    }
  },
  quadraticCurveTo(x13, y13, x22, y22) {
    const px1 = px2(x13, y13), py1 = py2(x13, y13), px22 = px2(x22, y22), py22 = py2(x22, y22);
    quadExtrema2(lx2, px1, px22, addX2);
    quadExtrema2(ly2, py1, py22, addY2);
    addL2(px22, py22);
  },
  bezierCurveTo(x13, y13, x22, y22, x32, y32) {
    const px1 = px2(x13, y13), py1 = py2(x13, y13), px22 = px2(x22, y22), py22 = py2(x22, y22), px32 = px2(x32, y32), py32 = py2(x32, y32);
    cubicExtrema2(lx2, px1, px22, px32, addX2);
    cubicExtrema2(ly2, py1, py22, py32, addY2);
    addL2(px32, py32);
  },
  arc(cx, cy, r, sa6, ea7, ccw) {
    sa6 += rot2;
    ea7 += rot2;
    lx2 = r * Math.cos(ea7) + cx;
    ly2 = r * Math.sin(ea7) + cy;
    if (Math.abs(ea7 - sa6) > circleThreshold2) {
      add5(cx - r, cy - r);
      add5(cx + r, cy + r);
    } else {
      const update3 = (a4) => add5(r * Math.cos(a4) + cx, r * Math.sin(a4) + cy);
      let s2, i;
      update3(sa6);
      update3(ea7);
      if (ea7 !== sa6) {
        sa6 = sa6 % Tau2;
        if (sa6 < 0)
          sa6 += Tau2;
        ea7 = ea7 % Tau2;
        if (ea7 < 0)
          ea7 += Tau2;
        if (ea7 < sa6) {
          ccw = !ccw;
          s2 = sa6;
          sa6 = ea7;
          ea7 = s2;
        }
        if (ccw) {
          ea7 -= Tau2;
          s2 = sa6 - sa6 % HalfPi2;
          for (i = 0; i < 4 && s2 > ea7; ++i, s2 -= HalfPi2)
            update3(s2);
        } else {
          s2 = sa6 - sa6 % HalfPi2 + HalfPi2;
          for (i = 0; i < 4 && s2 < ea7; ++i, s2 = s2 + HalfPi2)
            update3(s2);
        }
      }
    }
  }
};
function quadExtrema2(x07, x13, x22, cb) {
  const t = (x07 - x13) / (x07 + x22 - 2 * x13);
  if (0 < t && t < 1)
    cb(x07 + (x13 - x07) * t);
}
function cubicExtrema2(x07, x13, x22, x32, cb) {
  const a4 = x32 - x07 + 3 * x13 - 3 * x22, b6 = x07 + x22 - 2 * x13, c5 = x07 - x13;
  let t014 = 0, t13 = 0, r;
  if (Math.abs(a4) > Epsilon2) {
    r = b6 * b6 + c5 * a4;
    if (r >= 0) {
      r = Math.sqrt(r);
      t014 = (-b6 + r) / a4;
      t13 = (-b6 - r) / a4;
    }
  } else {
    t014 = 0.5 * c5 / b6;
  }
  if (0 < t014 && t014 < 1)
    cb(cubic2(t014, x07, x13, x22, x32));
  if (0 < t13 && t13 < 1)
    cb(cubic2(t13, x07, x13, x22, x32));
}
function cubic2(t, x07, x13, x22, x32) {
  const s2 = 1 - t, s22 = s2 * s2, t22 = t * t;
  return s22 * s2 * x07 + 3 * s22 * t * x13 + 3 * s2 * t22 * x22 + t22 * t * x32;
}
var context2 = (context2 = domCanvas3(1, 1)) ? context2.getContext("2d") : null;
var b2 = new Bounds2();
function intersectPath2(draw7) {
  return function(item, brush) {
    if (!context2)
      return true;
    draw7(context2, item);
    b2.clear().union(item.bounds).intersect(brush).round();
    const {
      x1: x13,
      y1: y13,
      x2: x22,
      y2: y22
    } = b2;
    for (let y9 = y13; y9 <= y22; ++y9) {
      for (let x9 = x13; x9 <= x22; ++x9) {
        if (context2.isPointInPath(x9, y9)) {
          return true;
        }
      }
    }
    return false;
  };
}
function intersectPoint2(item, box) {
  return box.contains(item.x || 0, item.y || 0);
}
function intersectRect2(item, box) {
  const x9 = item.x || 0, y9 = item.y || 0, w8 = item.width || 0, h6 = item.height || 0;
  return box.intersects(b2.set(x9, y9, x9 + w8, y9 + h6));
}
function intersectRule2(item, box) {
  const x9 = item.x || 0, y9 = item.y || 0, x22 = item.x2 != null ? item.x2 : x9, y22 = item.y2 != null ? item.y2 : y9;
  return intersectBoxLine2(box, x9, y9, x22, y22);
}
function intersectBoxLine2(box, x9, y9, u4, v2) {
  const {
    x1: x13,
    y1: y13,
    x2: x22,
    y2: y22
  } = box, dx = u4 - x9, dy = v2 - y9;
  let t014 = 0, t13 = 1, p, q, r, e3;
  for (e3 = 0; e3 < 4; ++e3) {
    if (e3 === 0) {
      p = -dx;
      q = -(x13 - x9);
    }
    if (e3 === 1) {
      p = dx;
      q = x22 - x9;
    }
    if (e3 === 2) {
      p = -dy;
      q = -(y13 - y9);
    }
    if (e3 === 3) {
      p = dy;
      q = y22 - y9;
    }
    if (Math.abs(p) < 1e-10 && q < 0)
      return false;
    r = q / p;
    if (p < 0) {
      if (r > t13)
        return false;
      else if (r > t014)
        t014 = r;
    } else if (p > 0) {
      if (r < t014)
        return false;
      else if (r < t13)
        t13 = r;
    }
  }
  return true;
}
function blend2(context7, item) {
  context7.globalCompositeOperation = item.blend || "source-over";
}
function value2(value7, dflt) {
  return value7 == null ? dflt : value7;
}
function addStops2(gradient8, stops) {
  const n = stops.length;
  for (let i = 0; i < n; ++i) {
    gradient8.addColorStop(stops[i].offset, stops[i].color);
  }
  return gradient8;
}
function gradient2(context7, spec, bounds6) {
  const w8 = bounds6.width(), h6 = bounds6.height();
  let gradient8;
  if (spec.gradient === "radial") {
    gradient8 = context7.createRadialGradient(bounds6.x1 + value2(spec.x1, 0.5) * w8, bounds6.y1 + value2(spec.y1, 0.5) * h6, Math.max(w8, h6) * value2(spec.r1, 0), bounds6.x1 + value2(spec.x2, 0.5) * w8, bounds6.y1 + value2(spec.y2, 0.5) * h6, Math.max(w8, h6) * value2(spec.r2, 0.5));
  } else {
    const x13 = value2(spec.x1, 0), y13 = value2(spec.y1, 0), x22 = value2(spec.x2, 1), y22 = value2(spec.y2, 0);
    if (x13 === x22 || y13 === y22 || w8 === h6) {
      gradient8 = context7.createLinearGradient(bounds6.x1 + x13 * w8, bounds6.y1 + y13 * h6, bounds6.x1 + x22 * w8, bounds6.y1 + y22 * h6);
    } else {
      const image7 = domCanvas3(Math.ceil(w8), Math.ceil(h6)), ictx = image7.getContext("2d");
      ictx.scale(w8, h6);
      ictx.fillStyle = addStops2(ictx.createLinearGradient(x13, y13, x22, y22), spec.stops);
      ictx.fillRect(0, 0, w8, h6);
      return context7.createPattern(image7, "no-repeat");
    }
  }
  return addStops2(gradient8, spec.stops);
}
function color3(context7, item, value7) {
  return isGradient2(value7) ? gradient2(context7, value7, item.bounds) : value7;
}
function fill2(context7, item, opacity2) {
  opacity2 *= item.fillOpacity == null ? 1 : item.fillOpacity;
  if (opacity2 > 0) {
    context7.globalAlpha = opacity2;
    context7.fillStyle = color3(context7, item, item.fill);
    return true;
  } else {
    return false;
  }
}
var Empty3 = [];
function stroke2(context7, item, opacity2) {
  var lw = (lw = item.strokeWidth) != null ? lw : 1;
  if (lw <= 0)
    return false;
  opacity2 *= item.strokeOpacity == null ? 1 : item.strokeOpacity;
  if (opacity2 > 0) {
    context7.globalAlpha = opacity2;
    context7.strokeStyle = color3(context7, item, item.stroke);
    context7.lineWidth = lw;
    context7.lineCap = item.strokeCap || "butt";
    context7.lineJoin = item.strokeJoin || "miter";
    context7.miterLimit = item.strokeMiterLimit || 10;
    if (context7.setLineDash) {
      context7.setLineDash(item.strokeDash || Empty3);
      context7.lineDashOffset = item.strokeDashOffset || 0;
    }
    return true;
  } else {
    return false;
  }
}
function compare4(a4, b6) {
  return a4.zindex - b6.zindex || a4.index - b6.index;
}
function zorder2(scene) {
  if (!scene.zdirty)
    return scene.zitems;
  var items = scene.items, output3 = [], item, i, n;
  for (i = 0, n = items.length; i < n; ++i) {
    item = items[i];
    item.index = i;
    if (item.zindex)
      output3.push(item);
  }
  scene.zdirty = false;
  return scene.zitems = output3.sort(compare4);
}
function visit2(scene, visitor) {
  var items = scene.items, i, n;
  if (!items || !items.length)
    return;
  const zitems = zorder2(scene);
  if (zitems && zitems.length) {
    for (i = 0, n = items.length; i < n; ++i) {
      if (!items[i].zindex)
        visitor(items[i]);
    }
    items = zitems;
  }
  for (i = 0, n = items.length; i < n; ++i) {
    visitor(items[i]);
  }
}
function pickVisit2(scene, visitor) {
  var items = scene.items, hit6, i;
  if (!items || !items.length)
    return null;
  const zitems = zorder2(scene);
  if (zitems && zitems.length)
    items = zitems;
  for (i = items.length; --i >= 0; ) {
    if (hit6 = visitor(items[i]))
      return hit6;
  }
  if (items === zitems) {
    for (items = scene.items, i = items.length; --i >= 0; ) {
      if (!items[i].zindex) {
        if (hit6 = visitor(items[i]))
          return hit6;
      }
    }
  }
  return null;
}
function drawAll2(path7) {
  return function(context7, scene, bounds6) {
    visit2(scene, (item) => {
      if (!bounds6 || bounds6.intersects(item.bounds)) {
        drawPath2(path7, context7, item, item);
      }
    });
  };
}
function drawOne2(path7) {
  return function(context7, scene, bounds6) {
    if (scene.items.length && (!bounds6 || bounds6.intersects(scene.bounds))) {
      drawPath2(path7, context7, scene.items[0], scene.items);
    }
  };
}
function drawPath2(path7, context7, item, items) {
  var opacity2 = item.opacity == null ? 1 : item.opacity;
  if (opacity2 === 0)
    return;
  if (path7(context7, items))
    return;
  blend2(context7, item);
  if (item.fill && fill2(context7, item, opacity2)) {
    context7.fill();
  }
  if (item.stroke && stroke2(context7, item, opacity2)) {
    context7.stroke();
  }
}
function pick$12(test2) {
  test2 = test2 || truthy10;
  return function(context7, scene, x9, y9, gx, gy) {
    x9 *= context7.pixelRatio;
    y9 *= context7.pixelRatio;
    return pickVisit2(scene, (item) => {
      const b6 = item.bounds;
      if (b6 && !b6.contains(gx, gy) || !b6)
        return;
      if (test2(context7, item, x9, y9, gx, gy))
        return item;
    });
  };
}
function hitPath2(path7, filled) {
  return function(context7, o, x9, y9) {
    var item = Array.isArray(o) ? o[0] : o, fill6 = filled == null ? item.fill : filled, stroke6 = item.stroke && context7.isPointInStroke, lw, lc;
    if (stroke6) {
      lw = item.strokeWidth;
      lc = item.strokeCap;
      context7.lineWidth = lw != null ? lw : 1;
      context7.lineCap = lc != null ? lc : "butt";
    }
    return path7(context7, o) ? false : fill6 && context7.isPointInPath(x9, y9) || stroke6 && context7.isPointInStroke(x9, y9);
  };
}
function pickPath2(path7) {
  return pick$12(hitPath2(path7));
}
function translate3(x9, y9) {
  return "translate(" + x9 + "," + y9 + ")";
}
function rotate2(a4) {
  return "rotate(" + a4 + ")";
}
function scale6(scaleX, scaleY2) {
  return "scale(" + scaleX + "," + scaleY2 + ")";
}
function translateItem2(item) {
  return translate3(item.x || 0, item.y || 0);
}
function rotateItem2(item) {
  return translate3(item.x || 0, item.y || 0) + (item.angle ? " " + rotate2(item.angle) : "");
}
function transformItem2(item) {
  return translate3(item.x || 0, item.y || 0) + (item.angle ? " " + rotate2(item.angle) : "") + (item.scaleX || item.scaleY ? " " + scale6(item.scaleX || 1, item.scaleY || 1) : "");
}
function markItemPath2(type7, shape6, isect) {
  function attr6(emit6, item) {
    emit6("transform", rotateItem2(item));
    emit6("d", shape6(null, item));
  }
  function bound6(bounds6, item) {
    shape6(boundContext2(bounds6, item.angle), item);
    return boundStroke2(bounds6, item).translate(item.x || 0, item.y || 0);
  }
  function draw7(context7, item) {
    var x9 = item.x || 0, y9 = item.y || 0, a4 = item.angle || 0;
    context7.translate(x9, y9);
    if (a4)
      context7.rotate(a4 *= DegToRad2);
    context7.beginPath();
    shape6(context7, item);
    if (a4)
      context7.rotate(-a4);
    context7.translate(-x9, -y9);
  }
  return {
    type: type7,
    tag: "path",
    nested: false,
    attr: attr6,
    bound: bound6,
    draw: drawAll2(draw7),
    pick: pickPath2(draw7),
    isect: isect || intersectPath2(draw7)
  };
}
var arc3 = markItemPath2("arc", arc$12);
function pickArea2(a4, p) {
  var v2 = a4[0].orient === "horizontal" ? p[1] : p[0], z = a4[0].orient === "horizontal" ? "y" : "x", i = a4.length, min5 = Infinity, hit6, d;
  while (--i >= 0) {
    if (a4[i].defined === false)
      continue;
    d = Math.abs(a4[i][z] - v2);
    if (d < min5) {
      min5 = d;
      hit6 = a4[i];
    }
  }
  return hit6;
}
function pickLine2(a4, p) {
  var t = Math.pow(a4[0].strokeWidth || 1, 2), i = a4.length, dx, dy, dd;
  while (--i >= 0) {
    if (a4[i].defined === false)
      continue;
    dx = a4[i].x - p[0];
    dy = a4[i].y - p[1];
    dd = dx * dx + dy * dy;
    if (dd < t)
      return a4[i];
  }
  return null;
}
function pickTrail2(a4, p) {
  var i = a4.length, dx, dy, dd;
  while (--i >= 0) {
    if (a4[i].defined === false)
      continue;
    dx = a4[i].x - p[0];
    dy = a4[i].y - p[1];
    dd = dx * dx + dy * dy;
    dx = a4[i].size || 1;
    if (dd < dx * dx)
      return a4[i];
  }
  return null;
}
function markMultiItemPath2(type7, shape6, tip) {
  function attr6(emit6, item) {
    var items = item.mark.items;
    if (items.length)
      emit6("d", shape6(null, items));
  }
  function bound6(bounds6, mark) {
    var items = mark.items;
    if (items.length === 0) {
      return bounds6;
    } else {
      shape6(boundContext2(bounds6), items);
      return boundStroke2(bounds6, items[0]);
    }
  }
  function draw7(context7, items) {
    context7.beginPath();
    shape6(context7, items);
  }
  const hit6 = hitPath2(draw7);
  function pick7(context7, scene, x9, y9, gx, gy) {
    var items = scene.items, b6 = scene.bounds;
    if (!items || !items.length || b6 && !b6.contains(gx, gy)) {
      return null;
    }
    x9 *= context7.pixelRatio;
    y9 *= context7.pixelRatio;
    return hit6(context7, items, x9, y9) ? items[0] : null;
  }
  return {
    type: type7,
    tag: "path",
    nested: true,
    attr: attr6,
    bound: bound6,
    draw: drawOne2(draw7),
    pick: pick7,
    isect: intersectPoint2,
    tip
  };
}
var area3 = markMultiItemPath2("area", area$12, pickArea2);
function clip2(context7, scene) {
  var clip7 = scene.clip;
  context7.save();
  if (isFunction8(clip7)) {
    context7.beginPath();
    clip7(context7);
    context7.clip();
  } else {
    clipGroup2(context7, scene.group);
  }
}
function clipGroup2(context7, group7) {
  context7.beginPath();
  hasCornerRadius2(group7) ? rectangle2(context7, group7, 0, 0) : context7.rect(0, 0, group7.width || 0, group7.height || 0);
  context7.clip();
}
function offset$12(item) {
  const sw = value2(item.strokeWidth, 1);
  return item.strokeOffset != null ? item.strokeOffset : item.stroke && sw > 0.5 && sw < 1.5 ? 0.5 - Math.abs(sw - 1) : 0;
}
function attr$52(emit6, item) {
  emit6("transform", translateItem2(item));
}
function emitRectangle2(emit6, item) {
  const off = offset$12(item);
  emit6("d", rectangle2(null, item, off, off));
}
function background2(emit6, item) {
  emit6("class", "background");
  emit6("aria-hidden", true);
  emitRectangle2(emit6, item);
}
function foreground2(emit6, item) {
  emit6("class", "foreground");
  emit6("aria-hidden", true);
  if (item.strokeForeground) {
    emitRectangle2(emit6, item);
  } else {
    emit6("d", "");
  }
}
function content2(emit6, item, renderer) {
  const url = item.clip ? clip$12(renderer, item, item) : null;
  emit6("clip-path", url);
}
function bound$52(bounds6, group7) {
  if (!group7.clip && group7.items) {
    const items = group7.items, m3 = items.length;
    for (let j = 0; j < m3; ++j) {
      bounds6.union(items[j].bounds);
    }
  }
  if ((group7.clip || group7.width || group7.height) && !group7.noBound) {
    bounds6.add(0, 0).add(group7.width || 0, group7.height || 0);
  }
  boundStroke2(bounds6, group7);
  return bounds6.translate(group7.x || 0, group7.y || 0);
}
function rectanglePath2(context7, group7, x9, y9) {
  const off = offset$12(group7);
  context7.beginPath();
  rectangle2(context7, group7, (x9 || 0) + off, (y9 || 0) + off);
}
var hitBackground2 = hitPath2(rectanglePath2);
var hitForeground2 = hitPath2(rectanglePath2, false);
var hitCorner2 = hitPath2(rectanglePath2, true);
function draw$42(context7, scene, bounds6, markTypes) {
  visit2(scene, (group7) => {
    const gx = group7.x || 0, gy = group7.y || 0, fore = group7.strokeForeground, opacity2 = group7.opacity == null ? 1 : group7.opacity;
    if ((group7.stroke || group7.fill) && opacity2) {
      rectanglePath2(context7, group7, gx, gy);
      blend2(context7, group7);
      if (group7.fill && fill2(context7, group7, opacity2)) {
        context7.fill();
      }
      if (group7.stroke && !fore && stroke2(context7, group7, opacity2)) {
        context7.stroke();
      }
    }
    context7.save();
    context7.translate(gx, gy);
    if (group7.clip)
      clipGroup2(context7, group7);
    if (bounds6)
      bounds6.translate(-gx, -gy);
    visit2(group7, (item) => {
      if (item.marktype === "group" || markTypes == null || markTypes.includes(item.marktype)) {
        this.draw(context7, item, bounds6, markTypes);
      }
    });
    if (bounds6)
      bounds6.translate(gx, gy);
    context7.restore();
    if (fore && group7.stroke && opacity2) {
      rectanglePath2(context7, group7, gx, gy);
      blend2(context7, group7);
      if (stroke2(context7, group7, opacity2)) {
        context7.stroke();
      }
    }
  });
}
function pick2(context7, scene, x9, y9, gx, gy) {
  if (scene.bounds && !scene.bounds.contains(gx, gy) || !scene.items) {
    return null;
  }
  const cx = x9 * context7.pixelRatio, cy = y9 * context7.pixelRatio;
  return pickVisit2(scene, (group7) => {
    let hit6, dx, dy;
    const b6 = group7.bounds;
    if (b6 && !b6.contains(gx, gy))
      return;
    dx = group7.x || 0;
    dy = group7.y || 0;
    const dw = dx + (group7.width || 0), dh = dy + (group7.height || 0), c5 = group7.clip;
    if (c5 && (gx < dx || gx > dw || gy < dy || gy > dh))
      return;
    context7.save();
    context7.translate(dx, dy);
    dx = gx - dx;
    dy = gy - dy;
    if (c5 && hasCornerRadius2(group7) && !hitCorner2(context7, group7, cx, cy)) {
      context7.restore();
      return null;
    }
    const fore = group7.strokeForeground, ix = scene.interactive !== false;
    if (ix && fore && group7.stroke && hitForeground2(context7, group7, cx, cy)) {
      context7.restore();
      return group7;
    }
    hit6 = pickVisit2(group7, (mark) => pickMark2(mark, dx, dy) ? this.pick(mark, x9, y9, dx, dy) : null);
    if (!hit6 && ix && (group7.fill || !fore && group7.stroke) && hitBackground2(context7, group7, cx, cy)) {
      hit6 = group7;
    }
    context7.restore();
    return hit6 || null;
  });
}
function pickMark2(mark, x9, y9) {
  return (mark.interactive !== false || mark.marktype === "group") && mark.bounds && mark.bounds.contains(x9, y9);
}
var group3 = {
  type: "group",
  tag: "g",
  nested: false,
  attr: attr$52,
  bound: bound$52,
  draw: draw$42,
  pick: pick2,
  isect: intersectRect2,
  content: content2,
  background: background2,
  foreground: foreground2
};
var metadata2 = {
  "xmlns": "http://www.w3.org/2000/svg",
  "xmlns:xlink": "http://www.w3.org/1999/xlink",
  "version": "1.1"
};
function getImage2(item, renderer) {
  var image7 = item.image;
  if (!image7 || item.url && item.url !== image7.url) {
    image7 = {
      complete: false,
      width: 0,
      height: 0
    };
    renderer.loadImage(item.url).then((image8) => {
      item.image = image8;
      item.image.url = item.url;
    });
  }
  return image7;
}
function imageWidth2(item, image7) {
  return item.width != null ? item.width : !image7 || !image7.width ? 0 : item.aspect !== false && item.height ? item.height * image7.width / image7.height : image7.width;
}
function imageHeight2(item, image7) {
  return item.height != null ? item.height : !image7 || !image7.height ? 0 : item.aspect !== false && item.width ? item.width * image7.height / image7.width : image7.height;
}
function imageXOffset2(align2, w8) {
  return align2 === "center" ? w8 / 2 : align2 === "right" ? w8 : 0;
}
function imageYOffset2(baseline3, h6) {
  return baseline3 === "middle" ? h6 / 2 : baseline3 === "bottom" ? h6 : 0;
}
function attr$42(emit6, item, renderer) {
  const img = getImage2(item, renderer), w8 = imageWidth2(item, img), h6 = imageHeight2(item, img), x9 = (item.x || 0) - imageXOffset2(item.align, w8), y9 = (item.y || 0) - imageYOffset2(item.baseline, h6), i = !img.src && img.toDataURL ? img.toDataURL() : img.src || "";
  emit6("href", i, metadata2["xmlns:xlink"], "xlink:href");
  emit6("transform", translate3(x9, y9));
  emit6("width", w8);
  emit6("height", h6);
  emit6("preserveAspectRatio", item.aspect === false ? "none" : "xMidYMid");
}
function bound$42(bounds6, item) {
  const img = item.image, w8 = imageWidth2(item, img), h6 = imageHeight2(item, img), x9 = (item.x || 0) - imageXOffset2(item.align, w8), y9 = (item.y || 0) - imageYOffset2(item.baseline, h6);
  return bounds6.set(x9, y9, x9 + w8, y9 + h6);
}
function draw$32(context7, scene, bounds6) {
  visit2(scene, (item) => {
    if (bounds6 && !bounds6.intersects(item.bounds))
      return;
    const img = getImage2(item, this);
    let w8 = imageWidth2(item, img);
    let h6 = imageHeight2(item, img);
    if (w8 === 0 || h6 === 0)
      return;
    let x9 = (item.x || 0) - imageXOffset2(item.align, w8), y9 = (item.y || 0) - imageYOffset2(item.baseline, h6), opacity2, ar0, ar1, t;
    if (item.aspect !== false) {
      ar0 = img.width / img.height;
      ar1 = item.width / item.height;
      if (ar0 === ar0 && ar1 === ar1 && ar0 !== ar1) {
        if (ar1 < ar0) {
          t = w8 / ar0;
          y9 += (h6 - t) / 2;
          h6 = t;
        } else {
          t = h6 * ar0;
          x9 += (w8 - t) / 2;
          w8 = t;
        }
      }
    }
    if (img.complete || img.toDataURL) {
      blend2(context7, item);
      context7.globalAlpha = (opacity2 = item.opacity) != null ? opacity2 : 1;
      context7.imageSmoothingEnabled = item.smooth !== false;
      context7.drawImage(img, x9, y9, w8, h6);
    }
  });
}
var image2 = {
  type: "image",
  tag: "image",
  nested: false,
  attr: attr$42,
  bound: bound$42,
  draw: draw$32,
  pick: pick$12(),
  isect: truthy10,
  // bounds check is sufficient
  get: getImage2,
  xOffset: imageXOffset2,
  yOffset: imageYOffset2
};
var line3 = markMultiItemPath2("line", line$12, pickLine2);
function attr$32(emit6, item) {
  var sx = item.scaleX || 1, sy = item.scaleY || 1;
  if (sx !== 1 || sy !== 1) {
    emit6("vector-effect", "non-scaling-stroke");
  }
  emit6("transform", transformItem2(item));
  emit6("d", item.path);
}
function path$12(context7, item) {
  var path7 = item.path;
  if (path7 == null)
    return true;
  var x9 = item.x || 0, y9 = item.y || 0, sx = item.scaleX || 1, sy = item.scaleY || 1, a4 = (item.angle || 0) * DegToRad2, cache2 = item.pathCache;
  if (!cache2 || cache2.path !== path7) {
    (item.pathCache = cache2 = parse5(path7)).path = path7;
  }
  if (a4 && context7.rotate && context7.translate) {
    context7.translate(x9, y9);
    context7.rotate(a4);
    pathRender2(context7, cache2, 0, 0, sx, sy);
    context7.rotate(-a4);
    context7.translate(-x9, -y9);
  } else {
    pathRender2(context7, cache2, x9, y9, sx, sy);
  }
}
function bound$32(bounds6, item) {
  return path$12(boundContext2(bounds6, item.angle), item) ? bounds6.set(0, 0, 0, 0) : boundStroke2(bounds6, item, true);
}
var path$22 = {
  type: "path",
  tag: "path",
  nested: false,
  attr: attr$32,
  bound: bound$32,
  draw: drawAll2(path$12),
  pick: pickPath2(path$12),
  isect: intersectPath2(path$12)
};
function attr$22(emit6, item) {
  emit6("d", rectangle2(null, item));
}
function bound$22(bounds6, item) {
  var x9, y9;
  return boundStroke2(bounds6.set(x9 = item.x || 0, y9 = item.y || 0, x9 + item.width || 0, y9 + item.height || 0), item);
}
function draw$22(context7, item) {
  context7.beginPath();
  rectangle2(context7, item);
}
var rect2 = {
  type: "rect",
  tag: "path",
  nested: false,
  attr: attr$22,
  bound: bound$22,
  draw: drawAll2(draw$22),
  pick: pickPath2(draw$22),
  isect: intersectRect2
};
function attr$12(emit6, item) {
  emit6("transform", translateItem2(item));
  emit6("x2", item.x2 != null ? item.x2 - (item.x || 0) : 0);
  emit6("y2", item.y2 != null ? item.y2 - (item.y || 0) : 0);
}
function bound$12(bounds6, item) {
  var x13, y13;
  return boundStroke2(bounds6.set(x13 = item.x || 0, y13 = item.y || 0, item.x2 != null ? item.x2 : x13, item.y2 != null ? item.y2 : y13), item);
}
function path3(context7, item, opacity2) {
  var x13, y13, x22, y22;
  if (item.stroke && stroke2(context7, item, opacity2)) {
    x13 = item.x || 0;
    y13 = item.y || 0;
    x22 = item.x2 != null ? item.x2 : x13;
    y22 = item.y2 != null ? item.y2 : y13;
    context7.beginPath();
    context7.moveTo(x13, y13);
    context7.lineTo(x22, y22);
    return true;
  }
  return false;
}
function draw$12(context7, scene, bounds6) {
  visit2(scene, (item) => {
    if (bounds6 && !bounds6.intersects(item.bounds))
      return;
    var opacity2 = item.opacity == null ? 1 : item.opacity;
    if (opacity2 && path3(context7, item, opacity2)) {
      blend2(context7, item);
      context7.stroke();
    }
  });
}
function hit$12(context7, item, x9, y9) {
  if (!context7.isPointInStroke)
    return false;
  return path3(context7, item, 1) && context7.isPointInStroke(x9, y9);
}
var rule2 = {
  type: "rule",
  tag: "line",
  nested: false,
  attr: attr$12,
  bound: bound$12,
  draw: draw$12,
  pick: pick$12(hit$12),
  isect: intersectRule2
};
var shape2 = markItemPath2("shape", shape$12);
var symbol2 = markItemPath2("symbol", symbol$12, intersectPoint2);
var widthCache2 = lruCache3();
var textMetrics2 = {
  height: fontSize2,
  measureWidth: measureWidth2,
  estimateWidth: estimateWidth2,
  width: estimateWidth2,
  canvas: useCanvas2
};
useCanvas2(true);
function useCanvas2(use) {
  textMetrics2.width = use && context2 ? measureWidth2 : estimateWidth2;
}
function estimateWidth2(item, text7) {
  return _estimateWidth2(textValue2(item, text7), fontSize2(item));
}
function _estimateWidth2(text7, currentFontHeight) {
  return ~~(0.8 * text7.length * currentFontHeight);
}
function measureWidth2(item, text7) {
  return fontSize2(item) <= 0 || !(text7 = textValue2(item, text7)) ? 0 : _measureWidth2(text7, font2(item));
}
function _measureWidth2(text7, currentFont) {
  const key4 = `(${currentFont}) ${text7}`;
  let width2 = widthCache2.get(key4);
  if (width2 === void 0) {
    context2.font = currentFont;
    width2 = context2.measureText(text7).width;
    widthCache2.set(key4, width2);
  }
  return width2;
}
function fontSize2(item) {
  return item.fontSize != null ? +item.fontSize || 0 : 11;
}
function lineHeight2(item) {
  return item.lineHeight != null ? item.lineHeight : fontSize2(item) + 2;
}
function lineArray2(_) {
  return isArray10(_) ? _.length > 1 ? _ : _[0] : _;
}
function textLines2(item) {
  return lineArray2(item.lineBreak && item.text && !isArray10(item.text) ? item.text.split(item.lineBreak) : item.text);
}
function textValue2(item, line8) {
  const text7 = line8 == null ? "" : (line8 + "").trim();
  return item.limit > 0 && text7.length ? truncate3(item, text7) : text7;
}
function widthGetter2(item) {
  if (textMetrics2.width === measureWidth2) {
    const currentFont = font2(item);
    return (text7) => _measureWidth2(text7, currentFont);
  } else if (textMetrics2.width === estimateWidth2) {
    const currentFontHeight = fontSize2(item);
    return (text7) => _estimateWidth2(text7, currentFontHeight);
  } else {
    return (text7) => textMetrics2.width(item, text7);
  }
}
function truncate3(item, text7) {
  var limit = +item.limit, width2 = widthGetter2(item);
  if (width2(text7) < limit)
    return text7;
  var ellipsis = item.ellipsis || "…", rtl = item.dir === "rtl", lo = 0, hi = text7.length, mid;
  limit -= width2(ellipsis);
  if (rtl) {
    while (lo < hi) {
      mid = lo + hi >>> 1;
      if (width2(text7.slice(mid)) > limit)
        lo = mid + 1;
      else
        hi = mid;
    }
    return ellipsis + text7.slice(lo);
  } else {
    while (lo < hi) {
      mid = 1 + (lo + hi >>> 1);
      if (width2(text7.slice(0, mid)) < limit)
        lo = mid;
      else
        hi = mid - 1;
    }
    return text7.slice(0, lo) + ellipsis;
  }
}
function fontFamily2(item, quote) {
  var font7 = item.font;
  return (quote && font7 ? String(font7).replace(/"/g, "'") : font7) || "sans-serif";
}
function font2(item, quote) {
  return (item.fontStyle ? item.fontStyle + " " : "") + (item.fontVariant ? item.fontVariant + " " : "") + (item.fontWeight ? item.fontWeight + " " : "") + fontSize2(item) + "px " + fontFamily2(item, quote);
}
function offset2(item) {
  var baseline3 = item.baseline, h6 = fontSize2(item);
  return Math.round(baseline3 === "top" ? 0.79 * h6 : baseline3 === "middle" ? 0.3 * h6 : baseline3 === "bottom" ? -0.21 * h6 : baseline3 === "line-top" ? 0.29 * h6 + 0.5 * lineHeight2(item) : baseline3 === "line-bottom" ? 0.29 * h6 - 0.5 * lineHeight2(item) : 0);
}
var textAlign2 = {
  "left": "start",
  "center": "middle",
  "right": "end"
};
var tempBounds3 = new Bounds2();
function anchorPoint2(item) {
  var x9 = item.x || 0, y9 = item.y || 0, r = item.radius || 0, t;
  if (r) {
    t = (item.theta || 0) - HalfPi2;
    x9 += r * Math.cos(t);
    y9 += r * Math.sin(t);
  }
  tempBounds3.x1 = x9;
  tempBounds3.y1 = y9;
  return tempBounds3;
}
function attr2(emit6, item) {
  var dx = item.dx || 0, dy = (item.dy || 0) + offset2(item), p = anchorPoint2(item), x9 = p.x1, y9 = p.y1, a4 = item.angle || 0, t;
  emit6("text-anchor", textAlign2[item.align] || "start");
  if (a4) {
    t = translate3(x9, y9) + " " + rotate2(a4);
    if (dx || dy)
      t += " " + translate3(dx, dy);
  } else {
    t = translate3(x9 + dx, y9 + dy);
  }
  emit6("transform", t);
}
function bound2(bounds6, item, mode2) {
  var h6 = textMetrics2.height(item), a4 = item.align, p = anchorPoint2(item), x9 = p.x1, y9 = p.y1, dx = item.dx || 0, dy = (item.dy || 0) + offset2(item) - Math.round(0.8 * h6), tl6 = textLines2(item), w8;
  if (isArray10(tl6)) {
    h6 += lineHeight2(item) * (tl6.length - 1);
    w8 = tl6.reduce((w9, t) => Math.max(w9, textMetrics2.width(item, t)), 0);
  } else {
    w8 = textMetrics2.width(item, tl6);
  }
  if (a4 === "center") {
    dx -= w8 / 2;
  } else if (a4 === "right") {
    dx -= w8;
  } else
    ;
  bounds6.set(dx += x9, dy += y9, dx + w8, dy + h6);
  if (item.angle && !mode2) {
    bounds6.rotate(item.angle * DegToRad2, x9, y9);
  } else if (mode2 === 2) {
    return bounds6.rotatedPoints(item.angle * DegToRad2, x9, y9);
  }
  return bounds6;
}
function draw2(context7, scene, bounds6) {
  visit2(scene, (item) => {
    var opacity2 = item.opacity == null ? 1 : item.opacity, p, x9, y9, i, lh, tl6, str;
    if (bounds6 && !bounds6.intersects(item.bounds) || // bounds check
    opacity2 === 0 || item.fontSize <= 0 || item.text == null || item.text.length === 0)
      return;
    context7.font = font2(item);
    context7.textAlign = item.align || "left";
    p = anchorPoint2(item);
    x9 = p.x1, y9 = p.y1;
    if (item.angle) {
      context7.save();
      context7.translate(x9, y9);
      context7.rotate(item.angle * DegToRad2);
      x9 = y9 = 0;
    }
    x9 += item.dx || 0;
    y9 += (item.dy || 0) + offset2(item);
    tl6 = textLines2(item);
    blend2(context7, item);
    if (isArray10(tl6)) {
      lh = lineHeight2(item);
      for (i = 0; i < tl6.length; ++i) {
        str = textValue2(item, tl6[i]);
        if (item.fill && fill2(context7, item, opacity2)) {
          context7.fillText(str, x9, y9);
        }
        if (item.stroke && stroke2(context7, item, opacity2)) {
          context7.strokeText(str, x9, y9);
        }
        y9 += lh;
      }
    } else {
      str = textValue2(item, tl6);
      if (item.fill && fill2(context7, item, opacity2)) {
        context7.fillText(str, x9, y9);
      }
      if (item.stroke && stroke2(context7, item, opacity2)) {
        context7.strokeText(str, x9, y9);
      }
    }
    if (item.angle)
      context7.restore();
  });
}
function hit2(context7, item, x9, y9, gx, gy) {
  if (item.fontSize <= 0)
    return false;
  if (!item.angle)
    return true;
  var p = anchorPoint2(item), ax = p.x1, ay = p.y1, b6 = bound2(tempBounds3, item, 1), a4 = -item.angle * DegToRad2, cos4 = Math.cos(a4), sin4 = Math.sin(a4), px6 = cos4 * gx - sin4 * gy + (ax - cos4 * ax + sin4 * ay), py6 = sin4 * gx + cos4 * gy + (ay - sin4 * ax - cos4 * ay);
  return b6.contains(px6, py6);
}
function intersectText2(item, box) {
  const p = bound2(tempBounds3, item, 2);
  return intersectBoxLine2(box, p[0], p[1], p[2], p[3]) || intersectBoxLine2(box, p[0], p[1], p[4], p[5]) || intersectBoxLine2(box, p[4], p[5], p[6], p[7]) || intersectBoxLine2(box, p[2], p[3], p[6], p[7]);
}
var text2 = {
  type: "text",
  tag: "text",
  nested: false,
  attr: attr2,
  bound: bound2,
  draw: draw2,
  pick: pick$12(hit2),
  isect: intersectText2
};
var trail2 = markMultiItemPath2("trail", trail$12, pickTrail2);
var Marks2 = {
  arc: arc3,
  area: area3,
  group: group3,
  image: image2,
  line: line3,
  path: path$22,
  rect: rect2,
  rule: rule2,
  shape: shape2,
  symbol: symbol2,
  text: text2,
  trail: trail2
};
function domCreate2(doc, tag, ns) {
  if (!doc && typeof document !== "undefined" && document.createElement) {
    doc = document;
  }
  return doc ? ns ? doc.createElementNS(ns, tag) : doc.createElement(tag) : null;
}
function domFind2(el, tag) {
  tag = tag.toLowerCase();
  var nodes = el.childNodes, i = 0, n = nodes.length;
  for (; i < n; ++i)
    if (nodes[i].tagName.toLowerCase() === tag) {
      return nodes[i];
    }
}
function domChild2(el, index4, tag, ns) {
  var a4 = el.childNodes[index4], b6;
  if (!a4 || a4.tagName.toLowerCase() !== tag.toLowerCase()) {
    b6 = a4 || null;
    a4 = domCreate2(el.ownerDocument, tag, ns);
    el.insertBefore(a4, b6);
  }
  return a4;
}
function domClear2(el, index4) {
  var nodes = el.childNodes, curr = nodes.length;
  while (curr > index4)
    el.removeChild(nodes[--curr]);
  return el;
}
function cssClass2(mark) {
  return "mark-" + mark.marktype + (mark.role ? " role-" + mark.role : "") + (mark.name ? " " + mark.name : "");
}
function point11(event2, el) {
  const rect7 = el.getBoundingClientRect();
  return [event2.clientX - rect7.left - (el.clientLeft || 0), event2.clientY - rect7.top - (el.clientTop || 0)];
}
function resolveItem2(item, event2, el, origin) {
  var mark = item && item.mark, mdef, p;
  if (mark && (mdef = Marks2[mark.marktype]).tip) {
    p = point11(event2, el);
    p[0] -= origin[0];
    p[1] -= origin[1];
    while (item = item.mark.group) {
      p[0] -= item.x || 0;
      p[1] -= item.y || 0;
    }
    item = mdef.tip(mark.items, p);
  }
  return item;
}
var Handler2 = class {
  /**
   * Create a new Handler instance.
   * @param {object} [customLoader] - Optional loader instance for
   *   href URL sanitization. If not specified, a standard loader
   *   instance will be generated.
   * @param {function} [customTooltip] - Optional tooltip handler
   *   function for custom tooltip display.
   * @constructor
   */
  constructor(customLoader, customTooltip) {
    this._active = null;
    this._handlers = {};
    this._loader = customLoader || loader3();
    this._tooltip = customTooltip || defaultTooltip2;
  }
  /**
   * Initialize a new Handler instance.
   * @param {DOMElement} el - The containing DOM element for the display.
   * @param {Array<number>} origin - The origin of the display, in pixels.
   *   The coordinate system will be translated to this point.
   * @param {object} [obj] - Optional context object that should serve as
   *   the "this" context for event callbacks.
   * @return {Handler} - This handler instance.
   */
  initialize(el, origin, obj) {
    this._el = el;
    this._obj = obj || null;
    return this.origin(origin);
  }
  /**
   * Returns the parent container element for a visualization.
   * @return {DOMElement} - The containing DOM element.
   */
  element() {
    return this._el;
  }
  /**
   * Returns the scene element (e.g., canvas or SVG) of the visualization
   * Subclasses must override if the first child is not the scene element.
   * @return {DOMElement} - The scene (e.g., canvas or SVG) element.
   */
  canvas() {
    return this._el && this._el.firstChild;
  }
  /**
   * Get / set the origin coordinates of the visualization.
   */
  origin(origin) {
    if (arguments.length) {
      this._origin = origin || [0, 0];
      return this;
    } else {
      return this._origin.slice();
    }
  }
  /**
   * Get / set the scenegraph root.
   */
  scene(scene) {
    if (!arguments.length)
      return this._scene;
    this._scene = scene;
    return this;
  }
  /**
   * Add an event handler. Subclasses should override this method.
   */
  on() {
  }
  /**
   * Remove an event handler. Subclasses should override this method.
   */
  off() {
  }
  /**
   * Utility method for finding the array index of an event handler.
   * @param {Array} h - An array of registered event handlers.
   * @param {string} type - The event type.
   * @param {function} handler - The event handler instance to find.
   * @return {number} - The handler's array index or -1 if not registered.
   */
  _handlerIndex(h6, type7, handler) {
    for (let i = h6 ? h6.length : 0; --i >= 0; ) {
      if (h6[i].type === type7 && (!handler || h6[i].handler === handler)) {
        return i;
      }
    }
    return -1;
  }
  /**
   * Returns an array with registered event handlers.
   * @param {string} [type] - The event type to query. Any annotations
   *   are ignored; for example, for the argument "click.foo", ".foo" will
   *   be ignored and the method returns all "click" handlers. If type is
   *   null or unspecified, this method returns handlers for all types.
   * @return {Array} - A new array containing all registered event handlers.
   */
  handlers(type7) {
    const h6 = this._handlers, a4 = [];
    if (type7) {
      a4.push(...h6[this.eventName(type7)]);
    } else {
      for (const k3 in h6) {
        a4.push(...h6[k3]);
      }
    }
    return a4;
  }
  /**
   * Parses an event name string to return the specific event type.
   * For example, given "click.foo" returns "click"
   * @param {string} name - The input event type string.
   * @return {string} - A string with the event type only.
   */
  eventName(name) {
    const i = name.indexOf(".");
    return i < 0 ? name : name.slice(0, i);
  }
  /**
   * Handle hyperlink navigation in response to an item.href value.
   * @param {Event} event - The event triggering hyperlink navigation.
   * @param {Item} item - The scenegraph item.
   * @param {string} href - The URL to navigate to.
   */
  handleHref(event2, item, href6) {
    this._loader.sanitize(href6, {
      context: "href"
    }).then((opt) => {
      const e3 = new MouseEvent(event2.type, event2), a4 = domCreate2(null, "a");
      for (const name in opt)
        a4.setAttribute(name, opt[name]);
      a4.dispatchEvent(e3);
    }).catch(() => {
    });
  }
  /**
   * Handle tooltip display in response to an item.tooltip value.
   * @param {Event} event - The event triggering tooltip display.
   * @param {Item} item - The scenegraph item.
   * @param {boolean} show - A boolean flag indicating whether
   *   to show or hide a tooltip for the given item.
   */
  handleTooltip(event2, item, show) {
    if (item && item.tooltip != null) {
      item = resolveItem2(item, event2, this.canvas(), this._origin);
      const value7 = show && item && item.tooltip || null;
      this._tooltip.call(this._obj, this, event2, item, value7);
    }
  }
  /**
   * Returns the size of a scenegraph item and its position relative
   * to the viewport.
   * @param {Item} item - The scenegraph item.
   * @return {object} - A bounding box object (compatible with the
   *   DOMRect type) consisting of x, y, width, heigh, top, left,
   *   right, and bottom properties.
   */
  getItemBoundingClientRect(item) {
    const el = this.canvas();
    if (!el)
      return;
    const rect7 = el.getBoundingClientRect(), origin = this._origin, bounds6 = item.bounds, width2 = bounds6.width(), height2 = bounds6.height();
    let x9 = bounds6.x1 + origin[0] + rect7.left, y9 = bounds6.y1 + origin[1] + rect7.top;
    while (item.mark && (item = item.mark.group)) {
      x9 += item.x || 0;
      y9 += item.y || 0;
    }
    return {
      x: x9,
      y: y9,
      width: width2,
      height: height2,
      left: x9,
      top: y9,
      right: x9 + width2,
      bottom: y9 + height2
    };
  }
};
function defaultTooltip2(handler, event2, item, value7) {
  handler.element().setAttribute("title", value7 || "");
}
var Renderer2 = class {
  /**
   * Create a new Renderer instance.
   * @param {object} [loader] - Optional loader instance for
   *   image and href URL sanitization. If not specified, a
   *   standard loader instance will be generated.
   * @constructor
   */
  constructor(loader7) {
    this._el = null;
    this._bgcolor = null;
    this._loader = new ResourceLoader2(loader7);
  }
  /**
   * Initialize a new Renderer instance.
   * @param {DOMElement} el - The containing DOM element for the display.
   * @param {number} width - The coordinate width of the display, in pixels.
   * @param {number} height - The coordinate height of the display, in pixels.
   * @param {Array<number>} origin - The origin of the display, in pixels.
   *   The coordinate system will be translated to this point.
   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
   *   the width and height to determine the final pixel size.
   * @return {Renderer} - This renderer instance.
   */
  initialize(el, width2, height2, origin, scaleFactor) {
    this._el = el;
    return this.resize(width2, height2, origin, scaleFactor);
  }
  /**
   * Returns the parent container element for a visualization.
   * @return {DOMElement} - The containing DOM element.
   */
  element() {
    return this._el;
  }
  /**
   * Returns the scene element (e.g., canvas or SVG) of the visualization
   * Subclasses must override if the first child is not the scene element.
   * @return {DOMElement} - The scene (e.g., canvas or SVG) element.
   */
  canvas() {
    return this._el && this._el.firstChild;
  }
  /**
   * Get / set the background color.
   */
  background(bgcolor) {
    if (arguments.length === 0)
      return this._bgcolor;
    this._bgcolor = bgcolor;
    return this;
  }
  /**
   * Resize the display.
   * @param {number} width - The new coordinate width of the display, in pixels.
   * @param {number} height - The new coordinate height of the display, in pixels.
   * @param {Array<number>} origin - The new origin of the display, in pixels.
   *   The coordinate system will be translated to this point.
   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
   *   the width and height to determine the final pixel size.
   * @return {Renderer} - This renderer instance;
   */
  resize(width2, height2, origin, scaleFactor) {
    this._width = width2;
    this._height = height2;
    this._origin = origin || [0, 0];
    this._scale = scaleFactor || 1;
    return this;
  }
  /**
   * Report a dirty item whose bounds should be redrawn.
   * This base class method does nothing. Subclasses that perform
   * incremental should implement this method.
   * @param {Item} item - The dirty item whose bounds should be redrawn.
   */
  dirty() {
  }
  /**
   * Render an input scenegraph, potentially with a set of dirty items.
   * This method will perform an immediate rendering with available resources.
   * The renderer may also need to perform image loading to perform a complete
   * render. This process can lead to asynchronous re-rendering of the scene
   * after this method returns. To receive notification when rendering is
   * complete, use the renderAsync method instead.
   * @param {object} scene - The root mark of a scenegraph to render.
   * @param {Array} markTypes - Array of the mark types to render.
   *                            If undefined, render all mark types
   * @return {Renderer} - This renderer instance.
   */
  render(scene, markTypes) {
    const r = this;
    r._call = function() {
      r._render(scene, markTypes);
    };
    r._call();
    r._call = null;
    return r;
  }
  /**
   * Internal rendering method. Renderer subclasses should override this
   * method to actually perform rendering.
   * @param {object} scene - The root mark of a scenegraph to render.
   * @param {Array} markTypes - Array of the mark types to render.
   *                            If undefined, render all mark types
   */
  _render() {
  }
  /**
   * Asynchronous rendering method. Similar to render, but returns a Promise
   * that resolves when all rendering is completed. Sometimes a renderer must
   * perform image loading to get a complete rendering. The returned
   * Promise will not resolve until this process completes.
   * @param {object} scene - The root mark of a scenegraph to render.
   * @param {Array} markTypes - Array of the mark types to render.
   *                            If undefined, render all mark types
   * @return {Promise} - A Promise that resolves when rendering is complete.
   */
  renderAsync(scene, markTypes) {
    const r = this.render(scene, markTypes);
    return this._ready ? this._ready.then(() => r) : Promise.resolve(r);
  }
  /**
   * Internal method for asynchronous resource loading.
   * Proxies method calls to the ImageLoader, and tracks loading
   * progress to invoke a re-render once complete.
   * @param {string} method - The method name to invoke on the ImageLoader.
   * @param {string} uri - The URI for the requested resource.
   * @return {Promise} - A Promise that resolves to the requested resource.
   */
  _load(method10, uri) {
    var r = this, p = r._loader[method10](uri);
    if (!r._ready) {
      const call = r._call;
      r._ready = r._loader.ready().then((redraw) => {
        if (redraw)
          call();
        r._ready = null;
      });
    }
    return p;
  }
  /**
   * Sanitize a URL to include as a hyperlink in the rendered scene.
   * This method proxies a call to ImageLoader.sanitizeURL, but also tracks
   * image loading progress and invokes a re-render once complete.
   * @param {string} uri - The URI string to sanitize.
   * @return {Promise} - A Promise that resolves to the sanitized URL.
   */
  sanitizeURL(uri) {
    return this._load("sanitizeURL", uri);
  }
  /**
   * Requests an image to include in the rendered scene.
   * This method proxies a call to ImageLoader.loadImage, but also tracks
   * image loading progress and invokes a re-render once complete.
   * @param {string} uri - The URI string of the image.
   * @return {Promise} - A Promise that resolves to the loaded Image.
   */
  loadImage(uri) {
    return this._load("loadImage", uri);
  }
};
var KeyDownEvent2 = "keydown";
var KeyPressEvent2 = "keypress";
var KeyUpEvent2 = "keyup";
var DragEnterEvent2 = "dragenter";
var DragLeaveEvent2 = "dragleave";
var DragOverEvent2 = "dragover";
var PointerDownEvent2 = "pointerdown";
var PointerUpEvent2 = "pointerup";
var PointerMoveEvent2 = "pointermove";
var PointerOutEvent2 = "pointerout";
var PointerOverEvent2 = "pointerover";
var MouseDownEvent2 = "mousedown";
var MouseUpEvent2 = "mouseup";
var MouseMoveEvent2 = "mousemove";
var MouseOutEvent2 = "mouseout";
var MouseOverEvent2 = "mouseover";
var ClickEvent2 = "click";
var DoubleClickEvent2 = "dblclick";
var WheelEvent2 = "wheel";
var MouseWheelEvent2 = "mousewheel";
var TouchStartEvent2 = "touchstart";
var TouchMoveEvent2 = "touchmove";
var TouchEndEvent2 = "touchend";
var Events2 = [KeyDownEvent2, KeyPressEvent2, KeyUpEvent2, DragEnterEvent2, DragLeaveEvent2, DragOverEvent2, PointerDownEvent2, PointerUpEvent2, PointerMoveEvent2, PointerOutEvent2, PointerOverEvent2, MouseDownEvent2, MouseUpEvent2, MouseMoveEvent2, MouseOutEvent2, MouseOverEvent2, ClickEvent2, DoubleClickEvent2, WheelEvent2, MouseWheelEvent2, TouchStartEvent2, TouchMoveEvent2, TouchEndEvent2];
var TooltipShowEvent2 = PointerMoveEvent2;
var TooltipHideEvent2 = MouseOutEvent2;
var HrefEvent2 = ClickEvent2;
var CanvasHandler2 = class extends Handler2 {
  constructor(loader7, tooltip2) {
    super(loader7, tooltip2);
    this._down = null;
    this._touch = null;
    this._first = true;
    this._events = {};
    this.events = Events2;
    this.pointermove = move2([PointerMoveEvent2, MouseMoveEvent2], [PointerOverEvent2, MouseOverEvent2], [PointerOutEvent2, MouseOutEvent2]);
    this.dragover = move2([DragOverEvent2], [DragEnterEvent2], [DragLeaveEvent2]), this.pointerout = inactive2([PointerOutEvent2, MouseOutEvent2]);
    this.dragleave = inactive2([DragLeaveEvent2]);
  }
  initialize(el, origin, obj) {
    this._canvas = el && domFind2(el, "canvas");
    [ClickEvent2, MouseDownEvent2, PointerDownEvent2, PointerMoveEvent2, PointerOutEvent2, DragLeaveEvent2].forEach((type7) => eventListenerCheck2(this, type7));
    return super.initialize(el, origin, obj);
  }
  // return the backing canvas instance
  canvas() {
    return this._canvas;
  }
  // retrieve the current canvas context
  context() {
    return this._canvas.getContext("2d");
  }
  // to keep old versions of firefox happy
  DOMMouseScroll(evt) {
    this.fire(MouseWheelEvent2, evt);
  }
  pointerdown(evt) {
    this._down = this._active;
    this.fire(PointerDownEvent2, evt);
  }
  mousedown(evt) {
    this._down = this._active;
    this.fire(MouseDownEvent2, evt);
  }
  click(evt) {
    if (this._down === this._active) {
      this.fire(ClickEvent2, evt);
      this._down = null;
    }
  }
  touchstart(evt) {
    this._touch = this.pickEvent(evt.changedTouches[0]);
    if (this._first) {
      this._active = this._touch;
      this._first = false;
    }
    this.fire(TouchStartEvent2, evt, true);
  }
  touchmove(evt) {
    this.fire(TouchMoveEvent2, evt, true);
  }
  touchend(evt) {
    this.fire(TouchEndEvent2, evt, true);
    this._touch = null;
  }
  // fire an event
  fire(type7, evt, touch2) {
    const a4 = touch2 ? this._touch : this._active, h6 = this._handlers[type7];
    evt.vegaType = type7;
    if (type7 === HrefEvent2 && a4 && a4.href) {
      this.handleHref(evt, a4, a4.href);
    } else if (type7 === TooltipShowEvent2 || type7 === TooltipHideEvent2) {
      this.handleTooltip(evt, a4, type7 !== TooltipHideEvent2);
    }
    if (h6) {
      for (let i = 0, len = h6.length; i < len; ++i) {
        h6[i].handler.call(this._obj, evt, a4);
      }
    }
  }
  // add an event handler
  on(type7, handler) {
    const name = this.eventName(type7), h6 = this._handlers, i = this._handlerIndex(h6[name], type7, handler);
    if (i < 0) {
      eventListenerCheck2(this, type7);
      (h6[name] || (h6[name] = [])).push({
        type: type7,
        handler
      });
    }
    return this;
  }
  // remove an event handler
  off(type7, handler) {
    const name = this.eventName(type7), h6 = this._handlers[name], i = this._handlerIndex(h6, type7, handler);
    if (i >= 0) {
      h6.splice(i, 1);
    }
    return this;
  }
  pickEvent(evt) {
    const p = point11(evt, this._canvas), o = this._origin;
    return this.pick(this._scene, p[0], p[1], p[0] - o[0], p[1] - o[1]);
  }
  // find the scenegraph item at the current pointer position
  // x, y -- the absolute x, y pointer coordinates on the canvas element
  // gx, gy -- the relative coordinates within the current group
  pick(scene, x9, y9, gx, gy) {
    const g = this.context(), mark = Marks2[scene.marktype];
    return mark.pick.call(this, g, scene, x9, y9, gx, gy);
  }
};
var eventBundle2 = (type7) => type7 === TouchStartEvent2 || type7 === TouchMoveEvent2 || type7 === TouchEndEvent2 ? [TouchStartEvent2, TouchMoveEvent2, TouchEndEvent2] : [type7];
function eventListenerCheck2(handler, type7) {
  eventBundle2(type7).forEach((_) => addEventListener2(handler, _));
}
function addEventListener2(handler, type7) {
  const canvas = handler.canvas();
  if (canvas && !handler._events[type7]) {
    handler._events[type7] = 1;
    canvas.addEventListener(type7, handler[type7] ? (evt) => handler[type7](evt) : (evt) => handler.fire(type7, evt));
  }
}
function fireAll2(handler, types, event2) {
  types.forEach((type7) => handler.fire(type7, event2));
}
function move2(moveEvents, overEvents, outEvents) {
  return function(evt) {
    const a4 = this._active, p = this.pickEvent(evt);
    if (p === a4) {
      fireAll2(this, moveEvents, evt);
    } else {
      if (!a4 || !a4.exit) {
        fireAll2(this, outEvents, evt);
      }
      this._active = p;
      fireAll2(this, overEvents, evt);
      fireAll2(this, moveEvents, evt);
    }
  };
}
function inactive2(types) {
  return function(evt) {
    fireAll2(this, types, evt);
    this._active = null;
  };
}
function devicePixelRatio2() {
  return typeof window !== "undefined" ? window.devicePixelRatio || 1 : 1;
}
function resize2(canvas, width2, height2, origin, scaleFactor, opt) {
  const inDOM = typeof HTMLElement !== "undefined" && canvas instanceof HTMLElement && canvas.parentNode != null, context7 = canvas.getContext("2d"), ratio = inDOM ? devicePixelRatio2() : scaleFactor;
  canvas.width = width2 * ratio;
  canvas.height = height2 * ratio;
  for (const key4 in opt) {
    context7[key4] = opt[key4];
  }
  if (inDOM && ratio !== 1) {
    canvas.style.width = width2 + "px";
    canvas.style.height = height2 + "px";
  }
  context7.pixelRatio = ratio;
  context7.setTransform(ratio, 0, 0, ratio, ratio * origin[0], ratio * origin[1]);
  return canvas;
}
var CanvasRenderer2 = class extends Renderer2 {
  constructor(loader7) {
    super(loader7);
    this._options = {};
    this._redraw = false;
    this._dirty = new Bounds2();
    this._tempb = new Bounds2();
  }
  initialize(el, width2, height2, origin, scaleFactor, options) {
    this._options = options || {};
    this._canvas = this._options.externalContext ? null : domCanvas3(1, 1, this._options.type);
    if (el && this._canvas) {
      domClear2(el, 0).appendChild(this._canvas);
      this._canvas.setAttribute("class", "marks");
    }
    return super.initialize(el, width2, height2, origin, scaleFactor);
  }
  resize(width2, height2, origin, scaleFactor) {
    super.resize(width2, height2, origin, scaleFactor);
    if (this._canvas) {
      resize2(this._canvas, this._width, this._height, this._origin, this._scale, this._options.context);
    } else {
      const ctx = this._options.externalContext;
      if (!ctx)
        error10("CanvasRenderer is missing a valid canvas or context");
      ctx.scale(this._scale, this._scale);
      ctx.translate(this._origin[0], this._origin[1]);
    }
    this._redraw = true;
    return this;
  }
  canvas() {
    return this._canvas;
  }
  context() {
    return this._options.externalContext || (this._canvas ? this._canvas.getContext("2d") : null);
  }
  dirty(item) {
    const b6 = this._tempb.clear().union(item.bounds);
    let g = item.mark.group;
    while (g) {
      b6.translate(g.x || 0, g.y || 0);
      g = g.mark.group;
    }
    this._dirty.union(b6);
  }
  _render(scene, markTypes) {
    const g = this.context(), o = this._origin, w8 = this._width, h6 = this._height, db = this._dirty, vb = viewBounds2(o, w8, h6);
    g.save();
    const b6 = this._redraw || db.empty() ? (this._redraw = false, vb.expand(1)) : clipToBounds2(g, vb.intersect(db), o);
    this.clear(-o[0], -o[1], w8, h6);
    this.draw(g, scene, b6, markTypes);
    g.restore();
    db.clear();
    return this;
  }
  draw(ctx, scene, bounds6, markTypes) {
    if (scene.marktype !== "group" && markTypes != null && !markTypes.includes(scene.marktype)) {
      return;
    }
    const mark = Marks2[scene.marktype];
    if (scene.clip)
      clip2(ctx, scene);
    mark.draw.call(this, ctx, scene, bounds6, markTypes);
    if (scene.clip)
      ctx.restore();
  }
  clear(x9, y9, w8, h6) {
    const opt = this._options, g = this.context();
    if (opt.type !== "pdf" && !opt.externalContext) {
      g.clearRect(x9, y9, w8, h6);
    }
    if (this._bgcolor != null) {
      g.fillStyle = this._bgcolor;
      g.fillRect(x9, y9, w8, h6);
    }
  }
};
var viewBounds2 = (origin, width2, height2) => new Bounds2().set(0, 0, width2, height2).translate(-origin[0], -origin[1]);
function clipToBounds2(g, b6, origin) {
  b6.expand(1).round();
  if (g.pixelRatio % 1) {
    b6.scale(g.pixelRatio).round().scale(1 / g.pixelRatio);
  }
  b6.translate(-(origin[0] % 1), -(origin[1] % 1));
  g.beginPath();
  g.rect(b6.x1, b6.y1, b6.width(), b6.height());
  g.clip();
  return b6;
}
var SVGHandler2 = class extends Handler2 {
  constructor(loader7, tooltip2) {
    super(loader7, tooltip2);
    const h6 = this;
    h6._hrefHandler = listener2(h6, (evt, item) => {
      if (item && item.href)
        h6.handleHref(evt, item, item.href);
    });
    h6._tooltipHandler = listener2(h6, (evt, item) => {
      h6.handleTooltip(evt, item, evt.type !== TooltipHideEvent2);
    });
  }
  initialize(el, origin, obj) {
    let svg = this._svg;
    if (svg) {
      svg.removeEventListener(HrefEvent2, this._hrefHandler);
      svg.removeEventListener(TooltipShowEvent2, this._tooltipHandler);
      svg.removeEventListener(TooltipHideEvent2, this._tooltipHandler);
    }
    this._svg = svg = el && domFind2(el, "svg");
    if (svg) {
      svg.addEventListener(HrefEvent2, this._hrefHandler);
      svg.addEventListener(TooltipShowEvent2, this._tooltipHandler);
      svg.addEventListener(TooltipHideEvent2, this._tooltipHandler);
    }
    return super.initialize(el, origin, obj);
  }
  canvas() {
    return this._svg;
  }
  // add an event handler
  on(type7, handler) {
    const name = this.eventName(type7), h6 = this._handlers, i = this._handlerIndex(h6[name], type7, handler);
    if (i < 0) {
      const x9 = {
        type: type7,
        handler,
        listener: listener2(this, handler)
      };
      (h6[name] || (h6[name] = [])).push(x9);
      if (this._svg) {
        this._svg.addEventListener(name, x9.listener);
      }
    }
    return this;
  }
  // remove an event handler
  off(type7, handler) {
    const name = this.eventName(type7), h6 = this._handlers[name], i = this._handlerIndex(h6, type7, handler);
    if (i >= 0) {
      if (this._svg) {
        this._svg.removeEventListener(name, h6[i].listener);
      }
      h6.splice(i, 1);
    }
    return this;
  }
};
var listener2 = (context7, handler) => (evt) => {
  let item = evt.target.__data__;
  item = Array.isArray(item) ? item[0] : item;
  evt.vegaType = evt.type;
  handler.call(context7._obj, evt, item);
};
var ARIA_HIDDEN2 = "aria-hidden";
var ARIA_LABEL2 = "aria-label";
var ARIA_ROLE2 = "role";
var ARIA_ROLEDESCRIPTION2 = "aria-roledescription";
var GRAPHICS_OBJECT2 = "graphics-object";
var GRAPHICS_SYMBOL2 = "graphics-symbol";
var bundle2 = (role, roledesc, label) => ({
  [ARIA_ROLE2]: role,
  [ARIA_ROLEDESCRIPTION2]: roledesc,
  [ARIA_LABEL2]: label || void 0
});
var AriaIgnore2 = toSet8(["axis-domain", "axis-grid", "axis-label", "axis-tick", "axis-title", "legend-band", "legend-entry", "legend-gradient", "legend-label", "legend-title", "legend-symbol", "title"]);
var AriaGuides2 = {
  "axis": {
    desc: "axis",
    caption: axisCaption2
  },
  "legend": {
    desc: "legend",
    caption: legendCaption2
  },
  "title-text": {
    desc: "title",
    caption: (item) => `Title text '${titleCaption2(item)}'`
  },
  "title-subtitle": {
    desc: "subtitle",
    caption: (item) => `Subtitle text '${titleCaption2(item)}'`
  }
};
var AriaEncode2 = {
  ariaRole: ARIA_ROLE2,
  ariaRoleDescription: ARIA_ROLEDESCRIPTION2,
  description: ARIA_LABEL2
};
function ariaItemAttributes2(emit6, item) {
  const hide = item.aria === false;
  emit6(ARIA_HIDDEN2, hide || void 0);
  if (hide || item.description == null) {
    for (const prop in AriaEncode2) {
      emit6(AriaEncode2[prop], void 0);
    }
  } else {
    const type7 = item.mark.marktype;
    emit6(ARIA_LABEL2, item.description);
    emit6(ARIA_ROLE2, item.ariaRole || (type7 === "group" ? GRAPHICS_OBJECT2 : GRAPHICS_SYMBOL2));
    emit6(ARIA_ROLEDESCRIPTION2, item.ariaRoleDescription || `${type7} mark`);
  }
}
function ariaMarkAttributes2(mark) {
  return mark.aria === false ? {
    [ARIA_HIDDEN2]: true
  } : AriaIgnore2[mark.role] ? null : AriaGuides2[mark.role] ? ariaGuide2(mark, AriaGuides2[mark.role]) : ariaMark2(mark);
}
function ariaMark2(mark) {
  const type7 = mark.marktype;
  const recurse6 = type7 === "group" || type7 === "text" || mark.items.some((_) => _.description != null && _.aria !== false);
  return bundle2(recurse6 ? GRAPHICS_OBJECT2 : GRAPHICS_SYMBOL2, `${type7} mark container`, mark.description);
}
function ariaGuide2(mark, opt) {
  try {
    const item = mark.items[0], caption = opt.caption || (() => "");
    return bundle2(opt.role || GRAPHICS_SYMBOL2, opt.desc, item.description || caption(item));
  } catch (err) {
    return null;
  }
}
function titleCaption2(item) {
  return array11(item.text).join(" ");
}
function axisCaption2(item) {
  const datum2 = item.datum, orient2 = item.orient, title2 = datum2.title ? extractTitle2(item) : null, ctx = item.context, scale19 = ctx.scales[datum2.scale].value, locale5 = ctx.dataflow.locale(), type7 = scale19.type, xy = orient2 === "left" || orient2 === "right" ? "Y" : "X";
  return `${xy}-axis` + (title2 ? ` titled '${title2}'` : "") + ` for a ${isDiscrete2(type7) ? "discrete" : type7} scale with ${domainCaption2(locale5, scale19, item)}`;
}
function legendCaption2(item) {
  const datum2 = item.datum, title2 = datum2.title ? extractTitle2(item) : null, type7 = `${datum2.type || ""} legend`.trim(), scales10 = datum2.scales, props = Object.keys(scales10), ctx = item.context, scale19 = ctx.scales[scales10[props[0]]].value, locale5 = ctx.dataflow.locale();
  return capitalize2(type7) + (title2 ? ` titled '${title2}'` : "") + ` for ${channelCaption2(props)} with ${domainCaption2(locale5, scale19, item)}`;
}
function extractTitle2(item) {
  try {
    return array11(peek7(item.items).items[0].text).join(" ");
  } catch (err) {
    return null;
  }
}
function channelCaption2(props) {
  props = props.map((p) => p + (p === "fill" || p === "stroke" ? " color" : ""));
  return props.length < 2 ? props[0] : props.slice(0, -1).join(", ") + " and " + peek7(props);
}
function capitalize2(s2) {
  return s2.length ? s2[0].toUpperCase() + s2.slice(1) : s2;
}
var innerText2 = (val) => (val + "").replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
var attrText2 = (val) => innerText2(val).replace(/"/g, "&quot;").replace(/\t/g, "&#x9;").replace(/\n/g, "&#xA;").replace(/\r/g, "&#xD;");
function markup2() {
  let buf = "", outer = "", inner = "";
  const stack2 = [], clear2 = () => outer = inner = "", push = (tag) => {
    if (outer) {
      buf += `${outer}>${inner}`;
      clear2();
    }
    stack2.push(tag);
  }, attr6 = (name, value7) => {
    if (value7 != null)
      outer += ` ${name}="${attrText2(value7)}"`;
    return m3;
  }, m3 = {
    open(tag, ...attrs) {
      push(tag);
      outer = "<" + tag;
      for (const set7 of attrs) {
        for (const key4 in set7)
          attr6(key4, set7[key4]);
      }
      return m3;
    },
    close() {
      const tag = stack2.pop();
      if (outer) {
        buf += outer + (inner ? `>${inner}</${tag}>` : "/>");
      } else {
        buf += `</${tag}>`;
      }
      clear2();
      return m3;
    },
    attr: attr6,
    text: (t) => (inner += innerText2(t), m3),
    toString: () => buf
  };
  return m3;
}
var serializeXML2 = (node) => _serialize2(markup2(), node) + "";
function _serialize2(m3, node) {
  m3.open(node.tagName);
  if (node.hasAttributes()) {
    const attrs = node.attributes, n = attrs.length;
    for (let i = 0; i < n; ++i) {
      m3.attr(attrs[i].name, attrs[i].value);
    }
  }
  if (node.hasChildNodes()) {
    const children3 = node.childNodes;
    for (const child of children3) {
      child.nodeType === 3 ? m3.text(child.nodeValue) : _serialize2(m3, child);
    }
  }
  return m3.close();
}
var stylesAttr2 = {
  fill: "fill",
  fillOpacity: "fill-opacity",
  stroke: "stroke",
  strokeOpacity: "stroke-opacity",
  strokeWidth: "stroke-width",
  strokeCap: "stroke-linecap",
  strokeJoin: "stroke-linejoin",
  strokeDash: "stroke-dasharray",
  strokeDashOffset: "stroke-dashoffset",
  strokeMiterLimit: "stroke-miterlimit",
  opacity: "opacity"
};
var stylesCss2 = {
  blend: "mix-blend-mode"
};
var rootAttributes2 = {
  "fill": "none",
  "stroke-miterlimit": 10
};
var RootIndex2 = 0;
var xmlns2 = "http://www.w3.org/2000/xmlns/";
var svgns2 = metadata2.xmlns;
var SVGRenderer2 = class extends Renderer2 {
  constructor(loader7) {
    super(loader7);
    this._dirtyID = 0;
    this._dirty = [];
    this._svg = null;
    this._root = null;
    this._defs = null;
  }
  /**
   * Initialize a new SVGRenderer instance.
   * @param {DOMElement} el - The containing DOM element for the display.
   * @param {number} width - The coordinate width of the display, in pixels.
   * @param {number} height - The coordinate height of the display, in pixels.
   * @param {Array<number>} origin - The origin of the display, in pixels.
   *   The coordinate system will be translated to this point.
   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
   *   the width and height to determine the final pixel size.
   * @return {SVGRenderer} - This renderer instance.
   */
  initialize(el, width2, height2, origin, scaleFactor) {
    this._defs = {};
    this._clearDefs();
    if (el) {
      this._svg = domChild2(el, 0, "svg", svgns2);
      this._svg.setAttributeNS(xmlns2, "xmlns", svgns2);
      this._svg.setAttributeNS(xmlns2, "xmlns:xlink", metadata2["xmlns:xlink"]);
      this._svg.setAttribute("version", metadata2["version"]);
      this._svg.setAttribute("class", "marks");
      domClear2(el, 1);
      this._root = domChild2(this._svg, RootIndex2, "g", svgns2);
      setAttributes2(this._root, rootAttributes2);
      domClear2(this._svg, RootIndex2 + 1);
    }
    this.background(this._bgcolor);
    return super.initialize(el, width2, height2, origin, scaleFactor);
  }
  /**
   * Get / set the background color.
   */
  background(bgcolor) {
    if (arguments.length && this._svg) {
      this._svg.style.setProperty("background-color", bgcolor);
    }
    return super.background(...arguments);
  }
  /**
   * Resize the display.
   * @param {number} width - The new coordinate width of the display, in pixels.
   * @param {number} height - The new coordinate height of the display, in pixels.
   * @param {Array<number>} origin - The new origin of the display, in pixels.
   *   The coordinate system will be translated to this point.
   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
   *   the width and height to determine the final pixel size.
   * @return {SVGRenderer} - This renderer instance;
   */
  resize(width2, height2, origin, scaleFactor) {
    super.resize(width2, height2, origin, scaleFactor);
    if (this._svg) {
      setAttributes2(this._svg, {
        width: this._width * this._scale,
        height: this._height * this._scale,
        viewBox: `0 0 ${this._width} ${this._height}`
      });
      this._root.setAttribute("transform", `translate(${this._origin})`);
    }
    this._dirty = [];
    return this;
  }
  /**
   * Returns the SVG element of the visualization.
   * @return {DOMElement} - The SVG element.
   */
  canvas() {
    return this._svg;
  }
  /**
   * Returns an SVG text string for the rendered content,
   * or null if this renderer is currently headless.
   */
  svg() {
    const svg = this._svg, bg = this._bgcolor;
    if (!svg)
      return null;
    let node;
    if (bg) {
      svg.removeAttribute("style");
      node = domChild2(svg, RootIndex2, "rect", svgns2);
      setAttributes2(node, {
        width: this._width,
        height: this._height,
        fill: bg
      });
    }
    const text7 = serializeXML2(svg);
    if (bg) {
      svg.removeChild(node);
      this._svg.style.setProperty("background-color", bg);
    }
    return text7;
  }
  /**
   * Internal rendering method.
   * @param {object} scene - The root mark of a scenegraph to render.
   * @param {Array} markTypes - Array of the mark types to render.
   *                            If undefined, render all mark types
   */
  _render(scene, markTypes) {
    if (this._dirtyCheck()) {
      if (this._dirtyAll)
        this._clearDefs();
      this.mark(this._root, scene, void 0, markTypes);
      domClear2(this._root, 1);
    }
    this.defs();
    this._dirty = [];
    ++this._dirtyID;
    return this;
  }
  // -- Manage rendering of items marked as dirty --
  /**
   * Flag a mark item as dirty.
   * @param {Item} item - The mark item.
   */
  dirty(item) {
    if (item.dirty !== this._dirtyID) {
      item.dirty = this._dirtyID;
      this._dirty.push(item);
    }
  }
  /**
   * Check if a mark item is considered dirty.
   * @param {Item} item - The mark item.
   */
  isDirty(item) {
    return this._dirtyAll || !item._svg || !item._svg.ownerSVGElement || item.dirty === this._dirtyID;
  }
  /**
   * Internal method to check dirty status and, if possible,
   * make targetted updates without a full rendering pass.
   */
  _dirtyCheck() {
    this._dirtyAll = true;
    const items = this._dirty;
    if (!items.length || !this._dirtyID)
      return true;
    const id24 = ++this._dirtyID;
    let item, mark, type7, mdef, i, n, o;
    for (i = 0, n = items.length; i < n; ++i) {
      item = items[i];
      mark = item.mark;
      if (mark.marktype !== type7) {
        type7 = mark.marktype;
        mdef = Marks2[type7];
      }
      if (mark.zdirty && mark.dirty !== id24) {
        this._dirtyAll = false;
        dirtyParents2(item, id24);
        mark.items.forEach((i2) => {
          i2.dirty = id24;
        });
      }
      if (mark.zdirty)
        continue;
      if (item.exit) {
        if (mdef.nested && mark.items.length) {
          o = mark.items[0];
          if (o._svg)
            this._update(mdef, o._svg, o);
        } else if (item._svg) {
          o = item._svg.parentNode;
          if (o)
            o.removeChild(item._svg);
        }
        item._svg = null;
        continue;
      }
      item = mdef.nested ? mark.items[0] : item;
      if (item._update === id24)
        continue;
      if (!item._svg || !item._svg.ownerSVGElement) {
        this._dirtyAll = false;
        dirtyParents2(item, id24);
      } else {
        this._update(mdef, item._svg, item);
      }
      item._update = id24;
    }
    return !this._dirtyAll;
  }
  // -- Construct & maintain scenegraph to SVG mapping ---
  /**
   * Render a set of mark items.
   * @param {SVGElement} el - The parent element in the SVG tree.
   * @param {object} scene - The mark parent to render.
   * @param {SVGElement} prev - The previous sibling in the SVG tree.
   * @param {Array} markTypes - Array of the mark types to render.
   *                            If undefined, render all mark types
   */
  mark(el, scene, prev, markTypes) {
    if (!this.isDirty(scene)) {
      return scene._svg;
    }
    const svg = this._svg, markType2 = scene.marktype, mdef = Marks2[markType2], events3 = scene.interactive === false ? "none" : null, isGroup = mdef.tag === "g";
    const parent = bind2(scene, el, prev, "g", svg);
    if (markType2 !== "group" && markTypes != null && !markTypes.includes(markType2)) {
      domClear2(parent, 0);
      return scene._svg;
    }
    parent.setAttribute("class", cssClass2(scene));
    const aria2 = ariaMarkAttributes2(scene);
    for (const key4 in aria2)
      setAttribute2(parent, key4, aria2[key4]);
    if (!isGroup) {
      setAttribute2(parent, "pointer-events", events3);
    }
    setAttribute2(parent, "clip-path", scene.clip ? clip$12(this, scene, scene.group) : null);
    let sibling = null, i = 0;
    const process2 = (item) => {
      const dirty = this.isDirty(item), node = bind2(item, parent, sibling, mdef.tag, svg);
      if (dirty) {
        this._update(mdef, node, item);
        if (isGroup)
          recurse2(this, node, item, markTypes);
      }
      sibling = node;
      ++i;
    };
    if (mdef.nested) {
      if (scene.items.length)
        process2(scene.items[0]);
    } else {
      visit2(scene, process2);
    }
    domClear2(parent, i);
    return parent;
  }
  /**
   * Update the attributes of an SVG element for a mark item.
   * @param {object} mdef - The mark definition object
   * @param {SVGElement} el - The SVG element.
   * @param {Item} item - The mark item.
   */
  _update(mdef, el, item) {
    element2 = el;
    values2 = el.__values__;
    ariaItemAttributes2(emit2, item);
    mdef.attr(emit2, item, this);
    const extra = mark_extras2[mdef.type];
    if (extra)
      extra.call(this, mdef, el, item);
    if (element2)
      this.style(element2, item);
  }
  /**
   * Update the presentation attributes of an SVG element for a mark item.
   * @param {SVGElement} el - The SVG element.
   * @param {Item} item - The mark item.
   */
  style(el, item) {
    if (item == null)
      return;
    for (const prop in stylesAttr2) {
      let value7 = prop === "font" ? fontFamily2(item) : item[prop];
      if (value7 === values2[prop])
        continue;
      const name = stylesAttr2[prop];
      if (value7 == null) {
        el.removeAttribute(name);
      } else {
        if (isGradient2(value7)) {
          value7 = gradientRef2(value7, this._defs.gradient, href2());
        }
        el.setAttribute(name, value7 + "");
      }
      values2[prop] = value7;
    }
    for (const prop in stylesCss2) {
      setStyle2(el, stylesCss2[prop], item[prop]);
    }
  }
  /**
   * Render SVG defs, as needed.
   * Must be called *after* marks have been processed to ensure the
   * collected state is current and accurate.
   */
  defs() {
    const svg = this._svg, defs = this._defs;
    let el = defs.el, index4 = 0;
    for (const id24 in defs.gradient) {
      if (!el)
        defs.el = el = domChild2(svg, RootIndex2 + 1, "defs", svgns2);
      index4 = updateGradient2(el, defs.gradient[id24], index4);
    }
    for (const id24 in defs.clipping) {
      if (!el)
        defs.el = el = domChild2(svg, RootIndex2 + 1, "defs", svgns2);
      index4 = updateClipping2(el, defs.clipping[id24], index4);
    }
    if (el) {
      index4 === 0 ? (svg.removeChild(el), defs.el = null) : domClear2(el, index4);
    }
  }
  /**
   * Clear defs caches.
   */
  _clearDefs() {
    const def6 = this._defs;
    def6.gradient = {};
    def6.clipping = {};
  }
};
function dirtyParents2(item, id24) {
  for (; item && item.dirty !== id24; item = item.mark.group) {
    item.dirty = id24;
    if (item.mark && item.mark.dirty !== id24) {
      item.mark.dirty = id24;
    } else
      return;
  }
}
function updateGradient2(el, grad, index4) {
  let i, n, stop2;
  if (grad.gradient === "radial") {
    let pt = domChild2(el, index4++, "pattern", svgns2);
    setAttributes2(pt, {
      id: patternPrefix2 + grad.id,
      viewBox: "0,0,1,1",
      width: "100%",
      height: "100%",
      preserveAspectRatio: "xMidYMid slice"
    });
    pt = domChild2(pt, 0, "rect", svgns2);
    setAttributes2(pt, {
      width: 1,
      height: 1,
      fill: `url(${href2()}#${grad.id})`
    });
    el = domChild2(el, index4++, "radialGradient", svgns2);
    setAttributes2(el, {
      id: grad.id,
      fx: grad.x1,
      fy: grad.y1,
      fr: grad.r1,
      cx: grad.x2,
      cy: grad.y2,
      r: grad.r2
    });
  } else {
    el = domChild2(el, index4++, "linearGradient", svgns2);
    setAttributes2(el, {
      id: grad.id,
      x1: grad.x1,
      x2: grad.x2,
      y1: grad.y1,
      y2: grad.y2
    });
  }
  for (i = 0, n = grad.stops.length; i < n; ++i) {
    stop2 = domChild2(el, i, "stop", svgns2);
    stop2.setAttribute("offset", grad.stops[i].offset);
    stop2.setAttribute("stop-color", grad.stops[i].color);
  }
  domClear2(el, i);
  return index4;
}
function updateClipping2(el, clip7, index4) {
  let mask;
  el = domChild2(el, index4, "clipPath", svgns2);
  el.setAttribute("id", clip7.id);
  if (clip7.path) {
    mask = domChild2(el, 0, "path", svgns2);
    mask.setAttribute("d", clip7.path);
  } else {
    mask = domChild2(el, 0, "rect", svgns2);
    setAttributes2(mask, {
      x: 0,
      y: 0,
      width: clip7.width,
      height: clip7.height
    });
  }
  domClear2(el, 1);
  return index4 + 1;
}
function recurse2(renderer, el, group7, markTypes) {
  el = el.lastChild.previousSibling;
  let prev, idx = 0;
  visit2(group7, (item) => {
    prev = renderer.mark(el, item, prev, markTypes);
    ++idx;
  });
  domClear2(el, 1 + idx);
}
function bind2(item, el, sibling, tag, svg) {
  let node = item._svg, doc;
  if (!node) {
    doc = el.ownerDocument;
    node = domCreate2(doc, tag, svgns2);
    item._svg = node;
    if (item.mark) {
      node.__data__ = item;
      node.__values__ = {
        fill: "default"
      };
      if (tag === "g") {
        const bg = domCreate2(doc, "path", svgns2);
        node.appendChild(bg);
        bg.__data__ = item;
        const cg = domCreate2(doc, "g", svgns2);
        node.appendChild(cg);
        cg.__data__ = item;
        const fg = domCreate2(doc, "path", svgns2);
        node.appendChild(fg);
        fg.__data__ = item;
        fg.__values__ = {
          fill: "default"
        };
      }
    }
  }
  if (node.ownerSVGElement !== svg || siblingCheck2(node, sibling)) {
    el.insertBefore(node, sibling ? sibling.nextSibling : el.firstChild);
  }
  return node;
}
function siblingCheck2(node, sibling) {
  return node.parentNode && node.parentNode.childNodes.length > 1 && node.previousSibling != sibling;
}
var element2 = null;
var values2 = null;
var mark_extras2 = {
  group(mdef, el, item) {
    const fg = element2 = el.childNodes[2];
    values2 = fg.__values__;
    mdef.foreground(emit2, item, this);
    values2 = el.__values__;
    element2 = el.childNodes[1];
    mdef.content(emit2, item, this);
    const bg = element2 = el.childNodes[0];
    mdef.background(emit2, item, this);
    const value7 = item.mark.interactive === false ? "none" : null;
    if (value7 !== values2.events) {
      setAttribute2(fg, "pointer-events", value7);
      setAttribute2(bg, "pointer-events", value7);
      values2.events = value7;
    }
    if (item.strokeForeground && item.stroke) {
      const fill6 = item.fill;
      setAttribute2(fg, "display", null);
      this.style(bg, item);
      setAttribute2(bg, "stroke", null);
      if (fill6)
        item.fill = null;
      values2 = fg.__values__;
      this.style(fg, item);
      if (fill6)
        item.fill = fill6;
      element2 = null;
    } else {
      setAttribute2(fg, "display", "none");
    }
  },
  image(mdef, el, item) {
    if (item.smooth === false) {
      setStyle2(el, "image-rendering", "optimizeSpeed");
      setStyle2(el, "image-rendering", "pixelated");
    } else {
      setStyle2(el, "image-rendering", null);
    }
  },
  text(mdef, el, item) {
    const tl6 = textLines2(item);
    let key4, value7, doc, lh;
    if (isArray10(tl6)) {
      value7 = tl6.map((_) => textValue2(item, _));
      key4 = value7.join("\n");
      if (key4 !== values2.text) {
        domClear2(el, 0);
        doc = el.ownerDocument;
        lh = lineHeight2(item);
        value7.forEach((t, i) => {
          const ts6 = domCreate2(doc, "tspan", svgns2);
          ts6.__data__ = item;
          ts6.textContent = t;
          if (i) {
            ts6.setAttribute("x", 0);
            ts6.setAttribute("dy", lh);
          }
          el.appendChild(ts6);
        });
        values2.text = key4;
      }
    } else {
      value7 = textValue2(item, tl6);
      if (value7 !== values2.text) {
        el.textContent = value7;
        values2.text = value7;
      }
    }
    setAttribute2(el, "font-family", fontFamily2(item));
    setAttribute2(el, "font-size", fontSize2(item) + "px");
    setAttribute2(el, "font-style", item.fontStyle);
    setAttribute2(el, "font-variant", item.fontVariant);
    setAttribute2(el, "font-weight", item.fontWeight);
  }
};
function emit2(name, value7, ns) {
  if (value7 === values2[name])
    return;
  if (ns) {
    setAttributeNS2(element2, name, value7, ns);
  } else {
    setAttribute2(element2, name, value7);
  }
  values2[name] = value7;
}
function setStyle2(el, name, value7) {
  if (value7 !== values2[name]) {
    if (value7 == null) {
      el.style.removeProperty(name);
    } else {
      el.style.setProperty(name, value7 + "");
    }
    values2[name] = value7;
  }
}
function setAttributes2(el, attrs) {
  for (const key4 in attrs) {
    setAttribute2(el, key4, attrs[key4]);
  }
}
function setAttribute2(el, name, value7) {
  if (value7 != null) {
    el.setAttribute(name, value7);
  } else {
    el.removeAttribute(name);
  }
}
function setAttributeNS2(el, name, value7, ns) {
  if (value7 != null) {
    el.setAttributeNS(ns, name, value7);
  } else {
    el.removeAttributeNS(ns, name);
  }
}
function href2() {
  let loc;
  return typeof window === "undefined" ? "" : (loc = window.location).hash ? loc.href.slice(0, -loc.hash.length) : loc.href;
}
var SVGStringRenderer2 = class extends Renderer2 {
  constructor(loader7) {
    super(loader7);
    this._text = null;
    this._defs = {
      gradient: {},
      clipping: {}
    };
  }
  /**
   * Returns the rendered SVG text string,
   * or null if rendering has not yet occurred.
   */
  svg() {
    return this._text;
  }
  /**
   * Internal rendering method.
   * @param {object} scene - The root mark of a scenegraph to render.
   */
  _render(scene) {
    const m3 = markup2();
    m3.open("svg", extend11({}, metadata2, {
      class: "marks",
      width: this._width * this._scale,
      height: this._height * this._scale,
      viewBox: `0 0 ${this._width} ${this._height}`
    }));
    const bg = this._bgcolor;
    if (bg && bg !== "transparent" && bg !== "none") {
      m3.open("rect", {
        width: this._width,
        height: this._height,
        fill: bg
      }).close();
    }
    m3.open("g", rootAttributes2, {
      transform: "translate(" + this._origin + ")"
    });
    this.mark(m3, scene);
    m3.close();
    this.defs(m3);
    this._text = m3.close() + "";
    return this;
  }
  /**
   * Render a set of mark items.
   * @param {object} m - The markup context.
   * @param {object} scene - The mark parent to render.
   */
  mark(m3, scene) {
    const mdef = Marks2[scene.marktype], tag = mdef.tag, attrList = [ariaItemAttributes2, mdef.attr];
    m3.open("g", {
      "class": cssClass2(scene),
      "clip-path": scene.clip ? clip$12(this, scene, scene.group) : null
    }, ariaMarkAttributes2(scene), {
      "pointer-events": tag !== "g" && scene.interactive === false ? "none" : null
    });
    const process2 = (item) => {
      const href6 = this.href(item);
      if (href6)
        m3.open("a", href6);
      m3.open(tag, this.attr(scene, item, attrList, tag !== "g" ? tag : null));
      if (tag === "text") {
        const tl6 = textLines2(item);
        if (isArray10(tl6)) {
          const attrs = {
            x: 0,
            dy: lineHeight2(item)
          };
          for (let i = 0; i < tl6.length; ++i) {
            m3.open("tspan", i ? attrs : null).text(textValue2(item, tl6[i])).close();
          }
        } else {
          m3.text(textValue2(item, tl6));
        }
      } else if (tag === "g") {
        const fore = item.strokeForeground, fill6 = item.fill, stroke6 = item.stroke;
        if (fore && stroke6) {
          item.stroke = null;
        }
        m3.open("path", this.attr(scene, item, mdef.background, "bgrect")).close();
        m3.open("g", this.attr(scene, item, mdef.content));
        visit2(item, (scene2) => this.mark(m3, scene2));
        m3.close();
        if (fore && stroke6) {
          if (fill6)
            item.fill = null;
          item.stroke = stroke6;
          m3.open("path", this.attr(scene, item, mdef.foreground, "bgrect")).close();
          if (fill6)
            item.fill = fill6;
        } else {
          m3.open("path", this.attr(scene, item, mdef.foreground, "bgfore")).close();
        }
      }
      m3.close();
      if (href6)
        m3.close();
    };
    if (mdef.nested) {
      if (scene.items && scene.items.length)
        process2(scene.items[0]);
    } else {
      visit2(scene, process2);
    }
    return m3.close();
  }
  /**
   * Get href attributes for a hyperlinked mark item.
   * @param {Item} item - The mark item.
   */
  href(item) {
    const href6 = item.href;
    let attr6;
    if (href6) {
      if (attr6 = this._hrefs && this._hrefs[href6]) {
        return attr6;
      } else {
        this.sanitizeURL(href6).then((attr7) => {
          attr7["xlink:href"] = attr7.href;
          attr7.href = null;
          (this._hrefs || (this._hrefs = {}))[href6] = attr7;
        });
      }
    }
    return null;
  }
  /**
   * Get an object of SVG attributes for a mark item.
   * @param {object} scene - The mark parent.
   * @param {Item} item - The mark item.
   * @param {array|function} attrs - One or more attribute emitters.
   * @param {string} tag - The tag being rendered.
   */
  attr(scene, item, attrs, tag) {
    const object2 = {}, emit6 = (name, value7, ns, prefixed) => {
      object2[prefixed || name] = value7;
    };
    if (Array.isArray(attrs)) {
      attrs.forEach((fn) => fn(emit6, item, this));
    } else {
      attrs(emit6, item, this);
    }
    if (tag) {
      style2(object2, item, scene, tag, this._defs);
    }
    return object2;
  }
  /**
   * Render SVG defs, as needed.
   * Must be called *after* marks have been processed to ensure the
   * collected state is current and accurate.
   * @param {object} m - The markup context.
   */
  defs(m3) {
    const gradient8 = this._defs.gradient, clipping = this._defs.clipping, count3 = Object.keys(gradient8).length + Object.keys(clipping).length;
    if (count3 === 0)
      return;
    m3.open("defs");
    for (const id24 in gradient8) {
      const def6 = gradient8[id24], stops = def6.stops;
      if (def6.gradient === "radial") {
        m3.open("pattern", {
          id: patternPrefix2 + id24,
          viewBox: "0,0,1,1",
          width: "100%",
          height: "100%",
          preserveAspectRatio: "xMidYMid slice"
        });
        m3.open("rect", {
          width: "1",
          height: "1",
          fill: "url(#" + id24 + ")"
        }).close();
        m3.close();
        m3.open("radialGradient", {
          id: id24,
          fx: def6.x1,
          fy: def6.y1,
          fr: def6.r1,
          cx: def6.x2,
          cy: def6.y2,
          r: def6.r2
        });
      } else {
        m3.open("linearGradient", {
          id: id24,
          x1: def6.x1,
          x2: def6.x2,
          y1: def6.y1,
          y2: def6.y2
        });
      }
      for (let i = 0; i < stops.length; ++i) {
        m3.open("stop", {
          offset: stops[i].offset,
          "stop-color": stops[i].color
        }).close();
      }
      m3.close();
    }
    for (const id24 in clipping) {
      const def6 = clipping[id24];
      m3.open("clipPath", {
        id: id24
      });
      if (def6.path) {
        m3.open("path", {
          d: def6.path
        }).close();
      } else {
        m3.open("rect", {
          x: 0,
          y: 0,
          width: def6.width,
          height: def6.height
        }).close();
      }
      m3.close();
    }
    m3.close();
  }
};
function style2(s2, item, scene, tag, defs) {
  let styleList;
  if (item == null)
    return s2;
  if (tag === "bgrect" && scene.interactive === false) {
    s2["pointer-events"] = "none";
  }
  if (tag === "bgfore") {
    if (scene.interactive === false) {
      s2["pointer-events"] = "none";
    }
    s2.display = "none";
    if (item.fill !== null)
      return s2;
  }
  if (tag === "image" && item.smooth === false) {
    styleList = ["image-rendering: optimizeSpeed;", "image-rendering: pixelated;"];
  }
  if (tag === "text") {
    s2["font-family"] = fontFamily2(item);
    s2["font-size"] = fontSize2(item) + "px";
    s2["font-style"] = item.fontStyle;
    s2["font-variant"] = item.fontVariant;
    s2["font-weight"] = item.fontWeight;
  }
  for (const prop in stylesAttr2) {
    let value7 = item[prop];
    const name = stylesAttr2[prop];
    if (value7 === "transparent" && (name === "fill" || name === "stroke"))
      ;
    else if (value7 != null) {
      if (isGradient2(value7)) {
        value7 = gradientRef2(value7, defs.gradient, "");
      }
      s2[name] = value7;
    }
  }
  for (const prop in stylesCss2) {
    const value7 = item[prop];
    if (value7 != null) {
      styleList = styleList || [];
      styleList.push(`${stylesCss2[prop]}: ${value7};`);
    }
  }
  if (styleList) {
    s2.style = styleList.join(" ");
  }
  return s2;
}
var OPTS2 = {
  svgMarkTypes: ["text"],
  svgOnTop: true,
  debug: false
};
var HybridRenderer2 = class extends Renderer2 {
  constructor(loader7) {
    super(loader7);
    this._svgRenderer = new SVGRenderer2(loader7);
    this._canvasRenderer = new CanvasRenderer2(loader7);
  }
  /**
   * Initialize a new HybridRenderer instance.
   * @param {DOMElement} el - The containing DOM element for the display.
   * @param {number} width - The coordinate width of the display, in pixels.
   * @param {number} height - The coordinate height of the display, in pixels.
   * @param {Array<number>} origin - The origin of the display, in pixels.
   *   The coordinate system will be translated to this point.
   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
   *   the width and height to determine the final pixel size.
   * @return {HybridRenderer} - This renderer instance.
   */
  initialize(el, width2, height2, origin, scaleFactor) {
    this._root_el = domChild2(el, 0, "div");
    const bottomEl = domChild2(this._root_el, 0, "div");
    const topEl = domChild2(this._root_el, 1, "div");
    this._root_el.style.position = "relative";
    if (!OPTS2.debug) {
      bottomEl.style.height = "100%";
      topEl.style.position = "absolute";
      topEl.style.top = "0";
      topEl.style.left = "0";
      topEl.style.height = "100%";
      topEl.style.width = "100%";
    }
    this._svgEl = OPTS2.svgOnTop ? topEl : bottomEl;
    this._canvasEl = OPTS2.svgOnTop ? bottomEl : topEl;
    this._svgEl.style.pointerEvents = "none";
    this._canvasRenderer.initialize(this._canvasEl, width2, height2, origin, scaleFactor);
    this._svgRenderer.initialize(this._svgEl, width2, height2, origin, scaleFactor);
    return super.initialize(el, width2, height2, origin, scaleFactor);
  }
  /**
   * Flag a mark item as dirty.
   * @param {Item} item - The mark item.
   */
  dirty(item) {
    if (OPTS2.svgMarkTypes.includes(item.mark.marktype)) {
      this._svgRenderer.dirty(item);
    } else {
      this._canvasRenderer.dirty(item);
    }
    return this;
  }
  /**
   * Internal rendering method.
   * @param {object} scene - The root mark of a scenegraph to render.
   * @param {Array} markTypes - Array of the mark types to render.
   *                            If undefined, render all mark types
   */
  _render(scene, markTypes) {
    const allMarkTypes = markTypes ?? ["arc", "area", "image", "line", "path", "rect", "rule", "shape", "symbol", "text", "trail"];
    const canvasMarkTypes = allMarkTypes.filter((m3) => !OPTS2.svgMarkTypes.includes(m3));
    this._svgRenderer.render(scene, OPTS2.svgMarkTypes);
    this._canvasRenderer.render(scene, canvasMarkTypes);
  }
  /**
   * Resize the display.
   * @param {number} width - The new coordinate width of the display, in pixels.
   * @param {number} height - The new coordinate height of the display, in pixels.
   * @param {Array<number>} origin - The new origin of the display, in pixels.
   *   The coordinate system will be translated to this point.
   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
   *   the width and height to determine the final pixel size.
   * @return {SVGRenderer} - This renderer instance;
   */
  resize(width2, height2, origin, scaleFactor) {
    super.resize(width2, height2, origin, scaleFactor);
    this._svgRenderer.resize(width2, height2, origin, scaleFactor);
    this._canvasRenderer.resize(width2, height2, origin, scaleFactor);
    return this;
  }
  background(bgcolor) {
    if (OPTS2.svgOnTop) {
      this._canvasRenderer.background(bgcolor);
    } else {
      this._svgRenderer.background(bgcolor);
    }
    return this;
  }
};
var HybridHandler2 = class extends CanvasHandler2 {
  constructor(loader7, tooltip2) {
    super(loader7, tooltip2);
  }
  initialize(el, origin, obj) {
    const canvas = domChild2(domChild2(el, 0, "div"), OPTS2.svgOnTop ? 0 : 1, "div");
    return super.initialize(canvas, origin, obj);
  }
};
var Canvas2 = "canvas";
var Hybrid2 = "hybrid";
var PNG2 = "png";
var SVG2 = "svg";
var None5 = "none";
var modules2 = {};
modules2[Canvas2] = modules2[PNG2] = {
  renderer: CanvasRenderer2,
  headless: CanvasRenderer2,
  handler: CanvasHandler2
};
modules2[SVG2] = {
  renderer: SVGRenderer2,
  headless: SVGStringRenderer2,
  handler: SVGHandler2
};
modules2[Hybrid2] = {
  renderer: HybridRenderer2,
  headless: HybridRenderer2,
  handler: HybridHandler2
};
modules2[None5] = {};
var clipBounds2 = new Bounds2();

// node_modules/vega-label/build/vega-label.js
var ALPHA_MASK = 4278190080;
function baseBitmaps($11, data3) {
  const bitmap = $11.bitmap();
  (data3 || []).forEach((d) => bitmap.set($11(d.boundary[0]), $11(d.boundary[3])));
  return [bitmap, void 0];
}
function markBitmaps($11, baseMark, avoidMarks, labelInside, isGroupArea) {
  const width2 = $11.width, height2 = $11.height, border = labelInside || isGroupArea, context7 = domCanvas3(width2, height2).getContext("2d"), baseMarkContext = domCanvas3(width2, height2).getContext("2d"), strokeContext = border && domCanvas3(width2, height2).getContext("2d");
  avoidMarks.forEach((items) => draw3(context7, items, false));
  draw3(baseMarkContext, baseMark, false);
  if (border) {
    draw3(strokeContext, baseMark, true);
  }
  const buffer = getBuffer(context7, width2, height2), baseMarkBuffer = getBuffer(baseMarkContext, width2, height2), strokeBuffer = border && getBuffer(strokeContext, width2, height2), layer1 = $11.bitmap(), layer2 = border && $11.bitmap();
  let x9, y9, u4, v2, index4, alpha, strokeAlpha, baseMarkAlpha;
  for (y9 = 0; y9 < height2; ++y9) {
    for (x9 = 0; x9 < width2; ++x9) {
      index4 = y9 * width2 + x9;
      alpha = buffer[index4] & ALPHA_MASK;
      baseMarkAlpha = baseMarkBuffer[index4] & ALPHA_MASK;
      strokeAlpha = border && strokeBuffer[index4] & ALPHA_MASK;
      if (alpha || strokeAlpha || baseMarkAlpha) {
        u4 = $11(x9);
        v2 = $11(y9);
        if (!isGroupArea && (alpha || baseMarkAlpha))
          layer1.set(u4, v2);
        if (border && (alpha || strokeAlpha))
          layer2.set(u4, v2);
      }
    }
  }
  return [layer1, layer2];
}
function getBuffer(context7, width2, height2) {
  return new Uint32Array(context7.getImageData(0, 0, width2, height2).data.buffer);
}
function draw3(context7, items, interior) {
  if (!items.length)
    return;
  const type7 = items[0].mark.marktype;
  if (type7 === "group") {
    items.forEach((group7) => {
      group7.items.forEach((mark) => draw3(context7, mark.items, interior));
    });
  } else {
    Marks2[type7].draw(context7, {
      items: interior ? items.map(prepare) : items
    });
  }
}
function prepare(source3) {
  const item = rederive(source3, {});
  if (item.stroke && item.strokeOpacity !== 0 || item.fill && item.fillOpacity !== 0) {
    return {
      ...item,
      strokeOpacity: 1,
      stroke: "#000",
      fillOpacity: 0
    };
  }
  return item;
}
var DIV = 5;
var MOD2 = 31;
var SIZE = 32;
var RIGHT0 = new Uint32Array(SIZE + 1);
var RIGHT1 = new Uint32Array(SIZE + 1);
RIGHT1[0] = 0;
RIGHT0[0] = ~RIGHT1[0];
for (let i = 1; i <= SIZE; ++i) {
  RIGHT1[i] = RIGHT1[i - 1] << 1 | 1;
  RIGHT0[i] = ~RIGHT1[i];
}
function Bitmap(w8, h6) {
  const array22 = new Uint32Array(~~((w8 * h6 + SIZE) / SIZE));
  function _set(index4, mask) {
    array22[index4] |= mask;
  }
  function _clear(index4, mask) {
    array22[index4] &= mask;
  }
  return {
    array: array22,
    get: (x9, y9) => {
      const index4 = y9 * w8 + x9;
      return array22[index4 >>> DIV] & 1 << (index4 & MOD2);
    },
    set: (x9, y9) => {
      const index4 = y9 * w8 + x9;
      _set(index4 >>> DIV, 1 << (index4 & MOD2));
    },
    clear: (x9, y9) => {
      const index4 = y9 * w8 + x9;
      _clear(index4 >>> DIV, ~(1 << (index4 & MOD2)));
    },
    getRange: (x9, y9, x22, y22) => {
      let r = y22, start, end, indexStart, indexEnd;
      for (; r >= y9; --r) {
        start = r * w8 + x9;
        end = r * w8 + x22;
        indexStart = start >>> DIV;
        indexEnd = end >>> DIV;
        if (indexStart === indexEnd) {
          if (array22[indexStart] & RIGHT0[start & MOD2] & RIGHT1[(end & MOD2) + 1]) {
            return true;
          }
        } else {
          if (array22[indexStart] & RIGHT0[start & MOD2])
            return true;
          if (array22[indexEnd] & RIGHT1[(end & MOD2) + 1])
            return true;
          for (let i = indexStart + 1; i < indexEnd; ++i) {
            if (array22[i])
              return true;
          }
        }
      }
      return false;
    },
    setRange: (x9, y9, x22, y22) => {
      let start, end, indexStart, indexEnd, i;
      for (; y9 <= y22; ++y9) {
        start = y9 * w8 + x9;
        end = y9 * w8 + x22;
        indexStart = start >>> DIV;
        indexEnd = end >>> DIV;
        if (indexStart === indexEnd) {
          _set(indexStart, RIGHT0[start & MOD2] & RIGHT1[(end & MOD2) + 1]);
        } else {
          _set(indexStart, RIGHT0[start & MOD2]);
          _set(indexEnd, RIGHT1[(end & MOD2) + 1]);
          for (i = indexStart + 1; i < indexEnd; ++i)
            _set(i, 4294967295);
        }
      }
    },
    clearRange: (x9, y9, x22, y22) => {
      let start, end, indexStart, indexEnd, i;
      for (; y9 <= y22; ++y9) {
        start = y9 * w8 + x9;
        end = y9 * w8 + x22;
        indexStart = start >>> DIV;
        indexEnd = end >>> DIV;
        if (indexStart === indexEnd) {
          _clear(indexStart, RIGHT1[start & MOD2] | RIGHT0[(end & MOD2) + 1]);
        } else {
          _clear(indexStart, RIGHT1[start & MOD2]);
          _clear(indexEnd, RIGHT0[(end & MOD2) + 1]);
          for (i = indexStart + 1; i < indexEnd; ++i)
            _clear(i, 0);
        }
      }
    },
    outOfBounds: (x9, y9, x22, y22) => x9 < 0 || y9 < 0 || y22 >= h6 || x22 >= w8
  };
}
function scaler(width2, height2, padding3) {
  const ratio = Math.max(1, Math.sqrt(width2 * height2 / 1e6)), w8 = ~~((width2 + 2 * padding3 + ratio) / ratio), h6 = ~~((height2 + 2 * padding3 + ratio) / ratio), scale19 = (_) => ~~((_ + padding3) / ratio);
  scale19.invert = (_) => _ * ratio - padding3;
  scale19.bitmap = () => Bitmap(w8, h6);
  scale19.ratio = ratio;
  scale19.padding = padding3;
  scale19.width = width2;
  scale19.height = height2;
  return scale19;
}
function placeAreaLabelNaive($11, bitmaps, avoidBaseMark, markIndex) {
  const width2 = $11.width, height2 = $11.height;
  return function(d) {
    const items = d.datum.datum.items[markIndex].items, n = items.length, textHeight = d.datum.fontSize, textWidth = textMetrics2.width(d.datum, d.datum.text);
    let maxAreaWidth = 0, x13, x22, y13, y22, x9, y9, areaWidth;
    for (let i = 0; i < n; ++i) {
      x13 = items[i].x;
      y13 = items[i].y;
      x22 = items[i].x2 === void 0 ? x13 : items[i].x2;
      y22 = items[i].y2 === void 0 ? y13 : items[i].y2;
      x9 = (x13 + x22) / 2;
      y9 = (y13 + y22) / 2;
      areaWidth = Math.abs(x22 - x13 + y22 - y13);
      if (areaWidth >= maxAreaWidth) {
        maxAreaWidth = areaWidth;
        d.x = x9;
        d.y = y9;
      }
    }
    x9 = textWidth / 2;
    y9 = textHeight / 2;
    x13 = d.x - x9;
    x22 = d.x + x9;
    y13 = d.y - y9;
    y22 = d.y + y9;
    d.align = "center";
    if (x13 < 0 && x22 <= width2) {
      d.align = "left";
    } else if (0 <= x13 && width2 < x22) {
      d.align = "right";
    }
    d.baseline = "middle";
    if (y13 < 0 && y22 <= height2) {
      d.baseline = "top";
    } else if (0 <= y13 && height2 < y22) {
      d.baseline = "bottom";
    }
    return true;
  };
}
function outOfBounds(x9, y9, textWidth, textHeight, width2, height2) {
  let r = textWidth / 2;
  return x9 - r < 0 || x9 + r > width2 || y9 - (r = textHeight / 2) < 0 || y9 + r > height2;
}
function collision($11, x9, y9, textHeight, textWidth, h6, bm0, bm1) {
  const w8 = textWidth * h6 / (textHeight * 2), x13 = $11(x9 - w8), x22 = $11(x9 + w8), y13 = $11(y9 - (h6 = h6 / 2)), y22 = $11(y9 + h6);
  return bm0.outOfBounds(x13, y13, x22, y22) || bm0.getRange(x13, y13, x22, y22) || bm1 && bm1.getRange(x13, y13, x22, y22);
}
function placeAreaLabelReducedSearch($11, bitmaps, avoidBaseMark, markIndex) {
  const width2 = $11.width, height2 = $11.height, bm0 = bitmaps[0], bm1 = bitmaps[1];
  function tryLabel(_x3, _y3, maxSize, textWidth, textHeight) {
    const x9 = $11.invert(_x3), y9 = $11.invert(_y3);
    let lo = maxSize, hi = height2, mid;
    if (!outOfBounds(x9, y9, textWidth, textHeight, width2, height2) && !collision($11, x9, y9, textHeight, textWidth, lo, bm0, bm1) && !collision($11, x9, y9, textHeight, textWidth, textHeight, bm0, null)) {
      while (hi - lo >= 1) {
        mid = (lo + hi) / 2;
        if (collision($11, x9, y9, textHeight, textWidth, mid, bm0, bm1)) {
          hi = mid;
        } else {
          lo = mid;
        }
      }
      if (lo > maxSize) {
        return [x9, y9, lo, true];
      }
    }
  }
  return function(d) {
    const items = d.datum.datum.items[markIndex].items, n = items.length, textHeight = d.datum.fontSize, textWidth = textMetrics2.width(d.datum, d.datum.text);
    let maxSize = avoidBaseMark ? textHeight : 0, labelPlaced = false, labelPlaced2 = false, maxAreaWidth = 0, x13, x22, y13, y22, x9, y9, _x3, _y3, _x1, _xMid, _x22, _y1, _yMid, _y22, areaWidth, result, swapTmp;
    for (let i = 0; i < n; ++i) {
      x13 = items[i].x;
      y13 = items[i].y;
      x22 = items[i].x2 === void 0 ? x13 : items[i].x2;
      y22 = items[i].y2 === void 0 ? y13 : items[i].y2;
      if (x13 > x22) {
        swapTmp = x13;
        x13 = x22;
        x22 = swapTmp;
      }
      if (y13 > y22) {
        swapTmp = y13;
        y13 = y22;
        y22 = swapTmp;
      }
      _x1 = $11(x13);
      _x22 = $11(x22);
      _xMid = ~~((_x1 + _x22) / 2);
      _y1 = $11(y13);
      _y22 = $11(y22);
      _yMid = ~~((_y1 + _y22) / 2);
      for (_x3 = _xMid; _x3 >= _x1; --_x3) {
        for (_y3 = _yMid; _y3 >= _y1; --_y3) {
          result = tryLabel(_x3, _y3, maxSize, textWidth, textHeight);
          if (result) {
            [d.x, d.y, maxSize, labelPlaced] = result;
          }
        }
      }
      for (_x3 = _xMid; _x3 <= _x22; ++_x3) {
        for (_y3 = _yMid; _y3 <= _y22; ++_y3) {
          result = tryLabel(_x3, _y3, maxSize, textWidth, textHeight);
          if (result) {
            [d.x, d.y, maxSize, labelPlaced] = result;
          }
        }
      }
      if (!labelPlaced && !avoidBaseMark) {
        areaWidth = Math.abs(x22 - x13 + y22 - y13);
        x9 = (x13 + x22) / 2;
        y9 = (y13 + y22) / 2;
        if (areaWidth >= maxAreaWidth && !outOfBounds(x9, y9, textWidth, textHeight, width2, height2) && !collision($11, x9, y9, textHeight, textWidth, textHeight, bm0, null)) {
          maxAreaWidth = areaWidth;
          d.x = x9;
          d.y = y9;
          labelPlaced2 = true;
        }
      }
    }
    if (labelPlaced || labelPlaced2) {
      x9 = textWidth / 2;
      y9 = textHeight / 2;
      bm0.setRange($11(d.x - x9), $11(d.y - y9), $11(d.x + x9), $11(d.y + y9));
      d.align = "center";
      d.baseline = "middle";
      return true;
    } else {
      return false;
    }
  };
}
var X_DIR = [-1, -1, 1, 1];
var Y_DIR = [-1, 1, -1, 1];
function placeAreaLabelFloodFill($11, bitmaps, avoidBaseMark, markIndex) {
  const width2 = $11.width, height2 = $11.height, bm0 = bitmaps[0], bm1 = bitmaps[1], bm2 = $11.bitmap();
  return function(d) {
    const items = d.datum.datum.items[markIndex].items, n = items.length, textHeight = d.datum.fontSize, textWidth = textMetrics2.width(d.datum, d.datum.text), stack2 = [];
    let maxSize = avoidBaseMark ? textHeight : 0, labelPlaced = false, labelPlaced2 = false, maxAreaWidth = 0, x13, x22, y13, y22, x9, y9, _x3, _y3, lo, hi, mid, areaWidth;
    for (let i = 0; i < n; ++i) {
      x13 = items[i].x;
      y13 = items[i].y;
      x22 = items[i].x2 === void 0 ? x13 : items[i].x2;
      y22 = items[i].y2 === void 0 ? y13 : items[i].y2;
      stack2.push([$11((x13 + x22) / 2), $11((y13 + y22) / 2)]);
      while (stack2.length) {
        [_x3, _y3] = stack2.pop();
        if (bm0.get(_x3, _y3) || bm1.get(_x3, _y3) || bm2.get(_x3, _y3))
          continue;
        bm2.set(_x3, _y3);
        for (let j = 0; j < 4; ++j) {
          x9 = _x3 + X_DIR[j];
          y9 = _y3 + Y_DIR[j];
          if (!bm2.outOfBounds(x9, y9, x9, y9))
            stack2.push([x9, y9]);
        }
        x9 = $11.invert(_x3);
        y9 = $11.invert(_y3);
        lo = maxSize;
        hi = height2;
        if (!outOfBounds(x9, y9, textWidth, textHeight, width2, height2) && !collision($11, x9, y9, textHeight, textWidth, lo, bm0, bm1) && !collision($11, x9, y9, textHeight, textWidth, textHeight, bm0, null)) {
          while (hi - lo >= 1) {
            mid = (lo + hi) / 2;
            if (collision($11, x9, y9, textHeight, textWidth, mid, bm0, bm1)) {
              hi = mid;
            } else {
              lo = mid;
            }
          }
          if (lo > maxSize) {
            d.x = x9;
            d.y = y9;
            maxSize = lo;
            labelPlaced = true;
          }
        }
      }
      if (!labelPlaced && !avoidBaseMark) {
        areaWidth = Math.abs(x22 - x13 + y22 - y13);
        x9 = (x13 + x22) / 2;
        y9 = (y13 + y22) / 2;
        if (areaWidth >= maxAreaWidth && !outOfBounds(x9, y9, textWidth, textHeight, width2, height2) && !collision($11, x9, y9, textHeight, textWidth, textHeight, bm0, null)) {
          maxAreaWidth = areaWidth;
          d.x = x9;
          d.y = y9;
          labelPlaced2 = true;
        }
      }
    }
    if (labelPlaced || labelPlaced2) {
      x9 = textWidth / 2;
      y9 = textHeight / 2;
      bm0.setRange($11(d.x - x9), $11(d.y - y9), $11(d.x + x9), $11(d.y + y9));
      d.align = "center";
      d.baseline = "middle";
      return true;
    } else {
      return false;
    }
  };
}
var Aligns = ["right", "center", "left"];
var Baselines = ["bottom", "middle", "top"];
function placeMarkLabel($11, bitmaps, anchors, offsets2) {
  const width2 = $11.width, height2 = $11.height, bm0 = bitmaps[0], bm1 = bitmaps[1], n = offsets2.length;
  return function(d) {
    const boundary = d.boundary, textHeight = d.datum.fontSize;
    if (boundary[2] < 0 || boundary[5] < 0 || boundary[0] > width2 || boundary[3] > height2) {
      return false;
    }
    let textWidth = d.textWidth ?? 0, dx, dy, isInside, sizeFactor, insideFactor, x13, x22, y13, y22, xc, yc, _x1, _x22, _y1, _y22;
    for (let i = 0; i < n; ++i) {
      dx = (anchors[i] & 3) - 1;
      dy = (anchors[i] >>> 2 & 3) - 1;
      isInside = dx === 0 && dy === 0 || offsets2[i] < 0;
      sizeFactor = dx && dy ? Math.SQRT1_2 : 1;
      insideFactor = offsets2[i] < 0 ? -1 : 1;
      x13 = boundary[1 + dx] + offsets2[i] * dx * sizeFactor;
      yc = boundary[4 + dy] + insideFactor * textHeight * dy / 2 + offsets2[i] * dy * sizeFactor;
      y13 = yc - textHeight / 2;
      y22 = yc + textHeight / 2;
      _x1 = $11(x13);
      _y1 = $11(y13);
      _y22 = $11(y22);
      if (!textWidth) {
        if (!test(_x1, _x1, _y1, _y22, bm0, bm1, x13, x13, y13, y22, boundary, isInside)) {
          continue;
        } else {
          textWidth = textMetrics2.width(d.datum, d.datum.text);
        }
      }
      xc = x13 + insideFactor * textWidth * dx / 2;
      x13 = xc - textWidth / 2;
      x22 = xc + textWidth / 2;
      _x1 = $11(x13);
      _x22 = $11(x22);
      if (test(_x1, _x22, _y1, _y22, bm0, bm1, x13, x22, y13, y22, boundary, isInside)) {
        d.x = !dx ? xc : dx * insideFactor < 0 ? x22 : x13;
        d.y = !dy ? yc : dy * insideFactor < 0 ? y22 : y13;
        d.align = Aligns[dx * insideFactor + 1];
        d.baseline = Baselines[dy * insideFactor + 1];
        bm0.setRange(_x1, _y1, _x22, _y22);
        return true;
      }
    }
    return false;
  };
}
function test(_x1, _x22, _y1, _y22, bm0, bm1, x13, x22, y13, y22, boundary, isInside) {
  return !(bm0.outOfBounds(_x1, _y1, _x22, _y22) || (isInside && bm1 || bm0).getRange(_x1, _y1, _x22, _y22));
}
var TOP = 0;
var MIDDLE = 4;
var BOTTOM = 8;
var LEFT = 0;
var CENTER = 1;
var RIGHT = 2;
var anchorCode = {
  "top-left": TOP + LEFT,
  "top": TOP + CENTER,
  "top-right": TOP + RIGHT,
  "left": MIDDLE + LEFT,
  "middle": MIDDLE + CENTER,
  "right": MIDDLE + RIGHT,
  "bottom-left": BOTTOM + LEFT,
  "bottom": BOTTOM + CENTER,
  "bottom-right": BOTTOM + RIGHT
};
var placeAreaLabel = {
  "naive": placeAreaLabelNaive,
  "reduced-search": placeAreaLabelReducedSearch,
  "floodfill": placeAreaLabelFloodFill
};
function labelLayout(texts, size, compare10, offset9, anchor, avoidMarks, avoidBaseMark, lineAnchor, markIndex, padding3, method10) {
  if (!texts.length)
    return texts;
  const positions = Math.max(offset9.length, anchor.length), offsets2 = getOffsets(offset9, positions), anchors = getAnchors(anchor, positions), marktype = markType(texts[0].datum), grouptype = marktype === "group" && texts[0].datum.items[markIndex].marktype, isGroupArea = grouptype === "area", boundary = markBoundary(marktype, grouptype, lineAnchor, markIndex), infPadding = padding3 === null || padding3 === Infinity, isNaiveGroupArea = isGroupArea && method10 === "naive";
  let maxTextWidth = -1, maxTextHeight = -1;
  const data3 = texts.map((d) => {
    const textWidth = infPadding ? textMetrics2.width(d, d.text) : void 0;
    maxTextWidth = Math.max(maxTextWidth, textWidth);
    maxTextHeight = Math.max(maxTextHeight, d.fontSize);
    return {
      datum: d,
      opacity: 0,
      x: void 0,
      y: void 0,
      align: void 0,
      baseline: void 0,
      boundary: boundary(d),
      textWidth
    };
  });
  padding3 = padding3 === null || padding3 === Infinity ? Math.max(maxTextWidth, maxTextHeight) + Math.max(...offset9) : padding3;
  const $11 = scaler(size[0], size[1], padding3);
  let bitmaps;
  if (!isNaiveGroupArea) {
    if (compare10) {
      data3.sort((a4, b6) => compare10(a4.datum, b6.datum));
    }
    let labelInside = false;
    for (let i = 0; i < anchors.length && !labelInside; ++i) {
      labelInside = anchors[i] === 5 || offsets2[i] < 0;
    }
    const baseMark = (marktype && avoidBaseMark || isGroupArea) && texts.map((d) => d.datum);
    bitmaps = avoidMarks.length || baseMark ? markBitmaps($11, baseMark || [], avoidMarks, labelInside, isGroupArea) : baseBitmaps($11, avoidBaseMark && data3);
  }
  const place2 = isGroupArea ? placeAreaLabel[method10]($11, bitmaps, avoidBaseMark, markIndex) : placeMarkLabel($11, bitmaps, anchors, offsets2);
  data3.forEach((d) => d.opacity = +place2(d));
  return data3;
}
function getOffsets(_, count3) {
  const offsets2 = new Float64Array(count3), n = _.length;
  for (let i = 0; i < n; ++i)
    offsets2[i] = _[i] || 0;
  for (let i = n; i < count3; ++i)
    offsets2[i] = offsets2[n - 1];
  return offsets2;
}
function getAnchors(_, count3) {
  const anchors = new Int8Array(count3), n = _.length;
  for (let i = 0; i < n; ++i)
    anchors[i] |= anchorCode[_[i]];
  for (let i = n; i < count3; ++i)
    anchors[i] = anchors[n - 1];
  return anchors;
}
function markType(item) {
  return item && item.mark && item.mark.marktype;
}
function markBoundary(marktype, grouptype, lineAnchor, markIndex) {
  const xy = (d) => [d.x, d.x, d.x, d.y, d.y, d.y];
  if (!marktype) {
    return xy;
  } else if (marktype === "line" || marktype === "area") {
    return (d) => xy(d.datum);
  } else if (grouptype === "line") {
    return (d) => {
      const items = d.datum.items[markIndex].items;
      return xy(items.length ? items[lineAnchor === "start" ? 0 : items.length - 1] : {
        x: NaN,
        y: NaN
      });
    };
  } else {
    return (d) => {
      const b6 = d.datum.bounds;
      return [b6.x1, (b6.x1 + b6.x2) / 2, b6.x2, b6.y1, (b6.y1 + b6.y2) / 2, b6.y2];
    };
  }
}
var Output3 = ["x", "y", "opacity", "align", "baseline"];
var Anchors = ["top-left", "left", "bottom-left", "top", "bottom", "top-right", "right", "bottom-right"];
function Label(params2) {
  Transform.call(this, null, params2);
}
Label.Definition = {
  type: "Label",
  metadata: {
    modifies: true
  },
  params: [{
    name: "size",
    type: "number",
    array: true,
    length: 2,
    required: true
  }, {
    name: "sort",
    type: "compare"
  }, {
    name: "anchor",
    type: "string",
    array: true,
    default: Anchors
  }, {
    name: "offset",
    type: "number",
    array: true,
    default: [1]
  }, {
    name: "padding",
    type: "number",
    default: 0,
    null: true
  }, {
    name: "lineAnchor",
    type: "string",
    values: ["start", "end"],
    default: "end"
  }, {
    name: "markIndex",
    type: "number",
    default: 0
  }, {
    name: "avoidBaseMark",
    type: "boolean",
    default: true
  }, {
    name: "avoidMarks",
    type: "data",
    array: true
  }, {
    name: "method",
    type: "string",
    default: "naive"
  }, {
    name: "as",
    type: "string",
    array: true,
    length: Output3.length,
    default: Output3
  }]
};
inherits9(Label, Transform, {
  transform(_, pulse2) {
    function modp(param2) {
      const p = _[param2];
      return isFunction8(p) && pulse2.modified(p.fields);
    }
    const mod = _.modified();
    if (!(mod || pulse2.changed(pulse2.ADD_REM) || modp("sort")))
      return;
    if (!_.size || _.size.length !== 2) {
      error10("Size parameter should be specified as a [width, height] array.");
    }
    const as = _.as || Output3;
    labelLayout(pulse2.materialize(pulse2.SOURCE).source || [], _.size, _.sort, array11(_.offset == null ? 1 : _.offset), array11(_.anchor || Anchors), _.avoidMarks || [], _.avoidBaseMark !== false, _.lineAnchor || "end", _.markIndex || 0, _.padding === void 0 ? 0 : _.padding, _.method || "naive").forEach((l) => {
      const t = l.datum;
      t[as[0]] = l.x;
      t[as[1]] = l.y;
      t[as[2]] = l.opacity;
      t[as[3]] = l.align;
      t[as[4]] = l.baseline;
    });
    return pulse2.reflow(mod).modifies(as);
  }
});

// node_modules/vega-regression/build/vega-regression.js
var vega_regression_exports = {};
__export(vega_regression_exports, {
  loess: () => Loess,
  regression: () => Regression
});

// node_modules/vega-regression/node_modules/vega-util/build/vega-util.js
function accessor11(fn, fields, name) {
  fn.fields = fields || [];
  fn.fname = name;
  return fn;
}
function accessorName4(fn) {
  return fn == null ? null : fn.fname;
}
function getter11(path7) {
  return path7.length === 1 ? get111(path7[0]) : getN11(path7);
}
var get111 = (field25) => function(obj) {
  return obj[field25];
};
var getN11 = (path7) => {
  const len = path7.length;
  return function(obj) {
    for (let i = 0; i < len; ++i) {
      obj = obj[path7[i]];
    }
    return obj;
  };
};
function error11(message) {
  throw Error(message);
}
function splitAccessPath11(p) {
  const path7 = [], n = p.length;
  let q = null, b6 = 0, s2 = "", i, j, c5;
  p = p + "";
  function push() {
    path7.push(s2 + p.substring(i, j));
    s2 = "";
    i = j + 1;
  }
  for (i = j = 0; j < n; ++j) {
    c5 = p[j];
    if (c5 === "\\") {
      s2 += p.substring(i, j++);
      i = j;
    } else if (c5 === q) {
      push();
      q = null;
      b6 = -1;
    } else if (q) {
      continue;
    } else if (i === b6 && c5 === '"') {
      i = j + 1;
      q = c5;
    } else if (i === b6 && c5 === "'") {
      i = j + 1;
      q = c5;
    } else if (c5 === "." && !b6) {
      if (j > i) {
        push();
      } else {
        i = j + 1;
      }
    } else if (c5 === "[") {
      if (j > i)
        push();
      b6 = i = j + 1;
    } else if (c5 === "]") {
      if (!b6)
        error11("Access path missing open bracket: " + p);
      if (b6 > 0)
        push();
      b6 = 0;
      i = j + 1;
    }
  }
  if (b6)
    error11("Access path missing closing bracket: " + p);
  if (q)
    error11("Access path missing closing quote: " + p);
  if (j > i) {
    j++;
    push();
  }
  return path7;
}
function field11(field25, name, opt) {
  const path7 = splitAccessPath11(field25);
  field25 = path7.length === 1 ? path7[0] : field25;
  return accessor11((opt && opt.get || getter11)(path7), [field25], name || field25);
}
var id11 = field11("id");
var identity15 = accessor11((_) => _, [], "identity");
var zero13 = accessor11(() => 0, [], "zero");
var one12 = accessor11(() => 1, [], "one");
var truthy11 = accessor11(() => true, [], "true");
var falsy11 = accessor11(() => false, [], "false");
var DisallowedObjectProperties11 = /* @__PURE__ */ new Set([...Object.getOwnPropertyNames(Object.prototype).filter((name) => typeof Object.prototype[name] === "function"), "__proto__"]);
var isArray11 = Array.isArray;
function extend12(_) {
  for (let x9, k3, i = 1, len = arguments.length; i < len; ++i) {
    x9 = arguments[i];
    for (k3 in x9) {
      _[k3] = x9[k3];
    }
  }
  return _;
}
function extent5(array22, f) {
  let i = 0, n, v2, min5, max5;
  if (array22 && (n = array22.length)) {
    if (f == null) {
      for (v2 = array22[i]; i < n && (v2 == null || v2 !== v2); v2 = array22[++i])
        ;
      min5 = max5 = v2;
      for (; i < n; ++i) {
        v2 = array22[i];
        if (v2 != null) {
          if (v2 < min5)
            min5 = v2;
          if (v2 > max5)
            max5 = v2;
        }
      }
    } else {
      for (v2 = f(array22[i]); i < n && (v2 == null || v2 !== v2); v2 = f(array22[++i]))
        ;
      min5 = max5 = v2;
      for (; i < n; ++i) {
        v2 = f(array22[i]);
        if (v2 != null) {
          if (v2 < min5)
            min5 = v2;
          if (v2 > max5)
            max5 = v2;
        }
      }
    }
  }
  return [min5, max5];
}
function has10(object2, property2) {
  return Object.hasOwn(object2, property2);
}
function inherits10(child, parent, members) {
  const proto = child.prototype = Object.create(parent.prototype);
  Object.defineProperty(proto, "constructor", {
    value: child,
    writable: true,
    enumerable: true,
    configurable: true
  });
  return extend12(proto, members);
}

// node_modules/vega-regression/build/vega-regression.js
function partition4(data3, groupby) {
  var groups2 = [], get23 = function(f) {
    return f(t);
  }, map13, i, n, t, k3, g;
  if (groupby == null) {
    groups2.push(data3);
  } else {
    for (map13 = {}, i = 0, n = data3.length; i < n; ++i) {
      t = data3[i];
      k3 = groupby.map(get23);
      g = map13[k3];
      if (!g) {
        map13[k3] = g = [];
        g.dims = k3;
        groups2.push(g);
      }
      g.push(t);
    }
  }
  return groups2;
}
function Loess(params2) {
  Transform.call(this, null, params2);
}
Loess.Definition = {
  "type": "Loess",
  "metadata": {
    "generates": true
  },
  "params": [{
    "name": "x",
    "type": "field",
    "required": true
  }, {
    "name": "y",
    "type": "field",
    "required": true
  }, {
    "name": "groupby",
    "type": "field",
    "array": true
  }, {
    "name": "bandwidth",
    "type": "number",
    "default": 0.3
  }, {
    "name": "as",
    "type": "string",
    "array": true
  }]
};
inherits10(Loess, Transform, {
  transform(_, pulse2) {
    const out = pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS);
    if (!this.value || pulse2.changed() || _.modified()) {
      const source3 = pulse2.materialize(pulse2.SOURCE).source, groups2 = partition4(source3, _.groupby), names = (_.groupby || []).map(accessorName4), m3 = names.length, as = _.as || [accessorName4(_.x), accessorName4(_.y)], values7 = [];
      groups2.forEach((g) => {
        loess(g, _.x, _.y, _.bandwidth || 0.3).forEach((p) => {
          const t = {};
          for (let i = 0; i < m3; ++i) {
            t[names[i]] = g.dims[i];
          }
          t[as[0]] = p[0];
          t[as[1]] = p[1];
          values7.push(ingest$1(t));
        });
      });
      if (this.value)
        out.rem = this.value;
      this.value = out.add = out.source = values7;
    }
    return out;
  }
});
var Methods2 = {
  constant: constant5,
  linear,
  log: log2,
  exp: exp2,
  pow: pow2,
  quad,
  poly
};
var degreesOfFreedom = (method10, order) => method10 === "poly" ? order : method10 === "quad" ? 2 : 1;
function Regression(params2) {
  Transform.call(this, null, params2);
}
Regression.Definition = {
  "type": "Regression",
  "metadata": {
    "generates": true
  },
  "params": [{
    "name": "x",
    "type": "field",
    "required": true
  }, {
    "name": "y",
    "type": "field",
    "required": true
  }, {
    "name": "groupby",
    "type": "field",
    "array": true
  }, {
    "name": "method",
    "type": "string",
    "default": "linear",
    "values": Object.keys(Methods2)
  }, {
    "name": "order",
    "type": "number",
    "default": 3
  }, {
    "name": "extent",
    "type": "number",
    "array": true,
    "length": 2
  }, {
    "name": "params",
    "type": "boolean",
    "default": false
  }, {
    "name": "as",
    "type": "string",
    "array": true
  }]
};
inherits10(Regression, Transform, {
  transform(_, pulse2) {
    const out = pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS);
    if (!this.value || pulse2.changed() || _.modified()) {
      const source3 = pulse2.materialize(pulse2.SOURCE).source, groups2 = partition4(source3, _.groupby), names = (_.groupby || []).map(accessorName4), method10 = _.method || "linear", order = _.order == null ? 3 : _.order, dof = degreesOfFreedom(method10, order), as = _.as || [accessorName4(_.x), accessorName4(_.y)], fit3 = Methods2[method10], values7 = [];
      let domain3 = _.extent;
      if (!has10(Methods2, method10)) {
        error11("Invalid regression method: " + method10);
      }
      if (domain3 != null) {
        if (method10 === "log" && domain3[0] <= 0) {
          pulse2.dataflow.warn("Ignoring extent with values <= 0 for log regression.");
          domain3 = null;
        }
      }
      groups2.forEach((g) => {
        const n = g.length;
        if (n <= dof) {
          pulse2.dataflow.warn("Skipping regression with more parameters than data points.");
          return;
        }
        const model = fit3(g, _.x, _.y, order);
        if (_.params) {
          values7.push(ingest$1({
            keys: g.dims,
            coef: model.coef,
            rSquared: model.rSquared
          }));
          return;
        }
        const dom = domain3 || extent5(g, _.x), add10 = (p) => {
          const t = {};
          for (let i = 0; i < names.length; ++i) {
            t[names[i]] = g.dims[i];
          }
          t[as[0]] = p[0];
          t[as[1]] = p[1];
          values7.push(ingest$1(t));
        };
        if (method10 === "linear" || method10 === "constant") {
          dom.forEach((x9) => add10([x9, model.predict(x9)]));
        } else {
          sampleCurve(model.predict, dom, 25, 200).forEach(add10);
        }
      });
      if (this.value)
        out.rem = this.value;
      this.value = out.add = out.source = values7;
    }
    return out;
  }
});

// node_modules/vega-voronoi/build/vega-voronoi.js
var vega_voronoi_exports = {};
__export(vega_voronoi_exports, {
  voronoi: () => Voronoi2
});

// node_modules/vega-voronoi/node_modules/vega-util/build/vega-util.js
function accessor12(fn, fields, name) {
  fn.fields = fields || [];
  fn.fname = name;
  return fn;
}
function getter12(path7) {
  return path7.length === 1 ? get112(path7[0]) : getN12(path7);
}
var get112 = (field25) => function(obj) {
  return obj[field25];
};
var getN12 = (path7) => {
  const len = path7.length;
  return function(obj) {
    for (let i = 0; i < len; ++i) {
      obj = obj[path7[i]];
    }
    return obj;
  };
};
function error12(message) {
  throw Error(message);
}
function splitAccessPath12(p) {
  const path7 = [], n = p.length;
  let q = null, b6 = 0, s2 = "", i, j, c5;
  p = p + "";
  function push() {
    path7.push(s2 + p.substring(i, j));
    s2 = "";
    i = j + 1;
  }
  for (i = j = 0; j < n; ++j) {
    c5 = p[j];
    if (c5 === "\\") {
      s2 += p.substring(i, j++);
      i = j;
    } else if (c5 === q) {
      push();
      q = null;
      b6 = -1;
    } else if (q) {
      continue;
    } else if (i === b6 && c5 === '"') {
      i = j + 1;
      q = c5;
    } else if (i === b6 && c5 === "'") {
      i = j + 1;
      q = c5;
    } else if (c5 === "." && !b6) {
      if (j > i) {
        push();
      } else {
        i = j + 1;
      }
    } else if (c5 === "[") {
      if (j > i)
        push();
      b6 = i = j + 1;
    } else if (c5 === "]") {
      if (!b6)
        error12("Access path missing open bracket: " + p);
      if (b6 > 0)
        push();
      b6 = 0;
      i = j + 1;
    }
  }
  if (b6)
    error12("Access path missing closing bracket: " + p);
  if (q)
    error12("Access path missing closing quote: " + p);
  if (j > i) {
    j++;
    push();
  }
  return path7;
}
function field12(field25, name, opt) {
  const path7 = splitAccessPath12(field25);
  field25 = path7.length === 1 ? path7[0] : field25;
  return accessor12((opt && opt.get || getter12)(path7), [field25], name || field25);
}
var id12 = field12("id");
var identity16 = accessor12((_) => _, [], "identity");
var zero14 = accessor12(() => 0, [], "zero");
var one13 = accessor12(() => 1, [], "one");
var truthy12 = accessor12(() => true, [], "true");
var falsy12 = accessor12(() => false, [], "false");
var DisallowedObjectProperties12 = /* @__PURE__ */ new Set([...Object.getOwnPropertyNames(Object.prototype).filter((name) => typeof Object.prototype[name] === "function"), "__proto__"]);
var isArray12 = Array.isArray;
function extend13(_) {
  for (let x9, k3, i = 1, len = arguments.length; i < len; ++i) {
    x9 = arguments[i];
    for (k3 in x9) {
      _[k3] = x9[k3];
    }
  }
  return _;
}
function inherits11(child, parent, members) {
  const proto = child.prototype = Object.create(parent.prototype);
  Object.defineProperty(proto, "constructor", {
    value: child,
    writable: true,
    enumerable: true,
    configurable: true
  });
  return extend13(proto, members);
}

// node_modules/robust-predicates/esm/util.js
var epsilon7 = 11102230246251565e-32;
var splitter = 134217729;
var resulterrbound = (3 + 8 * epsilon7) * epsilon7;
function sum3(elen, e3, flen, f, h6) {
  let Q, Qnew, hh, bvirt;
  let enow = e3[0];
  let fnow = f[0];
  let eindex = 0;
  let findex = 0;
  if (fnow > enow === fnow > -enow) {
    Q = enow;
    enow = e3[++eindex];
  } else {
    Q = fnow;
    fnow = f[++findex];
  }
  let hindex = 0;
  if (eindex < elen && findex < flen) {
    if (fnow > enow === fnow > -enow) {
      Qnew = enow + Q;
      hh = Q - (Qnew - enow);
      enow = e3[++eindex];
    } else {
      Qnew = fnow + Q;
      hh = Q - (Qnew - fnow);
      fnow = f[++findex];
    }
    Q = Qnew;
    if (hh !== 0) {
      h6[hindex++] = hh;
    }
    while (eindex < elen && findex < flen) {
      if (fnow > enow === fnow > -enow) {
        Qnew = Q + enow;
        bvirt = Qnew - Q;
        hh = Q - (Qnew - bvirt) + (enow - bvirt);
        enow = e3[++eindex];
      } else {
        Qnew = Q + fnow;
        bvirt = Qnew - Q;
        hh = Q - (Qnew - bvirt) + (fnow - bvirt);
        fnow = f[++findex];
      }
      Q = Qnew;
      if (hh !== 0) {
        h6[hindex++] = hh;
      }
    }
  }
  while (eindex < elen) {
    Qnew = Q + enow;
    bvirt = Qnew - Q;
    hh = Q - (Qnew - bvirt) + (enow - bvirt);
    enow = e3[++eindex];
    Q = Qnew;
    if (hh !== 0) {
      h6[hindex++] = hh;
    }
  }
  while (findex < flen) {
    Qnew = Q + fnow;
    bvirt = Qnew - Q;
    hh = Q - (Qnew - bvirt) + (fnow - bvirt);
    fnow = f[++findex];
    Q = Qnew;
    if (hh !== 0) {
      h6[hindex++] = hh;
    }
  }
  if (Q !== 0 || hindex === 0) {
    h6[hindex++] = Q;
  }
  return hindex;
}
function estimate(elen, e3) {
  let Q = e3[0];
  for (let i = 1; i < elen; i++)
    Q += e3[i];
  return Q;
}
function vec(n) {
  return new Float64Array(n);
}

// node_modules/robust-predicates/esm/orient2d.js
var ccwerrboundA = (3 + 16 * epsilon7) * epsilon7;
var ccwerrboundB = (2 + 12 * epsilon7) * epsilon7;
var ccwerrboundC = (9 + 64 * epsilon7) * epsilon7 * epsilon7;
var B3 = vec(4);
var C1 = vec(8);
var C22 = vec(12);
var D2 = vec(16);
var u = vec(4);
function orient2dadapt(ax, ay, bx, by, cx, cy, detsum) {
  let acxtail, acytail, bcxtail, bcytail;
  let bvirt, c5, ahi, alo, bhi, blo, _i, _j, _0, s1, s0, t13, t014, u32;
  const acx = ax - cx;
  const bcx = bx - cx;
  const acy = ay - cy;
  const bcy = by - cy;
  s1 = acx * bcy;
  c5 = splitter * acx;
  ahi = c5 - (c5 - acx);
  alo = acx - ahi;
  c5 = splitter * bcy;
  bhi = c5 - (c5 - bcy);
  blo = bcy - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t13 = acy * bcx;
  c5 = splitter * acy;
  ahi = c5 - (c5 - acy);
  alo = acy - ahi;
  c5 = splitter * bcx;
  bhi = c5 - (c5 - bcx);
  blo = bcx - bhi;
  t014 = alo * blo - (t13 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t014;
  bvirt = s0 - _i;
  B3[0] = s0 - (_i + bvirt) + (bvirt - t014);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t13;
  bvirt = _0 - _i;
  B3[1] = _0 - (_i + bvirt) + (bvirt - t13);
  u32 = _j + _i;
  bvirt = u32 - _j;
  B3[2] = _j - (u32 - bvirt) + (_i - bvirt);
  B3[3] = u32;
  let det = estimate(4, B3);
  let errbound = ccwerrboundB * detsum;
  if (det >= errbound || -det >= errbound) {
    return det;
  }
  bvirt = ax - acx;
  acxtail = ax - (acx + bvirt) + (bvirt - cx);
  bvirt = bx - bcx;
  bcxtail = bx - (bcx + bvirt) + (bvirt - cx);
  bvirt = ay - acy;
  acytail = ay - (acy + bvirt) + (bvirt - cy);
  bvirt = by - bcy;
  bcytail = by - (bcy + bvirt) + (bvirt - cy);
  if (acxtail === 0 && acytail === 0 && bcxtail === 0 && bcytail === 0) {
    return det;
  }
  errbound = ccwerrboundC * detsum + resulterrbound * Math.abs(det);
  det += acx * bcytail + bcy * acxtail - (acy * bcxtail + bcx * acytail);
  if (det >= errbound || -det >= errbound)
    return det;
  s1 = acxtail * bcy;
  c5 = splitter * acxtail;
  ahi = c5 - (c5 - acxtail);
  alo = acxtail - ahi;
  c5 = splitter * bcy;
  bhi = c5 - (c5 - bcy);
  blo = bcy - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t13 = acytail * bcx;
  c5 = splitter * acytail;
  ahi = c5 - (c5 - acytail);
  alo = acytail - ahi;
  c5 = splitter * bcx;
  bhi = c5 - (c5 - bcx);
  blo = bcx - bhi;
  t014 = alo * blo - (t13 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t014;
  bvirt = s0 - _i;
  u[0] = s0 - (_i + bvirt) + (bvirt - t014);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t13;
  bvirt = _0 - _i;
  u[1] = _0 - (_i + bvirt) + (bvirt - t13);
  u32 = _j + _i;
  bvirt = u32 - _j;
  u[2] = _j - (u32 - bvirt) + (_i - bvirt);
  u[3] = u32;
  const C1len = sum3(4, B3, 4, u, C1);
  s1 = acx * bcytail;
  c5 = splitter * acx;
  ahi = c5 - (c5 - acx);
  alo = acx - ahi;
  c5 = splitter * bcytail;
  bhi = c5 - (c5 - bcytail);
  blo = bcytail - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t13 = acy * bcxtail;
  c5 = splitter * acy;
  ahi = c5 - (c5 - acy);
  alo = acy - ahi;
  c5 = splitter * bcxtail;
  bhi = c5 - (c5 - bcxtail);
  blo = bcxtail - bhi;
  t014 = alo * blo - (t13 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t014;
  bvirt = s0 - _i;
  u[0] = s0 - (_i + bvirt) + (bvirt - t014);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t13;
  bvirt = _0 - _i;
  u[1] = _0 - (_i + bvirt) + (bvirt - t13);
  u32 = _j + _i;
  bvirt = u32 - _j;
  u[2] = _j - (u32 - bvirt) + (_i - bvirt);
  u[3] = u32;
  const C2len = sum3(C1len, C1, 4, u, C22);
  s1 = acxtail * bcytail;
  c5 = splitter * acxtail;
  ahi = c5 - (c5 - acxtail);
  alo = acxtail - ahi;
  c5 = splitter * bcytail;
  bhi = c5 - (c5 - bcytail);
  blo = bcytail - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t13 = acytail * bcxtail;
  c5 = splitter * acytail;
  ahi = c5 - (c5 - acytail);
  alo = acytail - ahi;
  c5 = splitter * bcxtail;
  bhi = c5 - (c5 - bcxtail);
  blo = bcxtail - bhi;
  t014 = alo * blo - (t13 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t014;
  bvirt = s0 - _i;
  u[0] = s0 - (_i + bvirt) + (bvirt - t014);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t13;
  bvirt = _0 - _i;
  u[1] = _0 - (_i + bvirt) + (bvirt - t13);
  u32 = _j + _i;
  bvirt = u32 - _j;
  u[2] = _j - (u32 - bvirt) + (_i - bvirt);
  u[3] = u32;
  const Dlen = sum3(C2len, C22, 4, u, D2);
  return D2[Dlen - 1];
}
function orient2d(ax, ay, bx, by, cx, cy) {
  const detleft = (ay - cy) * (bx - cx);
  const detright = (ax - cx) * (by - cy);
  const det = detleft - detright;
  const detsum = Math.abs(detleft + detright);
  if (Math.abs(det) >= ccwerrboundA * detsum)
    return det;
  return -orient2dadapt(ax, ay, bx, by, cx, cy, detsum);
}

// node_modules/robust-predicates/esm/orient3d.js
var o3derrboundA = (7 + 56 * epsilon7) * epsilon7;
var o3derrboundB = (3 + 28 * epsilon7) * epsilon7;
var o3derrboundC = (26 + 288 * epsilon7) * epsilon7 * epsilon7;
var bc = vec(4);
var ca = vec(4);
var ab = vec(4);
var at_b = vec(4);
var at_c = vec(4);
var bt_c = vec(4);
var bt_a = vec(4);
var ct_a = vec(4);
var ct_b = vec(4);
var bct = vec(8);
var cat = vec(8);
var abt = vec(8);
var u2 = vec(4);
var _8 = vec(8);
var _8b = vec(8);
var _16 = vec(8);
var _12 = vec(12);
var fin = vec(192);
var fin2 = vec(192);

// node_modules/robust-predicates/esm/incircle.js
var iccerrboundA = (10 + 96 * epsilon7) * epsilon7;
var iccerrboundB = (4 + 48 * epsilon7) * epsilon7;
var iccerrboundC = (44 + 576 * epsilon7) * epsilon7 * epsilon7;
var bc2 = vec(4);
var ca2 = vec(4);
var ab2 = vec(4);
var aa = vec(4);
var bb = vec(4);
var cc = vec(4);
var u3 = vec(4);
var v = vec(4);
var axtbc = vec(8);
var aytbc = vec(8);
var bxtca = vec(8);
var bytca = vec(8);
var cxtab = vec(8);
var cytab = vec(8);
var abt2 = vec(8);
var bct2 = vec(8);
var cat2 = vec(8);
var abtt = vec(4);
var bctt = vec(4);
var catt = vec(4);
var _82 = vec(8);
var _162 = vec(16);
var _16b = vec(16);
var _16c = vec(16);
var _32 = vec(32);
var _32b = vec(32);
var _48 = vec(48);
var _64 = vec(64);
var fin3 = vec(1152);
var fin22 = vec(1152);

// node_modules/robust-predicates/esm/insphere.js
var isperrboundA = (16 + 224 * epsilon7) * epsilon7;
var isperrboundB = (5 + 72 * epsilon7) * epsilon7;
var isperrboundC = (71 + 1408 * epsilon7) * epsilon7 * epsilon7;
var ab3 = vec(4);
var bc3 = vec(4);
var cd = vec(4);
var de = vec(4);
var ea3 = vec(4);
var ac = vec(4);
var bd = vec(4);
var ce = vec(4);
var da = vec(4);
var eb = vec(4);
var abc = vec(24);
var bcd = vec(24);
var cde = vec(24);
var dea = vec(24);
var eab = vec(24);
var abd = vec(24);
var bce = vec(24);
var cda = vec(24);
var deb = vec(24);
var eac = vec(24);
var adet = vec(1152);
var bdet = vec(1152);
var cdet = vec(1152);
var ddet = vec(1152);
var edet = vec(1152);
var abdet = vec(2304);
var cddet = vec(2304);
var cdedet = vec(3456);
var deter = vec(5760);
var _83 = vec(8);
var _8b2 = vec(8);
var _8c = vec(8);
var _163 = vec(16);
var _24 = vec(24);
var _482 = vec(48);
var _48b = vec(48);
var _96 = vec(96);
var _192 = vec(192);
var _384x = vec(384);
var _384y = vec(384);
var _384z = vec(384);
var _768 = vec(768);
var xdet = vec(96);
var ydet = vec(96);
var zdet = vec(96);
var fin4 = vec(1152);

// node_modules/delaunator/index.js
var EPSILON2 = Math.pow(2, -52);
var EDGE_STACK = new Uint32Array(512);
var Delaunator = class _Delaunator {
  static from(points2, getX = defaultGetX, getY = defaultGetY) {
    const n = points2.length;
    const coords = new Float64Array(n * 2);
    for (let i = 0; i < n; i++) {
      const p = points2[i];
      coords[2 * i] = getX(p);
      coords[2 * i + 1] = getY(p);
    }
    return new _Delaunator(coords);
  }
  constructor(coords) {
    const n = coords.length >> 1;
    if (n > 0 && typeof coords[0] !== "number")
      throw new Error("Expected coords to contain numbers.");
    this.coords = coords;
    const maxTriangles = Math.max(2 * n - 5, 0);
    this._triangles = new Uint32Array(maxTriangles * 3);
    this._halfedges = new Int32Array(maxTriangles * 3);
    this._hashSize = Math.ceil(Math.sqrt(n));
    this._hullPrev = new Uint32Array(n);
    this._hullNext = new Uint32Array(n);
    this._hullTri = new Uint32Array(n);
    this._hullHash = new Int32Array(this._hashSize);
    this._ids = new Uint32Array(n);
    this._dists = new Float64Array(n);
    this.update();
  }
  update() {
    const { coords, _hullPrev: hullPrev, _hullNext: hullNext, _hullTri: hullTri, _hullHash: hullHash } = this;
    const n = coords.length >> 1;
    let minX = Infinity;
    let minY = Infinity;
    let maxX = -Infinity;
    let maxY2 = -Infinity;
    for (let i = 0; i < n; i++) {
      const x9 = coords[2 * i];
      const y9 = coords[2 * i + 1];
      if (x9 < minX)
        minX = x9;
      if (y9 < minY)
        minY = y9;
      if (x9 > maxX)
        maxX = x9;
      if (y9 > maxY2)
        maxY2 = y9;
      this._ids[i] = i;
    }
    const cx = (minX + maxX) / 2;
    const cy = (minY + maxY2) / 2;
    let i0, i1, i2;
    for (let i = 0, minDist = Infinity; i < n; i++) {
      const d = dist(cx, cy, coords[2 * i], coords[2 * i + 1]);
      if (d < minDist) {
        i0 = i;
        minDist = d;
      }
    }
    const i0x = coords[2 * i0];
    const i0y = coords[2 * i0 + 1];
    for (let i = 0, minDist = Infinity; i < n; i++) {
      if (i === i0)
        continue;
      const d = dist(i0x, i0y, coords[2 * i], coords[2 * i + 1]);
      if (d < minDist && d > 0) {
        i1 = i;
        minDist = d;
      }
    }
    let i1x = coords[2 * i1];
    let i1y = coords[2 * i1 + 1];
    let minRadius = Infinity;
    for (let i = 0; i < n; i++) {
      if (i === i0 || i === i1)
        continue;
      const r = circumradius(i0x, i0y, i1x, i1y, coords[2 * i], coords[2 * i + 1]);
      if (r < minRadius) {
        i2 = i;
        minRadius = r;
      }
    }
    let i2x = coords[2 * i2];
    let i2y = coords[2 * i2 + 1];
    if (minRadius === Infinity) {
      for (let i = 0; i < n; i++) {
        this._dists[i] = coords[2 * i] - coords[0] || coords[2 * i + 1] - coords[1];
      }
      quicksort(this._ids, this._dists, 0, n - 1);
      const hull = new Uint32Array(n);
      let j = 0;
      for (let i = 0, d0 = -Infinity; i < n; i++) {
        const id24 = this._ids[i];
        const d = this._dists[id24];
        if (d > d0) {
          hull[j++] = id24;
          d0 = d;
        }
      }
      this.hull = hull.subarray(0, j);
      this.triangles = new Uint32Array(0);
      this.halfedges = new Uint32Array(0);
      return;
    }
    if (orient2d(i0x, i0y, i1x, i1y, i2x, i2y) < 0) {
      const i = i1;
      const x9 = i1x;
      const y9 = i1y;
      i1 = i2;
      i1x = i2x;
      i1y = i2y;
      i2 = i;
      i2x = x9;
      i2y = y9;
    }
    const center = circumcenter(i0x, i0y, i1x, i1y, i2x, i2y);
    this._cx = center.x;
    this._cy = center.y;
    for (let i = 0; i < n; i++) {
      this._dists[i] = dist(coords[2 * i], coords[2 * i + 1], center.x, center.y);
    }
    quicksort(this._ids, this._dists, 0, n - 1);
    this._hullStart = i0;
    let hullSize = 3;
    hullNext[i0] = hullPrev[i2] = i1;
    hullNext[i1] = hullPrev[i0] = i2;
    hullNext[i2] = hullPrev[i1] = i0;
    hullTri[i0] = 0;
    hullTri[i1] = 1;
    hullTri[i2] = 2;
    hullHash.fill(-1);
    hullHash[this._hashKey(i0x, i0y)] = i0;
    hullHash[this._hashKey(i1x, i1y)] = i1;
    hullHash[this._hashKey(i2x, i2y)] = i2;
    this.trianglesLen = 0;
    this._addTriangle(i0, i1, i2, -1, -1, -1);
    for (let k3 = 0, xp, yp; k3 < this._ids.length; k3++) {
      const i = this._ids[k3];
      const x9 = coords[2 * i];
      const y9 = coords[2 * i + 1];
      if (k3 > 0 && Math.abs(x9 - xp) <= EPSILON2 && Math.abs(y9 - yp) <= EPSILON2)
        continue;
      xp = x9;
      yp = y9;
      if (i === i0 || i === i1 || i === i2)
        continue;
      let start = 0;
      for (let j = 0, key4 = this._hashKey(x9, y9); j < this._hashSize; j++) {
        start = hullHash[(key4 + j) % this._hashSize];
        if (start !== -1 && start !== hullNext[start])
          break;
      }
      start = hullPrev[start];
      let e3 = start, q;
      while (q = hullNext[e3], orient2d(x9, y9, coords[2 * e3], coords[2 * e3 + 1], coords[2 * q], coords[2 * q + 1]) >= 0) {
        e3 = q;
        if (e3 === start) {
          e3 = -1;
          break;
        }
      }
      if (e3 === -1)
        continue;
      let t = this._addTriangle(e3, i, hullNext[e3], -1, -1, hullTri[e3]);
      hullTri[i] = this._legalize(t + 2);
      hullTri[e3] = t;
      hullSize++;
      let n2 = hullNext[e3];
      while (q = hullNext[n2], orient2d(x9, y9, coords[2 * n2], coords[2 * n2 + 1], coords[2 * q], coords[2 * q + 1]) < 0) {
        t = this._addTriangle(n2, i, q, hullTri[i], -1, hullTri[n2]);
        hullTri[i] = this._legalize(t + 2);
        hullNext[n2] = n2;
        hullSize--;
        n2 = q;
      }
      if (e3 === start) {
        while (q = hullPrev[e3], orient2d(x9, y9, coords[2 * q], coords[2 * q + 1], coords[2 * e3], coords[2 * e3 + 1]) < 0) {
          t = this._addTriangle(q, i, e3, -1, hullTri[e3], hullTri[q]);
          this._legalize(t + 2);
          hullTri[q] = t;
          hullNext[e3] = e3;
          hullSize--;
          e3 = q;
        }
      }
      this._hullStart = hullPrev[i] = e3;
      hullNext[e3] = hullPrev[n2] = i;
      hullNext[i] = n2;
      hullHash[this._hashKey(x9, y9)] = i;
      hullHash[this._hashKey(coords[2 * e3], coords[2 * e3 + 1])] = e3;
    }
    this.hull = new Uint32Array(hullSize);
    for (let i = 0, e3 = this._hullStart; i < hullSize; i++) {
      this.hull[i] = e3;
      e3 = hullNext[e3];
    }
    this.triangles = this._triangles.subarray(0, this.trianglesLen);
    this.halfedges = this._halfedges.subarray(0, this.trianglesLen);
  }
  _hashKey(x9, y9) {
    return Math.floor(pseudoAngle(x9 - this._cx, y9 - this._cy) * this._hashSize) % this._hashSize;
  }
  _legalize(a4) {
    const { _triangles: triangles, _halfedges: halfedges, coords } = this;
    let i = 0;
    let ar = 0;
    while (true) {
      const b6 = halfedges[a4];
      const a0 = a4 - a4 % 3;
      ar = a0 + (a4 + 2) % 3;
      if (b6 === -1) {
        if (i === 0)
          break;
        a4 = EDGE_STACK[--i];
        continue;
      }
      const b0 = b6 - b6 % 3;
      const al = a0 + (a4 + 1) % 3;
      const bl6 = b0 + (b6 + 2) % 3;
      const p02 = triangles[ar];
      const pr = triangles[a4];
      const pl = triangles[al];
      const p1 = triangles[bl6];
      const illegal = inCircle(
        coords[2 * p02],
        coords[2 * p02 + 1],
        coords[2 * pr],
        coords[2 * pr + 1],
        coords[2 * pl],
        coords[2 * pl + 1],
        coords[2 * p1],
        coords[2 * p1 + 1]
      );
      if (illegal) {
        triangles[a4] = p1;
        triangles[b6] = p02;
        const hbl = halfedges[bl6];
        if (hbl === -1) {
          let e3 = this._hullStart;
          do {
            if (this._hullTri[e3] === bl6) {
              this._hullTri[e3] = a4;
              break;
            }
            e3 = this._hullPrev[e3];
          } while (e3 !== this._hullStart);
        }
        this._link(a4, hbl);
        this._link(b6, halfedges[ar]);
        this._link(ar, bl6);
        const br6 = b0 + (b6 + 1) % 3;
        if (i < EDGE_STACK.length) {
          EDGE_STACK[i++] = br6;
        }
      } else {
        if (i === 0)
          break;
        a4 = EDGE_STACK[--i];
      }
    }
    return ar;
  }
  _link(a4, b6) {
    this._halfedges[a4] = b6;
    if (b6 !== -1)
      this._halfedges[b6] = a4;
  }
  // add a new triangle given vertex indices and adjacent half-edge ids
  _addTriangle(i0, i1, i2, a4, b6, c5) {
    const t = this.trianglesLen;
    this._triangles[t] = i0;
    this._triangles[t + 1] = i1;
    this._triangles[t + 2] = i2;
    this._link(t, a4);
    this._link(t + 1, b6);
    this._link(t + 2, c5);
    this.trianglesLen += 3;
    return t;
  }
};
function pseudoAngle(dx, dy) {
  const p = dx / (Math.abs(dx) + Math.abs(dy));
  return (dy > 0 ? 3 - p : 1 + p) / 4;
}
function dist(ax, ay, bx, by) {
  const dx = ax - bx;
  const dy = ay - by;
  return dx * dx + dy * dy;
}
function inCircle(ax, ay, bx, by, cx, cy, px6, py6) {
  const dx = ax - px6;
  const dy = ay - py6;
  const ex = bx - px6;
  const ey = by - py6;
  const fx = cx - px6;
  const fy = cy - py6;
  const ap = dx * dx + dy * dy;
  const bp = ex * ex + ey * ey;
  const cp = fx * fx + fy * fy;
  return dx * (ey * cp - bp * fy) - dy * (ex * cp - bp * fx) + ap * (ex * fy - ey * fx) < 0;
}
function circumradius(ax, ay, bx, by, cx, cy) {
  const dx = bx - ax;
  const dy = by - ay;
  const ex = cx - ax;
  const ey = cy - ay;
  const bl6 = dx * dx + dy * dy;
  const cl = ex * ex + ey * ey;
  const d = 0.5 / (dx * ey - dy * ex);
  const x9 = (ey * bl6 - dy * cl) * d;
  const y9 = (dx * cl - ex * bl6) * d;
  return x9 * x9 + y9 * y9;
}
function circumcenter(ax, ay, bx, by, cx, cy) {
  const dx = bx - ax;
  const dy = by - ay;
  const ex = cx - ax;
  const ey = cy - ay;
  const bl6 = dx * dx + dy * dy;
  const cl = ex * ex + ey * ey;
  const d = 0.5 / (dx * ey - dy * ex);
  const x9 = ax + (ey * bl6 - dy * cl) * d;
  const y9 = ay + (dx * cl - ex * bl6) * d;
  return { x: x9, y: y9 };
}
function quicksort(ids, dists, left, right) {
  if (right - left <= 20) {
    for (let i = left + 1; i <= right; i++) {
      const temp6 = ids[i];
      const tempDist = dists[temp6];
      let j = i - 1;
      while (j >= left && dists[ids[j]] > tempDist)
        ids[j + 1] = ids[j--];
      ids[j + 1] = temp6;
    }
  } else {
    const median2 = left + right >> 1;
    let i = left + 1;
    let j = right;
    swap2(ids, median2, i);
    if (dists[ids[left]] > dists[ids[right]])
      swap2(ids, left, right);
    if (dists[ids[i]] > dists[ids[right]])
      swap2(ids, i, right);
    if (dists[ids[left]] > dists[ids[i]])
      swap2(ids, left, i);
    const temp6 = ids[i];
    const tempDist = dists[temp6];
    while (true) {
      do
        i++;
      while (dists[ids[i]] < tempDist);
      do
        j--;
      while (dists[ids[j]] > tempDist);
      if (j < i)
        break;
      swap2(ids, i, j);
    }
    ids[left + 1] = ids[j];
    ids[j] = temp6;
    if (right - i + 1 >= j - left) {
      quicksort(ids, dists, i, right);
      quicksort(ids, dists, left, j - 1);
    } else {
      quicksort(ids, dists, left, j - 1);
      quicksort(ids, dists, i, right);
    }
  }
}
function swap2(arr, i, j) {
  const tmp = arr[i];
  arr[i] = arr[j];
  arr[j] = tmp;
}
function defaultGetX(p) {
  return p[0];
}
function defaultGetY(p) {
  return p[1];
}

// node_modules/d3-delaunay/src/path.js
var epsilon8 = 1e-6;
var Path2 = class {
  constructor() {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null;
    this._ = "";
  }
  moveTo(x9, y9) {
    this._ += `M${this._x0 = this._x1 = +x9},${this._y0 = this._y1 = +y9}`;
  }
  closePath() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._ += "Z";
    }
  }
  lineTo(x9, y9) {
    this._ += `L${this._x1 = +x9},${this._y1 = +y9}`;
  }
  arc(x9, y9, r) {
    x9 = +x9, y9 = +y9, r = +r;
    const x07 = x9 + r;
    const y07 = y9;
    if (r < 0)
      throw new Error("negative radius");
    if (this._x1 === null)
      this._ += `M${x07},${y07}`;
    else if (Math.abs(this._x1 - x07) > epsilon8 || Math.abs(this._y1 - y07) > epsilon8)
      this._ += "L" + x07 + "," + y07;
    if (!r)
      return;
    this._ += `A${r},${r},0,1,1,${x9 - r},${y9}A${r},${r},0,1,1,${this._x1 = x07},${this._y1 = y07}`;
  }
  rect(x9, y9, w8, h6) {
    this._ += `M${this._x0 = this._x1 = +x9},${this._y0 = this._y1 = +y9}h${+w8}v${+h6}h${-w8}Z`;
  }
  value() {
    return this._ || null;
  }
};

// node_modules/d3-delaunay/src/polygon.js
var Polygon = class {
  constructor() {
    this._ = [];
  }
  moveTo(x9, y9) {
    this._.push([x9, y9]);
  }
  closePath() {
    this._.push(this._[0].slice());
  }
  lineTo(x9, y9) {
    this._.push([x9, y9]);
  }
  value() {
    return this._.length ? this._ : null;
  }
};

// node_modules/d3-delaunay/src/voronoi.js
var Voronoi = class {
  constructor(delaunay, [xmin, ymin, xmax, ymax] = [0, 0, 960, 500]) {
    if (!((xmax = +xmax) >= (xmin = +xmin)) || !((ymax = +ymax) >= (ymin = +ymin)))
      throw new Error("invalid bounds");
    this.delaunay = delaunay;
    this._circumcenters = new Float64Array(delaunay.points.length * 2);
    this.vectors = new Float64Array(delaunay.points.length * 2);
    this.xmax = xmax, this.xmin = xmin;
    this.ymax = ymax, this.ymin = ymin;
    this._init();
  }
  update() {
    this.delaunay.update();
    this._init();
    return this;
  }
  _init() {
    const { delaunay: { points: points2, hull, triangles }, vectors } = this;
    let bx, by;
    const circumcenters = this.circumcenters = this._circumcenters.subarray(0, triangles.length / 3 * 2);
    for (let i = 0, j = 0, n = triangles.length, x9, y9; i < n; i += 3, j += 2) {
      const t13 = triangles[i] * 2;
      const t22 = triangles[i + 1] * 2;
      const t32 = triangles[i + 2] * 2;
      const x14 = points2[t13];
      const y14 = points2[t13 + 1];
      const x22 = points2[t22];
      const y22 = points2[t22 + 1];
      const x32 = points2[t32];
      const y32 = points2[t32 + 1];
      const dx = x22 - x14;
      const dy = y22 - y14;
      const ex = x32 - x14;
      const ey = y32 - y14;
      const ab4 = (dx * ey - dy * ex) * 2;
      if (Math.abs(ab4) < 1e-9) {
        if (bx === void 0) {
          bx = by = 0;
          for (const i2 of hull)
            bx += points2[i2 * 2], by += points2[i2 * 2 + 1];
          bx /= hull.length, by /= hull.length;
        }
        const a4 = 1e9 * Math.sign((bx - x14) * ey - (by - y14) * ex);
        x9 = (x14 + x32) / 2 - a4 * ey;
        y9 = (y14 + y32) / 2 + a4 * ex;
      } else {
        const d = 1 / ab4;
        const bl6 = dx * dx + dy * dy;
        const cl = ex * ex + ey * ey;
        x9 = x14 + (ey * bl6 - dy * cl) * d;
        y9 = y14 + (dx * cl - ex * bl6) * d;
      }
      circumcenters[j] = x9;
      circumcenters[j + 1] = y9;
    }
    let h6 = hull[hull.length - 1];
    let p02, p1 = h6 * 4;
    let x07, x13 = points2[2 * h6];
    let y07, y13 = points2[2 * h6 + 1];
    vectors.fill(0);
    for (let i = 0; i < hull.length; ++i) {
      h6 = hull[i];
      p02 = p1, x07 = x13, y07 = y13;
      p1 = h6 * 4, x13 = points2[2 * h6], y13 = points2[2 * h6 + 1];
      vectors[p02 + 2] = vectors[p1] = y07 - y13;
      vectors[p02 + 3] = vectors[p1 + 1] = x13 - x07;
    }
  }
  render(context7) {
    const buffer = context7 == null ? context7 = new Path2() : void 0;
    const { delaunay: { halfedges, inedges, hull }, circumcenters, vectors } = this;
    if (hull.length <= 1)
      return null;
    for (let i = 0, n = halfedges.length; i < n; ++i) {
      const j = halfedges[i];
      if (j < i)
        continue;
      const ti = Math.floor(i / 3) * 2;
      const tj = Math.floor(j / 3) * 2;
      const xi = circumcenters[ti];
      const yi = circumcenters[ti + 1];
      const xj = circumcenters[tj];
      const yj = circumcenters[tj + 1];
      this._renderSegment(xi, yi, xj, yj, context7);
    }
    let h0, h1 = hull[hull.length - 1];
    for (let i = 0; i < hull.length; ++i) {
      h0 = h1, h1 = hull[i];
      const t = Math.floor(inedges[h1] / 3) * 2;
      const x9 = circumcenters[t];
      const y9 = circumcenters[t + 1];
      const v2 = h0 * 4;
      const p = this._project(x9, y9, vectors[v2 + 2], vectors[v2 + 3]);
      if (p)
        this._renderSegment(x9, y9, p[0], p[1], context7);
    }
    return buffer && buffer.value();
  }
  renderBounds(context7) {
    const buffer = context7 == null ? context7 = new Path2() : void 0;
    context7.rect(this.xmin, this.ymin, this.xmax - this.xmin, this.ymax - this.ymin);
    return buffer && buffer.value();
  }
  renderCell(i, context7) {
    const buffer = context7 == null ? context7 = new Path2() : void 0;
    const points2 = this._clip(i);
    if (points2 === null || !points2.length)
      return;
    context7.moveTo(points2[0], points2[1]);
    let n = points2.length;
    while (points2[0] === points2[n - 2] && points2[1] === points2[n - 1] && n > 1)
      n -= 2;
    for (let i2 = 2; i2 < n; i2 += 2) {
      if (points2[i2] !== points2[i2 - 2] || points2[i2 + 1] !== points2[i2 - 1])
        context7.lineTo(points2[i2], points2[i2 + 1]);
    }
    context7.closePath();
    return buffer && buffer.value();
  }
  *cellPolygons() {
    const { delaunay: { points: points2 } } = this;
    for (let i = 0, n = points2.length / 2; i < n; ++i) {
      const cell2 = this.cellPolygon(i);
      if (cell2)
        cell2.index = i, yield cell2;
    }
  }
  cellPolygon(i) {
    const polygon = new Polygon();
    this.renderCell(i, polygon);
    return polygon.value();
  }
  _renderSegment(x07, y07, x13, y13, context7) {
    let S;
    const c0 = this._regioncode(x07, y07);
    const c1 = this._regioncode(x13, y13);
    if (c0 === 0 && c1 === 0) {
      context7.moveTo(x07, y07);
      context7.lineTo(x13, y13);
    } else if (S = this._clipSegment(x07, y07, x13, y13, c0, c1)) {
      context7.moveTo(S[0], S[1]);
      context7.lineTo(S[2], S[3]);
    }
  }
  contains(i, x9, y9) {
    if ((x9 = +x9, x9 !== x9) || (y9 = +y9, y9 !== y9))
      return false;
    return this.delaunay._step(i, x9, y9) === i;
  }
  *neighbors(i) {
    const ci = this._clip(i);
    if (ci)
      for (const j of this.delaunay.neighbors(i)) {
        const cj = this._clip(j);
        if (cj)
          loop:
            for (let ai = 0, li = ci.length; ai < li; ai += 2) {
              for (let aj = 0, lj = cj.length; aj < lj; aj += 2) {
                if (ci[ai] === cj[aj] && ci[ai + 1] === cj[aj + 1] && ci[(ai + 2) % li] === cj[(aj + lj - 2) % lj] && ci[(ai + 3) % li] === cj[(aj + lj - 1) % lj]) {
                  yield j;
                  break loop;
                }
              }
            }
      }
  }
  _cell(i) {
    const { circumcenters, delaunay: { inedges, halfedges, triangles } } = this;
    const e0 = inedges[i];
    if (e0 === -1)
      return null;
    const points2 = [];
    let e3 = e0;
    do {
      const t = Math.floor(e3 / 3);
      points2.push(circumcenters[t * 2], circumcenters[t * 2 + 1]);
      e3 = e3 % 3 === 2 ? e3 - 2 : e3 + 1;
      if (triangles[e3] !== i)
        break;
      e3 = halfedges[e3];
    } while (e3 !== e0 && e3 !== -1);
    return points2;
  }
  _clip(i) {
    if (i === 0 && this.delaunay.hull.length === 1) {
      return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
    }
    const points2 = this._cell(i);
    if (points2 === null)
      return null;
    const { vectors: V } = this;
    const v2 = i * 4;
    return this._simplify(V[v2] || V[v2 + 1] ? this._clipInfinite(i, points2, V[v2], V[v2 + 1], V[v2 + 2], V[v2 + 3]) : this._clipFinite(i, points2));
  }
  _clipFinite(i, points2) {
    const n = points2.length;
    let P = null;
    let x07, y07, x13 = points2[n - 2], y13 = points2[n - 1];
    let c0, c1 = this._regioncode(x13, y13);
    let e0, e1 = 0;
    for (let j = 0; j < n; j += 2) {
      x07 = x13, y07 = y13, x13 = points2[j], y13 = points2[j + 1];
      c0 = c1, c1 = this._regioncode(x13, y13);
      if (c0 === 0 && c1 === 0) {
        e0 = e1, e1 = 0;
        if (P)
          P.push(x13, y13);
        else
          P = [x13, y13];
      } else {
        let S, sx0, sy0, sx1, sy1;
        if (c0 === 0) {
          if ((S = this._clipSegment(x07, y07, x13, y13, c0, c1)) === null)
            continue;
          [sx0, sy0, sx1, sy1] = S;
        } else {
          if ((S = this._clipSegment(x13, y13, x07, y07, c1, c0)) === null)
            continue;
          [sx1, sy1, sx0, sy0] = S;
          e0 = e1, e1 = this._edgecode(sx0, sy0);
          if (e0 && e1)
            this._edge(i, e0, e1, P, P.length);
          if (P)
            P.push(sx0, sy0);
          else
            P = [sx0, sy0];
        }
        e0 = e1, e1 = this._edgecode(sx1, sy1);
        if (e0 && e1)
          this._edge(i, e0, e1, P, P.length);
        if (P)
          P.push(sx1, sy1);
        else
          P = [sx1, sy1];
      }
    }
    if (P) {
      e0 = e1, e1 = this._edgecode(P[0], P[1]);
      if (e0 && e1)
        this._edge(i, e0, e1, P, P.length);
    } else if (this.contains(i, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) {
      return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
    }
    return P;
  }
  _clipSegment(x07, y07, x13, y13, c0, c1) {
    const flip2 = c0 < c1;
    if (flip2)
      [x07, y07, x13, y13, c0, c1] = [x13, y13, x07, y07, c1, c0];
    while (true) {
      if (c0 === 0 && c1 === 0)
        return flip2 ? [x13, y13, x07, y07] : [x07, y07, x13, y13];
      if (c0 & c1)
        return null;
      let x9, y9, c5 = c0 || c1;
      if (c5 & 8)
        x9 = x07 + (x13 - x07) * (this.ymax - y07) / (y13 - y07), y9 = this.ymax;
      else if (c5 & 4)
        x9 = x07 + (x13 - x07) * (this.ymin - y07) / (y13 - y07), y9 = this.ymin;
      else if (c5 & 2)
        y9 = y07 + (y13 - y07) * (this.xmax - x07) / (x13 - x07), x9 = this.xmax;
      else
        y9 = y07 + (y13 - y07) * (this.xmin - x07) / (x13 - x07), x9 = this.xmin;
      if (c0)
        x07 = x9, y07 = y9, c0 = this._regioncode(x07, y07);
      else
        x13 = x9, y13 = y9, c1 = this._regioncode(x13, y13);
    }
  }
  _clipInfinite(i, points2, vx0, vy0, vxn, vyn) {
    let P = Array.from(points2), p;
    if (p = this._project(P[0], P[1], vx0, vy0))
      P.unshift(p[0], p[1]);
    if (p = this._project(P[P.length - 2], P[P.length - 1], vxn, vyn))
      P.push(p[0], p[1]);
    if (P = this._clipFinite(i, P)) {
      for (let j = 0, n = P.length, c0, c1 = this._edgecode(P[n - 2], P[n - 1]); j < n; j += 2) {
        c0 = c1, c1 = this._edgecode(P[j], P[j + 1]);
        if (c0 && c1)
          j = this._edge(i, c0, c1, P, j), n = P.length;
      }
    } else if (this.contains(i, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) {
      P = [this.xmin, this.ymin, this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax];
    }
    return P;
  }
  _edge(i, e0, e1, P, j) {
    while (e0 !== e1) {
      let x9, y9;
      switch (e0) {
        case 5:
          e0 = 4;
          continue;
        case 4:
          e0 = 6, x9 = this.xmax, y9 = this.ymin;
          break;
        case 6:
          e0 = 2;
          continue;
        case 2:
          e0 = 10, x9 = this.xmax, y9 = this.ymax;
          break;
        case 10:
          e0 = 8;
          continue;
        case 8:
          e0 = 9, x9 = this.xmin, y9 = this.ymax;
          break;
        case 9:
          e0 = 1;
          continue;
        case 1:
          e0 = 5, x9 = this.xmin, y9 = this.ymin;
          break;
      }
      if ((P[j] !== x9 || P[j + 1] !== y9) && this.contains(i, x9, y9)) {
        P.splice(j, 0, x9, y9), j += 2;
      }
    }
    return j;
  }
  _project(x07, y07, vx, vy) {
    let t = Infinity, c5, x9, y9;
    if (vy < 0) {
      if (y07 <= this.ymin)
        return null;
      if ((c5 = (this.ymin - y07) / vy) < t)
        y9 = this.ymin, x9 = x07 + (t = c5) * vx;
    } else if (vy > 0) {
      if (y07 >= this.ymax)
        return null;
      if ((c5 = (this.ymax - y07) / vy) < t)
        y9 = this.ymax, x9 = x07 + (t = c5) * vx;
    }
    if (vx > 0) {
      if (x07 >= this.xmax)
        return null;
      if ((c5 = (this.xmax - x07) / vx) < t)
        x9 = this.xmax, y9 = y07 + (t = c5) * vy;
    } else if (vx < 0) {
      if (x07 <= this.xmin)
        return null;
      if ((c5 = (this.xmin - x07) / vx) < t)
        x9 = this.xmin, y9 = y07 + (t = c5) * vy;
    }
    return [x9, y9];
  }
  _edgecode(x9, y9) {
    return (x9 === this.xmin ? 1 : x9 === this.xmax ? 2 : 0) | (y9 === this.ymin ? 4 : y9 === this.ymax ? 8 : 0);
  }
  _regioncode(x9, y9) {
    return (x9 < this.xmin ? 1 : x9 > this.xmax ? 2 : 0) | (y9 < this.ymin ? 4 : y9 > this.ymax ? 8 : 0);
  }
  _simplify(P) {
    if (P && P.length > 4) {
      for (let i = 0; i < P.length; i += 2) {
        const j = (i + 2) % P.length, k3 = (i + 4) % P.length;
        if (P[i] === P[j] && P[j] === P[k3] || P[i + 1] === P[j + 1] && P[j + 1] === P[k3 + 1]) {
          P.splice(j, 2), i -= 2;
        }
      }
      if (!P.length)
        P = null;
    }
    return P;
  }
};

// node_modules/d3-delaunay/src/delaunay.js
var tau5 = 2 * Math.PI;
var pow7 = Math.pow;
function pointX(p) {
  return p[0];
}
function pointY(p) {
  return p[1];
}
function collinear2(d) {
  const { triangles, coords } = d;
  for (let i = 0; i < triangles.length; i += 3) {
    const a4 = 2 * triangles[i], b6 = 2 * triangles[i + 1], c5 = 2 * triangles[i + 2], cross3 = (coords[c5] - coords[a4]) * (coords[b6 + 1] - coords[a4 + 1]) - (coords[b6] - coords[a4]) * (coords[c5 + 1] - coords[a4 + 1]);
    if (cross3 > 1e-10)
      return false;
  }
  return true;
}
function jitter(x9, y9, r) {
  return [x9 + Math.sin(x9 + y9) * r, y9 + Math.cos(x9 - y9) * r];
}
var Delaunay = class _Delaunay {
  static from(points2, fx = pointX, fy = pointY, that) {
    return new _Delaunay("length" in points2 ? flatArray(points2, fx, fy, that) : Float64Array.from(flatIterable(points2, fx, fy, that)));
  }
  constructor(points2) {
    this._delaunator = new Delaunator(points2);
    this.inedges = new Int32Array(points2.length / 2);
    this._hullIndex = new Int32Array(points2.length / 2);
    this.points = this._delaunator.coords;
    this._init();
  }
  update() {
    this._delaunator.update();
    this._init();
    return this;
  }
  _init() {
    const d = this._delaunator, points2 = this.points;
    if (d.hull && d.hull.length > 2 && collinear2(d)) {
      this.collinear = Int32Array.from({ length: points2.length / 2 }, (_, i) => i).sort((i, j) => points2[2 * i] - points2[2 * j] || points2[2 * i + 1] - points2[2 * j + 1]);
      const e3 = this.collinear[0], f = this.collinear[this.collinear.length - 1], bounds6 = [points2[2 * e3], points2[2 * e3 + 1], points2[2 * f], points2[2 * f + 1]], r = 1e-8 * Math.hypot(bounds6[3] - bounds6[1], bounds6[2] - bounds6[0]);
      for (let i = 0, n = points2.length / 2; i < n; ++i) {
        const p = jitter(points2[2 * i], points2[2 * i + 1], r);
        points2[2 * i] = p[0];
        points2[2 * i + 1] = p[1];
      }
      this._delaunator = new Delaunator(points2);
    } else {
      delete this.collinear;
    }
    const halfedges = this.halfedges = this._delaunator.halfedges;
    const hull = this.hull = this._delaunator.hull;
    const triangles = this.triangles = this._delaunator.triangles;
    const inedges = this.inedges.fill(-1);
    const hullIndex = this._hullIndex.fill(-1);
    for (let e3 = 0, n = halfedges.length; e3 < n; ++e3) {
      const p = triangles[e3 % 3 === 2 ? e3 - 2 : e3 + 1];
      if (halfedges[e3] === -1 || inedges[p] === -1)
        inedges[p] = e3;
    }
    for (let i = 0, n = hull.length; i < n; ++i) {
      hullIndex[hull[i]] = i;
    }
    if (hull.length <= 2 && hull.length > 0) {
      this.triangles = new Int32Array(3).fill(-1);
      this.halfedges = new Int32Array(3).fill(-1);
      this.triangles[0] = hull[0];
      inedges[hull[0]] = 1;
      if (hull.length === 2) {
        inedges[hull[1]] = 0;
        this.triangles[1] = hull[1];
        this.triangles[2] = hull[1];
      }
    }
  }
  voronoi(bounds6) {
    return new Voronoi(this, bounds6);
  }
  *neighbors(i) {
    const { inedges, hull, _hullIndex, halfedges, triangles, collinear: collinear3 } = this;
    if (collinear3) {
      const l = collinear3.indexOf(i);
      if (l > 0)
        yield collinear3[l - 1];
      if (l < collinear3.length - 1)
        yield collinear3[l + 1];
      return;
    }
    const e0 = inedges[i];
    if (e0 === -1)
      return;
    let e3 = e0, p02 = -1;
    do {
      yield p02 = triangles[e3];
      e3 = e3 % 3 === 2 ? e3 - 2 : e3 + 1;
      if (triangles[e3] !== i)
        return;
      e3 = halfedges[e3];
      if (e3 === -1) {
        const p = hull[(_hullIndex[i] + 1) % hull.length];
        if (p !== p02)
          yield p;
        return;
      }
    } while (e3 !== e0);
  }
  find(x9, y9, i = 0) {
    if ((x9 = +x9, x9 !== x9) || (y9 = +y9, y9 !== y9))
      return -1;
    const i0 = i;
    let c5;
    while ((c5 = this._step(i, x9, y9)) >= 0 && c5 !== i && c5 !== i0)
      i = c5;
    return c5;
  }
  _step(i, x9, y9) {
    const { inedges, hull, _hullIndex, halfedges, triangles, points: points2 } = this;
    if (inedges[i] === -1 || !points2.length)
      return (i + 1) % (points2.length >> 1);
    let c5 = i;
    let dc = pow7(x9 - points2[i * 2], 2) + pow7(y9 - points2[i * 2 + 1], 2);
    const e0 = inedges[i];
    let e3 = e0;
    do {
      let t = triangles[e3];
      const dt = pow7(x9 - points2[t * 2], 2) + pow7(y9 - points2[t * 2 + 1], 2);
      if (dt < dc)
        dc = dt, c5 = t;
      e3 = e3 % 3 === 2 ? e3 - 2 : e3 + 1;
      if (triangles[e3] !== i)
        break;
      e3 = halfedges[e3];
      if (e3 === -1) {
        e3 = hull[(_hullIndex[i] + 1) % hull.length];
        if (e3 !== t) {
          if (pow7(x9 - points2[e3 * 2], 2) + pow7(y9 - points2[e3 * 2 + 1], 2) < dc)
            return e3;
        }
        break;
      }
    } while (e3 !== e0);
    return c5;
  }
  render(context7) {
    const buffer = context7 == null ? context7 = new Path2() : void 0;
    const { points: points2, halfedges, triangles } = this;
    for (let i = 0, n = halfedges.length; i < n; ++i) {
      const j = halfedges[i];
      if (j < i)
        continue;
      const ti = triangles[i] * 2;
      const tj = triangles[j] * 2;
      context7.moveTo(points2[ti], points2[ti + 1]);
      context7.lineTo(points2[tj], points2[tj + 1]);
    }
    this.renderHull(context7);
    return buffer && buffer.value();
  }
  renderPoints(context7, r) {
    if (r === void 0 && (!context7 || typeof context7.moveTo !== "function"))
      r = context7, context7 = null;
    r = r == void 0 ? 2 : +r;
    const buffer = context7 == null ? context7 = new Path2() : void 0;
    const { points: points2 } = this;
    for (let i = 0, n = points2.length; i < n; i += 2) {
      const x9 = points2[i], y9 = points2[i + 1];
      context7.moveTo(x9 + r, y9);
      context7.arc(x9, y9, r, 0, tau5);
    }
    return buffer && buffer.value();
  }
  renderHull(context7) {
    const buffer = context7 == null ? context7 = new Path2() : void 0;
    const { hull, points: points2 } = this;
    const h6 = hull[0] * 2, n = hull.length;
    context7.moveTo(points2[h6], points2[h6 + 1]);
    for (let i = 1; i < n; ++i) {
      const h7 = 2 * hull[i];
      context7.lineTo(points2[h7], points2[h7 + 1]);
    }
    context7.closePath();
    return buffer && buffer.value();
  }
  hullPolygon() {
    const polygon = new Polygon();
    this.renderHull(polygon);
    return polygon.value();
  }
  renderTriangle(i, context7) {
    const buffer = context7 == null ? context7 = new Path2() : void 0;
    const { points: points2, triangles } = this;
    const t014 = triangles[i *= 3] * 2;
    const t13 = triangles[i + 1] * 2;
    const t22 = triangles[i + 2] * 2;
    context7.moveTo(points2[t014], points2[t014 + 1]);
    context7.lineTo(points2[t13], points2[t13 + 1]);
    context7.lineTo(points2[t22], points2[t22 + 1]);
    context7.closePath();
    return buffer && buffer.value();
  }
  *trianglePolygons() {
    const { triangles } = this;
    for (let i = 0, n = triangles.length / 3; i < n; ++i) {
      yield this.trianglePolygon(i);
    }
  }
  trianglePolygon(i) {
    const polygon = new Polygon();
    this.renderTriangle(i, polygon);
    return polygon.value();
  }
};
function flatArray(points2, fx, fy, that) {
  const n = points2.length;
  const array22 = new Float64Array(n * 2);
  for (let i = 0; i < n; ++i) {
    const p = points2[i];
    array22[i * 2] = fx.call(that, p, i, points2);
    array22[i * 2 + 1] = fy.call(that, p, i, points2);
  }
  return array22;
}
function* flatIterable(points2, fx, fy, that) {
  let i = 0;
  for (const p of points2) {
    yield fx.call(that, p, i, points2);
    yield fy.call(that, p, i, points2);
    ++i;
  }
}

// node_modules/vega-voronoi/build/vega-voronoi.js
function Voronoi2(params2) {
  Transform.call(this, null, params2);
}
Voronoi2.Definition = {
  "type": "Voronoi",
  "metadata": {
    "modifies": true
  },
  "params": [{
    "name": "x",
    "type": "field",
    "required": true
  }, {
    "name": "y",
    "type": "field",
    "required": true
  }, {
    "name": "size",
    "type": "number",
    "array": true,
    "length": 2
  }, {
    "name": "extent",
    "type": "array",
    "array": true,
    "length": 2,
    "default": [[-1e5, -1e5], [1e5, 1e5]],
    "content": {
      "type": "number",
      "array": true,
      "length": 2
    }
  }, {
    "name": "as",
    "type": "string",
    "default": "path"
  }]
};
var defaultExtent = [-1e5, -1e5, 1e5, 1e5];
inherits11(Voronoi2, Transform, {
  transform(_, pulse2) {
    const as = _.as || "path", data3 = pulse2.source;
    if (!data3 || !data3.length)
      return pulse2;
    let s2 = _.size;
    s2 = s2 ? [0, 0, s2[0], s2[1]] : (s2 = _.extent) ? [s2[0][0], s2[0][1], s2[1][0], s2[1][1]] : defaultExtent;
    const voronoi = this.value = Delaunay.from(data3, _.x, _.y).voronoi(s2);
    for (let i = 0, n = data3.length; i < n; ++i) {
      const polygon = voronoi.cellPolygon(i);
      data3[i][as] = polygon && !isPoint(polygon) ? toPathString(polygon) : null;
    }
    return pulse2.reflow(_.modified()).modifies(as);
  }
});
function toPathString(p) {
  const x9 = p[0][0], y9 = p[0][1];
  let n = p.length - 1;
  for (; p[n][0] === x9 && p[n][1] === y9; --n)
    ;
  return "M" + p.slice(0, n + 1).join("L") + "Z";
}
function isPoint(p) {
  return p.length === 2 && p[0][0] === p[1][0] && p[0][1] === p[1][1];
}

// node_modules/vega-wordcloud/build/vega-wordcloud.js
var vega_wordcloud_exports = {};
__export(vega_wordcloud_exports, {
  wordcloud: () => Wordcloud
});

// node_modules/vega-wordcloud/node_modules/vega-canvas/build/vega-canvas.browser.js
function domCanvas4(w8, h6) {
  if (typeof document !== "undefined" && document.createElement) {
    const c5 = document.createElement("canvas");
    if (c5 && c5.getContext) {
      c5.width = w8;
      c5.height = h6;
      return c5;
    }
  }
  return null;
}

// node_modules/vega-wordcloud/node_modules/vega-util/build/vega-util.js
function accessor13(fn, fields, name) {
  fn.fields = fields || [];
  fn.fname = name;
  return fn;
}
function getter13(path7) {
  return path7.length === 1 ? get113(path7[0]) : getN13(path7);
}
var get113 = (field25) => function(obj) {
  return obj[field25];
};
var getN13 = (path7) => {
  const len = path7.length;
  return function(obj) {
    for (let i = 0; i < len; ++i) {
      obj = obj[path7[i]];
    }
    return obj;
  };
};
function error13(message) {
  throw Error(message);
}
function splitAccessPath13(p) {
  const path7 = [], n = p.length;
  let q = null, b6 = 0, s2 = "", i, j, c5;
  p = p + "";
  function push() {
    path7.push(s2 + p.substring(i, j));
    s2 = "";
    i = j + 1;
  }
  for (i = j = 0; j < n; ++j) {
    c5 = p[j];
    if (c5 === "\\") {
      s2 += p.substring(i, j++);
      i = j;
    } else if (c5 === q) {
      push();
      q = null;
      b6 = -1;
    } else if (q) {
      continue;
    } else if (i === b6 && c5 === '"') {
      i = j + 1;
      q = c5;
    } else if (i === b6 && c5 === "'") {
      i = j + 1;
      q = c5;
    } else if (c5 === "." && !b6) {
      if (j > i) {
        push();
      } else {
        i = j + 1;
      }
    } else if (c5 === "[") {
      if (j > i)
        push();
      b6 = i = j + 1;
    } else if (c5 === "]") {
      if (!b6)
        error13("Access path missing open bracket: " + p);
      if (b6 > 0)
        push();
      b6 = 0;
      i = j + 1;
    }
  }
  if (b6)
    error13("Access path missing closing bracket: " + p);
  if (q)
    error13("Access path missing closing quote: " + p);
  if (j > i) {
    j++;
    push();
  }
  return path7;
}
function field13(field25, name, opt) {
  const path7 = splitAccessPath13(field25);
  field25 = path7.length === 1 ? path7[0] : field25;
  return accessor13((opt && opt.get || getter13)(path7), [field25], name || field25);
}
var id13 = field13("id");
var identity17 = accessor13((_) => _, [], "identity");
var zero15 = accessor13(() => 0, [], "zero");
var one14 = accessor13(() => 1, [], "one");
var truthy13 = accessor13(() => true, [], "true");
var falsy13 = accessor13(() => false, [], "false");
var DisallowedObjectProperties13 = /* @__PURE__ */ new Set([...Object.getOwnPropertyNames(Object.prototype).filter((name) => typeof Object.prototype[name] === "function"), "__proto__"]);
var isArray13 = Array.isArray;
function peek8(array22) {
  return array22[array22.length - 1];
}
function toNumber8(_) {
  return _ == null || _ === "" ? null : +_;
}
function array12(_) {
  return _ != null ? isArray13(_) ? _ : [_] : [];
}
function isFunction9(_) {
  return typeof _ === "function";
}
function constant11(_) {
  return isFunction9(_) ? _ : () => _;
}
function extend14(_) {
  for (let x9, k3, i = 1, len = arguments.length; i < len; ++i) {
    x9 = arguments[i];
    for (k3 in x9) {
      _[k3] = x9[k3];
    }
  }
  return _;
}
function extent6(array22, f) {
  let i = 0, n, v2, min5, max5;
  if (array22 && (n = array22.length)) {
    if (f == null) {
      for (v2 = array22[i]; i < n && (v2 == null || v2 !== v2); v2 = array22[++i])
        ;
      min5 = max5 = v2;
      for (; i < n; ++i) {
        v2 = array22[i];
        if (v2 != null) {
          if (v2 < min5)
            min5 = v2;
          if (v2 > max5)
            max5 = v2;
        }
      }
    } else {
      for (v2 = f(array22[i]); i < n && (v2 == null || v2 !== v2); v2 = f(array22[++i]))
        ;
      min5 = max5 = v2;
      for (; i < n; ++i) {
        v2 = f(array22[i]);
        if (v2 != null) {
          if (v2 < min5)
            min5 = v2;
          if (v2 > max5)
            max5 = v2;
        }
      }
    }
  }
  return [min5, max5];
}
function inherits12(child, parent, members) {
  const proto = child.prototype = Object.create(parent.prototype);
  Object.defineProperty(proto, "constructor", {
    value: child,
    writable: true,
    enumerable: true,
    configurable: true
  });
  return extend14(proto, members);
}
function toSet9(_) {
  const s2 = {}, n = _.length;
  for (let i = 0; i < n; ++i)
    s2[_[i]] = true;
  return s2;
}

// node_modules/vega-wordcloud/node_modules/vega-time/build/vega-time.js
var YEAR7 = "year";
var QUARTER7 = "quarter";
var MONTH7 = "month";
var WEEK7 = "week";
var DATE7 = "date";
var DAY7 = "day";
var DAYOFYEAR7 = "dayofyear";
var HOURS7 = "hours";
var MINUTES7 = "minutes";
var SECONDS7 = "seconds";
var MILLISECONDS7 = "milliseconds";
var TIME_UNITS7 = [YEAR7, QUARTER7, MONTH7, WEEK7, DATE7, DAY7, DAYOFYEAR7, HOURS7, MINUTES7, SECONDS7, MILLISECONDS7];
var UNITS7 = TIME_UNITS7.reduce((o, u4, i) => (o[u4] = 1 + i, o), {});
var defaultSpecifiers7 = {
  [YEAR7]: "%Y ",
  [QUARTER7]: "Q%q ",
  [MONTH7]: "%b ",
  [DATE7]: "%d ",
  [WEEK7]: "W%U ",
  [DAY7]: "%a ",
  [DAYOFYEAR7]: "%j ",
  [HOURS7]: "%H:00",
  [MINUTES7]: "00:%M",
  [SECONDS7]: ":%S",
  [MILLISECONDS7]: ".%L",
  [`${YEAR7}-${MONTH7}`]: "%Y-%m ",
  [`${YEAR7}-${MONTH7}-${DATE7}`]: "%Y-%m-%d ",
  [`${HOURS7}-${MINUTES7}`]: "%H:%M"
};
var t09 = /* @__PURE__ */ new Date();
function localYear7(y9) {
  t09.setFullYear(y9);
  t09.setMonth(0);
  t09.setDate(1);
  t09.setHours(0, 0, 0, 0);
  return t09;
}
function localDayOfYear7(d) {
  return timeDay.count(localYear7(d.getFullYear()) - 1, d);
}
function localWeekNum7(d) {
  return timeSunday.count(localYear7(d.getFullYear()) - 1, d);
}
function localFirst7(y9) {
  return localYear7(y9).getDay();
}
function utcDayOfYear7(d) {
  const y9 = Date.UTC(d.getUTCFullYear(), 0, 1);
  return utcDay.count(y9 - 1, d);
}
function utcWeekNum7(d) {
  const y9 = Date.UTC(d.getUTCFullYear(), 0, 1);
  return utcSunday.count(y9 - 1, d);
}
function utcFirst7(y9) {
  t09.setTime(Date.UTC(y9, 0, 1));
  return t09.getUTCDay();
}
function weekday7(week3, day, firstDay) {
  return day + week3 * 7 - (firstDay + 6) % 7;
}
var localGet7 = {
  [YEAR7]: (d) => d.getFullYear(),
  [QUARTER7]: (d) => Math.floor(d.getMonth() / 3),
  [MONTH7]: (d) => d.getMonth(),
  [DATE7]: (d) => d.getDate(),
  [HOURS7]: (d) => d.getHours(),
  [MINUTES7]: (d) => d.getMinutes(),
  [SECONDS7]: (d) => d.getSeconds(),
  [MILLISECONDS7]: (d) => d.getMilliseconds(),
  [DAYOFYEAR7]: (d) => localDayOfYear7(d),
  [WEEK7]: (d) => localWeekNum7(d),
  [WEEK7 + DAY7]: (d, y9) => weekday7(localWeekNum7(d), d.getDay(), localFirst7(y9)),
  [DAY7]: (d, y9) => weekday7(1, d.getDay(), localFirst7(y9))
};
var localInv7 = {
  [QUARTER7]: (q) => 3 * q,
  [WEEK7]: (w8, y9) => weekday7(w8, 0, localFirst7(y9))
};
var utcGet7 = {
  [YEAR7]: (d) => d.getUTCFullYear(),
  [QUARTER7]: (d) => Math.floor(d.getUTCMonth() / 3),
  [MONTH7]: (d) => d.getUTCMonth(),
  [DATE7]: (d) => d.getUTCDate(),
  [HOURS7]: (d) => d.getUTCHours(),
  [MINUTES7]: (d) => d.getUTCMinutes(),
  [SECONDS7]: (d) => d.getUTCSeconds(),
  [MILLISECONDS7]: (d) => d.getUTCMilliseconds(),
  [DAYOFYEAR7]: (d) => utcDayOfYear7(d),
  [WEEK7]: (d) => utcWeekNum7(d),
  [DAY7]: (d, y9) => weekday7(1, d.getUTCDay(), utcFirst7(y9)),
  [WEEK7 + DAY7]: (d, y9) => weekday7(utcWeekNum7(d), d.getUTCDay(), utcFirst7(y9))
};
var utcInv7 = {
  [QUARTER7]: (q) => 3 * q,
  [WEEK7]: (w8, y9) => weekday7(w8, 0, utcFirst7(y9))
};
var timeIntervals7 = {
  [YEAR7]: timeYear,
  [QUARTER7]: timeMonth.every(3),
  [MONTH7]: timeMonth,
  [WEEK7]: timeSunday,
  [DATE7]: timeDay,
  [DAY7]: timeDay,
  [DAYOFYEAR7]: timeDay,
  [HOURS7]: timeHour,
  [MINUTES7]: timeMinute,
  [SECONDS7]: second,
  [MILLISECONDS7]: millisecond
};
var utcIntervals7 = {
  [YEAR7]: utcYear,
  [QUARTER7]: utcMonth.every(3),
  [MONTH7]: utcMonth,
  [WEEK7]: utcSunday,
  [DATE7]: utcDay,
  [DAY7]: utcDay,
  [DAYOFYEAR7]: utcDay,
  [HOURS7]: utcHour,
  [MINUTES7]: utcMinute,
  [SECONDS7]: second,
  [MILLISECONDS7]: millisecond
};
var durationSecond8 = 1e3;
var durationMinute8 = durationSecond8 * 60;
var durationHour8 = durationMinute8 * 60;
var durationDay8 = durationHour8 * 24;
var durationWeek8 = durationDay8 * 7;
var durationMonth8 = durationDay8 * 30;
var durationYear8 = durationDay8 * 365;
var Milli7 = [YEAR7, MONTH7, DATE7, HOURS7, MINUTES7, SECONDS7, MILLISECONDS7];
var Seconds7 = Milli7.slice(0, -1);
var Minutes7 = Seconds7.slice(0, -1);
var Hours7 = Minutes7.slice(0, -1);
var Day7 = Hours7.slice(0, -1);
var Week7 = [YEAR7, WEEK7];
var Month7 = [YEAR7, MONTH7];
var Year7 = [YEAR7];
var intervals7 = [[Seconds7, 1, durationSecond8], [Seconds7, 5, 5 * durationSecond8], [Seconds7, 15, 15 * durationSecond8], [Seconds7, 30, 30 * durationSecond8], [Minutes7, 1, durationMinute8], [Minutes7, 5, 5 * durationMinute8], [Minutes7, 15, 15 * durationMinute8], [Minutes7, 30, 30 * durationMinute8], [Hours7, 1, durationHour8], [Hours7, 3, 3 * durationHour8], [Hours7, 6, 6 * durationHour8], [Hours7, 12, 12 * durationHour8], [Day7, 1, durationDay8], [Week7, 1, durationWeek8], [Month7, 1, durationMonth8], [Month7, 3, 3 * durationMonth8], [Year7, 1, durationYear8]];

// node_modules/vega-wordcloud/node_modules/vega-scale/build/vega-scale.js
function bandSpace5(count3, paddingInner2, paddingOuter2) {
  const space = count3 - paddingInner2 + paddingOuter2 * 2;
  return count3 ? space > 0 ? space : 1 : 0;
}
var Identity5 = "identity";
var Linear6 = "linear";
var Log5 = "log";
var Pow5 = "pow";
var Sqrt5 = "sqrt";
var Symlog5 = "symlog";
var Time5 = "time";
var UTC5 = "utc";
var Sequential5 = "sequential";
var Diverging5 = "diverging";
var Quantile6 = "quantile";
var Quantize5 = "quantize";
var Threshold5 = "threshold";
var Ordinal5 = "ordinal";
var Point5 = "point";
var Band5 = "band";
var BinOrdinal5 = "bin-ordinal";
var Continuous5 = "continuous";
var Discrete5 = "discrete";
var Discretizing5 = "discretizing";
var Interpolating5 = "interpolating";
var Temporal5 = "temporal";
function invertRange5(scale19) {
  return function(_) {
    let lo = _[0], hi = _[1], t;
    if (hi < lo) {
      t = lo;
      lo = hi;
      hi = t;
    }
    return [scale19.invert(lo), scale19.invert(hi)];
  };
}
function invertRangeExtent5(scale19) {
  return function(_) {
    const range7 = scale19.range();
    let lo = _[0], hi = _[1], min5 = -1, max5, t, i, n;
    if (hi < lo) {
      t = lo;
      lo = hi;
      hi = t;
    }
    for (i = 0, n = range7.length; i < n; ++i) {
      if (range7[i] >= lo && range7[i] <= hi) {
        if (min5 < 0)
          min5 = i;
        max5 = i;
      }
    }
    if (min5 < 0)
      return void 0;
    lo = scale19.invertExtent(range7[min5]);
    hi = scale19.invertExtent(range7[max5]);
    return [lo[0] === void 0 ? lo[1] : lo[0], hi[1] === void 0 ? hi[0] : hi[1]];
  };
}
function band6() {
  const scale19 = ordinal().unknown(void 0), domain3 = scale19.domain, ordinalRange = scale19.range;
  let range$1 = [0, 1], step, bandwidth2, round2 = false, paddingInner2 = 0, paddingOuter2 = 0, align2 = 0.5;
  delete scale19.unknown;
  function rescale() {
    const n = domain3().length, reverse4 = range$1[1] < range$1[0], stop2 = range$1[1 - reverse4], space = bandSpace5(n, paddingInner2, paddingOuter2);
    let start = range$1[reverse4 - 0];
    step = (stop2 - start) / (space || 1);
    if (round2) {
      step = Math.floor(step);
    }
    start += (stop2 - start - step * (n - paddingInner2)) * align2;
    bandwidth2 = step * (1 - paddingInner2);
    if (round2) {
      start = Math.round(start);
      bandwidth2 = Math.round(bandwidth2);
    }
    const values7 = range(n).map((i) => start + step * i);
    return ordinalRange(reverse4 ? values7.reverse() : values7);
  }
  scale19.domain = function(_) {
    if (arguments.length) {
      domain3(_);
      return rescale();
    } else {
      return domain3();
    }
  };
  scale19.range = function(_) {
    if (arguments.length) {
      range$1 = [+_[0], +_[1]];
      return rescale();
    } else {
      return range$1.slice();
    }
  };
  scale19.rangeRound = function(_) {
    range$1 = [+_[0], +_[1]];
    round2 = true;
    return rescale();
  };
  scale19.bandwidth = function() {
    return bandwidth2;
  };
  scale19.step = function() {
    return step;
  };
  scale19.round = function(_) {
    if (arguments.length) {
      round2 = !!_;
      return rescale();
    } else {
      return round2;
    }
  };
  scale19.padding = function(_) {
    if (arguments.length) {
      paddingOuter2 = Math.max(0, Math.min(1, _));
      paddingInner2 = paddingOuter2;
      return rescale();
    } else {
      return paddingInner2;
    }
  };
  scale19.paddingInner = function(_) {
    if (arguments.length) {
      paddingInner2 = Math.max(0, Math.min(1, _));
      return rescale();
    } else {
      return paddingInner2;
    }
  };
  scale19.paddingOuter = function(_) {
    if (arguments.length) {
      paddingOuter2 = Math.max(0, Math.min(1, _));
      return rescale();
    } else {
      return paddingOuter2;
    }
  };
  scale19.align = function(_) {
    if (arguments.length) {
      align2 = Math.max(0, Math.min(1, _));
      return rescale();
    } else {
      return align2;
    }
  };
  scale19.invertRange = function(_) {
    if (_[0] == null || _[1] == null)
      return;
    const reverse4 = range$1[1] < range$1[0], values7 = reverse4 ? ordinalRange().reverse() : ordinalRange(), n = values7.length - 1;
    let lo = +_[0], hi = +_[1], a4, b6, t;
    if (lo !== lo || hi !== hi)
      return;
    if (hi < lo) {
      t = lo;
      lo = hi;
      hi = t;
    }
    if (hi < values7[0] || lo > range$1[1 - reverse4])
      return;
    a4 = Math.max(0, bisectRight(values7, lo) - 1);
    b6 = lo === hi ? a4 : bisectRight(values7, hi) - 1;
    if (lo - values7[a4] > bandwidth2 + 1e-10)
      ++a4;
    if (reverse4) {
      t = a4;
      a4 = n - b6;
      b6 = n - t;
    }
    return a4 > b6 ? void 0 : domain3().slice(a4, b6 + 1);
  };
  scale19.invert = function(_) {
    const value7 = scale19.invertRange([_, _]);
    return value7 ? value7[0] : value7;
  };
  scale19.copy = function() {
    return band6().domain(domain3()).range(range$1).round(round2).paddingInner(paddingInner2).paddingOuter(paddingOuter2).align(align2);
  };
  return rescale();
}
function pointish5(scale19) {
  const copy4 = scale19.copy;
  scale19.padding = scale19.paddingOuter;
  delete scale19.paddingInner;
  scale19.copy = function() {
    return pointish5(copy4());
  };
  return scale19;
}
function point12() {
  return pointish5(band6().paddingInner(1));
}
var map8 = Array.prototype.map;
function numbers7(_) {
  return map8.call(_, toNumber8);
}
var slice7 = Array.prototype.slice;
function scaleBinOrdinal5() {
  let domain3 = [], range7 = [];
  function scale19(x9) {
    return x9 == null || x9 !== x9 ? void 0 : range7[(bisect_default2(domain3, x9) - 1) % range7.length];
  }
  scale19.domain = function(_) {
    if (arguments.length) {
      domain3 = numbers7(_);
      return scale19;
    } else {
      return domain3.slice();
    }
  };
  scale19.range = function(_) {
    if (arguments.length) {
      range7 = slice7.call(_);
      return scale19;
    } else {
      return range7.slice();
    }
  };
  scale19.tickFormat = function(count3, specifier) {
    return tickFormat(domain3[0], peek8(domain3), count3 == null ? 10 : count3, specifier);
  };
  scale19.copy = function() {
    return scaleBinOrdinal5().domain(scale19.domain()).range(scale19.range());
  };
  return scale19;
}
var scales5 = /* @__PURE__ */ new Map();
var VEGA_SCALE5 = Symbol("vega_scale");
function registerScale5(scale19) {
  scale19[VEGA_SCALE5] = true;
  return scale19;
}
function create7(type7, constructor, metadata6) {
  const ctr = function scale19() {
    const s2 = constructor();
    if (!s2.invertRange) {
      s2.invertRange = s2.invert ? invertRange5(s2) : s2.invertExtent ? invertRangeExtent5(s2) : void 0;
    }
    s2.type = type7;
    return registerScale5(s2);
  };
  ctr.metadata = toSet9(array12(metadata6));
  return ctr;
}
function scale8(type7, scale19, metadata6) {
  if (arguments.length > 1) {
    scales5.set(type7, create7(type7, scale19, metadata6));
    return this;
  } else {
    return isValidScaleType5(type7) ? scales5.get(type7) : void 0;
  }
}
scale8(Identity5, identity8);
scale8(Linear6, linear3, Continuous5);
scale8(Log5, log3, [Continuous5, Log5]);
scale8(Pow5, pow3, Continuous5);
scale8(Sqrt5, sqrt2, Continuous5);
scale8(Symlog5, symlog2, Continuous5);
scale8(Time5, time, [Continuous5, Temporal5]);
scale8(UTC5, utcTime, [Continuous5, Temporal5]);
scale8(Sequential5, sequential, [Continuous5, Interpolating5]);
scale8(`${Sequential5}-${Linear6}`, sequential, [Continuous5, Interpolating5]);
scale8(`${Sequential5}-${Log5}`, sequentialLog, [Continuous5, Interpolating5, Log5]);
scale8(`${Sequential5}-${Pow5}`, sequentialPow, [Continuous5, Interpolating5]);
scale8(`${Sequential5}-${Sqrt5}`, sequentialSqrt, [Continuous5, Interpolating5]);
scale8(`${Sequential5}-${Symlog5}`, sequentialSymlog, [Continuous5, Interpolating5]);
scale8(`${Diverging5}-${Linear6}`, diverging, [Continuous5, Interpolating5]);
scale8(`${Diverging5}-${Log5}`, divergingLog, [Continuous5, Interpolating5, Log5]);
scale8(`${Diverging5}-${Pow5}`, divergingPow, [Continuous5, Interpolating5]);
scale8(`${Diverging5}-${Sqrt5}`, divergingSqrt, [Continuous5, Interpolating5]);
scale8(`${Diverging5}-${Symlog5}`, divergingSymlog, [Continuous5, Interpolating5]);
scale8(Quantile6, quantile2, [Discretizing5, Quantile6]);
scale8(Quantize5, quantize, Discretizing5);
scale8(Threshold5, threshold, Discretizing5);
scale8(BinOrdinal5, scaleBinOrdinal5, [Discrete5, Discretizing5]);
scale8(Ordinal5, ordinal, Discrete5);
scale8(Band5, band6, Discrete5);
scale8(Point5, point12, Discrete5);
function isValidScaleType5(type7) {
  return scales5.has(type7);
}
function interpolateColors5(colors10, type7, gamma2) {
  return piecewise(interpolate5(type7 || "rgb", gamma2), colors10);
}
function interpolate5(type7, gamma2) {
  const interp = src_exports[method5(type7)];
  return gamma2 != null && interp && interp.gamma ? interp.gamma(gamma2) : interp;
}
function method5(type7) {
  return "interpolate" + type7.toLowerCase().split("-").map((s2) => s2[0].toUpperCase() + s2.slice(1)).join("");
}
var continuous6 = {
  blues: "cfe1f2bed8eca8cee58fc1de74b2d75ba3cf4592c63181bd206fb2125ca40a4a90",
  greens: "d3eecdc0e6baabdda594d3917bc77d60ba6c46ab5e329a512089430e7735036429",
  greys: "e2e2e2d4d4d4c4c4c4b1b1b19d9d9d8888887575756262624d4d4d3535351e1e1e",
  oranges: "fdd8b3fdc998fdb87bfda55efc9244f87f2cf06b18e4580bd14904b93d029f3303",
  purples: "e2e1efd4d4e8c4c5e0b4b3d6a3a0cc928ec3827cb97566ae684ea25c3696501f8c",
  reds: "fdc9b4fcb49afc9e80fc8767fa7051f6573fec3f2fdc2a25c81b1db21218970b13",
  blueGreen: "d5efedc1e8e0a7ddd18bd2be70c6a958ba9144ad77319c5d2089460e7736036429",
  bluePurple: "ccddecbad0e4a8c2dd9ab0d4919cc98d85be8b6db28a55a6873c99822287730f71",
  greenBlue: "d3eecec5e8c3b1e1bb9bd8bb82cec269c2ca51b2cd3c9fc7288abd1675b10b60a1",
  orangeRed: "fddcaffdcf9bfdc18afdad77fb9562f67d53ee6545e24932d32d1ebf130da70403",
  purpleBlue: "dbdaebc8cee4b1c3de97b7d87bacd15b9fc93a90c01e7fb70b70ab056199045281",
  purpleBlueGreen: "dbd8eac8cee4b0c3de93b7d872acd1549fc83892bb1c88a3097f8702736b016353",
  purpleRed: "dcc9e2d3b3d7ce9eccd186c0da6bb2e14da0e23189d91e6fc61159ab07498f023a",
  redPurple: "fccfccfcbec0faa9b8f98faff571a5ec539ddb3695c41b8aa908808d0179700174",
  yellowGreen: "e4f4acd1eca0b9e2949ed68880c97c62bb6e47aa5e3297502083440e723b036034",
  yellowOrangeBrown: "feeaa1fedd84fecc63feb746fca031f68921eb7215db5e0bc54c05ab3d038f3204",
  yellowOrangeRed: "fee087fed16ffebd59fea849fd903efc7335f9522bee3423de1b20ca0b22af0225",
  blueOrange: "134b852f78b35da2cb9dcae1d2e5eff2f0ebfce0bafbbf74e8932fc5690d994a07",
  brownBlueGreen: "704108a0651ac79548e3c78af3e6c6eef1eac9e9e48ed1c74da79e187a72025147",
  purpleGreen: "5b1667834792a67fb6c9aed3e6d6e8eff0efd9efd5aedda971bb75368e490e5e29",
  purpleOrange: "4114696647968f83b7b9b4d6dadbebf3eeeafce0bafbbf74e8932fc5690d994a07",
  redBlue: "8c0d25bf363adf745ef4ae91fbdbc9f2efeed2e5ef9dcae15da2cb2f78b3134b85",
  redGrey: "8c0d25bf363adf745ef4ae91fcdccbfaf4f1e2e2e2c0c0c0969696646464343434",
  yellowGreenBlue: "eff9bddbf1b4bde5b594d5b969c5be45b4c22c9ec02182b82163aa23479c1c3185",
  redYellowBlue: "a50026d4322cf16e43fcac64fedd90faf8c1dcf1ecabd6e875abd04a74b4313695",
  redYellowGreen: "a50026d4322cf16e43fcac63fedd8df9f7aed7ee8ea4d86e64bc6122964f006837",
  pinkYellowGreen: "8e0152c0267edd72adf0b3d6faddedf5f3efe1f2cab6de8780bb474f9125276419",
  spectral: "9e0142d13c4bf0704afcac63fedd8dfbf8b0e0f3a1a9dda269bda94288b55e4fa2",
  viridis: "440154470e61481a6c482575472f7d443a834144873d4e8a39568c35608d31688e2d708e2a788e27818e23888e21918d1f988b1fa08822a8842ab07f35b77943bf7154c56866cc5d7ad1518fd744a5db36bcdf27d2e21be9e51afde725",
  magma: "0000040404130b0924150e3720114b2c11603b0f704a107957157e651a80721f817f24828c29819a2e80a8327db6377ac43c75d1426fde4968e95462f1605df76f5cfa7f5efc8f65fe9f6dfeaf78febf84fece91fddea0fcedaffcfdbf",
  inferno: "0000040403130c0826170c3b240c4f330a5f420a68500d6c5d126e6b176e781c6d86216b932667a12b62ae305cbb3755c73e4cd24644dd513ae65c30ed6925f3771af8850ffb9506fca50afcb519fac62df6d645f2e661f3f484fcffa4",
  plasma: "0d088723069033059742039d5002a25d01a66a00a87801a88405a7900da49c179ea72198b12a90ba3488c33d80cb4779d35171da5a69e16462e76e5bed7953f2834cf68f44fa9a3dfca636fdb32ffec029fcce25f9dc24f5ea27f0f921",
  cividis: "00205100235800265d002961012b65042e670831690d346b11366c16396d1c3c6e213f6e26426e2c456e31476e374a6e3c4d6e42506e47536d4c566d51586e555b6e5a5e6e5e616e62646f66676f6a6a706e6d717270717573727976737c79747f7c75827f758682768985778c8877908b78938e789691789a94789e9778a19b78a59e77a9a177aea575b2a874b6ab73bbaf71c0b26fc5b66dc9b96acebd68d3c065d8c462ddc85fe2cb5ce7cf58ebd355f0d652f3da4ff7de4cfae249fce647",
  rainbow: "6e40aa883eb1a43db3bf3cafd83fa4ee4395fe4b83ff576eff6659ff7847ff8c38f3a130e2b72fcfcc36bee044aff05b8ff4576ff65b52f6673af27828ea8d1ddfa319d0b81cbecb23abd82f96e03d82e14c6edb5a5dd0664dbf6e40aa",
  sinebow: "ff4040fc582af47218e78d0bd5a703bfbf00a7d5038de70b72f41858fc2a40ff402afc5818f4720be78d03d5a700bfbf03a7d50b8de71872f42a58fc4040ff582afc7218f48d0be7a703d5bf00bfd503a7e70b8df41872fc2a58ff4040",
  turbo: "23171b32204a3e2a71453493493eae4b49c54a53d7485ee44569ee4074f53c7ff8378af93295f72e9ff42ba9ef28b3e926bce125c5d925cdcf27d5c629dcbc2de3b232e9a738ee9d3ff39347f68950f9805afc7765fd6e70fe667cfd5e88fc5795fb51a1f84badf545b9f140c5ec3cd0e637dae034e4d931ecd12ef4c92bfac029ffb626ffad24ffa223ff9821ff8d1fff821dff771cfd6c1af76118f05616e84b14df4111d5380fcb2f0dc0260ab61f07ac1805a313029b0f00950c00910b00",
  browns: "eedbbdecca96e9b97ae4a865dc9856d18954c7784cc0673fb85536ad44339f3632",
  tealBlues: "bce4d89dd3d181c3cb65b3c245a2b9368fae347da0306a932c5985",
  teals: "bbdfdfa2d4d58ac9c975bcbb61b0af4da5a43799982b8b8c1e7f7f127273006667",
  warmGreys: "dcd4d0cec5c1c0b8b4b3aaa7a59c9998908c8b827f7e7673726866665c5a59504e",
  goldGreen: "f4d166d5ca60b6c35c98bb597cb25760a6564b9c533f8f4f33834a257740146c36",
  goldOrange: "f4d166f8be5cf8aa4cf5983bf3852aef701be2621fd65322c54923b142239e3a26",
  goldRed: "f4d166f6be59f9aa51fc964ef6834bee734ae56249db5247cf4244c43141b71d3e",
  lightGreyRed: "efe9e6e1dad7d5cbc8c8bdb9bbaea9cd967ddc7b43e15f19df4011dc000b",
  lightGreyTeal: "e4eaead6dcddc8ced2b7c2c7a6b4bc64b0bf22a6c32295c11f85be1876bc",
  lightMulti: "e0f1f2c4e9d0b0de9fd0e181f6e072f6c053f3993ef77440ef4a3c",
  lightOrange: "f2e7daf7d5baf9c499fab184fa9c73f68967ef7860e8645bde515bd43d5b",
  lightTealBlue: "e3e9e0c0dccf9aceca7abfc859afc0389fb9328dad2f7ca0276b95255988",
  darkBlue: "3232322d46681a5c930074af008cbf05a7ce25c0dd38daed50f3faffffff",
  darkGold: "3c3c3c584b37725e348c7631ae8b2bcfa424ecc31ef9de30fff184ffffff",
  darkGreen: "3a3a3a215748006f4d048942489e4276b340a6c63dd2d836ffeb2cffffaa",
  darkMulti: "3737371f5287197d8c29a86995ce3fffe800ffffff",
  darkRed: "3434347036339e3c38cc4037e75d1eec8620eeab29f0ce32ffeb2c"
};
var discrete5 = {
  accent: Accent_default,
  category10: category10_default,
  category20: "1f77b4aec7e8ff7f0effbb782ca02c98df8ad62728ff98969467bdc5b0d58c564bc49c94e377c2f7b6d27f7f7fc7c7c7bcbd22dbdb8d17becf9edae5",
  category20b: "393b795254a36b6ecf9c9ede6379398ca252b5cf6bcedb9c8c6d31bd9e39e7ba52e7cb94843c39ad494ad6616be7969c7b4173a55194ce6dbdde9ed6",
  category20c: "3182bd6baed69ecae1c6dbefe6550dfd8d3cfdae6bfdd0a231a35474c476a1d99bc7e9c0756bb19e9ac8bcbddcdadaeb636363969696bdbdbdd9d9d9",
  dark2: Dark2_default,
  observable10: observable10_default,
  paired: Paired_default,
  pastel1: Pastel1_default,
  pastel2: Pastel2_default,
  set1: Set1_default,
  set2: Set2_default,
  set3: Set3_default,
  tableau10: "4c78a8f58518e4575672b7b254a24beeca3bb279a2ff9da69d755dbab0ac",
  tableau20: "4c78a89ecae9f58518ffbf7954a24b88d27ab79a20f2cf5b43989483bcb6e45756ff9d9879706ebab0acd67195fcbfd2b279a2d6a5c99e765fd8b5a5"
};
function colors5(palette) {
  if (isArray13(palette))
    return palette;
  const n = palette.length / 6 | 0, c5 = new Array(n);
  for (let i = 0; i < n; ) {
    c5[i] = "#" + palette.slice(i * 6, ++i * 6);
  }
  return c5;
}
function apply5(_, f) {
  for (const k3 in _)
    scheme32(k3, f(_[k3]));
}
var schemes5 = {};
apply5(discrete5, colors5);
apply5(continuous6, (_) => interpolateColors5(colors5(_)));
function scheme32(name, scheme38) {
  name = name && name.toLowerCase();
  if (arguments.length > 1) {
    schemes5[name] = scheme38;
    return this;
  } else {
    return schemes5[name];
  }
}
var symbols7 = {
  [Quantile6]: "quantiles",
  [Quantize5]: "thresholds",
  [Threshold5]: "domain"
};
var formats6 = {
  [Quantile6]: "quantiles",
  [Quantize5]: "domain"
};

// node_modules/vega-wordcloud/build/vega-wordcloud.js
var cloudRadians = Math.PI / 180;
var cw = 1 << 11 >> 5;
var ch = 1 << 11;
function cloud() {
  var size = [256, 256], text7, font7, fontSize6, fontStyle, fontWeight2, rotate6, padding3, spiral = archimedeanSpiral, words = [], random2 = Math.random, cloud2 = {};
  cloud2.layout = function() {
    var contextAndRatio = getContext2(domCanvas4()), board = zeroArray((size[0] >> 5) * size[1]), bounds6 = null, n = words.length, i = -1, tags = [], data3 = words.map((d2) => ({
      text: text7(d2),
      font: font7(d2),
      style: fontStyle(d2),
      weight: fontWeight2(d2),
      rotate: rotate6(d2),
      size: ~~(fontSize6(d2) + 1e-14),
      padding: padding3(d2),
      xoff: 0,
      yoff: 0,
      x1: 0,
      y1: 0,
      x0: 0,
      y0: 0,
      hasText: false,
      sprite: null,
      datum: d2
    })).sort((a4, b6) => b6.size - a4.size);
    while (++i < n) {
      var d = data3[i];
      d.x = size[0] * (random2() + 0.5) >> 1;
      d.y = size[1] * (random2() + 0.5) >> 1;
      cloudSprite(contextAndRatio, d, data3, i);
      if (d.hasText && place2(board, d, bounds6)) {
        tags.push(d);
        if (bounds6)
          cloudBounds(bounds6, d);
        else
          bounds6 = [{
            x: d.x + d.x0,
            y: d.y + d.y0
          }, {
            x: d.x + d.x1,
            y: d.y + d.y1
          }];
        d.x -= size[0] >> 1;
        d.y -= size[1] >> 1;
      }
    }
    return tags;
  };
  function getContext2(canvas) {
    canvas.width = canvas.height = 1;
    var ratio = Math.sqrt(canvas.getContext("2d").getImageData(0, 0, 1, 1).data.length >> 2);
    canvas.width = (cw << 5) / ratio;
    canvas.height = ch / ratio;
    var context7 = canvas.getContext("2d");
    context7.fillStyle = context7.strokeStyle = "red";
    context7.textAlign = "center";
    return {
      context: context7,
      ratio
    };
  }
  function place2(board, tag, bounds6) {
    var startX = tag.x, startY = tag.y, maxDelta = Math.hypot(size[0], size[1]), s2 = spiral(size), dt = random2() < 0.5 ? 1 : -1, t = -dt, dxdy, dx, dy;
    while (dxdy = s2(t += dt)) {
      dx = ~~dxdy[0];
      dy = ~~dxdy[1];
      if (Math.min(Math.abs(dx), Math.abs(dy)) >= maxDelta)
        break;
      tag.x = startX + dx;
      tag.y = startY + dy;
      if (tag.x + tag.x0 < 0 || tag.y + tag.y0 < 0 || tag.x + tag.x1 > size[0] || tag.y + tag.y1 > size[1])
        continue;
      if (!bounds6 || !cloudCollide(tag, board, size[0])) {
        if (!bounds6 || collideRects(tag, bounds6)) {
          var sprite = tag.sprite, w8 = tag.width >> 5, sw = size[0] >> 5, lx6 = tag.x - (w8 << 4), sx = lx6 & 127, msx = 32 - sx, h6 = tag.y1 - tag.y0, x9 = (tag.y + tag.y0) * sw + (lx6 >> 5), last;
          for (var j = 0; j < h6; j++) {
            last = 0;
            for (var i = 0; i <= w8; i++) {
              board[x9 + i] |= last << msx | (i < w8 ? (last = sprite[j * w8 + i]) >>> sx : 0);
            }
            x9 += sw;
          }
          tag.sprite = null;
          return true;
        }
      }
    }
    return false;
  }
  cloud2.words = function(_) {
    if (arguments.length) {
      words = _;
      return cloud2;
    } else {
      return words;
    }
  };
  cloud2.size = function(_) {
    if (arguments.length) {
      size = [+_[0], +_[1]];
      return cloud2;
    } else {
      return size;
    }
  };
  cloud2.font = function(_) {
    if (arguments.length) {
      font7 = functor(_);
      return cloud2;
    } else {
      return font7;
    }
  };
  cloud2.fontStyle = function(_) {
    if (arguments.length) {
      fontStyle = functor(_);
      return cloud2;
    } else {
      return fontStyle;
    }
  };
  cloud2.fontWeight = function(_) {
    if (arguments.length) {
      fontWeight2 = functor(_);
      return cloud2;
    } else {
      return fontWeight2;
    }
  };
  cloud2.rotate = function(_) {
    if (arguments.length) {
      rotate6 = functor(_);
      return cloud2;
    } else {
      return rotate6;
    }
  };
  cloud2.text = function(_) {
    if (arguments.length) {
      text7 = functor(_);
      return cloud2;
    } else {
      return text7;
    }
  };
  cloud2.spiral = function(_) {
    if (arguments.length) {
      spiral = spirals[_] || _;
      return cloud2;
    } else {
      return spiral;
    }
  };
  cloud2.fontSize = function(_) {
    if (arguments.length) {
      fontSize6 = functor(_);
      return cloud2;
    } else {
      return fontSize6;
    }
  };
  cloud2.padding = function(_) {
    if (arguments.length) {
      padding3 = functor(_);
      return cloud2;
    } else {
      return padding3;
    }
  };
  cloud2.random = function(_) {
    if (arguments.length) {
      random2 = _;
      return cloud2;
    } else {
      return random2;
    }
  };
  return cloud2;
}
function cloudSprite(contextAndRatio, d, data3, di) {
  if (d.sprite)
    return;
  var c5 = contextAndRatio.context, ratio = contextAndRatio.ratio;
  c5.clearRect(0, 0, (cw << 5) / ratio, ch / ratio);
  var x9 = 0, y9 = 0, maxh = 0, n = data3.length, w8, w32, h6, i, j;
  --di;
  while (++di < n) {
    d = data3[di];
    c5.save();
    c5.font = d.style + " " + d.weight + " " + ~~((d.size + 1) / ratio) + "px " + d.font;
    w8 = c5.measureText(d.text + "m").width * ratio;
    h6 = d.size << 1;
    if (d.rotate) {
      var sr = Math.sin(d.rotate * cloudRadians), cr6 = Math.cos(d.rotate * cloudRadians), wcr = w8 * cr6, wsr = w8 * sr, hcr = h6 * cr6, hsr = h6 * sr;
      w8 = Math.max(Math.abs(wcr + hsr), Math.abs(wcr - hsr)) + 31 >> 5 << 5;
      h6 = ~~Math.max(Math.abs(wsr + hcr), Math.abs(wsr - hcr));
    } else {
      w8 = w8 + 31 >> 5 << 5;
    }
    if (h6 > maxh)
      maxh = h6;
    if (x9 + w8 >= cw << 5) {
      x9 = 0;
      y9 += maxh;
      maxh = 0;
    }
    if (y9 + h6 >= ch)
      break;
    c5.translate((x9 + (w8 >> 1)) / ratio, (y9 + (h6 >> 1)) / ratio);
    if (d.rotate)
      c5.rotate(d.rotate * cloudRadians);
    c5.fillText(d.text, 0, 0);
    if (d.padding) {
      c5.lineWidth = 2 * d.padding;
      c5.strokeText(d.text, 0, 0);
    }
    c5.restore();
    d.width = w8;
    d.height = h6;
    d.xoff = x9;
    d.yoff = y9;
    d.x1 = w8 >> 1;
    d.y1 = h6 >> 1;
    d.x0 = -d.x1;
    d.y0 = -d.y1;
    d.hasText = true;
    x9 += w8;
  }
  var pixels = c5.getImageData(0, 0, (cw << 5) / ratio, ch / ratio).data, sprite = [];
  while (--di >= 0) {
    d = data3[di];
    if (!d.hasText)
      continue;
    w8 = d.width;
    w32 = w8 >> 5;
    h6 = d.y1 - d.y0;
    for (i = 0; i < h6 * w32; i++)
      sprite[i] = 0;
    x9 = d.xoff;
    if (x9 == null)
      return;
    y9 = d.yoff;
    var seen = 0, seenRow = -1;
    for (j = 0; j < h6; j++) {
      for (i = 0; i < w8; i++) {
        var k3 = w32 * j + (i >> 5), m3 = pixels[(y9 + j) * (cw << 5) + (x9 + i) << 2] ? 1 << 31 - i % 32 : 0;
        sprite[k3] |= m3;
        seen |= m3;
      }
      if (seen)
        seenRow = j;
      else {
        d.y0++;
        h6--;
        j--;
        y9++;
      }
    }
    d.y1 = d.y0 + seenRow;
    d.sprite = sprite.slice(0, (d.y1 - d.y0) * w32);
  }
}
function cloudCollide(tag, board, sw) {
  sw >>= 5;
  var sprite = tag.sprite, w8 = tag.width >> 5, lx6 = tag.x - (w8 << 4), sx = lx6 & 127, msx = 32 - sx, h6 = tag.y1 - tag.y0, x9 = (tag.y + tag.y0) * sw + (lx6 >> 5), last;
  for (var j = 0; j < h6; j++) {
    last = 0;
    for (var i = 0; i <= w8; i++) {
      if ((last << msx | (i < w8 ? (last = sprite[j * w8 + i]) >>> sx : 0)) & board[x9 + i])
        return true;
    }
    x9 += sw;
  }
  return false;
}
function cloudBounds(bounds6, d) {
  var b0 = bounds6[0], b1 = bounds6[1];
  if (d.x + d.x0 < b0.x)
    b0.x = d.x + d.x0;
  if (d.y + d.y0 < b0.y)
    b0.y = d.y + d.y0;
  if (d.x + d.x1 > b1.x)
    b1.x = d.x + d.x1;
  if (d.y + d.y1 > b1.y)
    b1.y = d.y + d.y1;
}
function collideRects(a4, b6) {
  return a4.x + a4.x1 > b6[0].x && a4.x + a4.x0 < b6[1].x && a4.y + a4.y1 > b6[0].y && a4.y + a4.y0 < b6[1].y;
}
function archimedeanSpiral(size) {
  var e3 = size[0] / size[1];
  return function(t) {
    return [e3 * (t *= 0.1) * Math.cos(t), t * Math.sin(t)];
  };
}
function rectangularSpiral(size) {
  var dy = 4, dx = dy * size[0] / size[1], x9 = 0, y9 = 0;
  return function(t) {
    var sign4 = t < 0 ? -1 : 1;
    switch (Math.sqrt(1 + 4 * sign4 * t) - sign4 & 3) {
      case 0:
        x9 += dx;
        break;
      case 1:
        y9 += dy;
        break;
      case 2:
        x9 -= dx;
        break;
      default:
        y9 -= dy;
        break;
    }
    return [x9, y9];
  };
}
function zeroArray(n) {
  var a4 = [], i = -1;
  while (++i < n)
    a4[i] = 0;
  return a4;
}
function functor(d) {
  return typeof d === "function" ? d : function() {
    return d;
  };
}
var spirals = {
  archimedean: archimedeanSpiral,
  rectangular: rectangularSpiral
};
var Output4 = ["x", "y", "font", "fontSize", "fontStyle", "fontWeight", "angle"];
var Params2 = ["text", "font", "rotate", "fontSize", "fontStyle", "fontWeight"];
function Wordcloud(params2) {
  Transform.call(this, cloud(), params2);
}
Wordcloud.Definition = {
  "type": "Wordcloud",
  "metadata": {
    "modifies": true
  },
  "params": [{
    "name": "size",
    "type": "number",
    "array": true,
    "length": 2
  }, {
    "name": "font",
    "type": "string",
    "expr": true,
    "default": "sans-serif"
  }, {
    "name": "fontStyle",
    "type": "string",
    "expr": true,
    "default": "normal"
  }, {
    "name": "fontWeight",
    "type": "string",
    "expr": true,
    "default": "normal"
  }, {
    "name": "fontSize",
    "type": "number",
    "expr": true,
    "default": 14
  }, {
    "name": "fontSizeRange",
    "type": "number",
    "array": "nullable",
    "default": [10, 50]
  }, {
    "name": "rotate",
    "type": "number",
    "expr": true,
    "default": 0
  }, {
    "name": "text",
    "type": "field"
  }, {
    "name": "spiral",
    "type": "string",
    "values": ["archimedean", "rectangular"]
  }, {
    "name": "padding",
    "type": "number",
    "expr": true
  }, {
    "name": "as",
    "type": "string",
    "array": true,
    "length": 7,
    "default": Output4
  }]
};
inherits12(Wordcloud, Transform, {
  transform(_, pulse2) {
    if (_.size && !(_.size[0] && _.size[1])) {
      error13("Wordcloud size dimensions must be non-zero.");
    }
    function modp(param2) {
      const p = _[param2];
      return isFunction9(p) && pulse2.modified(p.fields);
    }
    const mod = _.modified();
    if (!(mod || pulse2.changed(pulse2.ADD_REM) || Params2.some(modp)))
      return;
    const data3 = pulse2.materialize(pulse2.SOURCE).source, layout = this.value, as = _.as || Output4;
    let fontSize6 = _.fontSize || 14, range7;
    isFunction9(fontSize6) ? range7 = _.fontSizeRange : fontSize6 = constant11(fontSize6);
    if (range7) {
      const fsize = fontSize6, sizeScale = scale8("sqrt")().domain(extent6(data3, fsize)).range(range7);
      fontSize6 = (x9) => sizeScale(fsize(x9));
    }
    data3.forEach((t) => {
      t[as[0]] = NaN;
      t[as[1]] = NaN;
      t[as[3]] = 0;
    });
    const words = layout.words(data3).text(_.text).size(_.size || [500, 500]).padding(_.padding || 1).spiral(_.spiral || "archimedean").rotate(_.rotate || 0).font(_.font || "sans-serif").fontStyle(_.fontStyle || "normal").fontWeight(_.fontWeight || "normal").fontSize(fontSize6).random(random).layout();
    const size = layout.size(), dx = size[0] >> 1, dy = size[1] >> 1, n = words.length;
    for (let i = 0, w8, t; i < n; ++i) {
      w8 = words[i];
      t = w8.datum;
      t[as[0]] = w8.x + dx;
      t[as[1]] = w8.y + dy;
      t[as[2]] = w8.font;
      t[as[3]] = w8.size;
      t[as[4]] = w8.style;
      t[as[5]] = w8.weight;
      t[as[6]] = w8.rotate;
    }
    return pulse2.reflow(mod).modifies(as);
  }
});

// node_modules/vega-crossfilter/build/vega-crossfilter.js
var vega_crossfilter_exports = {};
__export(vega_crossfilter_exports, {
  crossfilter: () => CrossFilter,
  resolvefilter: () => ResolveFilter
});

// node_modules/vega-crossfilter/node_modules/vega-util/build/vega-util.js
function accessor14(fn, fields, name) {
  fn.fields = fields || [];
  fn.fname = name;
  return fn;
}
function getter14(path7) {
  return path7.length === 1 ? get114(path7[0]) : getN14(path7);
}
var get114 = (field25) => function(obj) {
  return obj[field25];
};
var getN14 = (path7) => {
  const len = path7.length;
  return function(obj) {
    for (let i = 0; i < len; ++i) {
      obj = obj[path7[i]];
    }
    return obj;
  };
};
function error14(message) {
  throw Error(message);
}
function splitAccessPath14(p) {
  const path7 = [], n = p.length;
  let q = null, b6 = 0, s2 = "", i, j, c5;
  p = p + "";
  function push() {
    path7.push(s2 + p.substring(i, j));
    s2 = "";
    i = j + 1;
  }
  for (i = j = 0; j < n; ++j) {
    c5 = p[j];
    if (c5 === "\\") {
      s2 += p.substring(i, j++);
      i = j;
    } else if (c5 === q) {
      push();
      q = null;
      b6 = -1;
    } else if (q) {
      continue;
    } else if (i === b6 && c5 === '"') {
      i = j + 1;
      q = c5;
    } else if (i === b6 && c5 === "'") {
      i = j + 1;
      q = c5;
    } else if (c5 === "." && !b6) {
      if (j > i) {
        push();
      } else {
        i = j + 1;
      }
    } else if (c5 === "[") {
      if (j > i)
        push();
      b6 = i = j + 1;
    } else if (c5 === "]") {
      if (!b6)
        error14("Access path missing open bracket: " + p);
      if (b6 > 0)
        push();
      b6 = 0;
      i = j + 1;
    }
  }
  if (b6)
    error14("Access path missing closing bracket: " + p);
  if (q)
    error14("Access path missing closing quote: " + p);
  if (j > i) {
    j++;
    push();
  }
  return path7;
}
function field14(field25, name, opt) {
  const path7 = splitAccessPath14(field25);
  field25 = path7.length === 1 ? path7[0] : field25;
  return accessor14((opt && opt.get || getter14)(path7), [field25], name || field25);
}
var id14 = field14("id");
var identity18 = accessor14((_) => _, [], "identity");
var zero16 = accessor14(() => 0, [], "zero");
var one15 = accessor14(() => 1, [], "one");
var truthy14 = accessor14(() => true, [], "true");
var falsy14 = accessor14(() => false, [], "false");
var DisallowedObjectProperties14 = /* @__PURE__ */ new Set([...Object.getOwnPropertyNames(Object.prototype).filter((name) => typeof Object.prototype[name] === "function"), "__proto__"]);
var isArray14 = Array.isArray;
function extend15(_) {
  for (let x9, k3, i = 1, len = arguments.length; i < len; ++i) {
    x9 = arguments[i];
    for (k3 in x9) {
      _[k3] = x9[k3];
    }
  }
  return _;
}
function inherits13(child, parent, members) {
  const proto = child.prototype = Object.create(parent.prototype);
  Object.defineProperty(proto, "constructor", {
    value: child,
    writable: true,
    enumerable: true,
    configurable: true
  });
  return extend15(proto, members);
}

// node_modules/vega-crossfilter/build/vega-crossfilter.js
var array82 = (n) => new Uint8Array(n);
var array16 = (n) => new Uint16Array(n);
var array32 = (n) => new Uint32Array(n);
function Bitmaps() {
  let width2 = 8, data3 = [], seen = array32(0), curr = array13(0, width2), prev = array13(0, width2);
  return {
    data: () => data3,
    seen: () => seen = lengthen(seen, data3.length),
    add(array22) {
      for (let i = 0, j = data3.length, n = array22.length, t; i < n; ++i) {
        t = array22[i];
        t._index = j++;
        data3.push(t);
      }
    },
    remove(num, map13) {
      const n = data3.length, copy4 = Array(n - num), reindex = data3;
      let t, i, j;
      for (i = 0; !map13[i] && i < n; ++i) {
        copy4[i] = data3[i];
        reindex[i] = i;
      }
      for (j = i; i < n; ++i) {
        t = data3[i];
        if (!map13[i]) {
          reindex[i] = j;
          curr[j] = curr[i];
          prev[j] = prev[i];
          copy4[j] = t;
          t._index = j++;
        } else {
          reindex[i] = -1;
        }
        curr[i] = 0;
      }
      data3 = copy4;
      return reindex;
    },
    size: () => data3.length,
    curr: () => curr,
    prev: () => prev,
    reset: (k3) => prev[k3] = curr[k3],
    all: () => width2 < 257 ? 255 : width2 < 65537 ? 65535 : 4294967295,
    set(k3, one26) {
      curr[k3] |= one26;
    },
    clear(k3, one26) {
      curr[k3] &= ~one26;
    },
    resize(n, m3) {
      const k3 = curr.length;
      if (n > k3 || m3 > width2) {
        width2 = Math.max(m3, width2);
        curr = array13(n, width2, curr);
        prev = array13(n, width2);
      }
    }
  };
}
function lengthen(array22, length2, copy4) {
  if (array22.length >= length2)
    return array22;
  copy4 = copy4 || new array22.constructor(length2);
  copy4.set(array22);
  return copy4;
}
function array13(n, m3, array22) {
  const copy4 = (m3 < 257 ? array82 : m3 < 65537 ? array16 : array32)(n);
  if (array22)
    copy4.set(array22);
  return copy4;
}
function Dimension(index4, i, query) {
  const bit = 1 << i;
  return {
    one: bit,
    zero: ~bit,
    range: query.slice(),
    bisect: index4.bisect,
    index: index4.index,
    size: index4.size,
    onAdd(added, curr) {
      const dim = this, range7 = dim.bisect(dim.range, added.value), idx = added.index, lo = range7[0], hi = range7[1], n1 = idx.length;
      let i2;
      for (i2 = 0; i2 < lo; ++i2)
        curr[idx[i2]] |= bit;
      for (i2 = hi; i2 < n1; ++i2)
        curr[idx[i2]] |= bit;
      return dim;
    }
  };
}
function SortedIndex() {
  let index4 = array32(0), value7 = [], size = 0;
  function insert2(key4, data3, base) {
    if (!data3.length)
      return [];
    const n0 = size, n1 = data3.length, addi = array32(n1);
    let addv = Array(n1), oldv, oldi, i;
    for (i = 0; i < n1; ++i) {
      addv[i] = key4(data3[i]);
      addi[i] = i;
    }
    addv = sort2(addv, addi);
    if (n0) {
      oldv = value7;
      oldi = index4;
      value7 = Array(n0 + n1);
      index4 = array32(n0 + n1);
      merge4(base, oldv, oldi, n0, addv, addi, n1, value7, index4);
    } else {
      if (base > 0)
        for (i = 0; i < n1; ++i) {
          addi[i] += base;
        }
      value7 = addv;
      index4 = addi;
    }
    size = n0 + n1;
    return {
      index: addi,
      value: addv
    };
  }
  function remove2(num, map13) {
    const n = size;
    let idx, i, j;
    for (i = 0; !map13[index4[i]] && i < n; ++i)
      ;
    for (j = i; i < n; ++i) {
      if (!map13[idx = index4[i]]) {
        index4[j] = idx;
        value7[j] = value7[i];
        ++j;
      }
    }
    size = n - num;
  }
  function reindex(map13) {
    for (let i = 0, n = size; i < n; ++i) {
      index4[i] = map13[index4[i]];
    }
  }
  function bisect2(range7, array22) {
    let n;
    if (array22) {
      n = array22.length;
    } else {
      array22 = value7;
      n = size;
    }
    return [bisectLeft(array22, range7[0], 0, n), bisectRight(array22, range7[1], 0, n)];
  }
  return {
    insert: insert2,
    remove: remove2,
    bisect: bisect2,
    reindex,
    index: () => index4,
    size: () => size
  };
}
function sort2(values7, index4) {
  values7.sort.call(index4, (a4, b6) => {
    const x9 = values7[a4], y9 = values7[b6];
    return x9 < y9 ? -1 : x9 > y9 ? 1 : 0;
  });
  return permute(values7, index4);
}
function merge4(base, value0, index0, n0, value1, index1, n1, value7, index4) {
  let i0 = 0, i1 = 0, i;
  for (i = 0; i0 < n0 && i1 < n1; ++i) {
    if (value0[i0] < value1[i1]) {
      value7[i] = value0[i0];
      index4[i] = index0[i0++];
    } else {
      value7[i] = value1[i1];
      index4[i] = index1[i1++] + base;
    }
  }
  for (; i0 < n0; ++i0, ++i) {
    value7[i] = value0[i0];
    index4[i] = index0[i0];
  }
  for (; i1 < n1; ++i1, ++i) {
    value7[i] = value1[i1];
    index4[i] = index1[i1] + base;
  }
}
function CrossFilter(params2) {
  Transform.call(this, Bitmaps(), params2);
  this._indices = null;
  this._dims = null;
}
CrossFilter.Definition = {
  "type": "CrossFilter",
  "metadata": {},
  "params": [{
    "name": "fields",
    "type": "field",
    "array": true,
    "required": true
  }, {
    "name": "query",
    "type": "array",
    "array": true,
    "required": true,
    "content": {
      "type": "number",
      "array": true,
      "length": 2
    }
  }]
};
inherits13(CrossFilter, Transform, {
  transform(_, pulse2) {
    if (!this._dims) {
      return this.init(_, pulse2);
    } else {
      var init2 = _.modified("fields") || _.fields.some((f) => pulse2.modified(f.fields));
      return init2 ? this.reinit(_, pulse2) : this.eval(_, pulse2);
    }
  },
  init(_, pulse2) {
    const fields = _.fields, query = _.query, indices = this._indices = {}, dims = this._dims = [], m3 = query.length;
    let i = 0, key4, index4;
    for (; i < m3; ++i) {
      key4 = fields[i].fname;
      index4 = indices[key4] || (indices[key4] = SortedIndex());
      dims.push(Dimension(index4, i, query[i]));
    }
    return this.eval(_, pulse2);
  },
  reinit(_, pulse2) {
    const output3 = pulse2.materialize().fork(), fields = _.fields, query = _.query, indices = this._indices, dims = this._dims, bits = this.value, curr = bits.curr(), prev = bits.prev(), all = bits.all(), out = output3.rem = output3.add, mod = output3.mod, m3 = query.length, adds = {};
    let add10, index4, key4, mods, remMap, modMap, i, n, f;
    prev.set(curr);
    if (pulse2.rem.length) {
      remMap = this.remove(_, pulse2, output3);
    }
    if (pulse2.add.length) {
      bits.add(pulse2.add);
    }
    if (pulse2.mod.length) {
      modMap = {};
      for (mods = pulse2.mod, i = 0, n = mods.length; i < n; ++i) {
        modMap[mods[i]._index] = 1;
      }
    }
    for (i = 0; i < m3; ++i) {
      f = fields[i];
      if (!dims[i] || _.modified("fields", i) || pulse2.modified(f.fields)) {
        key4 = f.fname;
        if (!(add10 = adds[key4])) {
          indices[key4] = index4 = SortedIndex();
          adds[key4] = add10 = index4.insert(f, pulse2.source, 0);
        }
        dims[i] = Dimension(index4, i, query[i]).onAdd(add10, curr);
      }
    }
    for (i = 0, n = bits.data().length; i < n; ++i) {
      if (remMap[i]) {
        continue;
      } else if (prev[i] !== curr[i]) {
        out.push(i);
      } else if (modMap[i] && curr[i] !== all) {
        mod.push(i);
      }
    }
    bits.mask = (1 << m3) - 1;
    return output3;
  },
  eval(_, pulse2) {
    const output3 = pulse2.materialize().fork(), m3 = this._dims.length;
    let mask = 0;
    if (pulse2.rem.length) {
      this.remove(_, pulse2, output3);
      mask |= (1 << m3) - 1;
    }
    if (_.modified("query") && !_.modified("fields")) {
      mask |= this.update(_, pulse2, output3);
    }
    if (pulse2.add.length) {
      this.insert(_, pulse2, output3);
      mask |= (1 << m3) - 1;
    }
    if (pulse2.mod.length) {
      this.modify(pulse2, output3);
      mask |= (1 << m3) - 1;
    }
    this.value.mask = mask;
    return output3;
  },
  insert(_, pulse2, output3) {
    const tuples = pulse2.add, bits = this.value, dims = this._dims, indices = this._indices, fields = _.fields, adds = {}, out = output3.add, n = bits.size() + tuples.length, m3 = dims.length;
    let k3 = bits.size(), j, key4, add10;
    bits.resize(n, m3);
    bits.add(tuples);
    const curr = bits.curr(), prev = bits.prev(), all = bits.all();
    for (j = 0; j < m3; ++j) {
      key4 = fields[j].fname;
      add10 = adds[key4] || (adds[key4] = indices[key4].insert(fields[j], tuples, k3));
      dims[j].onAdd(add10, curr);
    }
    for (; k3 < n; ++k3) {
      prev[k3] = all;
      if (curr[k3] !== all)
        out.push(k3);
    }
  },
  modify(pulse2, output3) {
    const out = output3.mod, bits = this.value, curr = bits.curr(), all = bits.all(), tuples = pulse2.mod;
    let i, n, k3;
    for (i = 0, n = tuples.length; i < n; ++i) {
      k3 = tuples[i]._index;
      if (curr[k3] !== all)
        out.push(k3);
    }
  },
  remove(_, pulse2, output3) {
    const indices = this._indices, bits = this.value, curr = bits.curr(), prev = bits.prev(), all = bits.all(), map13 = {}, out = output3.rem, tuples = pulse2.rem;
    let i, n, k3, f;
    for (i = 0, n = tuples.length; i < n; ++i) {
      k3 = tuples[i]._index;
      map13[k3] = 1;
      prev[k3] = f = curr[k3];
      curr[k3] = all;
      if (f !== all)
        out.push(k3);
    }
    for (k3 in indices) {
      indices[k3].remove(n, map13);
    }
    this.reindex(pulse2, n, map13);
    return map13;
  },
  // reindex filters and indices after propagation completes
  reindex(pulse2, num, map13) {
    const indices = this._indices, bits = this.value;
    pulse2.runAfter(() => {
      const indexMap = bits.remove(num, map13);
      for (const key4 in indices)
        indices[key4].reindex(indexMap);
    });
  },
  update(_, pulse2, output3) {
    const dims = this._dims, query = _.query, stamp = pulse2.stamp, m3 = dims.length;
    let mask = 0, i, q;
    output3.filters = 0;
    for (q = 0; q < m3; ++q) {
      if (_.modified("query", q)) {
        i = q;
        ++mask;
      }
    }
    if (mask === 1) {
      mask = dims[i].one;
      this.incrementOne(dims[i], query[i], output3.add, output3.rem);
    } else {
      for (q = 0, mask = 0; q < m3; ++q) {
        if (!_.modified("query", q))
          continue;
        mask |= dims[q].one;
        this.incrementAll(dims[q], query[q], stamp, output3.add);
        output3.rem = output3.add;
      }
    }
    return mask;
  },
  incrementAll(dim, query, stamp, out) {
    const bits = this.value, seen = bits.seen(), curr = bits.curr(), prev = bits.prev(), index4 = dim.index(), old = dim.bisect(dim.range), range7 = dim.bisect(query), lo1 = range7[0], hi1 = range7[1], lo0 = old[0], hi0 = old[1], one26 = dim.one;
    let i, j, k3;
    if (lo1 < lo0) {
      for (i = lo1, j = Math.min(lo0, hi1); i < j; ++i) {
        k3 = index4[i];
        if (seen[k3] !== stamp) {
          prev[k3] = curr[k3];
          seen[k3] = stamp;
          out.push(k3);
        }
        curr[k3] ^= one26;
      }
    } else if (lo1 > lo0) {
      for (i = lo0, j = Math.min(lo1, hi0); i < j; ++i) {
        k3 = index4[i];
        if (seen[k3] !== stamp) {
          prev[k3] = curr[k3];
          seen[k3] = stamp;
          out.push(k3);
        }
        curr[k3] ^= one26;
      }
    }
    if (hi1 > hi0) {
      for (i = Math.max(lo1, hi0), j = hi1; i < j; ++i) {
        k3 = index4[i];
        if (seen[k3] !== stamp) {
          prev[k3] = curr[k3];
          seen[k3] = stamp;
          out.push(k3);
        }
        curr[k3] ^= one26;
      }
    } else if (hi1 < hi0) {
      for (i = Math.max(lo0, hi1), j = hi0; i < j; ++i) {
        k3 = index4[i];
        if (seen[k3] !== stamp) {
          prev[k3] = curr[k3];
          seen[k3] = stamp;
          out.push(k3);
        }
        curr[k3] ^= one26;
      }
    }
    dim.range = query.slice();
  },
  incrementOne(dim, query, add10, rem2) {
    const bits = this.value, curr = bits.curr(), index4 = dim.index(), old = dim.bisect(dim.range), range7 = dim.bisect(query), lo1 = range7[0], hi1 = range7[1], lo0 = old[0], hi0 = old[1], one26 = dim.one;
    let i, j, k3;
    if (lo1 < lo0) {
      for (i = lo1, j = Math.min(lo0, hi1); i < j; ++i) {
        k3 = index4[i];
        curr[k3] ^= one26;
        add10.push(k3);
      }
    } else if (lo1 > lo0) {
      for (i = lo0, j = Math.min(lo1, hi0); i < j; ++i) {
        k3 = index4[i];
        curr[k3] ^= one26;
        rem2.push(k3);
      }
    }
    if (hi1 > hi0) {
      for (i = Math.max(lo1, hi0), j = hi1; i < j; ++i) {
        k3 = index4[i];
        curr[k3] ^= one26;
        add10.push(k3);
      }
    } else if (hi1 < hi0) {
      for (i = Math.max(lo0, hi1), j = hi0; i < j; ++i) {
        k3 = index4[i];
        curr[k3] ^= one26;
        rem2.push(k3);
      }
    }
    dim.range = query.slice();
  }
});
function ResolveFilter(params2) {
  Transform.call(this, null, params2);
}
ResolveFilter.Definition = {
  "type": "ResolveFilter",
  "metadata": {},
  "params": [{
    "name": "ignore",
    "type": "number",
    "required": true,
    "description": "A bit mask indicating which filters to ignore."
  }, {
    "name": "filter",
    "type": "object",
    "required": true,
    "description": "Per-tuple filter bitmaps from a CrossFilter transform."
  }]
};
inherits13(ResolveFilter, Transform, {
  transform(_, pulse2) {
    const ignore = ~(_.ignore || 0), bitmap = _.filter, mask = bitmap.mask;
    if ((mask & ignore) === 0)
      return pulse2.StopPropagation;
    const output3 = pulse2.fork(pulse2.ALL), data3 = bitmap.data(), curr = bitmap.curr(), prev = bitmap.prev(), pass = (k3) => !(curr[k3] & ignore) ? data3[k3] : null;
    output3.filter(output3.MOD, pass);
    if (!(mask & mask - 1)) {
      output3.filter(output3.ADD, pass);
      output3.filter(output3.REM, (k3) => (curr[k3] & ignore) === mask ? data3[k3] : null);
    } else {
      output3.filter(output3.ADD, (k3) => {
        const c5 = curr[k3] & ignore, f = !c5 && c5 ^ prev[k3] & ignore;
        return f ? data3[k3] : null;
      });
      output3.filter(output3.REM, (k3) => {
        const c5 = curr[k3] & ignore, f = c5 && !(c5 ^ (c5 ^ prev[k3] & ignore));
        return f ? data3[k3] : null;
      });
    }
    return output3.filter(output3.SOURCE, (t) => pass(t._index));
  }
});

// node_modules/vega/node_modules/vega-time/build/vega-time.js
var YEAR8 = "year";
var QUARTER8 = "quarter";
var MONTH8 = "month";
var WEEK8 = "week";
var DATE8 = "date";
var DAY8 = "day";
var DAYOFYEAR8 = "dayofyear";
var HOURS8 = "hours";
var MINUTES8 = "minutes";
var SECONDS8 = "seconds";
var MILLISECONDS8 = "milliseconds";
var TIME_UNITS8 = [YEAR8, QUARTER8, MONTH8, WEEK8, DATE8, DAY8, DAYOFYEAR8, HOURS8, MINUTES8, SECONDS8, MILLISECONDS8];
var UNITS8 = TIME_UNITS8.reduce((o, u4, i) => (o[u4] = 1 + i, o), {});
function timeUnits2(units) {
  const u4 = array(units).slice(), m3 = {};
  if (!u4.length)
    error("Missing time unit.");
  u4.forEach((unit2) => {
    if (has(UNITS8, unit2)) {
      m3[unit2] = 1;
    } else {
      error(`Invalid time unit: ${unit2}.`);
    }
  });
  const numTypes = (m3[WEEK8] || m3[DAY8] ? 1 : 0) + (m3[QUARTER8] || m3[MONTH8] || m3[DATE8] ? 1 : 0) + (m3[DAYOFYEAR8] ? 1 : 0);
  if (numTypes > 1) {
    error(`Incompatible time units: ${units}`);
  }
  u4.sort((a4, b6) => UNITS8[a4] - UNITS8[b6]);
  return u4;
}
var defaultSpecifiers8 = {
  [YEAR8]: "%Y ",
  [QUARTER8]: "Q%q ",
  [MONTH8]: "%b ",
  [DATE8]: "%d ",
  [WEEK8]: "W%U ",
  [DAY8]: "%a ",
  [DAYOFYEAR8]: "%j ",
  [HOURS8]: "%H:00",
  [MINUTES8]: "00:%M",
  [SECONDS8]: ":%S",
  [MILLISECONDS8]: ".%L",
  [`${YEAR8}-${MONTH8}`]: "%Y-%m ",
  [`${YEAR8}-${MONTH8}-${DATE8}`]: "%Y-%m-%d ",
  [`${HOURS8}-${MINUTES8}`]: "%H:%M"
};
function timeUnitSpecifier(units, specifiers) {
  const s2 = extend({}, defaultSpecifiers8, specifiers), u4 = timeUnits2(units), n = u4.length;
  let fmt = "", start = 0, end, key4;
  for (start = 0; start < n; ) {
    for (end = u4.length; end > start; --end) {
      key4 = u4.slice(start, end).join("-");
      if (s2[key4] != null) {
        fmt += s2[key4];
        start = end;
        break;
      }
    }
  }
  return fmt.trim();
}
var t010 = /* @__PURE__ */ new Date();
function localYear8(y9) {
  t010.setFullYear(y9);
  t010.setMonth(0);
  t010.setDate(1);
  t010.setHours(0, 0, 0, 0);
  return t010;
}
function dayofyear(d) {
  return localDayOfYear8(new Date(d));
}
function week(d) {
  return localWeekNum8(new Date(d));
}
function localDayOfYear8(d) {
  return timeDay.count(localYear8(d.getFullYear()) - 1, d);
}
function localWeekNum8(d) {
  return timeSunday.count(localYear8(d.getFullYear()) - 1, d);
}
function localFirst8(y9) {
  return localYear8(y9).getDay();
}
function localDate3(y9, m3, d, H, M2, S, L) {
  if (0 <= y9 && y9 < 100) {
    const date2 = new Date(-1, m3, d, H, M2, S, L);
    date2.setFullYear(y9);
    return date2;
  }
  return new Date(y9, m3, d, H, M2, S, L);
}
function utcdayofyear(d) {
  return utcDayOfYear8(new Date(d));
}
function utcweek(d) {
  return utcWeekNum8(new Date(d));
}
function utcDayOfYear8(d) {
  const y9 = Date.UTC(d.getUTCFullYear(), 0, 1);
  return utcDay.count(y9 - 1, d);
}
function utcWeekNum8(d) {
  const y9 = Date.UTC(d.getUTCFullYear(), 0, 1);
  return utcSunday.count(y9 - 1, d);
}
function utcFirst8(y9) {
  t010.setTime(Date.UTC(y9, 0, 1));
  return t010.getUTCDay();
}
function utcDate3(y9, m3, d, H, M2, S, L) {
  if (0 <= y9 && y9 < 100) {
    const date2 = new Date(Date.UTC(-1, m3, d, H, M2, S, L));
    date2.setUTCFullYear(d.y);
    return date2;
  }
  return new Date(Date.UTC(y9, m3, d, H, M2, S, L));
}
function floor3(units, step, get23, inv, newDate2) {
  const s2 = step || 1, b6 = peek(units), _ = (unit2, p, key4) => {
    key4 = key4 || unit2;
    return getUnit2(get23[key4], inv[key4], unit2 === b6 && s2, p);
  };
  const t = /* @__PURE__ */ new Date(), u4 = toSet(units), y9 = u4[YEAR8] ? _(YEAR8) : constant(2012), m3 = u4[MONTH8] ? _(MONTH8) : u4[QUARTER8] ? _(QUARTER8) : zero, d = u4[WEEK8] && u4[DAY8] ? _(DAY8, 1, WEEK8 + DAY8) : u4[WEEK8] ? _(WEEK8, 1) : u4[DAY8] ? _(DAY8, 1) : u4[DATE8] ? _(DATE8, 1) : u4[DAYOFYEAR8] ? _(DAYOFYEAR8, 1) : one, H = u4[HOURS8] ? _(HOURS8) : zero, M2 = u4[MINUTES8] ? _(MINUTES8) : zero, S = u4[SECONDS8] ? _(SECONDS8) : zero, L = u4[MILLISECONDS8] ? _(MILLISECONDS8) : zero;
  return function(v2) {
    t.setTime(+v2);
    const year = y9(t);
    return newDate2(year, m3(t), d(t, year), H(t), M2(t), S(t), L(t));
  };
}
function getUnit2(f, inv, step, phase) {
  const u4 = step <= 1 ? f : phase ? (d, y9) => phase + step * Math.floor((f(d, y9) - phase) / step) : (d, y9) => step * Math.floor(f(d, y9) / step);
  return inv ? (d, y9) => inv(u4(d, y9), y9) : u4;
}
function weekday8(week3, day, firstDay) {
  return day + week3 * 7 - (firstDay + 6) % 7;
}
var localGet8 = {
  [YEAR8]: (d) => d.getFullYear(),
  [QUARTER8]: (d) => Math.floor(d.getMonth() / 3),
  [MONTH8]: (d) => d.getMonth(),
  [DATE8]: (d) => d.getDate(),
  [HOURS8]: (d) => d.getHours(),
  [MINUTES8]: (d) => d.getMinutes(),
  [SECONDS8]: (d) => d.getSeconds(),
  [MILLISECONDS8]: (d) => d.getMilliseconds(),
  [DAYOFYEAR8]: (d) => localDayOfYear8(d),
  [WEEK8]: (d) => localWeekNum8(d),
  [WEEK8 + DAY8]: (d, y9) => weekday8(localWeekNum8(d), d.getDay(), localFirst8(y9)),
  [DAY8]: (d, y9) => weekday8(1, d.getDay(), localFirst8(y9))
};
var localInv8 = {
  [QUARTER8]: (q) => 3 * q,
  [WEEK8]: (w8, y9) => weekday8(w8, 0, localFirst8(y9))
};
function timeFloor2(units, step) {
  return floor3(units, step || 1, localGet8, localInv8, localDate3);
}
var utcGet8 = {
  [YEAR8]: (d) => d.getUTCFullYear(),
  [QUARTER8]: (d) => Math.floor(d.getUTCMonth() / 3),
  [MONTH8]: (d) => d.getUTCMonth(),
  [DATE8]: (d) => d.getUTCDate(),
  [HOURS8]: (d) => d.getUTCHours(),
  [MINUTES8]: (d) => d.getUTCMinutes(),
  [SECONDS8]: (d) => d.getUTCSeconds(),
  [MILLISECONDS8]: (d) => d.getUTCMilliseconds(),
  [DAYOFYEAR8]: (d) => utcDayOfYear8(d),
  [WEEK8]: (d) => utcWeekNum8(d),
  [DAY8]: (d, y9) => weekday8(1, d.getUTCDay(), utcFirst8(y9)),
  [WEEK8 + DAY8]: (d, y9) => weekday8(utcWeekNum8(d), d.getUTCDay(), utcFirst8(y9))
};
var utcInv8 = {
  [QUARTER8]: (q) => 3 * q,
  [WEEK8]: (w8, y9) => weekday8(w8, 0, utcFirst8(y9))
};
function utcFloor2(units, step) {
  return floor3(units, step || 1, utcGet8, utcInv8, utcDate3);
}
var timeIntervals8 = {
  [YEAR8]: timeYear,
  [QUARTER8]: timeMonth.every(3),
  [MONTH8]: timeMonth,
  [WEEK8]: timeSunday,
  [DATE8]: timeDay,
  [DAY8]: timeDay,
  [DAYOFYEAR8]: timeDay,
  [HOURS8]: timeHour,
  [MINUTES8]: timeMinute,
  [SECONDS8]: second,
  [MILLISECONDS8]: millisecond
};
var utcIntervals8 = {
  [YEAR8]: utcYear,
  [QUARTER8]: utcMonth.every(3),
  [MONTH8]: utcMonth,
  [WEEK8]: utcSunday,
  [DATE8]: utcDay,
  [DAY8]: utcDay,
  [DAYOFYEAR8]: utcDay,
  [HOURS8]: utcHour,
  [MINUTES8]: utcMinute,
  [SECONDS8]: second,
  [MILLISECONDS8]: millisecond
};
function timeInterval9(unit2) {
  return timeIntervals8[unit2];
}
function utcInterval8(unit2) {
  return utcIntervals8[unit2];
}
function offset3(ival, date2, step) {
  return ival ? ival.offset(date2, step) : void 0;
}
function timeOffset(unit2, date2, step) {
  return offset3(timeInterval9(unit2), date2, step);
}
function utcOffset(unit2, date2, step) {
  return offset3(utcInterval8(unit2), date2, step);
}
function sequence(ival, start, stop2, step) {
  return ival ? ival.range(start, stop2, step) : void 0;
}
function timeSequence(unit2, start, stop2, step) {
  return sequence(timeInterval9(unit2), start, stop2, step);
}
function utcSequence(unit2, start, stop2, step) {
  return sequence(utcInterval8(unit2), start, stop2, step);
}
var durationSecond9 = 1e3;
var durationMinute9 = durationSecond9 * 60;
var durationHour9 = durationMinute9 * 60;
var durationDay9 = durationHour9 * 24;
var durationWeek9 = durationDay9 * 7;
var durationMonth9 = durationDay9 * 30;
var durationYear9 = durationDay9 * 365;
var Milli8 = [YEAR8, MONTH8, DATE8, HOURS8, MINUTES8, SECONDS8, MILLISECONDS8];
var Seconds8 = Milli8.slice(0, -1);
var Minutes8 = Seconds8.slice(0, -1);
var Hours8 = Minutes8.slice(0, -1);
var Day8 = Hours8.slice(0, -1);
var Week8 = [YEAR8, WEEK8];
var Month8 = [YEAR8, MONTH8];
var Year8 = [YEAR8];
var intervals8 = [[Seconds8, 1, durationSecond9], [Seconds8, 5, 5 * durationSecond9], [Seconds8, 15, 15 * durationSecond9], [Seconds8, 30, 30 * durationSecond9], [Minutes8, 1, durationMinute9], [Minutes8, 5, 5 * durationMinute9], [Minutes8, 15, 15 * durationMinute9], [Minutes8, 30, 30 * durationMinute9], [Hours8, 1, durationHour9], [Hours8, 3, 3 * durationHour9], [Hours8, 6, 6 * durationHour9], [Hours8, 12, 12 * durationHour9], [Day8, 1, durationDay9], [Week8, 1, durationWeek9], [Month8, 1, durationMonth9], [Month8, 3, 3 * durationMonth9], [Year8, 1, durationYear9]];
function bin4(opt) {
  const ext = opt.extent, max5 = opt.maxbins || 40, target2 = Math.abs(span(ext)) / max5;
  let i = bisector((i2) => i2[2]).right(intervals8, target2), units, step;
  if (i === intervals8.length) {
    units = Year8, step = tickStep(ext[0] / durationYear9, ext[1] / durationYear9, max5);
  } else if (i) {
    i = intervals8[target2 / intervals8[i - 1][2] < intervals8[i][2] / target2 ? i - 1 : i];
    units = i[0];
    step = i[1];
  } else {
    units = Milli8;
    step = Math.max(tickStep(ext[0], ext[1], max5), 1);
  }
  return {
    units,
    step
  };
}

// node_modules/vega/node_modules/vega-format/build/vega-format.js
function memoize4(method10) {
  const cache2 = {};
  return (spec) => cache2[spec] || (cache2[spec] = method10(spec));
}
function trimZeroes4(numberFormat2, decimalChar) {
  return (x9) => {
    const str = numberFormat2(x9), dec = str.indexOf(decimalChar);
    if (dec < 0)
      return str;
    let idx = rightmostDigit4(str, dec);
    const end = idx < str.length ? str.slice(idx) : "";
    while (--idx > dec)
      if (str[idx] !== "0") {
        ++idx;
        break;
      }
    return str.slice(0, idx) + end;
  };
}
function rightmostDigit4(str, dec) {
  let i = str.lastIndexOf("e"), c5;
  if (i > 0)
    return i;
  for (i = str.length; --i > dec; ) {
    c5 = str.charCodeAt(i);
    if (c5 >= 48 && c5 <= 57)
      return i + 1;
  }
}
function numberLocale4(locale5) {
  const format14 = memoize4(locale5.format), formatPrefix2 = locale5.formatPrefix;
  return {
    format: format14,
    formatPrefix: formatPrefix2,
    formatFloat(spec) {
      const s2 = formatSpecifier(spec || ",");
      if (s2.precision == null) {
        s2.precision = 12;
        switch (s2.type) {
          case "%":
            s2.precision -= 2;
            break;
          case "e":
            s2.precision -= 1;
            break;
        }
        return trimZeroes4(
          format14(s2),
          // number format
          format14(".1f")(1)[1]
          // decimal point character
        );
      } else {
        return format14(s2);
      }
    },
    formatSpan(start, stop2, count3, specifier) {
      specifier = formatSpecifier(specifier == null ? ",f" : specifier);
      const step = tickStep(start, stop2, count3), value7 = Math.max(Math.abs(start), Math.abs(stop2));
      let precision;
      if (specifier.precision == null) {
        switch (specifier.type) {
          case "s": {
            if (!isNaN(precision = precisionPrefix_default(step, value7))) {
              specifier.precision = precision;
            }
            return formatPrefix2(specifier, value7);
          }
          case "":
          case "e":
          case "g":
          case "p":
          case "r": {
            if (!isNaN(precision = precisionRound_default(step, value7))) {
              specifier.precision = precision - (specifier.type === "e");
            }
            break;
          }
          case "f":
          case "%": {
            if (!isNaN(precision = precisionFixed_default(step))) {
              specifier.precision = precision - (specifier.type === "%") * 2;
            }
            break;
          }
        }
      }
      return format14(specifier);
    }
  };
}
var defaultNumberLocale4;
resetNumberFormatDefaultLocale4();
function resetNumberFormatDefaultLocale4() {
  return defaultNumberLocale4 = numberLocale4({
    format,
    formatPrefix
  });
}
function numberFormatLocale2(definition3) {
  return numberLocale4(locale_default(definition3));
}
function numberFormatDefaultLocale2(definition3) {
  return arguments.length ? defaultNumberLocale4 = numberFormatLocale2(definition3) : defaultNumberLocale4;
}
function timeMultiFormat4(format14, interval3, spec) {
  spec = spec || {};
  if (!isObject(spec)) {
    error(`Invalid time multi-format specifier: ${spec}`);
  }
  const second2 = interval3(SECONDS8), minute = interval3(MINUTES8), hour = interval3(HOURS8), day = interval3(DATE8), week3 = interval3(WEEK8), month = interval3(MONTH8), quarter3 = interval3(QUARTER8), year = interval3(YEAR8), L = format14(spec[MILLISECONDS8] || ".%L"), S = format14(spec[SECONDS8] || ":%S"), M2 = format14(spec[MINUTES8] || "%I:%M"), H = format14(spec[HOURS8] || "%I %p"), d = format14(spec[DATE8] || spec[DAY8] || "%a %d"), w8 = format14(spec[WEEK8] || "%b %d"), m3 = format14(spec[MONTH8] || "%B"), q = format14(spec[QUARTER8] || "%B"), y9 = format14(spec[YEAR8] || "%Y");
  return (date2) => (second2(date2) < date2 ? L : minute(date2) < date2 ? S : hour(date2) < date2 ? M2 : day(date2) < date2 ? H : month(date2) < date2 ? week3(date2) < date2 ? d : w8 : year(date2) < date2 ? quarter3(date2) < date2 ? m3 : q : y9)(date2);
}
function timeLocale4(locale5) {
  const timeFormat4 = memoize4(locale5.format), utcFormat3 = memoize4(locale5.utcFormat);
  return {
    timeFormat: (spec) => isString(spec) ? timeFormat4(spec) : timeMultiFormat4(timeFormat4, timeInterval9, spec),
    utcFormat: (spec) => isString(spec) ? utcFormat3(spec) : timeMultiFormat4(utcFormat3, utcInterval8, spec),
    timeParse: memoize4(locale5.parse),
    utcParse: memoize4(locale5.utcParse)
  };
}
var defaultTimeLocale4;
resetTimeFormatDefaultLocale4();
function resetTimeFormatDefaultLocale4() {
  return defaultTimeLocale4 = timeLocale4({
    format: timeFormat,
    parse: timeParse,
    utcFormat,
    utcParse
  });
}
function timeFormatLocale2(definition3) {
  return timeLocale4(formatLocale(definition3));
}
function timeFormatDefaultLocale4(definition3) {
  return arguments.length ? defaultTimeLocale4 = timeFormatLocale2(definition3) : defaultTimeLocale4;
}
var createLocale2 = (number12, time3) => extend({}, number12, time3);
function locale3(numberSpec, timeSpec) {
  const number12 = numberSpec ? numberFormatLocale2(numberSpec) : numberFormatDefaultLocale2();
  const time3 = timeSpec ? timeFormatLocale2(timeSpec) : timeFormatDefaultLocale4();
  return createLocale2(number12, time3);
}
function defaultLocale4(numberSpec, timeSpec) {
  const args = arguments.length;
  if (args && args !== 2) {
    error("defaultLocale expects either zero or two arguments.");
  }
  return args ? createLocale2(numberFormatDefaultLocale2(numberSpec), timeFormatDefaultLocale4(timeSpec)) : createLocale2(numberFormatDefaultLocale2(), timeFormatDefaultLocale4());
}
function resetDefaultLocale() {
  resetNumberFormatDefaultLocale4();
  resetTimeFormatDefaultLocale4();
  return defaultLocale4();
}

// node_modules/vega/node_modules/vega-loader/build/vega-loader.browser.js
var protocol_re4 = /^(data:|([A-Za-z]+:)?\/\/)/;
var allowed_re4 = /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp|file|data):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i;
var whitespace_re4 = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205f\u3000]/g;
var fileProtocol4 = "file://";
function loaderFactory4(fs) {
  return (options) => ({
    options: options || {},
    sanitize: sanitize4,
    load: load4,
    fileAccess: false,
    file: fileLoader4(),
    http: httpLoader4
  });
}
async function load4(uri, options) {
  const opt = await this.sanitize(uri, options), url = opt.href;
  return opt.localFile ? this.file(url) : this.http(url, options == null ? void 0 : options.http);
}
async function sanitize4(uri, options) {
  options = extend({}, this.options, options);
  const fileAccess = this.fileAccess, result = {
    href: null
  };
  let isFile, loadFile, base;
  const isAllowed = allowed_re4.test(uri.replace(whitespace_re4, ""));
  if (uri == null || typeof uri !== "string" || !isAllowed) {
    error("Sanitize failure, invalid URI: " + $(uri));
  }
  const hasProtocol = protocol_re4.test(uri);
  if ((base = options.baseURL) && !hasProtocol) {
    if (!uri.startsWith("/") && !base.endsWith("/")) {
      uri = "/" + uri;
    }
    uri = base + uri;
  }
  loadFile = (isFile = uri.startsWith(fileProtocol4)) || options.mode === "file" || options.mode !== "http" && !hasProtocol && fileAccess;
  if (isFile) {
    uri = uri.slice(fileProtocol4.length);
  } else if (uri.startsWith("//")) {
    if (options.defaultProtocol === "file") {
      uri = uri.slice(2);
      loadFile = true;
    } else {
      uri = (options.defaultProtocol || "http") + ":" + uri;
    }
  }
  Object.defineProperty(result, "localFile", {
    value: !!loadFile
  });
  result.href = uri;
  if (options.target) {
    result.target = options.target + "";
  }
  if (options.rel) {
    result.rel = options.rel + "";
  }
  if (options.context === "image" && options.crossOrigin) {
    result.crossOrigin = options.crossOrigin + "";
  }
  return result;
}
function fileLoader4(fs) {
  return fileReject4;
}
async function fileReject4() {
  error("No file system access.");
}
async function httpLoader4(url, options) {
  const opt = extend({}, this.options.http, options), type7 = options && options.response, response = await fetch(url, opt);
  return !response.ok ? error(response.status + "" + response.statusText) : isFunction(response[type7]) ? response[type7]() : response.text();
}
var isValid2 = (_) => _ != null && _ === _;
var isBoolean3 = (_) => _ === "true" || _ === "false" || _ === true || _ === false;
var isDate4 = (_) => !Number.isNaN(Date.parse(_));
var isNumber10 = (_) => !Number.isNaN(+_) && !(_ instanceof Date);
var isInteger2 = (_) => isNumber10(_) && Number.isInteger(+_);
var typeParsers2 = {
  boolean: toBoolean,
  integer: toNumber,
  number: toNumber,
  date: toDate,
  string: toString,
  unknown: identity
};
var typeTests2 = [isBoolean3, isInteger2, isNumber10, isDate4];
var typeList2 = ["boolean", "integer", "number", "date"];
function inferType2(values7, field25) {
  if (!values7 || !values7.length)
    return "unknown";
  const n = values7.length, m3 = typeTests2.length, a4 = typeTests2.map((_, i) => i + 1);
  for (let i = 0, t = 0, j, value7; i < n; ++i) {
    value7 = field25 ? values7[i][field25] : values7[i];
    for (j = 0; j < m3; ++j) {
      if (a4[j] && isValid2(value7) && !typeTests2[j](value7)) {
        a4[j] = 0;
        ++t;
        if (t === typeTests2.length)
          return "string";
      }
    }
  }
  return typeList2[a4.reduce((u4, v2) => u4 === 0 ? v2 : u4, 0) - 1];
}
function inferTypes2(data3, fields) {
  return fields.reduce((types, field25) => {
    types[field25] = inferType2(data3, field25);
    return types;
  }, {});
}
function delimitedFormat4(delimiter) {
  const parse12 = function(data3, format14) {
    const delim = {
      delimiter
    };
    return dsv4(data3, format14 ? extend(format14, delim) : delim);
  };
  parse12.responseType = "text";
  return parse12;
}
function dsv4(data3, format14) {
  if (format14.header) {
    data3 = format14.header.map($).join(format14.delimiter) + "\n" + data3;
  }
  return dsv_default(format14.delimiter).parse(data3 + "");
}
dsv4.responseType = "text";
function isBuffer4(_) {
  return typeof Buffer === "function" && isFunction(Buffer.isBuffer) ? Buffer.isBuffer(_) : false;
}
function json4(data3, format14) {
  const prop = format14 && format14.property ? field(format14.property) : identity;
  return isObject(data3) && !isBuffer4(data3) ? parseJSON4(prop(data3), format14) : prop(JSON.parse(data3));
}
json4.responseType = "json";
function parseJSON4(data3, format14) {
  if (!isArray(data3) && isIterable(data3)) {
    data3 = [...data3];
  }
  return format14 && format14.copy ? JSON.parse(JSON.stringify(data3)) : data3;
}
var filters4 = {
  interior: (a4, b6) => a4 !== b6,
  exterior: (a4, b6) => a4 === b6
};
function topojson4(data3, format14) {
  let method10, object2, property2, filter4;
  data3 = json4(data3, format14);
  if (format14 && format14.feature) {
    method10 = feature_default;
    property2 = format14.feature;
  } else if (format14 && format14.mesh) {
    method10 = mesh_default;
    property2 = format14.mesh;
    filter4 = filters4[format14.filter];
  } else {
    error("Missing TopoJSON feature or mesh parameter.");
  }
  object2 = (object2 = data3.objects[property2]) ? method10(data3, object2, filter4) : error("Invalid TopoJSON object: " + property2);
  return object2 && object2.features || [object2];
}
topojson4.responseType = "json";
var format7 = {
  dsv: dsv4,
  csv: delimitedFormat4(","),
  tsv: delimitedFormat4("	"),
  json: json4,
  topojson: topojson4
};
function formats7(name, reader) {
  if (arguments.length > 1) {
    format7[name] = reader;
    return this;
  } else {
    return has(format7, name) ? format7[name] : null;
  }
}
function responseType2(type7) {
  const f = formats7(type7);
  return f && f.responseType || "text";
}
function read2(data3, schema, timeParser, utcParser) {
  schema = schema || {};
  const reader = formats7(schema.type || "json");
  if (!reader)
    error("Unknown data format type: " + schema.type);
  data3 = reader(data3, schema);
  if (schema.parse)
    parse6(data3, schema.parse, timeParser, utcParser);
  if (has(data3, "columns"))
    delete data3.columns;
  return data3;
}
function parse6(data3, types, timeParser, utcParser) {
  if (!data3.length)
    return;
  const locale5 = timeFormatDefaultLocale4();
  timeParser = timeParser || locale5.timeParse;
  utcParser = utcParser || locale5.utcParse;
  let fields = data3.columns || Object.keys(data3[0]), datum2, field25, i, j, n, m3;
  if (types === "auto")
    types = inferTypes2(data3, fields);
  fields = Object.keys(types);
  const parsers = fields.map((field26) => {
    const type7 = types[field26];
    let parts, pattern;
    if (type7 && (type7.startsWith("date:") || type7.startsWith("utc:"))) {
      parts = type7.split(/:(.+)?/, 2);
      pattern = parts[1];
      if (pattern[0] === "'" && pattern[pattern.length - 1] === "'" || pattern[0] === '"' && pattern[pattern.length - 1] === '"') {
        pattern = pattern.slice(1, -1);
      }
      const parse12 = parts[0] === "utc" ? utcParser : timeParser;
      return parse12(pattern);
    }
    if (!typeParsers2[type7]) {
      throw Error("Illegal format pattern: " + field26 + ":" + type7);
    }
    return typeParsers2[type7];
  });
  for (i = 0, n = data3.length, m3 = fields.length; i < n; ++i) {
    datum2 = data3[i];
    for (j = 0; j < m3; ++j) {
      field25 = fields[j];
      datum2[field25] = parsers[j](datum2[field25]);
    }
  }
}
var loader4 = loaderFactory4();

// node_modules/vega/node_modules/vega-canvas/build/vega-canvas.browser.js
function domCanvas5(w8, h6) {
  if (typeof document !== "undefined" && document.createElement) {
    const c5 = document.createElement("canvas");
    if (c5 && c5.getContext) {
      c5.width = w8;
      c5.height = h6;
      return c5;
    }
  }
  return null;
}
var domImage3 = () => typeof Image !== "undefined" ? Image : null;

// node_modules/vega/node_modules/vega-scale/build/vega-scale.js
function bandSpace6(count3, paddingInner2, paddingOuter2) {
  const space = count3 - paddingInner2 + paddingOuter2 * 2;
  return count3 ? space > 0 ? space : 1 : 0;
}
var Identity6 = "identity";
var Linear7 = "linear";
var Log6 = "log";
var Pow6 = "pow";
var Sqrt6 = "sqrt";
var Symlog6 = "symlog";
var Time6 = "time";
var UTC6 = "utc";
var Sequential6 = "sequential";
var Diverging6 = "diverging";
var Quantile7 = "quantile";
var Quantize6 = "quantize";
var Threshold6 = "threshold";
var Ordinal6 = "ordinal";
var Point6 = "point";
var Band6 = "band";
var BinOrdinal6 = "bin-ordinal";
var Continuous6 = "continuous";
var Discrete6 = "discrete";
var Discretizing6 = "discretizing";
var Interpolating6 = "interpolating";
var Temporal6 = "temporal";
function invertRange6(scale19) {
  return function(_) {
    let lo = _[0], hi = _[1], t;
    if (hi < lo) {
      t = lo;
      lo = hi;
      hi = t;
    }
    return [scale19.invert(lo), scale19.invert(hi)];
  };
}
function invertRangeExtent6(scale19) {
  return function(_) {
    const range7 = scale19.range();
    let lo = _[0], hi = _[1], min5 = -1, max5, t, i, n;
    if (hi < lo) {
      t = lo;
      lo = hi;
      hi = t;
    }
    for (i = 0, n = range7.length; i < n; ++i) {
      if (range7[i] >= lo && range7[i] <= hi) {
        if (min5 < 0)
          min5 = i;
        max5 = i;
      }
    }
    if (min5 < 0)
      return void 0;
    lo = scale19.invertExtent(range7[min5]);
    hi = scale19.invertExtent(range7[max5]);
    return [lo[0] === void 0 ? lo[1] : lo[0], hi[1] === void 0 ? hi[0] : hi[1]];
  };
}
function band7() {
  const scale19 = ordinal().unknown(void 0), domain3 = scale19.domain, ordinalRange = scale19.range;
  let range$1 = [0, 1], step, bandwidth2, round2 = false, paddingInner2 = 0, paddingOuter2 = 0, align2 = 0.5;
  delete scale19.unknown;
  function rescale() {
    const n = domain3().length, reverse4 = range$1[1] < range$1[0], stop2 = range$1[1 - reverse4], space = bandSpace6(n, paddingInner2, paddingOuter2);
    let start = range$1[reverse4 - 0];
    step = (stop2 - start) / (space || 1);
    if (round2) {
      step = Math.floor(step);
    }
    start += (stop2 - start - step * (n - paddingInner2)) * align2;
    bandwidth2 = step * (1 - paddingInner2);
    if (round2) {
      start = Math.round(start);
      bandwidth2 = Math.round(bandwidth2);
    }
    const values7 = range(n).map((i) => start + step * i);
    return ordinalRange(reverse4 ? values7.reverse() : values7);
  }
  scale19.domain = function(_) {
    if (arguments.length) {
      domain3(_);
      return rescale();
    } else {
      return domain3();
    }
  };
  scale19.range = function(_) {
    if (arguments.length) {
      range$1 = [+_[0], +_[1]];
      return rescale();
    } else {
      return range$1.slice();
    }
  };
  scale19.rangeRound = function(_) {
    range$1 = [+_[0], +_[1]];
    round2 = true;
    return rescale();
  };
  scale19.bandwidth = function() {
    return bandwidth2;
  };
  scale19.step = function() {
    return step;
  };
  scale19.round = function(_) {
    if (arguments.length) {
      round2 = !!_;
      return rescale();
    } else {
      return round2;
    }
  };
  scale19.padding = function(_) {
    if (arguments.length) {
      paddingOuter2 = Math.max(0, Math.min(1, _));
      paddingInner2 = paddingOuter2;
      return rescale();
    } else {
      return paddingInner2;
    }
  };
  scale19.paddingInner = function(_) {
    if (arguments.length) {
      paddingInner2 = Math.max(0, Math.min(1, _));
      return rescale();
    } else {
      return paddingInner2;
    }
  };
  scale19.paddingOuter = function(_) {
    if (arguments.length) {
      paddingOuter2 = Math.max(0, Math.min(1, _));
      return rescale();
    } else {
      return paddingOuter2;
    }
  };
  scale19.align = function(_) {
    if (arguments.length) {
      align2 = Math.max(0, Math.min(1, _));
      return rescale();
    } else {
      return align2;
    }
  };
  scale19.invertRange = function(_) {
    if (_[0] == null || _[1] == null)
      return;
    const reverse4 = range$1[1] < range$1[0], values7 = reverse4 ? ordinalRange().reverse() : ordinalRange(), n = values7.length - 1;
    let lo = +_[0], hi = +_[1], a4, b6, t;
    if (lo !== lo || hi !== hi)
      return;
    if (hi < lo) {
      t = lo;
      lo = hi;
      hi = t;
    }
    if (hi < values7[0] || lo > range$1[1 - reverse4])
      return;
    a4 = Math.max(0, bisectRight(values7, lo) - 1);
    b6 = lo === hi ? a4 : bisectRight(values7, hi) - 1;
    if (lo - values7[a4] > bandwidth2 + 1e-10)
      ++a4;
    if (reverse4) {
      t = a4;
      a4 = n - b6;
      b6 = n - t;
    }
    return a4 > b6 ? void 0 : domain3().slice(a4, b6 + 1);
  };
  scale19.invert = function(_) {
    const value7 = scale19.invertRange([_, _]);
    return value7 ? value7[0] : value7;
  };
  scale19.copy = function() {
    return band7().domain(domain3()).range(range$1).round(round2).paddingInner(paddingInner2).paddingOuter(paddingOuter2).align(align2);
  };
  return rescale();
}
function pointish6(scale19) {
  const copy4 = scale19.copy;
  scale19.padding = scale19.paddingOuter;
  delete scale19.paddingInner;
  scale19.copy = function() {
    return pointish6(copy4());
  };
  return scale19;
}
function point13() {
  return pointish6(band7().paddingInner(1));
}
var map9 = Array.prototype.map;
function numbers8(_) {
  return map9.call(_, toNumber);
}
var slice8 = Array.prototype.slice;
function scaleBinOrdinal6() {
  let domain3 = [], range7 = [];
  function scale19(x9) {
    return x9 == null || x9 !== x9 ? void 0 : range7[(bisect_default2(domain3, x9) - 1) % range7.length];
  }
  scale19.domain = function(_) {
    if (arguments.length) {
      domain3 = numbers8(_);
      return scale19;
    } else {
      return domain3.slice();
    }
  };
  scale19.range = function(_) {
    if (arguments.length) {
      range7 = slice8.call(_);
      return scale19;
    } else {
      return range7.slice();
    }
  };
  scale19.tickFormat = function(count3, specifier) {
    return tickFormat(domain3[0], peek(domain3), count3 == null ? 10 : count3, specifier);
  };
  scale19.copy = function() {
    return scaleBinOrdinal6().domain(scale19.domain()).range(scale19.range());
  };
  return scale19;
}
var scales6 = /* @__PURE__ */ new Map();
var VEGA_SCALE6 = Symbol("vega_scale");
function registerScale6(scale19) {
  scale19[VEGA_SCALE6] = true;
  return scale19;
}
function create8(type7, constructor, metadata6) {
  const ctr = function scale19() {
    const s2 = constructor();
    if (!s2.invertRange) {
      s2.invertRange = s2.invert ? invertRange6(s2) : s2.invertExtent ? invertRangeExtent6(s2) : void 0;
    }
    s2.type = type7;
    return registerScale6(s2);
  };
  ctr.metadata = toSet(array(metadata6));
  return ctr;
}
function scale9(type7, scale19, metadata6) {
  if (arguments.length > 1) {
    scales6.set(type7, create8(type7, scale19, metadata6));
    return this;
  } else {
    return isValidScaleType6(type7) ? scales6.get(type7) : void 0;
  }
}
scale9(Identity6, identity8);
scale9(Linear7, linear3, Continuous6);
scale9(Log6, log3, [Continuous6, Log6]);
scale9(Pow6, pow3, Continuous6);
scale9(Sqrt6, sqrt2, Continuous6);
scale9(Symlog6, symlog2, Continuous6);
scale9(Time6, time, [Continuous6, Temporal6]);
scale9(UTC6, utcTime, [Continuous6, Temporal6]);
scale9(Sequential6, sequential, [Continuous6, Interpolating6]);
scale9(`${Sequential6}-${Linear7}`, sequential, [Continuous6, Interpolating6]);
scale9(`${Sequential6}-${Log6}`, sequentialLog, [Continuous6, Interpolating6, Log6]);
scale9(`${Sequential6}-${Pow6}`, sequentialPow, [Continuous6, Interpolating6]);
scale9(`${Sequential6}-${Sqrt6}`, sequentialSqrt, [Continuous6, Interpolating6]);
scale9(`${Sequential6}-${Symlog6}`, sequentialSymlog, [Continuous6, Interpolating6]);
scale9(`${Diverging6}-${Linear7}`, diverging, [Continuous6, Interpolating6]);
scale9(`${Diverging6}-${Log6}`, divergingLog, [Continuous6, Interpolating6, Log6]);
scale9(`${Diverging6}-${Pow6}`, divergingPow, [Continuous6, Interpolating6]);
scale9(`${Diverging6}-${Sqrt6}`, divergingSqrt, [Continuous6, Interpolating6]);
scale9(`${Diverging6}-${Symlog6}`, divergingSymlog, [Continuous6, Interpolating6]);
scale9(Quantile7, quantile2, [Discretizing6, Quantile7]);
scale9(Quantize6, quantize, Discretizing6);
scale9(Threshold6, threshold, Discretizing6);
scale9(BinOrdinal6, scaleBinOrdinal6, [Discrete6, Discretizing6]);
scale9(Ordinal6, ordinal, Discrete6);
scale9(Band6, band7, Discrete6);
scale9(Point6, point13, Discrete6);
function isValidScaleType6(type7) {
  return scales6.has(type7);
}
function hasType4(key4, type7) {
  const s2 = scales6.get(key4);
  return s2 && s2.metadata[type7];
}
function isDiscrete3(key4) {
  return hasType4(key4, Discrete6);
}
function isDiscretizing3(key4) {
  return hasType4(key4, Discretizing6);
}
function isLogarithmic4(key4) {
  return hasType4(key4, Log6);
}
function isTemporal3(key4) {
  return hasType4(key4, Temporal6);
}
function interpolateRange2(interpolator, range7) {
  const start = range7[0], span12 = peek(range7) - start;
  return function(i) {
    return interpolator(start + i * span12);
  };
}
function interpolateColors6(colors10, type7, gamma2) {
  return piecewise(interpolate6(type7 || "rgb", gamma2), colors10);
}
function quantizeInterpolator2(interpolator, count3) {
  const samples = new Array(count3), n = count3 + 1;
  for (let i = 0; i < count3; )
    samples[i] = interpolator(++i / n);
  return samples;
}
function interpolate6(type7, gamma2) {
  const interp = src_exports[method6(type7)];
  return gamma2 != null && interp && interp.gamma ? interp.gamma(gamma2) : interp;
}
function method6(type7) {
  return "interpolate" + type7.toLowerCase().split("-").map((s2) => s2[0].toUpperCase() + s2.slice(1)).join("");
}
var continuous7 = {
  blues: "cfe1f2bed8eca8cee58fc1de74b2d75ba3cf4592c63181bd206fb2125ca40a4a90",
  greens: "d3eecdc0e6baabdda594d3917bc77d60ba6c46ab5e329a512089430e7735036429",
  greys: "e2e2e2d4d4d4c4c4c4b1b1b19d9d9d8888887575756262624d4d4d3535351e1e1e",
  oranges: "fdd8b3fdc998fdb87bfda55efc9244f87f2cf06b18e4580bd14904b93d029f3303",
  purples: "e2e1efd4d4e8c4c5e0b4b3d6a3a0cc928ec3827cb97566ae684ea25c3696501f8c",
  reds: "fdc9b4fcb49afc9e80fc8767fa7051f6573fec3f2fdc2a25c81b1db21218970b13",
  blueGreen: "d5efedc1e8e0a7ddd18bd2be70c6a958ba9144ad77319c5d2089460e7736036429",
  bluePurple: "ccddecbad0e4a8c2dd9ab0d4919cc98d85be8b6db28a55a6873c99822287730f71",
  greenBlue: "d3eecec5e8c3b1e1bb9bd8bb82cec269c2ca51b2cd3c9fc7288abd1675b10b60a1",
  orangeRed: "fddcaffdcf9bfdc18afdad77fb9562f67d53ee6545e24932d32d1ebf130da70403",
  purpleBlue: "dbdaebc8cee4b1c3de97b7d87bacd15b9fc93a90c01e7fb70b70ab056199045281",
  purpleBlueGreen: "dbd8eac8cee4b0c3de93b7d872acd1549fc83892bb1c88a3097f8702736b016353",
  purpleRed: "dcc9e2d3b3d7ce9eccd186c0da6bb2e14da0e23189d91e6fc61159ab07498f023a",
  redPurple: "fccfccfcbec0faa9b8f98faff571a5ec539ddb3695c41b8aa908808d0179700174",
  yellowGreen: "e4f4acd1eca0b9e2949ed68880c97c62bb6e47aa5e3297502083440e723b036034",
  yellowOrangeBrown: "feeaa1fedd84fecc63feb746fca031f68921eb7215db5e0bc54c05ab3d038f3204",
  yellowOrangeRed: "fee087fed16ffebd59fea849fd903efc7335f9522bee3423de1b20ca0b22af0225",
  blueOrange: "134b852f78b35da2cb9dcae1d2e5eff2f0ebfce0bafbbf74e8932fc5690d994a07",
  brownBlueGreen: "704108a0651ac79548e3c78af3e6c6eef1eac9e9e48ed1c74da79e187a72025147",
  purpleGreen: "5b1667834792a67fb6c9aed3e6d6e8eff0efd9efd5aedda971bb75368e490e5e29",
  purpleOrange: "4114696647968f83b7b9b4d6dadbebf3eeeafce0bafbbf74e8932fc5690d994a07",
  redBlue: "8c0d25bf363adf745ef4ae91fbdbc9f2efeed2e5ef9dcae15da2cb2f78b3134b85",
  redGrey: "8c0d25bf363adf745ef4ae91fcdccbfaf4f1e2e2e2c0c0c0969696646464343434",
  yellowGreenBlue: "eff9bddbf1b4bde5b594d5b969c5be45b4c22c9ec02182b82163aa23479c1c3185",
  redYellowBlue: "a50026d4322cf16e43fcac64fedd90faf8c1dcf1ecabd6e875abd04a74b4313695",
  redYellowGreen: "a50026d4322cf16e43fcac63fedd8df9f7aed7ee8ea4d86e64bc6122964f006837",
  pinkYellowGreen: "8e0152c0267edd72adf0b3d6faddedf5f3efe1f2cab6de8780bb474f9125276419",
  spectral: "9e0142d13c4bf0704afcac63fedd8dfbf8b0e0f3a1a9dda269bda94288b55e4fa2",
  viridis: "440154470e61481a6c482575472f7d443a834144873d4e8a39568c35608d31688e2d708e2a788e27818e23888e21918d1f988b1fa08822a8842ab07f35b77943bf7154c56866cc5d7ad1518fd744a5db36bcdf27d2e21be9e51afde725",
  magma: "0000040404130b0924150e3720114b2c11603b0f704a107957157e651a80721f817f24828c29819a2e80a8327db6377ac43c75d1426fde4968e95462f1605df76f5cfa7f5efc8f65fe9f6dfeaf78febf84fece91fddea0fcedaffcfdbf",
  inferno: "0000040403130c0826170c3b240c4f330a5f420a68500d6c5d126e6b176e781c6d86216b932667a12b62ae305cbb3755c73e4cd24644dd513ae65c30ed6925f3771af8850ffb9506fca50afcb519fac62df6d645f2e661f3f484fcffa4",
  plasma: "0d088723069033059742039d5002a25d01a66a00a87801a88405a7900da49c179ea72198b12a90ba3488c33d80cb4779d35171da5a69e16462e76e5bed7953f2834cf68f44fa9a3dfca636fdb32ffec029fcce25f9dc24f5ea27f0f921",
  cividis: "00205100235800265d002961012b65042e670831690d346b11366c16396d1c3c6e213f6e26426e2c456e31476e374a6e3c4d6e42506e47536d4c566d51586e555b6e5a5e6e5e616e62646f66676f6a6a706e6d717270717573727976737c79747f7c75827f758682768985778c8877908b78938e789691789a94789e9778a19b78a59e77a9a177aea575b2a874b6ab73bbaf71c0b26fc5b66dc9b96acebd68d3c065d8c462ddc85fe2cb5ce7cf58ebd355f0d652f3da4ff7de4cfae249fce647",
  rainbow: "6e40aa883eb1a43db3bf3cafd83fa4ee4395fe4b83ff576eff6659ff7847ff8c38f3a130e2b72fcfcc36bee044aff05b8ff4576ff65b52f6673af27828ea8d1ddfa319d0b81cbecb23abd82f96e03d82e14c6edb5a5dd0664dbf6e40aa",
  sinebow: "ff4040fc582af47218e78d0bd5a703bfbf00a7d5038de70b72f41858fc2a40ff402afc5818f4720be78d03d5a700bfbf03a7d50b8de71872f42a58fc4040ff582afc7218f48d0be7a703d5bf00bfd503a7e70b8df41872fc2a58ff4040",
  turbo: "23171b32204a3e2a71453493493eae4b49c54a53d7485ee44569ee4074f53c7ff8378af93295f72e9ff42ba9ef28b3e926bce125c5d925cdcf27d5c629dcbc2de3b232e9a738ee9d3ff39347f68950f9805afc7765fd6e70fe667cfd5e88fc5795fb51a1f84badf545b9f140c5ec3cd0e637dae034e4d931ecd12ef4c92bfac029ffb626ffad24ffa223ff9821ff8d1fff821dff771cfd6c1af76118f05616e84b14df4111d5380fcb2f0dc0260ab61f07ac1805a313029b0f00950c00910b00",
  browns: "eedbbdecca96e9b97ae4a865dc9856d18954c7784cc0673fb85536ad44339f3632",
  tealBlues: "bce4d89dd3d181c3cb65b3c245a2b9368fae347da0306a932c5985",
  teals: "bbdfdfa2d4d58ac9c975bcbb61b0af4da5a43799982b8b8c1e7f7f127273006667",
  warmGreys: "dcd4d0cec5c1c0b8b4b3aaa7a59c9998908c8b827f7e7673726866665c5a59504e",
  goldGreen: "f4d166d5ca60b6c35c98bb597cb25760a6564b9c533f8f4f33834a257740146c36",
  goldOrange: "f4d166f8be5cf8aa4cf5983bf3852aef701be2621fd65322c54923b142239e3a26",
  goldRed: "f4d166f6be59f9aa51fc964ef6834bee734ae56249db5247cf4244c43141b71d3e",
  lightGreyRed: "efe9e6e1dad7d5cbc8c8bdb9bbaea9cd967ddc7b43e15f19df4011dc000b",
  lightGreyTeal: "e4eaead6dcddc8ced2b7c2c7a6b4bc64b0bf22a6c32295c11f85be1876bc",
  lightMulti: "e0f1f2c4e9d0b0de9fd0e181f6e072f6c053f3993ef77440ef4a3c",
  lightOrange: "f2e7daf7d5baf9c499fab184fa9c73f68967ef7860e8645bde515bd43d5b",
  lightTealBlue: "e3e9e0c0dccf9aceca7abfc859afc0389fb9328dad2f7ca0276b95255988",
  darkBlue: "3232322d46681a5c930074af008cbf05a7ce25c0dd38daed50f3faffffff",
  darkGold: "3c3c3c584b37725e348c7631ae8b2bcfa424ecc31ef9de30fff184ffffff",
  darkGreen: "3a3a3a215748006f4d048942489e4276b340a6c63dd2d836ffeb2cffffaa",
  darkMulti: "3737371f5287197d8c29a86995ce3fffe800ffffff",
  darkRed: "3434347036339e3c38cc4037e75d1eec8620eeab29f0ce32ffeb2c"
};
var discrete6 = {
  accent: Accent_default,
  category10: category10_default,
  category20: "1f77b4aec7e8ff7f0effbb782ca02c98df8ad62728ff98969467bdc5b0d58c564bc49c94e377c2f7b6d27f7f7fc7c7c7bcbd22dbdb8d17becf9edae5",
  category20b: "393b795254a36b6ecf9c9ede6379398ca252b5cf6bcedb9c8c6d31bd9e39e7ba52e7cb94843c39ad494ad6616be7969c7b4173a55194ce6dbdde9ed6",
  category20c: "3182bd6baed69ecae1c6dbefe6550dfd8d3cfdae6bfdd0a231a35474c476a1d99bc7e9c0756bb19e9ac8bcbddcdadaeb636363969696bdbdbdd9d9d9",
  dark2: Dark2_default,
  observable10: observable10_default,
  paired: Paired_default,
  pastel1: Pastel1_default,
  pastel2: Pastel2_default,
  set1: Set1_default,
  set2: Set2_default,
  set3: Set3_default,
  tableau10: "4c78a8f58518e4575672b7b254a24beeca3bb279a2ff9da69d755dbab0ac",
  tableau20: "4c78a89ecae9f58518ffbf7954a24b88d27ab79a20f2cf5b43989483bcb6e45756ff9d9879706ebab0acd67195fcbfd2b279a2d6a5c99e765fd8b5a5"
};
function colors6(palette) {
  if (isArray(palette))
    return palette;
  const n = palette.length / 6 | 0, c5 = new Array(n);
  for (let i = 0; i < n; ) {
    c5[i] = "#" + palette.slice(i * 6, ++i * 6);
  }
  return c5;
}
function apply6(_, f) {
  for (const k3 in _)
    scheme33(k3, f(_[k3]));
}
var schemes6 = {};
apply6(discrete6, colors6);
apply6(continuous7, (_) => interpolateColors6(colors6(_)));
function scheme33(name, scheme38) {
  name = name && name.toLowerCase();
  if (arguments.length > 1) {
    schemes6[name] = scheme38;
    return this;
  } else {
    return schemes6[name];
  }
}
var SymbolLegend4 = "symbol";
var DiscreteLegend4 = "discrete";
var defaultFormatter4 = (value7) => isArray(value7) ? value7.map((v2) => String(v2)) : String(value7);
var ascending7 = (a4, b6) => a4[1] - b6[1];
var descending5 = (a4, b6) => b6[1] - a4[1];
function validTicks4(scale19, ticks2, count3) {
  let range7 = scale19.range(), lo = range7[0], hi = peek(range7), cmp = ascending7;
  if (lo > hi) {
    range7 = hi;
    hi = lo;
    lo = range7;
    cmp = descending5;
  }
  lo = Math.floor(lo);
  hi = Math.ceil(hi);
  ticks2 = ticks2.map((v2) => [v2, scale19(v2)]).filter((_) => lo <= _[1] && _[1] <= hi).sort(cmp).map((_) => _[0]);
  if (count3 > 0 && ticks2.length > 1) {
    const endpoints = [ticks2[0], peek(ticks2)];
    while (ticks2.length > count3 && ticks2.length >= 3) {
      ticks2 = ticks2.filter((_, i) => !(i % 2));
    }
    if (ticks2.length < 3) {
      ticks2 = endpoints;
    }
  }
  return ticks2;
}
function tickValues4(scale19, count3) {
  return scale19.bins ? validTicks4(scale19, scale19.bins, count3) : scale19.ticks ? scale19.ticks(count3) : scale19.domain();
}
function tickFormat5(locale5, scale19, count3, specifier, formatType, noSkip) {
  const type7 = scale19.type;
  let format14 = defaultFormatter4;
  if (type7 === Time6 || formatType === Time6) {
    format14 = locale5.timeFormat(specifier);
  } else if (type7 === UTC6 || formatType === UTC6) {
    format14 = locale5.utcFormat(specifier);
  } else if (isLogarithmic4(type7)) {
    const varfmt = locale5.formatFloat(specifier);
    if (noSkip || scale19.bins) {
      format14 = varfmt;
    } else {
      const test2 = tickLog4(scale19, count3, false);
      format14 = (_) => test2(_) ? varfmt(_) : "";
    }
  } else if (scale19.tickFormat) {
    const d = scale19.domain();
    format14 = locale5.formatSpan(d[0], d[d.length - 1], count3, specifier);
  } else if (specifier) {
    format14 = locale5.format(specifier);
  }
  return format14;
}
function tickLog4(scale19, count3, values7) {
  const ticks2 = tickValues4(scale19, count3), base = scale19.base(), logb = Math.log(base), k3 = Math.max(1, base * count3 / ticks2.length);
  const test2 = (d) => {
    let i = d / Math.pow(base, Math.round(Math.log(d) / logb));
    if (i * base < base - 0.5)
      i *= base;
    return i <= k3;
  };
  return values7 ? ticks2.filter(test2) : test2;
}
var symbols8 = {
  [Quantile7]: "quantiles",
  [Quantize6]: "thresholds",
  [Threshold6]: "domain"
};
var formats8 = {
  [Quantile7]: "quantiles",
  [Quantize6]: "domain"
};
function labelValues4(scale19, count3) {
  return scale19.bins ? binValues4(scale19.bins) : scale19.type === Log6 ? tickLog4(scale19, count3, true) : symbols8[scale19.type] ? thresholdValues4(scale19[symbols8[scale19.type]]()) : tickValues4(scale19, count3);
}
function thresholdFormat4(locale5, scale19, specifier) {
  const _ = scale19[formats8[scale19.type]](), n = _.length;
  let d = n > 1 ? _[1] - _[0] : _[0], i;
  for (i = 1; i < n; ++i) {
    d = Math.min(d, _[i] - _[i - 1]);
  }
  return locale5.formatSpan(0, d, 3 * 10, specifier);
}
function thresholdValues4(thresholds) {
  const values7 = [-Infinity].concat(thresholds);
  values7.max = Infinity;
  return values7;
}
function binValues4(bins2) {
  const values7 = bins2.slice(0, -1);
  values7.max = peek(bins2);
  return values7;
}
var isDiscreteRange4 = (scale19) => symbols8[scale19.type] || scale19.bins;
function labelFormat4(locale5, scale19, count3, type7, specifier, formatType, noSkip) {
  const format14 = formats8[scale19.type] && formatType !== Time6 && formatType !== UTC6 ? thresholdFormat4(locale5, scale19, specifier) : tickFormat5(locale5, scale19, count3, specifier, formatType, noSkip);
  return type7 === SymbolLegend4 && isDiscreteRange4(scale19) ? formatRange4(format14) : type7 === DiscreteLegend4 ? formatDiscrete4(format14) : formatPoint4(format14);
}
var formatRange4 = (format14) => (value7, index4, array22) => {
  const limit = get9(array22[index4 + 1], get9(array22.max, Infinity)), lo = formatValue4(value7, format14), hi = formatValue4(limit, format14);
  return lo && hi ? lo + " – " + hi : hi ? "< " + hi : "≥ " + lo;
};
var get9 = (value7, dflt) => value7 != null ? value7 : dflt;
var formatDiscrete4 = (format14) => (value7, index4) => index4 ? format14(value7) : null;
var formatPoint4 = (format14) => (value7) => format14(value7);
var formatValue4 = (value7, format14) => Number.isFinite(value7) ? format14(value7) : null;
function format8(locale5, scale19, specifier, formatType) {
  const type7 = formatType || scale19.type;
  if (isString(specifier) && isTemporal3(type7)) {
    specifier = specifier.replace(/%a/g, "%A").replace(/%b/g, "%B");
  }
  return !specifier && type7 === Time6 ? locale5.timeFormat("%A, %d %B %Y, %X") : !specifier && type7 === UTC6 ? locale5.utcFormat("%A, %d %B %Y, %X UTC") : labelFormat4(locale5, scale19, 5, null, specifier, formatType, true);
}
function domainCaption3(locale5, scale19, opt) {
  opt = opt || {};
  const max5 = Math.max(3, opt.maxlen || 7), fmt = format8(locale5, scale19, opt.format, opt.formatType);
  if (isDiscretizing3(scale19.type)) {
    const v2 = labelValues4(scale19).slice(1).map(fmt), n = v2.length;
    return `${n} boundar${n === 1 ? "y" : "ies"}: ${v2.join(", ")}`;
  } else if (isDiscrete3(scale19.type)) {
    const d = scale19.domain(), n = d.length, v2 = n > max5 ? d.slice(0, max5 - 2).map(fmt).join(", ") + ", ending with " + d.slice(-1).map(fmt) : d.map(fmt).join(", ");
    return `${n} value${n === 1 ? "" : "s"}: ${v2}`;
  } else {
    const d = scale19.domain();
    return `values from ${fmt(d[0])} to ${fmt(peek(d))}`;
  }
}

// node_modules/vega/node_modules/vega-scenegraph/build/vega-scenegraph.js
var gradient_id3 = 0;
function resetSVGGradientId() {
  gradient_id3 = 0;
}
var patternPrefix3 = "p_";
function isGradient3(value7) {
  return value7 && value7.gradient;
}
function gradientRef3(g, defs, base) {
  const type7 = g.gradient;
  let id24 = g.id, prefix = type7 === "radial" ? patternPrefix3 : "";
  if (!id24) {
    id24 = g.id = "gradient_" + gradient_id3++;
    if (type7 === "radial") {
      g.x1 = get10(g.x1, 0.5);
      g.y1 = get10(g.y1, 0.5);
      g.r1 = get10(g.r1, 0);
      g.x2 = get10(g.x2, 0.5);
      g.y2 = get10(g.y2, 0.5);
      g.r2 = get10(g.r2, 0.5);
      prefix = patternPrefix3;
    } else {
      g.x1 = get10(g.x1, 0);
      g.y1 = get10(g.y1, 0);
      g.x2 = get10(g.x2, 1);
      g.y2 = get10(g.y2, 0);
    }
  }
  defs[id24] = g;
  return "url(" + (base || "") + "#" + prefix + id24 + ")";
}
function get10(val, def6) {
  return val != null ? val : def6;
}
function Gradient(p02, p1) {
  var stops = [], gradient8;
  return gradient8 = {
    gradient: "linear",
    x1: p02 ? p02[0] : 0,
    y1: p02 ? p02[1] : 0,
    x2: p1 ? p1[0] : 1,
    y2: p1 ? p1[1] : 0,
    stops,
    stop: function(offset9, color9) {
      stops.push({
        offset: offset9,
        color: color9
      });
      return gradient8;
    }
  };
}
var lookup5 = {
  "basis": {
    curve: basis_default
  },
  "basis-closed": {
    curve: basisClosed_default
  },
  "basis-open": {
    curve: basisOpen_default
  },
  "bundle": {
    curve: bundle_default,
    tension: "beta",
    value: 0.85
  },
  "cardinal": {
    curve: cardinal_default,
    tension: "tension",
    value: 0
  },
  "cardinal-open": {
    curve: cardinalOpen_default,
    tension: "tension",
    value: 0
  },
  "cardinal-closed": {
    curve: cardinalClosed_default,
    tension: "tension",
    value: 0
  },
  "catmull-rom": {
    curve: catmullRom_default,
    tension: "alpha",
    value: 0.5
  },
  "catmull-rom-closed": {
    curve: catmullRomClosed_default,
    tension: "alpha",
    value: 0.5
  },
  "catmull-rom-open": {
    curve: catmullRomOpen_default,
    tension: "alpha",
    value: 0.5
  },
  "linear": {
    curve: linear_default
  },
  "linear-closed": {
    curve: linearClosed_default
  },
  "monotone": {
    horizontal: monotoneY,
    vertical: monotoneX
  },
  "natural": {
    curve: natural_default
  },
  "step": {
    curve: step_default
  },
  "step-after": {
    curve: stepAfter
  },
  "step-before": {
    curve: stepBefore
  }
};
function curves3(type7, orientation, tension) {
  var entry2 = has(lookup5, type7) && lookup5[type7], curve2 = null;
  if (entry2) {
    curve2 = entry2.curve || entry2[orientation || "vertical"];
    if (entry2.tension && tension != null) {
      curve2 = curve2[entry2.tension](tension);
    }
  }
  return curve2;
}
var paramCounts3 = {
  m: 2,
  l: 2,
  h: 1,
  v: 1,
  z: 0,
  c: 6,
  s: 4,
  q: 4,
  t: 2,
  a: 7
};
var commandPattern3 = /[mlhvzcsqta]([^mlhvzcsqta]+|$)/gi;
var numberPattern3 = /^[+-]?(([0-9]*\.[0-9]+)|([0-9]+\.)|([0-9]+))([eE][+-]?[0-9]+)?/;
var spacePattern3 = /^((\s+,?\s*)|(,\s*))/;
var flagPattern3 = /^[01]/;
function parse7(path7) {
  const commands = [];
  const matches = path7.match(commandPattern3) || [];
  matches.forEach((str) => {
    let cmd = str[0];
    const type7 = cmd.toLowerCase();
    const paramCount = paramCounts3[type7];
    const params2 = parseParams3(type7, paramCount, str.slice(1).trim());
    const count3 = params2.length;
    if (count3 < paramCount || count3 && count3 % paramCount !== 0) {
      throw Error("Invalid SVG path, incorrect parameter count");
    }
    commands.push([cmd, ...params2.slice(0, paramCount)]);
    if (count3 === paramCount) {
      return;
    }
    if (type7 === "m") {
      cmd = cmd === "M" ? "L" : "l";
    }
    for (let i = paramCount; i < count3; i += paramCount) {
      commands.push([cmd, ...params2.slice(i, i + paramCount)]);
    }
  });
  return commands;
}
function parseParams3(type7, paramCount, segment) {
  const params2 = [];
  for (let index4 = 0; paramCount && index4 < segment.length; ) {
    for (let i = 0; i < paramCount; ++i) {
      const pattern = type7 === "a" && (i === 3 || i === 4) ? flagPattern3 : numberPattern3;
      const match2 = segment.slice(index4).match(pattern);
      if (match2 === null) {
        throw Error("Invalid SVG path, incorrect parameter type");
      }
      index4 += match2[0].length;
      params2.push(+match2[0]);
      const ws = segment.slice(index4).match(spacePattern3);
      if (ws !== null) {
        index4 += ws[0].length;
      }
    }
  }
  return params2;
}
var DegToRad3 = Math.PI / 180;
var Epsilon3 = 1e-14;
var HalfPi3 = Math.PI / 2;
var Tau3 = Math.PI * 2;
var HalfSqrt33 = Math.sqrt(3) / 2;
var segmentCache3 = {};
var bezierCache3 = {};
var join3 = [].join;
function segments3(x9, y9, rx, ry, large, sweep, rotateX, ox, oy) {
  const key4 = join3.call(arguments);
  if (segmentCache3[key4]) {
    return segmentCache3[key4];
  }
  const th = rotateX * DegToRad3;
  const sin_th = Math.sin(th);
  const cos_th = Math.cos(th);
  rx = Math.abs(rx);
  ry = Math.abs(ry);
  const px6 = cos_th * (ox - x9) * 0.5 + sin_th * (oy - y9) * 0.5;
  const py6 = cos_th * (oy - y9) * 0.5 - sin_th * (ox - x9) * 0.5;
  let pl = px6 * px6 / (rx * rx) + py6 * py6 / (ry * ry);
  if (pl > 1) {
    pl = Math.sqrt(pl);
    rx *= pl;
    ry *= pl;
  }
  const a00 = cos_th / rx;
  const a01 = sin_th / rx;
  const a10 = -sin_th / ry;
  const a11 = cos_th / ry;
  const x07 = a00 * ox + a01 * oy;
  const y07 = a10 * ox + a11 * oy;
  const x13 = a00 * x9 + a01 * y9;
  const y13 = a10 * x9 + a11 * y9;
  const d = (x13 - x07) * (x13 - x07) + (y13 - y07) * (y13 - y07);
  let sfactor_sq = 1 / d - 0.25;
  if (sfactor_sq < 0)
    sfactor_sq = 0;
  let sfactor = Math.sqrt(sfactor_sq);
  if (sweep == large)
    sfactor = -sfactor;
  const xc = 0.5 * (x07 + x13) - sfactor * (y13 - y07);
  const yc = 0.5 * (y07 + y13) + sfactor * (x13 - x07);
  const th0 = Math.atan2(y07 - yc, x07 - xc);
  const th1 = Math.atan2(y13 - yc, x13 - xc);
  let th_arc = th1 - th0;
  if (th_arc < 0 && sweep === 1) {
    th_arc += Tau3;
  } else if (th_arc > 0 && sweep === 0) {
    th_arc -= Tau3;
  }
  const segs = Math.ceil(Math.abs(th_arc / (HalfPi3 + 1e-3)));
  const result = [];
  for (let i = 0; i < segs; ++i) {
    const th2 = th0 + i * th_arc / segs;
    const th3 = th0 + (i + 1) * th_arc / segs;
    result[i] = [xc, yc, th2, th3, rx, ry, sin_th, cos_th];
  }
  return segmentCache3[key4] = result;
}
function bezier3(params2) {
  const key4 = join3.call(params2);
  if (bezierCache3[key4]) {
    return bezierCache3[key4];
  }
  var cx = params2[0], cy = params2[1], th0 = params2[2], th1 = params2[3], rx = params2[4], ry = params2[5], sin_th = params2[6], cos_th = params2[7];
  const a00 = cos_th * rx;
  const a01 = -sin_th * ry;
  const a10 = sin_th * rx;
  const a11 = cos_th * ry;
  const cos_th0 = Math.cos(th0);
  const sin_th0 = Math.sin(th0);
  const cos_th1 = Math.cos(th1);
  const sin_th1 = Math.sin(th1);
  const th_half = 0.5 * (th1 - th0);
  const sin_th_h2 = Math.sin(th_half * 0.5);
  const t = 8 / 3 * sin_th_h2 * sin_th_h2 / Math.sin(th_half);
  const x13 = cx + cos_th0 - t * sin_th0;
  const y13 = cy + sin_th0 + t * cos_th0;
  const x32 = cx + cos_th1;
  const y32 = cy + sin_th1;
  const x22 = x32 + t * sin_th1;
  const y22 = y32 - t * cos_th1;
  return bezierCache3[key4] = [a00 * x13 + a01 * y13, a10 * x13 + a11 * y13, a00 * x22 + a01 * y22, a10 * x22 + a11 * y22, a00 * x32 + a01 * y32, a10 * x32 + a11 * y32];
}
var temp3 = ["l", 0, 0, 0, 0, 0, 0, 0];
function scale$13(current2, sX, sY) {
  const c5 = temp3[0] = current2[0];
  if (c5 === "a" || c5 === "A") {
    temp3[1] = sX * current2[1];
    temp3[2] = sY * current2[2];
    temp3[3] = current2[3];
    temp3[4] = current2[4];
    temp3[5] = current2[5];
    temp3[6] = sX * current2[6];
    temp3[7] = sY * current2[7];
  } else if (c5 === "h" || c5 === "H") {
    temp3[1] = sX * current2[1];
  } else if (c5 === "v" || c5 === "V") {
    temp3[1] = sY * current2[1];
  } else {
    for (var i = 1, n = current2.length; i < n; ++i) {
      temp3[i] = (i % 2 == 1 ? sX : sY) * current2[i];
    }
  }
  return temp3;
}
function pathRender3(context7, path7, l, t, sX, sY) {
  var current2, previous = null, x9 = 0, y9 = 0, controlX = 0, controlY = 0, tempX, tempY, tempControlX, tempControlY, anchorX = 0, anchorY = 0;
  if (l == null)
    l = 0;
  if (t == null)
    t = 0;
  if (sX == null)
    sX = 1;
  if (sY == null)
    sY = sX;
  if (context7.beginPath)
    context7.beginPath();
  for (var i = 0, len = path7.length; i < len; ++i) {
    current2 = path7[i];
    if (sX !== 1 || sY !== 1) {
      current2 = scale$13(current2, sX, sY);
    }
    switch (current2[0]) {
      case "l":
        x9 += current2[1];
        y9 += current2[2];
        context7.lineTo(x9 + l, y9 + t);
        break;
      case "L":
        x9 = current2[1];
        y9 = current2[2];
        context7.lineTo(x9 + l, y9 + t);
        break;
      case "h":
        x9 += current2[1];
        context7.lineTo(x9 + l, y9 + t);
        break;
      case "H":
        x9 = current2[1];
        context7.lineTo(x9 + l, y9 + t);
        break;
      case "v":
        y9 += current2[1];
        context7.lineTo(x9 + l, y9 + t);
        break;
      case "V":
        y9 = current2[1];
        context7.lineTo(x9 + l, y9 + t);
        break;
      case "m":
        x9 += current2[1];
        y9 += current2[2];
        anchorX = x9;
        anchorY = y9;
        context7.moveTo(x9 + l, y9 + t);
        break;
      case "M":
        x9 = current2[1];
        y9 = current2[2];
        anchorX = x9;
        anchorY = y9;
        context7.moveTo(x9 + l, y9 + t);
        break;
      case "c":
        tempX = x9 + current2[5];
        tempY = y9 + current2[6];
        controlX = x9 + current2[3];
        controlY = y9 + current2[4];
        context7.bezierCurveTo(
          x9 + current2[1] + l,
          // x1
          y9 + current2[2] + t,
          // y1
          controlX + l,
          // x2
          controlY + t,
          // y2
          tempX + l,
          tempY + t
        );
        x9 = tempX;
        y9 = tempY;
        break;
      case "C":
        x9 = current2[5];
        y9 = current2[6];
        controlX = current2[3];
        controlY = current2[4];
        context7.bezierCurveTo(current2[1] + l, current2[2] + t, controlX + l, controlY + t, x9 + l, y9 + t);
        break;
      case "s":
        tempX = x9 + current2[3];
        tempY = y9 + current2[4];
        controlX = 2 * x9 - controlX;
        controlY = 2 * y9 - controlY;
        context7.bezierCurveTo(controlX + l, controlY + t, x9 + current2[1] + l, y9 + current2[2] + t, tempX + l, tempY + t);
        controlX = x9 + current2[1];
        controlY = y9 + current2[2];
        x9 = tempX;
        y9 = tempY;
        break;
      case "S":
        tempX = current2[3];
        tempY = current2[4];
        controlX = 2 * x9 - controlX;
        controlY = 2 * y9 - controlY;
        context7.bezierCurveTo(controlX + l, controlY + t, current2[1] + l, current2[2] + t, tempX + l, tempY + t);
        x9 = tempX;
        y9 = tempY;
        controlX = current2[1];
        controlY = current2[2];
        break;
      case "q":
        tempX = x9 + current2[3];
        tempY = y9 + current2[4];
        controlX = x9 + current2[1];
        controlY = y9 + current2[2];
        context7.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t);
        x9 = tempX;
        y9 = tempY;
        break;
      case "Q":
        tempX = current2[3];
        tempY = current2[4];
        context7.quadraticCurveTo(current2[1] + l, current2[2] + t, tempX + l, tempY + t);
        x9 = tempX;
        y9 = tempY;
        controlX = current2[1];
        controlY = current2[2];
        break;
      case "t":
        tempX = x9 + current2[1];
        tempY = y9 + current2[2];
        if (previous[0].match(/[QqTt]/) === null) {
          controlX = x9;
          controlY = y9;
        } else if (previous[0] === "t") {
          controlX = 2 * x9 - tempControlX;
          controlY = 2 * y9 - tempControlY;
        } else if (previous[0] === "q") {
          controlX = 2 * x9 - controlX;
          controlY = 2 * y9 - controlY;
        }
        tempControlX = controlX;
        tempControlY = controlY;
        context7.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t);
        x9 = tempX;
        y9 = tempY;
        controlX = x9 + current2[1];
        controlY = y9 + current2[2];
        break;
      case "T":
        tempX = current2[1];
        tempY = current2[2];
        controlX = 2 * x9 - controlX;
        controlY = 2 * y9 - controlY;
        context7.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t);
        x9 = tempX;
        y9 = tempY;
        break;
      case "a":
        drawArc3(context7, x9 + l, y9 + t, [current2[1], current2[2], current2[3], current2[4], current2[5], current2[6] + x9 + l, current2[7] + y9 + t]);
        x9 += current2[6];
        y9 += current2[7];
        break;
      case "A":
        drawArc3(context7, x9 + l, y9 + t, [current2[1], current2[2], current2[3], current2[4], current2[5], current2[6] + l, current2[7] + t]);
        x9 = current2[6];
        y9 = current2[7];
        break;
      case "z":
      case "Z":
        x9 = anchorX;
        y9 = anchorY;
        context7.closePath();
        break;
    }
    previous = current2;
  }
}
function drawArc3(context7, x9, y9, coords) {
  const seg = segments3(
    coords[5],
    // end x
    coords[6],
    // end y
    coords[0],
    // radius x
    coords[1],
    // radius y
    coords[3],
    // large flag
    coords[4],
    // sweep flag
    coords[2],
    // rotation
    x9,
    y9
  );
  for (let i = 0; i < seg.length; ++i) {
    const bez = bezier3(seg[i]);
    context7.bezierCurveTo(bez[0], bez[1], bez[2], bez[3], bez[4], bez[5]);
  }
}
var Tan303 = 0.5773502691896257;
var builtins3 = {
  "circle": {
    draw: function(context7, size) {
      const r = Math.sqrt(size) / 2;
      context7.moveTo(r, 0);
      context7.arc(0, 0, r, 0, Tau3);
    }
  },
  "cross": {
    draw: function(context7, size) {
      var r = Math.sqrt(size) / 2, s2 = r / 2.5;
      context7.moveTo(-r, -s2);
      context7.lineTo(-r, s2);
      context7.lineTo(-s2, s2);
      context7.lineTo(-s2, r);
      context7.lineTo(s2, r);
      context7.lineTo(s2, s2);
      context7.lineTo(r, s2);
      context7.lineTo(r, -s2);
      context7.lineTo(s2, -s2);
      context7.lineTo(s2, -r);
      context7.lineTo(-s2, -r);
      context7.lineTo(-s2, -s2);
      context7.closePath();
    }
  },
  "diamond": {
    draw: function(context7, size) {
      const r = Math.sqrt(size) / 2;
      context7.moveTo(-r, 0);
      context7.lineTo(0, -r);
      context7.lineTo(r, 0);
      context7.lineTo(0, r);
      context7.closePath();
    }
  },
  "square": {
    draw: function(context7, size) {
      var w8 = Math.sqrt(size), x9 = -w8 / 2;
      context7.rect(x9, x9, w8, w8);
    }
  },
  "arrow": {
    draw: function(context7, size) {
      var r = Math.sqrt(size) / 2, s2 = r / 7, t = r / 2.5, v2 = r / 8;
      context7.moveTo(-s2, r);
      context7.lineTo(s2, r);
      context7.lineTo(s2, -v2);
      context7.lineTo(t, -v2);
      context7.lineTo(0, -r);
      context7.lineTo(-t, -v2);
      context7.lineTo(-s2, -v2);
      context7.closePath();
    }
  },
  "wedge": {
    draw: function(context7, size) {
      var r = Math.sqrt(size) / 2, h6 = HalfSqrt33 * r, o = h6 - r * Tan303, b6 = r / 4;
      context7.moveTo(0, -h6 - o);
      context7.lineTo(-b6, h6 - o);
      context7.lineTo(b6, h6 - o);
      context7.closePath();
    }
  },
  "triangle": {
    draw: function(context7, size) {
      var r = Math.sqrt(size) / 2, h6 = HalfSqrt33 * r, o = h6 - r * Tan303;
      context7.moveTo(0, -h6 - o);
      context7.lineTo(-r, h6 - o);
      context7.lineTo(r, h6 - o);
      context7.closePath();
    }
  },
  "triangle-up": {
    draw: function(context7, size) {
      var r = Math.sqrt(size) / 2, h6 = HalfSqrt33 * r;
      context7.moveTo(0, -h6);
      context7.lineTo(-r, h6);
      context7.lineTo(r, h6);
      context7.closePath();
    }
  },
  "triangle-down": {
    draw: function(context7, size) {
      var r = Math.sqrt(size) / 2, h6 = HalfSqrt33 * r;
      context7.moveTo(0, h6);
      context7.lineTo(-r, -h6);
      context7.lineTo(r, -h6);
      context7.closePath();
    }
  },
  "triangle-right": {
    draw: function(context7, size) {
      var r = Math.sqrt(size) / 2, h6 = HalfSqrt33 * r;
      context7.moveTo(h6, 0);
      context7.lineTo(-h6, -r);
      context7.lineTo(-h6, r);
      context7.closePath();
    }
  },
  "triangle-left": {
    draw: function(context7, size) {
      var r = Math.sqrt(size) / 2, h6 = HalfSqrt33 * r;
      context7.moveTo(-h6, 0);
      context7.lineTo(h6, -r);
      context7.lineTo(h6, r);
      context7.closePath();
    }
  },
  "stroke": {
    draw: function(context7, size) {
      const r = Math.sqrt(size) / 2;
      context7.moveTo(-r, 0);
      context7.lineTo(r, 0);
    }
  }
};
function symbols9(_) {
  return has(builtins3, _) ? builtins3[_] : customSymbol3(_);
}
var custom12 = {};
function customSymbol3(path7) {
  if (!has(custom12, path7)) {
    const parsed = parse7(path7);
    custom12[path7] = {
      draw: function(context7, size) {
        pathRender3(context7, parsed, 0, 0, Math.sqrt(size) / 2);
      }
    };
  }
  return custom12[path7];
}
var C4 = 0.448084975506;
function rectangleX3(d) {
  return d.x;
}
function rectangleY3(d) {
  return d.y;
}
function rectangleWidth3(d) {
  return d.width;
}
function rectangleHeight3(d) {
  return d.height;
}
function number7(_) {
  return typeof _ === "function" ? _ : () => +_;
}
function clamp3(value7, min5, max5) {
  return Math.max(min5, Math.min(value7, max5));
}
function vg_rect3() {
  var x9 = rectangleX3, y9 = rectangleY3, width2 = rectangleWidth3, height2 = rectangleHeight3, crTL = number7(0), crTR = crTL, crBL = crTL, crBR = crTL, context7 = null;
  function rectangle6(_, x07, y07) {
    var buffer, x13 = x07 != null ? x07 : +x9.call(this, _), y13 = y07 != null ? y07 : +y9.call(this, _), w8 = +width2.call(this, _), h6 = +height2.call(this, _), s2 = Math.min(w8, h6) / 2, tl6 = clamp3(+crTL.call(this, _), 0, s2), tr6 = clamp3(+crTR.call(this, _), 0, s2), bl6 = clamp3(+crBL.call(this, _), 0, s2), br6 = clamp3(+crBR.call(this, _), 0, s2);
    if (!context7)
      context7 = buffer = path();
    if (tl6 <= 0 && tr6 <= 0 && bl6 <= 0 && br6 <= 0) {
      context7.rect(x13, y13, w8, h6);
    } else {
      var x22 = x13 + w8, y22 = y13 + h6;
      context7.moveTo(x13 + tl6, y13);
      context7.lineTo(x22 - tr6, y13);
      context7.bezierCurveTo(x22 - C4 * tr6, y13, x22, y13 + C4 * tr6, x22, y13 + tr6);
      context7.lineTo(x22, y22 - br6);
      context7.bezierCurveTo(x22, y22 - C4 * br6, x22 - C4 * br6, y22, x22 - br6, y22);
      context7.lineTo(x13 + bl6, y22);
      context7.bezierCurveTo(x13 + C4 * bl6, y22, x13, y22 - C4 * bl6, x13, y22 - bl6);
      context7.lineTo(x13, y13 + tl6);
      context7.bezierCurveTo(x13, y13 + C4 * tl6, x13 + C4 * tl6, y13, x13 + tl6, y13);
      context7.closePath();
    }
    if (buffer) {
      context7 = null;
      return buffer + "" || null;
    }
  }
  rectangle6.x = function(_) {
    if (arguments.length) {
      x9 = number7(_);
      return rectangle6;
    } else {
      return x9;
    }
  };
  rectangle6.y = function(_) {
    if (arguments.length) {
      y9 = number7(_);
      return rectangle6;
    } else {
      return y9;
    }
  };
  rectangle6.width = function(_) {
    if (arguments.length) {
      width2 = number7(_);
      return rectangle6;
    } else {
      return width2;
    }
  };
  rectangle6.height = function(_) {
    if (arguments.length) {
      height2 = number7(_);
      return rectangle6;
    } else {
      return height2;
    }
  };
  rectangle6.cornerRadius = function(tl6, tr6, br6, bl6) {
    if (arguments.length) {
      crTL = number7(tl6);
      crTR = tr6 != null ? number7(tr6) : crTL;
      crBR = br6 != null ? number7(br6) : crTL;
      crBL = bl6 != null ? number7(bl6) : crTR;
      return rectangle6;
    } else {
      return crTL;
    }
  };
  rectangle6.context = function(_) {
    if (arguments.length) {
      context7 = _ == null ? null : _;
      return rectangle6;
    } else {
      return context7;
    }
  };
  return rectangle6;
}
function vg_trail3() {
  var x9, y9, size, defined2, context7 = null, ready, x13, y13, r1;
  function point21(x22, y22, w22) {
    const r2 = w22 / 2;
    if (ready) {
      var ux = y13 - y22, uy = x22 - x13;
      if (ux || uy) {
        var ud = Math.hypot(ux, uy), rx = (ux /= ud) * r1, ry = (uy /= ud) * r1, t = Math.atan2(uy, ux);
        context7.moveTo(x13 - rx, y13 - ry);
        context7.lineTo(x22 - ux * r2, y22 - uy * r2);
        context7.arc(x22, y22, r2, t - Math.PI, t);
        context7.lineTo(x13 + rx, y13 + ry);
        context7.arc(x13, y13, r1, t, t + Math.PI);
      } else {
        context7.arc(x22, y22, r2, 0, Tau3);
      }
      context7.closePath();
    } else {
      ready = 1;
    }
    x13 = x22;
    y13 = y22;
    r1 = r2;
  }
  function trail7(data3) {
    var i, n = data3.length, d, defined0 = false, buffer;
    if (context7 == null)
      context7 = buffer = path();
    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined2(d = data3[i], i, data3)) === defined0) {
        if (defined0 = !defined0)
          ready = 0;
      }
      if (defined0)
        point21(+x9(d, i, data3), +y9(d, i, data3), +size(d, i, data3));
    }
    if (buffer) {
      context7 = null;
      return buffer + "" || null;
    }
  }
  trail7.x = function(_) {
    if (arguments.length) {
      x9 = _;
      return trail7;
    } else {
      return x9;
    }
  };
  trail7.y = function(_) {
    if (arguments.length) {
      y9 = _;
      return trail7;
    } else {
      return y9;
    }
  };
  trail7.size = function(_) {
    if (arguments.length) {
      size = _;
      return trail7;
    } else {
      return size;
    }
  };
  trail7.defined = function(_) {
    if (arguments.length) {
      defined2 = _;
      return trail7;
    } else {
      return defined2;
    }
  };
  trail7.context = function(_) {
    if (arguments.length) {
      if (_ == null) {
        context7 = null;
      } else {
        context7 = _;
      }
      return trail7;
    } else {
      return context7;
    }
  };
  return trail7;
}
function value$13(a4, b6) {
  return a4 != null ? a4 : b6;
}
var x6 = (item) => item.x || 0;
var y6 = (item) => item.y || 0;
var w4 = (item) => item.width || 0;
var h3 = (item) => item.height || 0;
var xw3 = (item) => (item.x || 0) + (item.width || 0);
var yh3 = (item) => (item.y || 0) + (item.height || 0);
var sa3 = (item) => item.startAngle || 0;
var ea4 = (item) => item.endAngle || 0;
var pa3 = (item) => item.padAngle || 0;
var ir3 = (item) => item.innerRadius || 0;
var or3 = (item) => item.outerRadius || 0;
var cr3 = (item) => item.cornerRadius || 0;
var tl3 = (item) => value$13(item.cornerRadiusTopLeft, item.cornerRadius) || 0;
var tr3 = (item) => value$13(item.cornerRadiusTopRight, item.cornerRadius) || 0;
var br3 = (item) => value$13(item.cornerRadiusBottomRight, item.cornerRadius) || 0;
var bl3 = (item) => value$13(item.cornerRadiusBottomLeft, item.cornerRadius) || 0;
var sz3 = (item) => value$13(item.size, 64);
var ts3 = (item) => item.size || 1;
var def3 = (item) => !(item.defined === false);
var type3 = (item) => symbols9(item.shape || "circle");
var arcShape3 = arc_default().startAngle(sa3).endAngle(ea4).padAngle(pa3).innerRadius(ir3).outerRadius(or3).cornerRadius(cr3);
var areavShape3 = area_default().x(x6).y1(y6).y0(yh3).defined(def3);
var areahShape3 = area_default().y(y6).x1(x6).x0(xw3).defined(def3);
var lineShape3 = line_default().x(x6).y(y6).defined(def3);
var rectShape3 = vg_rect3().x(x6).y(y6).width(w4).height(h3).cornerRadius(tl3, tr3, br3, bl3);
var symbolShape3 = Symbol2().type(type3).size(sz3);
var trailShape3 = vg_trail3().x(x6).y(y6).defined(def3).size(ts3);
function hasCornerRadius3(item) {
  return item.cornerRadius || item.cornerRadiusTopLeft || item.cornerRadiusTopRight || item.cornerRadiusBottomRight || item.cornerRadiusBottomLeft;
}
function arc$13(context7, item) {
  return arcShape3.context(context7)(item);
}
function area$13(context7, items) {
  const item = items[0], interp = item.interpolate || "linear";
  return (item.orient === "horizontal" ? areahShape3 : areavShape3).curve(curves3(interp, item.orient, item.tension)).context(context7)(items);
}
function line$13(context7, items) {
  const item = items[0], interp = item.interpolate || "linear";
  return lineShape3.curve(curves3(interp, item.orient, item.tension)).context(context7)(items);
}
function rectangle3(context7, item, x9, y9) {
  return rectShape3.context(context7)(item, x9, y9);
}
function shape$13(context7, item) {
  return (item.mark.shape || item.shape).context(context7)(item);
}
function symbol$13(context7, item) {
  return symbolShape3.context(context7)(item);
}
function trail$13(context7, items) {
  return trailShape3.context(context7)(items);
}
var clip_id3 = 1;
function resetSVGClipId() {
  clip_id3 = 1;
}
function clip$13(renderer, item, size) {
  var clip7 = item.clip, defs = renderer._defs, id24 = item.clip_id || (item.clip_id = "clip" + clip_id3++), c5 = defs.clipping[id24] || (defs.clipping[id24] = {
    id: id24
  });
  if (isFunction(clip7)) {
    c5.path = clip7(null);
  } else if (hasCornerRadius3(size)) {
    c5.path = rectangle3(null, size, 0, 0);
  } else {
    c5.width = size.width || 0;
    c5.height = size.height || 0;
  }
  return "url(#" + id24 + ")";
}
function Bounds3(b6) {
  this.clear();
  if (b6)
    this.union(b6);
}
Bounds3.prototype = {
  clone() {
    return new Bounds3(this);
  },
  clear() {
    this.x1 = +Number.MAX_VALUE;
    this.y1 = +Number.MAX_VALUE;
    this.x2 = -Number.MAX_VALUE;
    this.y2 = -Number.MAX_VALUE;
    return this;
  },
  empty() {
    return this.x1 === +Number.MAX_VALUE && this.y1 === +Number.MAX_VALUE && this.x2 === -Number.MAX_VALUE && this.y2 === -Number.MAX_VALUE;
  },
  equals(b6) {
    return this.x1 === b6.x1 && this.y1 === b6.y1 && this.x2 === b6.x2 && this.y2 === b6.y2;
  },
  set(x13, y13, x22, y22) {
    if (x22 < x13) {
      this.x2 = x13;
      this.x1 = x22;
    } else {
      this.x1 = x13;
      this.x2 = x22;
    }
    if (y22 < y13) {
      this.y2 = y13;
      this.y1 = y22;
    } else {
      this.y1 = y13;
      this.y2 = y22;
    }
    return this;
  },
  add(x9, y9) {
    if (x9 < this.x1)
      this.x1 = x9;
    if (y9 < this.y1)
      this.y1 = y9;
    if (x9 > this.x2)
      this.x2 = x9;
    if (y9 > this.y2)
      this.y2 = y9;
    return this;
  },
  expand(d) {
    this.x1 -= d;
    this.y1 -= d;
    this.x2 += d;
    this.y2 += d;
    return this;
  },
  round() {
    this.x1 = Math.floor(this.x1);
    this.y1 = Math.floor(this.y1);
    this.x2 = Math.ceil(this.x2);
    this.y2 = Math.ceil(this.y2);
    return this;
  },
  scale(s2) {
    this.x1 *= s2;
    this.y1 *= s2;
    this.x2 *= s2;
    this.y2 *= s2;
    return this;
  },
  translate(dx, dy) {
    this.x1 += dx;
    this.x2 += dx;
    this.y1 += dy;
    this.y2 += dy;
    return this;
  },
  rotate(angle2, x9, y9) {
    const p = this.rotatedPoints(angle2, x9, y9);
    return this.clear().add(p[0], p[1]).add(p[2], p[3]).add(p[4], p[5]).add(p[6], p[7]);
  },
  rotatedPoints(angle2, x9, y9) {
    var {
      x1: x13,
      y1: y13,
      x2: x22,
      y2: y22
    } = this, cos4 = Math.cos(angle2), sin4 = Math.sin(angle2), cx = x9 - x9 * cos4 + y9 * sin4, cy = y9 - x9 * sin4 - y9 * cos4;
    return [cos4 * x13 - sin4 * y13 + cx, sin4 * x13 + cos4 * y13 + cy, cos4 * x13 - sin4 * y22 + cx, sin4 * x13 + cos4 * y22 + cy, cos4 * x22 - sin4 * y13 + cx, sin4 * x22 + cos4 * y13 + cy, cos4 * x22 - sin4 * y22 + cx, sin4 * x22 + cos4 * y22 + cy];
  },
  union(b6) {
    if (b6.x1 < this.x1)
      this.x1 = b6.x1;
    if (b6.y1 < this.y1)
      this.y1 = b6.y1;
    if (b6.x2 > this.x2)
      this.x2 = b6.x2;
    if (b6.y2 > this.y2)
      this.y2 = b6.y2;
    return this;
  },
  intersect(b6) {
    if (b6.x1 > this.x1)
      this.x1 = b6.x1;
    if (b6.y1 > this.y1)
      this.y1 = b6.y1;
    if (b6.x2 < this.x2)
      this.x2 = b6.x2;
    if (b6.y2 < this.y2)
      this.y2 = b6.y2;
    return this;
  },
  encloses(b6) {
    return b6 && this.x1 <= b6.x1 && this.x2 >= b6.x2 && this.y1 <= b6.y1 && this.y2 >= b6.y2;
  },
  alignsWith(b6) {
    return b6 && (this.x1 == b6.x1 || this.x2 == b6.x2 || this.y1 == b6.y1 || this.y2 == b6.y2);
  },
  intersects(b6) {
    return b6 && !(this.x2 < b6.x1 || this.x1 > b6.x2 || this.y2 < b6.y1 || this.y1 > b6.y2);
  },
  contains(x9, y9) {
    return !(x9 < this.x1 || x9 > this.x2 || y9 < this.y1 || y9 > this.y2);
  },
  width() {
    return this.x2 - this.x1;
  },
  height() {
    return this.y2 - this.y1;
  }
};
function Item3(mark) {
  this.mark = mark;
  this.bounds = this.bounds || new Bounds3();
}
function GroupItem3(mark) {
  Item3.call(this, mark);
  this.items = this.items || [];
}
inherits(GroupItem3, Item3);
var ResourceLoader3 = class {
  constructor(customLoader) {
    this._pending = 0;
    this._loader = customLoader || loader4();
  }
  pending() {
    return this._pending;
  }
  sanitizeURL(uri) {
    const loader7 = this;
    increment3(loader7);
    return loader7._loader.sanitize(uri, {
      context: "href"
    }).then((opt) => {
      decrement3(loader7);
      return opt;
    }).catch(() => {
      decrement3(loader7);
      return null;
    });
  }
  loadImage(uri) {
    const loader7 = this, Image2 = domImage3();
    increment3(loader7);
    return loader7._loader.sanitize(uri, {
      context: "image"
    }).then((opt) => {
      const url = opt.href;
      if (!url || !Image2)
        throw {
          url
        };
      const img = new Image2();
      const cors = has(opt, "crossOrigin") ? opt.crossOrigin : "anonymous";
      if (cors != null)
        img.crossOrigin = cors;
      img.onload = () => decrement3(loader7);
      img.onerror = () => decrement3(loader7);
      img.src = url;
      return img;
    }).catch((e3) => {
      decrement3(loader7);
      return {
        complete: false,
        width: 0,
        height: 0,
        src: e3 && e3.url || ""
      };
    });
  }
  ready() {
    const loader7 = this;
    return new Promise((accept) => {
      function poll(value7) {
        if (!loader7.pending())
          accept(value7);
        else
          setTimeout(() => {
            poll(true);
          }, 10);
      }
      poll(false);
    });
  }
};
function increment3(loader7) {
  loader7._pending += 1;
}
function decrement3(loader7) {
  loader7._pending -= 1;
}
function boundStroke3(bounds6, item, miter) {
  if (item.stroke && item.opacity !== 0 && item.strokeOpacity !== 0) {
    const sw = item.strokeWidth != null ? +item.strokeWidth : 1;
    bounds6.expand(sw + (miter ? miterAdjustment3(item, sw) : 0));
  }
  return bounds6;
}
function miterAdjustment3(item, strokeWidth) {
  return item.strokeJoin && item.strokeJoin !== "miter" ? 0 : strokeWidth;
}
var circleThreshold3 = Tau3 - 1e-8;
var bounds3;
var lx3;
var ly3;
var rot3;
var ma3;
var mb3;
var mc3;
var md3;
var add6 = (x9, y9) => bounds3.add(x9, y9);
var addL3 = (x9, y9) => add6(lx3 = x9, ly3 = y9);
var addX3 = (x9) => add6(x9, bounds3.y1);
var addY3 = (y9) => add6(bounds3.x1, y9);
var px3 = (x9, y9) => ma3 * x9 + mc3 * y9;
var py3 = (x9, y9) => mb3 * x9 + md3 * y9;
var addp3 = (x9, y9) => add6(px3(x9, y9), py3(x9, y9));
var addpL3 = (x9, y9) => addL3(px3(x9, y9), py3(x9, y9));
function boundContext3(_, deg) {
  bounds3 = _;
  if (deg) {
    rot3 = deg * DegToRad3;
    ma3 = md3 = Math.cos(rot3);
    mb3 = Math.sin(rot3);
    mc3 = -mb3;
  } else {
    ma3 = md3 = 1;
    rot3 = mb3 = mc3 = 0;
  }
  return context$13;
}
var context$13 = {
  beginPath() {
  },
  closePath() {
  },
  moveTo: addpL3,
  lineTo: addpL3,
  rect(x9, y9, w8, h6) {
    if (rot3) {
      addp3(x9 + w8, y9);
      addp3(x9 + w8, y9 + h6);
      addp3(x9, y9 + h6);
      addpL3(x9, y9);
    } else {
      add6(x9 + w8, y9 + h6);
      addL3(x9, y9);
    }
  },
  quadraticCurveTo(x13, y13, x22, y22) {
    const px1 = px3(x13, y13), py1 = py3(x13, y13), px22 = px3(x22, y22), py22 = py3(x22, y22);
    quadExtrema3(lx3, px1, px22, addX3);
    quadExtrema3(ly3, py1, py22, addY3);
    addL3(px22, py22);
  },
  bezierCurveTo(x13, y13, x22, y22, x32, y32) {
    const px1 = px3(x13, y13), py1 = py3(x13, y13), px22 = px3(x22, y22), py22 = py3(x22, y22), px32 = px3(x32, y32), py32 = py3(x32, y32);
    cubicExtrema3(lx3, px1, px22, px32, addX3);
    cubicExtrema3(ly3, py1, py22, py32, addY3);
    addL3(px32, py32);
  },
  arc(cx, cy, r, sa6, ea7, ccw) {
    sa6 += rot3;
    ea7 += rot3;
    lx3 = r * Math.cos(ea7) + cx;
    ly3 = r * Math.sin(ea7) + cy;
    if (Math.abs(ea7 - sa6) > circleThreshold3) {
      add6(cx - r, cy - r);
      add6(cx + r, cy + r);
    } else {
      const update3 = (a4) => add6(r * Math.cos(a4) + cx, r * Math.sin(a4) + cy);
      let s2, i;
      update3(sa6);
      update3(ea7);
      if (ea7 !== sa6) {
        sa6 = sa6 % Tau3;
        if (sa6 < 0)
          sa6 += Tau3;
        ea7 = ea7 % Tau3;
        if (ea7 < 0)
          ea7 += Tau3;
        if (ea7 < sa6) {
          ccw = !ccw;
          s2 = sa6;
          sa6 = ea7;
          ea7 = s2;
        }
        if (ccw) {
          ea7 -= Tau3;
          s2 = sa6 - sa6 % HalfPi3;
          for (i = 0; i < 4 && s2 > ea7; ++i, s2 -= HalfPi3)
            update3(s2);
        } else {
          s2 = sa6 - sa6 % HalfPi3 + HalfPi3;
          for (i = 0; i < 4 && s2 < ea7; ++i, s2 = s2 + HalfPi3)
            update3(s2);
        }
      }
    }
  }
};
function quadExtrema3(x07, x13, x22, cb) {
  const t = (x07 - x13) / (x07 + x22 - 2 * x13);
  if (0 < t && t < 1)
    cb(x07 + (x13 - x07) * t);
}
function cubicExtrema3(x07, x13, x22, x32, cb) {
  const a4 = x32 - x07 + 3 * x13 - 3 * x22, b6 = x07 + x22 - 2 * x13, c5 = x07 - x13;
  let t014 = 0, t13 = 0, r;
  if (Math.abs(a4) > Epsilon3) {
    r = b6 * b6 + c5 * a4;
    if (r >= 0) {
      r = Math.sqrt(r);
      t014 = (-b6 + r) / a4;
      t13 = (-b6 - r) / a4;
    }
  } else {
    t014 = 0.5 * c5 / b6;
  }
  if (0 < t014 && t014 < 1)
    cb(cubic3(t014, x07, x13, x22, x32));
  if (0 < t13 && t13 < 1)
    cb(cubic3(t13, x07, x13, x22, x32));
}
function cubic3(t, x07, x13, x22, x32) {
  const s2 = 1 - t, s22 = s2 * s2, t22 = t * t;
  return s22 * s2 * x07 + 3 * s22 * t * x13 + 3 * s2 * t22 * x22 + t22 * t * x32;
}
var context3 = (context3 = domCanvas5(1, 1)) ? context3.getContext("2d") : null;
var b3 = new Bounds3();
function intersectPath3(draw7) {
  return function(item, brush) {
    if (!context3)
      return true;
    draw7(context3, item);
    b3.clear().union(item.bounds).intersect(brush).round();
    const {
      x1: x13,
      y1: y13,
      x2: x22,
      y2: y22
    } = b3;
    for (let y9 = y13; y9 <= y22; ++y9) {
      for (let x9 = x13; x9 <= x22; ++x9) {
        if (context3.isPointInPath(x9, y9)) {
          return true;
        }
      }
    }
    return false;
  };
}
function intersectPoint3(item, box) {
  return box.contains(item.x || 0, item.y || 0);
}
function intersectRect3(item, box) {
  const x9 = item.x || 0, y9 = item.y || 0, w8 = item.width || 0, h6 = item.height || 0;
  return box.intersects(b3.set(x9, y9, x9 + w8, y9 + h6));
}
function intersectRule3(item, box) {
  const x9 = item.x || 0, y9 = item.y || 0, x22 = item.x2 != null ? item.x2 : x9, y22 = item.y2 != null ? item.y2 : y9;
  return intersectBoxLine3(box, x9, y9, x22, y22);
}
function intersectBoxLine3(box, x9, y9, u4, v2) {
  const {
    x1: x13,
    y1: y13,
    x2: x22,
    y2: y22
  } = box, dx = u4 - x9, dy = v2 - y9;
  let t014 = 0, t13 = 1, p, q, r, e3;
  for (e3 = 0; e3 < 4; ++e3) {
    if (e3 === 0) {
      p = -dx;
      q = -(x13 - x9);
    }
    if (e3 === 1) {
      p = dx;
      q = x22 - x9;
    }
    if (e3 === 2) {
      p = -dy;
      q = -(y13 - y9);
    }
    if (e3 === 3) {
      p = dy;
      q = y22 - y9;
    }
    if (Math.abs(p) < 1e-10 && q < 0)
      return false;
    r = q / p;
    if (p < 0) {
      if (r > t13)
        return false;
      else if (r > t014)
        t014 = r;
    } else if (p > 0) {
      if (r < t014)
        return false;
      else if (r < t13)
        t13 = r;
    }
  }
  return true;
}
function blend3(context7, item) {
  context7.globalCompositeOperation = item.blend || "source-over";
}
function value3(value7, dflt) {
  return value7 == null ? dflt : value7;
}
function addStops3(gradient8, stops) {
  const n = stops.length;
  for (let i = 0; i < n; ++i) {
    gradient8.addColorStop(stops[i].offset, stops[i].color);
  }
  return gradient8;
}
function gradient3(context7, spec, bounds6) {
  const w8 = bounds6.width(), h6 = bounds6.height();
  let gradient8;
  if (spec.gradient === "radial") {
    gradient8 = context7.createRadialGradient(bounds6.x1 + value3(spec.x1, 0.5) * w8, bounds6.y1 + value3(spec.y1, 0.5) * h6, Math.max(w8, h6) * value3(spec.r1, 0), bounds6.x1 + value3(spec.x2, 0.5) * w8, bounds6.y1 + value3(spec.y2, 0.5) * h6, Math.max(w8, h6) * value3(spec.r2, 0.5));
  } else {
    const x13 = value3(spec.x1, 0), y13 = value3(spec.y1, 0), x22 = value3(spec.x2, 1), y22 = value3(spec.y2, 0);
    if (x13 === x22 || y13 === y22 || w8 === h6) {
      gradient8 = context7.createLinearGradient(bounds6.x1 + x13 * w8, bounds6.y1 + y13 * h6, bounds6.x1 + x22 * w8, bounds6.y1 + y22 * h6);
    } else {
      const image7 = domCanvas5(Math.ceil(w8), Math.ceil(h6)), ictx = image7.getContext("2d");
      ictx.scale(w8, h6);
      ictx.fillStyle = addStops3(ictx.createLinearGradient(x13, y13, x22, y22), spec.stops);
      ictx.fillRect(0, 0, w8, h6);
      return context7.createPattern(image7, "no-repeat");
    }
  }
  return addStops3(gradient8, spec.stops);
}
function color4(context7, item, value7) {
  return isGradient3(value7) ? gradient3(context7, value7, item.bounds) : value7;
}
function fill3(context7, item, opacity2) {
  opacity2 *= item.fillOpacity == null ? 1 : item.fillOpacity;
  if (opacity2 > 0) {
    context7.globalAlpha = opacity2;
    context7.fillStyle = color4(context7, item, item.fill);
    return true;
  } else {
    return false;
  }
}
var Empty4 = [];
function stroke3(context7, item, opacity2) {
  var lw = (lw = item.strokeWidth) != null ? lw : 1;
  if (lw <= 0)
    return false;
  opacity2 *= item.strokeOpacity == null ? 1 : item.strokeOpacity;
  if (opacity2 > 0) {
    context7.globalAlpha = opacity2;
    context7.strokeStyle = color4(context7, item, item.stroke);
    context7.lineWidth = lw;
    context7.lineCap = item.strokeCap || "butt";
    context7.lineJoin = item.strokeJoin || "miter";
    context7.miterLimit = item.strokeMiterLimit || 10;
    if (context7.setLineDash) {
      context7.setLineDash(item.strokeDash || Empty4);
      context7.lineDashOffset = item.strokeDashOffset || 0;
    }
    return true;
  } else {
    return false;
  }
}
function compare5(a4, b6) {
  return a4.zindex - b6.zindex || a4.index - b6.index;
}
function zorder3(scene) {
  if (!scene.zdirty)
    return scene.zitems;
  var items = scene.items, output3 = [], item, i, n;
  for (i = 0, n = items.length; i < n; ++i) {
    item = items[i];
    item.index = i;
    if (item.zindex)
      output3.push(item);
  }
  scene.zdirty = false;
  return scene.zitems = output3.sort(compare5);
}
function visit3(scene, visitor) {
  var items = scene.items, i, n;
  if (!items || !items.length)
    return;
  const zitems = zorder3(scene);
  if (zitems && zitems.length) {
    for (i = 0, n = items.length; i < n; ++i) {
      if (!items[i].zindex)
        visitor(items[i]);
    }
    items = zitems;
  }
  for (i = 0, n = items.length; i < n; ++i) {
    visitor(items[i]);
  }
}
function pickVisit3(scene, visitor) {
  var items = scene.items, hit6, i;
  if (!items || !items.length)
    return null;
  const zitems = zorder3(scene);
  if (zitems && zitems.length)
    items = zitems;
  for (i = items.length; --i >= 0; ) {
    if (hit6 = visitor(items[i]))
      return hit6;
  }
  if (items === zitems) {
    for (items = scene.items, i = items.length; --i >= 0; ) {
      if (!items[i].zindex) {
        if (hit6 = visitor(items[i]))
          return hit6;
      }
    }
  }
  return null;
}
function drawAll3(path7) {
  return function(context7, scene, bounds6) {
    visit3(scene, (item) => {
      if (!bounds6 || bounds6.intersects(item.bounds)) {
        drawPath3(path7, context7, item, item);
      }
    });
  };
}
function drawOne3(path7) {
  return function(context7, scene, bounds6) {
    if (scene.items.length && (!bounds6 || bounds6.intersects(scene.bounds))) {
      drawPath3(path7, context7, scene.items[0], scene.items);
    }
  };
}
function drawPath3(path7, context7, item, items) {
  var opacity2 = item.opacity == null ? 1 : item.opacity;
  if (opacity2 === 0)
    return;
  if (path7(context7, items))
    return;
  blend3(context7, item);
  if (item.fill && fill3(context7, item, opacity2)) {
    context7.fill();
  }
  if (item.stroke && stroke3(context7, item, opacity2)) {
    context7.stroke();
  }
}
function pick$13(test2) {
  test2 = test2 || truthy;
  return function(context7, scene, x9, y9, gx, gy) {
    x9 *= context7.pixelRatio;
    y9 *= context7.pixelRatio;
    return pickVisit3(scene, (item) => {
      const b6 = item.bounds;
      if (b6 && !b6.contains(gx, gy) || !b6)
        return;
      if (test2(context7, item, x9, y9, gx, gy))
        return item;
    });
  };
}
function hitPath3(path7, filled) {
  return function(context7, o, x9, y9) {
    var item = Array.isArray(o) ? o[0] : o, fill6 = filled == null ? item.fill : filled, stroke6 = item.stroke && context7.isPointInStroke, lw, lc;
    if (stroke6) {
      lw = item.strokeWidth;
      lc = item.strokeCap;
      context7.lineWidth = lw != null ? lw : 1;
      context7.lineCap = lc != null ? lc : "butt";
    }
    return path7(context7, o) ? false : fill6 && context7.isPointInPath(x9, y9) || stroke6 && context7.isPointInStroke(x9, y9);
  };
}
function pickPath3(path7) {
  return pick$13(hitPath3(path7));
}
function translate4(x9, y9) {
  return "translate(" + x9 + "," + y9 + ")";
}
function rotate3(a4) {
  return "rotate(" + a4 + ")";
}
function scale10(scaleX, scaleY2) {
  return "scale(" + scaleX + "," + scaleY2 + ")";
}
function translateItem3(item) {
  return translate4(item.x || 0, item.y || 0);
}
function rotateItem3(item) {
  return translate4(item.x || 0, item.y || 0) + (item.angle ? " " + rotate3(item.angle) : "");
}
function transformItem3(item) {
  return translate4(item.x || 0, item.y || 0) + (item.angle ? " " + rotate3(item.angle) : "") + (item.scaleX || item.scaleY ? " " + scale10(item.scaleX || 1, item.scaleY || 1) : "");
}
function markItemPath3(type7, shape6, isect) {
  function attr6(emit6, item) {
    emit6("transform", rotateItem3(item));
    emit6("d", shape6(null, item));
  }
  function bound6(bounds6, item) {
    shape6(boundContext3(bounds6, item.angle), item);
    return boundStroke3(bounds6, item).translate(item.x || 0, item.y || 0);
  }
  function draw7(context7, item) {
    var x9 = item.x || 0, y9 = item.y || 0, a4 = item.angle || 0;
    context7.translate(x9, y9);
    if (a4)
      context7.rotate(a4 *= DegToRad3);
    context7.beginPath();
    shape6(context7, item);
    if (a4)
      context7.rotate(-a4);
    context7.translate(-x9, -y9);
  }
  return {
    type: type7,
    tag: "path",
    nested: false,
    attr: attr6,
    bound: bound6,
    draw: drawAll3(draw7),
    pick: pickPath3(draw7),
    isect: isect || intersectPath3(draw7)
  };
}
var arc4 = markItemPath3("arc", arc$13);
function pickArea3(a4, p) {
  var v2 = a4[0].orient === "horizontal" ? p[1] : p[0], z = a4[0].orient === "horizontal" ? "y" : "x", i = a4.length, min5 = Infinity, hit6, d;
  while (--i >= 0) {
    if (a4[i].defined === false)
      continue;
    d = Math.abs(a4[i][z] - v2);
    if (d < min5) {
      min5 = d;
      hit6 = a4[i];
    }
  }
  return hit6;
}
function pickLine3(a4, p) {
  var t = Math.pow(a4[0].strokeWidth || 1, 2), i = a4.length, dx, dy, dd;
  while (--i >= 0) {
    if (a4[i].defined === false)
      continue;
    dx = a4[i].x - p[0];
    dy = a4[i].y - p[1];
    dd = dx * dx + dy * dy;
    if (dd < t)
      return a4[i];
  }
  return null;
}
function pickTrail3(a4, p) {
  var i = a4.length, dx, dy, dd;
  while (--i >= 0) {
    if (a4[i].defined === false)
      continue;
    dx = a4[i].x - p[0];
    dy = a4[i].y - p[1];
    dd = dx * dx + dy * dy;
    dx = a4[i].size || 1;
    if (dd < dx * dx)
      return a4[i];
  }
  return null;
}
function markMultiItemPath3(type7, shape6, tip) {
  function attr6(emit6, item) {
    var items = item.mark.items;
    if (items.length)
      emit6("d", shape6(null, items));
  }
  function bound6(bounds6, mark) {
    var items = mark.items;
    if (items.length === 0) {
      return bounds6;
    } else {
      shape6(boundContext3(bounds6), items);
      return boundStroke3(bounds6, items[0]);
    }
  }
  function draw7(context7, items) {
    context7.beginPath();
    shape6(context7, items);
  }
  const hit6 = hitPath3(draw7);
  function pick7(context7, scene, x9, y9, gx, gy) {
    var items = scene.items, b6 = scene.bounds;
    if (!items || !items.length || b6 && !b6.contains(gx, gy)) {
      return null;
    }
    x9 *= context7.pixelRatio;
    y9 *= context7.pixelRatio;
    return hit6(context7, items, x9, y9) ? items[0] : null;
  }
  return {
    type: type7,
    tag: "path",
    nested: true,
    attr: attr6,
    bound: bound6,
    draw: drawOne3(draw7),
    pick: pick7,
    isect: intersectPoint3,
    tip
  };
}
var area4 = markMultiItemPath3("area", area$13, pickArea3);
function clip3(context7, scene) {
  var clip7 = scene.clip;
  context7.save();
  if (isFunction(clip7)) {
    context7.beginPath();
    clip7(context7);
    context7.clip();
  } else {
    clipGroup3(context7, scene.group);
  }
}
function clipGroup3(context7, group7) {
  context7.beginPath();
  hasCornerRadius3(group7) ? rectangle3(context7, group7, 0, 0) : context7.rect(0, 0, group7.width || 0, group7.height || 0);
  context7.clip();
}
function offset$13(item) {
  const sw = value3(item.strokeWidth, 1);
  return item.strokeOffset != null ? item.strokeOffset : item.stroke && sw > 0.5 && sw < 1.5 ? 0.5 - Math.abs(sw - 1) : 0;
}
function attr$53(emit6, item) {
  emit6("transform", translateItem3(item));
}
function emitRectangle3(emit6, item) {
  const off = offset$13(item);
  emit6("d", rectangle3(null, item, off, off));
}
function background3(emit6, item) {
  emit6("class", "background");
  emit6("aria-hidden", true);
  emitRectangle3(emit6, item);
}
function foreground3(emit6, item) {
  emit6("class", "foreground");
  emit6("aria-hidden", true);
  if (item.strokeForeground) {
    emitRectangle3(emit6, item);
  } else {
    emit6("d", "");
  }
}
function content3(emit6, item, renderer) {
  const url = item.clip ? clip$13(renderer, item, item) : null;
  emit6("clip-path", url);
}
function bound$53(bounds6, group7) {
  if (!group7.clip && group7.items) {
    const items = group7.items, m3 = items.length;
    for (let j = 0; j < m3; ++j) {
      bounds6.union(items[j].bounds);
    }
  }
  if ((group7.clip || group7.width || group7.height) && !group7.noBound) {
    bounds6.add(0, 0).add(group7.width || 0, group7.height || 0);
  }
  boundStroke3(bounds6, group7);
  return bounds6.translate(group7.x || 0, group7.y || 0);
}
function rectanglePath3(context7, group7, x9, y9) {
  const off = offset$13(group7);
  context7.beginPath();
  rectangle3(context7, group7, (x9 || 0) + off, (y9 || 0) + off);
}
var hitBackground3 = hitPath3(rectanglePath3);
var hitForeground3 = hitPath3(rectanglePath3, false);
var hitCorner3 = hitPath3(rectanglePath3, true);
function draw$43(context7, scene, bounds6, markTypes) {
  visit3(scene, (group7) => {
    const gx = group7.x || 0, gy = group7.y || 0, fore = group7.strokeForeground, opacity2 = group7.opacity == null ? 1 : group7.opacity;
    if ((group7.stroke || group7.fill) && opacity2) {
      rectanglePath3(context7, group7, gx, gy);
      blend3(context7, group7);
      if (group7.fill && fill3(context7, group7, opacity2)) {
        context7.fill();
      }
      if (group7.stroke && !fore && stroke3(context7, group7, opacity2)) {
        context7.stroke();
      }
    }
    context7.save();
    context7.translate(gx, gy);
    if (group7.clip)
      clipGroup3(context7, group7);
    if (bounds6)
      bounds6.translate(-gx, -gy);
    visit3(group7, (item) => {
      if (item.marktype === "group" || markTypes == null || markTypes.includes(item.marktype)) {
        this.draw(context7, item, bounds6, markTypes);
      }
    });
    if (bounds6)
      bounds6.translate(gx, gy);
    context7.restore();
    if (fore && group7.stroke && opacity2) {
      rectanglePath3(context7, group7, gx, gy);
      blend3(context7, group7);
      if (stroke3(context7, group7, opacity2)) {
        context7.stroke();
      }
    }
  });
}
function pick3(context7, scene, x9, y9, gx, gy) {
  if (scene.bounds && !scene.bounds.contains(gx, gy) || !scene.items) {
    return null;
  }
  const cx = x9 * context7.pixelRatio, cy = y9 * context7.pixelRatio;
  return pickVisit3(scene, (group7) => {
    let hit6, dx, dy;
    const b6 = group7.bounds;
    if (b6 && !b6.contains(gx, gy))
      return;
    dx = group7.x || 0;
    dy = group7.y || 0;
    const dw = dx + (group7.width || 0), dh = dy + (group7.height || 0), c5 = group7.clip;
    if (c5 && (gx < dx || gx > dw || gy < dy || gy > dh))
      return;
    context7.save();
    context7.translate(dx, dy);
    dx = gx - dx;
    dy = gy - dy;
    if (c5 && hasCornerRadius3(group7) && !hitCorner3(context7, group7, cx, cy)) {
      context7.restore();
      return null;
    }
    const fore = group7.strokeForeground, ix = scene.interactive !== false;
    if (ix && fore && group7.stroke && hitForeground3(context7, group7, cx, cy)) {
      context7.restore();
      return group7;
    }
    hit6 = pickVisit3(group7, (mark) => pickMark3(mark, dx, dy) ? this.pick(mark, x9, y9, dx, dy) : null);
    if (!hit6 && ix && (group7.fill || !fore && group7.stroke) && hitBackground3(context7, group7, cx, cy)) {
      hit6 = group7;
    }
    context7.restore();
    return hit6 || null;
  });
}
function pickMark3(mark, x9, y9) {
  return (mark.interactive !== false || mark.marktype === "group") && mark.bounds && mark.bounds.contains(x9, y9);
}
var group4 = {
  type: "group",
  tag: "g",
  nested: false,
  attr: attr$53,
  bound: bound$53,
  draw: draw$43,
  pick: pick3,
  isect: intersectRect3,
  content: content3,
  background: background3,
  foreground: foreground3
};
var metadata3 = {
  "xmlns": "http://www.w3.org/2000/svg",
  "xmlns:xlink": "http://www.w3.org/1999/xlink",
  "version": "1.1"
};
function getImage3(item, renderer) {
  var image7 = item.image;
  if (!image7 || item.url && item.url !== image7.url) {
    image7 = {
      complete: false,
      width: 0,
      height: 0
    };
    renderer.loadImage(item.url).then((image8) => {
      item.image = image8;
      item.image.url = item.url;
    });
  }
  return image7;
}
function imageWidth3(item, image7) {
  return item.width != null ? item.width : !image7 || !image7.width ? 0 : item.aspect !== false && item.height ? item.height * image7.width / image7.height : image7.width;
}
function imageHeight3(item, image7) {
  return item.height != null ? item.height : !image7 || !image7.height ? 0 : item.aspect !== false && item.width ? item.width * image7.height / image7.width : image7.height;
}
function imageXOffset3(align2, w8) {
  return align2 === "center" ? w8 / 2 : align2 === "right" ? w8 : 0;
}
function imageYOffset3(baseline3, h6) {
  return baseline3 === "middle" ? h6 / 2 : baseline3 === "bottom" ? h6 : 0;
}
function attr$43(emit6, item, renderer) {
  const img = getImage3(item, renderer), w8 = imageWidth3(item, img), h6 = imageHeight3(item, img), x9 = (item.x || 0) - imageXOffset3(item.align, w8), y9 = (item.y || 0) - imageYOffset3(item.baseline, h6), i = !img.src && img.toDataURL ? img.toDataURL() : img.src || "";
  emit6("href", i, metadata3["xmlns:xlink"], "xlink:href");
  emit6("transform", translate4(x9, y9));
  emit6("width", w8);
  emit6("height", h6);
  emit6("preserveAspectRatio", item.aspect === false ? "none" : "xMidYMid");
}
function bound$43(bounds6, item) {
  const img = item.image, w8 = imageWidth3(item, img), h6 = imageHeight3(item, img), x9 = (item.x || 0) - imageXOffset3(item.align, w8), y9 = (item.y || 0) - imageYOffset3(item.baseline, h6);
  return bounds6.set(x9, y9, x9 + w8, y9 + h6);
}
function draw$33(context7, scene, bounds6) {
  visit3(scene, (item) => {
    if (bounds6 && !bounds6.intersects(item.bounds))
      return;
    const img = getImage3(item, this);
    let w8 = imageWidth3(item, img);
    let h6 = imageHeight3(item, img);
    if (w8 === 0 || h6 === 0)
      return;
    let x9 = (item.x || 0) - imageXOffset3(item.align, w8), y9 = (item.y || 0) - imageYOffset3(item.baseline, h6), opacity2, ar0, ar1, t;
    if (item.aspect !== false) {
      ar0 = img.width / img.height;
      ar1 = item.width / item.height;
      if (ar0 === ar0 && ar1 === ar1 && ar0 !== ar1) {
        if (ar1 < ar0) {
          t = w8 / ar0;
          y9 += (h6 - t) / 2;
          h6 = t;
        } else {
          t = h6 * ar0;
          x9 += (w8 - t) / 2;
          w8 = t;
        }
      }
    }
    if (img.complete || img.toDataURL) {
      blend3(context7, item);
      context7.globalAlpha = (opacity2 = item.opacity) != null ? opacity2 : 1;
      context7.imageSmoothingEnabled = item.smooth !== false;
      context7.drawImage(img, x9, y9, w8, h6);
    }
  });
}
var image3 = {
  type: "image",
  tag: "image",
  nested: false,
  attr: attr$43,
  bound: bound$43,
  draw: draw$33,
  pick: pick$13(),
  isect: truthy,
  // bounds check is sufficient
  get: getImage3,
  xOffset: imageXOffset3,
  yOffset: imageYOffset3
};
var line4 = markMultiItemPath3("line", line$13, pickLine3);
function attr$33(emit6, item) {
  var sx = item.scaleX || 1, sy = item.scaleY || 1;
  if (sx !== 1 || sy !== 1) {
    emit6("vector-effect", "non-scaling-stroke");
  }
  emit6("transform", transformItem3(item));
  emit6("d", item.path);
}
function path$13(context7, item) {
  var path7 = item.path;
  if (path7 == null)
    return true;
  var x9 = item.x || 0, y9 = item.y || 0, sx = item.scaleX || 1, sy = item.scaleY || 1, a4 = (item.angle || 0) * DegToRad3, cache2 = item.pathCache;
  if (!cache2 || cache2.path !== path7) {
    (item.pathCache = cache2 = parse7(path7)).path = path7;
  }
  if (a4 && context7.rotate && context7.translate) {
    context7.translate(x9, y9);
    context7.rotate(a4);
    pathRender3(context7, cache2, 0, 0, sx, sy);
    context7.rotate(-a4);
    context7.translate(-x9, -y9);
  } else {
    pathRender3(context7, cache2, x9, y9, sx, sy);
  }
}
function bound$33(bounds6, item) {
  return path$13(boundContext3(bounds6, item.angle), item) ? bounds6.set(0, 0, 0, 0) : boundStroke3(bounds6, item, true);
}
var path$23 = {
  type: "path",
  tag: "path",
  nested: false,
  attr: attr$33,
  bound: bound$33,
  draw: drawAll3(path$13),
  pick: pickPath3(path$13),
  isect: intersectPath3(path$13)
};
function attr$23(emit6, item) {
  emit6("d", rectangle3(null, item));
}
function bound$23(bounds6, item) {
  var x9, y9;
  return boundStroke3(bounds6.set(x9 = item.x || 0, y9 = item.y || 0, x9 + item.width || 0, y9 + item.height || 0), item);
}
function draw$23(context7, item) {
  context7.beginPath();
  rectangle3(context7, item);
}
var rect3 = {
  type: "rect",
  tag: "path",
  nested: false,
  attr: attr$23,
  bound: bound$23,
  draw: drawAll3(draw$23),
  pick: pickPath3(draw$23),
  isect: intersectRect3
};
function attr$13(emit6, item) {
  emit6("transform", translateItem3(item));
  emit6("x2", item.x2 != null ? item.x2 - (item.x || 0) : 0);
  emit6("y2", item.y2 != null ? item.y2 - (item.y || 0) : 0);
}
function bound$13(bounds6, item) {
  var x13, y13;
  return boundStroke3(bounds6.set(x13 = item.x || 0, y13 = item.y || 0, item.x2 != null ? item.x2 : x13, item.y2 != null ? item.y2 : y13), item);
}
function path4(context7, item, opacity2) {
  var x13, y13, x22, y22;
  if (item.stroke && stroke3(context7, item, opacity2)) {
    x13 = item.x || 0;
    y13 = item.y || 0;
    x22 = item.x2 != null ? item.x2 : x13;
    y22 = item.y2 != null ? item.y2 : y13;
    context7.beginPath();
    context7.moveTo(x13, y13);
    context7.lineTo(x22, y22);
    return true;
  }
  return false;
}
function draw$13(context7, scene, bounds6) {
  visit3(scene, (item) => {
    if (bounds6 && !bounds6.intersects(item.bounds))
      return;
    var opacity2 = item.opacity == null ? 1 : item.opacity;
    if (opacity2 && path4(context7, item, opacity2)) {
      blend3(context7, item);
      context7.stroke();
    }
  });
}
function hit$13(context7, item, x9, y9) {
  if (!context7.isPointInStroke)
    return false;
  return path4(context7, item, 1) && context7.isPointInStroke(x9, y9);
}
var rule3 = {
  type: "rule",
  tag: "line",
  nested: false,
  attr: attr$13,
  bound: bound$13,
  draw: draw$13,
  pick: pick$13(hit$13),
  isect: intersectRule3
};
var shape3 = markItemPath3("shape", shape$13);
var symbol3 = markItemPath3("symbol", symbol$13, intersectPoint3);
var widthCache3 = lruCache();
var textMetrics3 = {
  height: fontSize3,
  measureWidth: measureWidth3,
  estimateWidth: estimateWidth3,
  width: estimateWidth3,
  canvas: useCanvas3
};
useCanvas3(true);
function useCanvas3(use) {
  textMetrics3.width = use && context3 ? measureWidth3 : estimateWidth3;
}
function estimateWidth3(item, text7) {
  return _estimateWidth3(textValue3(item, text7), fontSize3(item));
}
function _estimateWidth3(text7, currentFontHeight) {
  return ~~(0.8 * text7.length * currentFontHeight);
}
function measureWidth3(item, text7) {
  return fontSize3(item) <= 0 || !(text7 = textValue3(item, text7)) ? 0 : _measureWidth3(text7, font3(item));
}
function _measureWidth3(text7, currentFont) {
  const key4 = `(${currentFont}) ${text7}`;
  let width2 = widthCache3.get(key4);
  if (width2 === void 0) {
    context3.font = currentFont;
    width2 = context3.measureText(text7).width;
    widthCache3.set(key4, width2);
  }
  return width2;
}
function fontSize3(item) {
  return item.fontSize != null ? +item.fontSize || 0 : 11;
}
function lineHeight3(item) {
  return item.lineHeight != null ? item.lineHeight : fontSize3(item) + 2;
}
function lineArray3(_) {
  return isArray(_) ? _.length > 1 ? _ : _[0] : _;
}
function textLines3(item) {
  return lineArray3(item.lineBreak && item.text && !isArray(item.text) ? item.text.split(item.lineBreak) : item.text);
}
function multiLineOffset2(item) {
  const tl6 = textLines3(item);
  return (isArray(tl6) ? tl6.length - 1 : 0) * lineHeight3(item);
}
function textValue3(item, line8) {
  const text7 = line8 == null ? "" : (line8 + "").trim();
  return item.limit > 0 && text7.length ? truncate4(item, text7) : text7;
}
function widthGetter3(item) {
  if (textMetrics3.width === measureWidth3) {
    const currentFont = font3(item);
    return (text7) => _measureWidth3(text7, currentFont);
  } else if (textMetrics3.width === estimateWidth3) {
    const currentFontHeight = fontSize3(item);
    return (text7) => _estimateWidth3(text7, currentFontHeight);
  } else {
    return (text7) => textMetrics3.width(item, text7);
  }
}
function truncate4(item, text7) {
  var limit = +item.limit, width2 = widthGetter3(item);
  if (width2(text7) < limit)
    return text7;
  var ellipsis = item.ellipsis || "…", rtl = item.dir === "rtl", lo = 0, hi = text7.length, mid;
  limit -= width2(ellipsis);
  if (rtl) {
    while (lo < hi) {
      mid = lo + hi >>> 1;
      if (width2(text7.slice(mid)) > limit)
        lo = mid + 1;
      else
        hi = mid;
    }
    return ellipsis + text7.slice(lo);
  } else {
    while (lo < hi) {
      mid = 1 + (lo + hi >>> 1);
      if (width2(text7.slice(0, mid)) < limit)
        lo = mid;
      else
        hi = mid - 1;
    }
    return text7.slice(0, lo) + ellipsis;
  }
}
function fontFamily3(item, quote) {
  var font7 = item.font;
  return (quote && font7 ? String(font7).replace(/"/g, "'") : font7) || "sans-serif";
}
function font3(item, quote) {
  return (item.fontStyle ? item.fontStyle + " " : "") + (item.fontVariant ? item.fontVariant + " " : "") + (item.fontWeight ? item.fontWeight + " " : "") + fontSize3(item) + "px " + fontFamily3(item, quote);
}
function offset4(item) {
  var baseline3 = item.baseline, h6 = fontSize3(item);
  return Math.round(baseline3 === "top" ? 0.79 * h6 : baseline3 === "middle" ? 0.3 * h6 : baseline3 === "bottom" ? -0.21 * h6 : baseline3 === "line-top" ? 0.29 * h6 + 0.5 * lineHeight3(item) : baseline3 === "line-bottom" ? 0.29 * h6 - 0.5 * lineHeight3(item) : 0);
}
var textAlign3 = {
  "left": "start",
  "center": "middle",
  "right": "end"
};
var tempBounds4 = new Bounds3();
function anchorPoint3(item) {
  var x9 = item.x || 0, y9 = item.y || 0, r = item.radius || 0, t;
  if (r) {
    t = (item.theta || 0) - HalfPi3;
    x9 += r * Math.cos(t);
    y9 += r * Math.sin(t);
  }
  tempBounds4.x1 = x9;
  tempBounds4.y1 = y9;
  return tempBounds4;
}
function attr3(emit6, item) {
  var dx = item.dx || 0, dy = (item.dy || 0) + offset4(item), p = anchorPoint3(item), x9 = p.x1, y9 = p.y1, a4 = item.angle || 0, t;
  emit6("text-anchor", textAlign3[item.align] || "start");
  if (a4) {
    t = translate4(x9, y9) + " " + rotate3(a4);
    if (dx || dy)
      t += " " + translate4(dx, dy);
  } else {
    t = translate4(x9 + dx, y9 + dy);
  }
  emit6("transform", t);
}
function bound3(bounds6, item, mode2) {
  var h6 = textMetrics3.height(item), a4 = item.align, p = anchorPoint3(item), x9 = p.x1, y9 = p.y1, dx = item.dx || 0, dy = (item.dy || 0) + offset4(item) - Math.round(0.8 * h6), tl6 = textLines3(item), w8;
  if (isArray(tl6)) {
    h6 += lineHeight3(item) * (tl6.length - 1);
    w8 = tl6.reduce((w9, t) => Math.max(w9, textMetrics3.width(item, t)), 0);
  } else {
    w8 = textMetrics3.width(item, tl6);
  }
  if (a4 === "center") {
    dx -= w8 / 2;
  } else if (a4 === "right") {
    dx -= w8;
  } else
    ;
  bounds6.set(dx += x9, dy += y9, dx + w8, dy + h6);
  if (item.angle && !mode2) {
    bounds6.rotate(item.angle * DegToRad3, x9, y9);
  } else if (mode2 === 2) {
    return bounds6.rotatedPoints(item.angle * DegToRad3, x9, y9);
  }
  return bounds6;
}
function draw4(context7, scene, bounds6) {
  visit3(scene, (item) => {
    var opacity2 = item.opacity == null ? 1 : item.opacity, p, x9, y9, i, lh, tl6, str;
    if (bounds6 && !bounds6.intersects(item.bounds) || // bounds check
    opacity2 === 0 || item.fontSize <= 0 || item.text == null || item.text.length === 0)
      return;
    context7.font = font3(item);
    context7.textAlign = item.align || "left";
    p = anchorPoint3(item);
    x9 = p.x1, y9 = p.y1;
    if (item.angle) {
      context7.save();
      context7.translate(x9, y9);
      context7.rotate(item.angle * DegToRad3);
      x9 = y9 = 0;
    }
    x9 += item.dx || 0;
    y9 += (item.dy || 0) + offset4(item);
    tl6 = textLines3(item);
    blend3(context7, item);
    if (isArray(tl6)) {
      lh = lineHeight3(item);
      for (i = 0; i < tl6.length; ++i) {
        str = textValue3(item, tl6[i]);
        if (item.fill && fill3(context7, item, opacity2)) {
          context7.fillText(str, x9, y9);
        }
        if (item.stroke && stroke3(context7, item, opacity2)) {
          context7.strokeText(str, x9, y9);
        }
        y9 += lh;
      }
    } else {
      str = textValue3(item, tl6);
      if (item.fill && fill3(context7, item, opacity2)) {
        context7.fillText(str, x9, y9);
      }
      if (item.stroke && stroke3(context7, item, opacity2)) {
        context7.strokeText(str, x9, y9);
      }
    }
    if (item.angle)
      context7.restore();
  });
}
function hit3(context7, item, x9, y9, gx, gy) {
  if (item.fontSize <= 0)
    return false;
  if (!item.angle)
    return true;
  var p = anchorPoint3(item), ax = p.x1, ay = p.y1, b6 = bound3(tempBounds4, item, 1), a4 = -item.angle * DegToRad3, cos4 = Math.cos(a4), sin4 = Math.sin(a4), px6 = cos4 * gx - sin4 * gy + (ax - cos4 * ax + sin4 * ay), py6 = sin4 * gx + cos4 * gy + (ay - sin4 * ax - cos4 * ay);
  return b6.contains(px6, py6);
}
function intersectText3(item, box) {
  const p = bound3(tempBounds4, item, 2);
  return intersectBoxLine3(box, p[0], p[1], p[2], p[3]) || intersectBoxLine3(box, p[0], p[1], p[4], p[5]) || intersectBoxLine3(box, p[4], p[5], p[6], p[7]) || intersectBoxLine3(box, p[2], p[3], p[6], p[7]);
}
var text3 = {
  type: "text",
  tag: "text",
  nested: false,
  attr: attr3,
  bound: bound3,
  draw: draw4,
  pick: pick$13(hit3),
  isect: intersectText3
};
var trail3 = markMultiItemPath3("trail", trail$13, pickTrail3);
var Marks3 = {
  arc: arc4,
  area: area4,
  group: group4,
  image: image3,
  line: line4,
  path: path$23,
  rect: rect3,
  rule: rule3,
  shape: shape3,
  symbol: symbol3,
  text: text3,
  trail: trail3
};
function boundItem2(item, func, opt) {
  var type7 = Marks3[item.mark.marktype], bound6 = func || type7.bound;
  if (type7.nested)
    item = item.mark;
  return bound6(item.bounds || (item.bounds = new Bounds3()), item, opt);
}
var DUMMY = {
  mark: null
};
function boundMark(mark, bounds6, opt) {
  var type7 = Marks3[mark.marktype], bound6 = type7.bound, items = mark.items, hasItems = items && items.length, i, n, item, b6;
  if (type7.nested) {
    if (hasItems) {
      item = items[0];
    } else {
      DUMMY.mark = mark;
      item = DUMMY;
    }
    b6 = boundItem2(item, bound6, opt);
    bounds6 = bounds6 && bounds6.union(b6) || b6;
    return bounds6;
  }
  bounds6 = bounds6 || mark.bounds && mark.bounds.clear() || new Bounds3();
  if (hasItems) {
    for (i = 0, n = items.length; i < n; ++i) {
      bounds6.union(boundItem2(items[i], bound6, opt));
    }
  }
  return mark.bounds = bounds6;
}
var keys = [
  "marktype",
  "name",
  "role",
  "interactive",
  "clip",
  "items",
  "zindex",
  "x",
  "y",
  "width",
  "height",
  "align",
  "baseline",
  // layout
  "fill",
  "fillOpacity",
  "opacity",
  "blend",
  // fill
  "stroke",
  "strokeOpacity",
  "strokeWidth",
  "strokeCap",
  // stroke
  "strokeDash",
  "strokeDashOffset",
  // stroke dash
  "strokeForeground",
  "strokeOffset",
  // group
  "startAngle",
  "endAngle",
  "innerRadius",
  "outerRadius",
  // arc
  "cornerRadius",
  "padAngle",
  // arc, rect
  "cornerRadiusTopLeft",
  "cornerRadiusTopRight",
  // rect, group
  "cornerRadiusBottomLeft",
  "cornerRadiusBottomRight",
  "interpolate",
  "tension",
  "orient",
  "defined",
  // area, line
  "url",
  "aspect",
  "smooth",
  // image
  "path",
  "scaleX",
  "scaleY",
  // path
  "x2",
  "y2",
  // rule
  "size",
  "shape",
  // symbol
  "text",
  "angle",
  "theta",
  "radius",
  "dir",
  "dx",
  "dy",
  // text
  "ellipsis",
  "limit",
  "lineBreak",
  "lineHeight",
  "font",
  "fontSize",
  "fontWeight",
  "fontStyle",
  "fontVariant",
  // font
  "description",
  "aria",
  "ariaRole",
  "ariaRoleDescription"
  // aria
];
function sceneToJSON(scene, indent) {
  return JSON.stringify(scene, keys, indent);
}
function sceneFromJSON(json7) {
  const scene = typeof json7 === "string" ? JSON.parse(json7) : json7;
  return initialize(scene);
}
function initialize(scene) {
  var type7 = scene.marktype, items = scene.items, parent, i, n;
  if (items) {
    for (i = 0, n = items.length; i < n; ++i) {
      parent = type7 ? "mark" : "group";
      items[i][parent] = scene;
      if (items[i].zindex)
        items[i][parent].zdirty = true;
      if ("group" === (type7 || parent))
        initialize(items[i]);
    }
  }
  if (type7)
    boundMark(scene);
  return scene;
}
var Scenegraph = class {
  constructor(scene) {
    if (arguments.length) {
      this.root = sceneFromJSON(scene);
    } else {
      this.root = createMark({
        marktype: "group",
        name: "root",
        role: "frame"
      });
      this.root.items = [new GroupItem3(this.root)];
    }
  }
  toJSON(indent) {
    return sceneToJSON(this.root, indent || 0);
  }
  mark(markdef, group7, index4) {
    group7 = group7 || this.root.items[0];
    const mark = createMark(markdef, group7);
    group7.items[index4] = mark;
    if (mark.zindex)
      mark.group.zdirty = true;
    return mark;
  }
};
function createMark(def6, group7) {
  const mark = {
    bounds: new Bounds3(),
    clip: !!def6.clip,
    group: group7,
    interactive: def6.interactive === false ? false : true,
    items: [],
    marktype: def6.marktype,
    name: def6.name || void 0,
    role: def6.role || void 0,
    zindex: def6.zindex || 0
  };
  if (def6.aria != null) {
    mark.aria = def6.aria;
  }
  if (def6.description) {
    mark.description = def6.description;
  }
  return mark;
}
function domCreate3(doc, tag, ns) {
  if (!doc && typeof document !== "undefined" && document.createElement) {
    doc = document;
  }
  return doc ? ns ? doc.createElementNS(ns, tag) : doc.createElement(tag) : null;
}
function domFind3(el, tag) {
  tag = tag.toLowerCase();
  var nodes = el.childNodes, i = 0, n = nodes.length;
  for (; i < n; ++i)
    if (nodes[i].tagName.toLowerCase() === tag) {
      return nodes[i];
    }
}
function domChild3(el, index4, tag, ns) {
  var a4 = el.childNodes[index4], b6;
  if (!a4 || a4.tagName.toLowerCase() !== tag.toLowerCase()) {
    b6 = a4 || null;
    a4 = domCreate3(el.ownerDocument, tag, ns);
    el.insertBefore(a4, b6);
  }
  return a4;
}
function domClear3(el, index4) {
  var nodes = el.childNodes, curr = nodes.length;
  while (curr > index4)
    el.removeChild(nodes[--curr]);
  return el;
}
function cssClass3(mark) {
  return "mark-" + mark.marktype + (mark.role ? " role-" + mark.role : "") + (mark.name ? " " + mark.name : "");
}
function point14(event2, el) {
  const rect7 = el.getBoundingClientRect();
  return [event2.clientX - rect7.left - (el.clientLeft || 0), event2.clientY - rect7.top - (el.clientTop || 0)];
}
function resolveItem3(item, event2, el, origin) {
  var mark = item && item.mark, mdef, p;
  if (mark && (mdef = Marks3[mark.marktype]).tip) {
    p = point14(event2, el);
    p[0] -= origin[0];
    p[1] -= origin[1];
    while (item = item.mark.group) {
      p[0] -= item.x || 0;
      p[1] -= item.y || 0;
    }
    item = mdef.tip(mark.items, p);
  }
  return item;
}
var Handler3 = class {
  /**
   * Create a new Handler instance.
   * @param {object} [customLoader] - Optional loader instance for
   *   href URL sanitization. If not specified, a standard loader
   *   instance will be generated.
   * @param {function} [customTooltip] - Optional tooltip handler
   *   function for custom tooltip display.
   * @constructor
   */
  constructor(customLoader, customTooltip) {
    this._active = null;
    this._handlers = {};
    this._loader = customLoader || loader4();
    this._tooltip = customTooltip || defaultTooltip3;
  }
  /**
   * Initialize a new Handler instance.
   * @param {DOMElement} el - The containing DOM element for the display.
   * @param {Array<number>} origin - The origin of the display, in pixels.
   *   The coordinate system will be translated to this point.
   * @param {object} [obj] - Optional context object that should serve as
   *   the "this" context for event callbacks.
   * @return {Handler} - This handler instance.
   */
  initialize(el, origin, obj) {
    this._el = el;
    this._obj = obj || null;
    return this.origin(origin);
  }
  /**
   * Returns the parent container element for a visualization.
   * @return {DOMElement} - The containing DOM element.
   */
  element() {
    return this._el;
  }
  /**
   * Returns the scene element (e.g., canvas or SVG) of the visualization
   * Subclasses must override if the first child is not the scene element.
   * @return {DOMElement} - The scene (e.g., canvas or SVG) element.
   */
  canvas() {
    return this._el && this._el.firstChild;
  }
  /**
   * Get / set the origin coordinates of the visualization.
   */
  origin(origin) {
    if (arguments.length) {
      this._origin = origin || [0, 0];
      return this;
    } else {
      return this._origin.slice();
    }
  }
  /**
   * Get / set the scenegraph root.
   */
  scene(scene) {
    if (!arguments.length)
      return this._scene;
    this._scene = scene;
    return this;
  }
  /**
   * Add an event handler. Subclasses should override this method.
   */
  on() {
  }
  /**
   * Remove an event handler. Subclasses should override this method.
   */
  off() {
  }
  /**
   * Utility method for finding the array index of an event handler.
   * @param {Array} h - An array of registered event handlers.
   * @param {string} type - The event type.
   * @param {function} handler - The event handler instance to find.
   * @return {number} - The handler's array index or -1 if not registered.
   */
  _handlerIndex(h6, type7, handler) {
    for (let i = h6 ? h6.length : 0; --i >= 0; ) {
      if (h6[i].type === type7 && (!handler || h6[i].handler === handler)) {
        return i;
      }
    }
    return -1;
  }
  /**
   * Returns an array with registered event handlers.
   * @param {string} [type] - The event type to query. Any annotations
   *   are ignored; for example, for the argument "click.foo", ".foo" will
   *   be ignored and the method returns all "click" handlers. If type is
   *   null or unspecified, this method returns handlers for all types.
   * @return {Array} - A new array containing all registered event handlers.
   */
  handlers(type7) {
    const h6 = this._handlers, a4 = [];
    if (type7) {
      a4.push(...h6[this.eventName(type7)]);
    } else {
      for (const k3 in h6) {
        a4.push(...h6[k3]);
      }
    }
    return a4;
  }
  /**
   * Parses an event name string to return the specific event type.
   * For example, given "click.foo" returns "click"
   * @param {string} name - The input event type string.
   * @return {string} - A string with the event type only.
   */
  eventName(name) {
    const i = name.indexOf(".");
    return i < 0 ? name : name.slice(0, i);
  }
  /**
   * Handle hyperlink navigation in response to an item.href value.
   * @param {Event} event - The event triggering hyperlink navigation.
   * @param {Item} item - The scenegraph item.
   * @param {string} href - The URL to navigate to.
   */
  handleHref(event2, item, href6) {
    this._loader.sanitize(href6, {
      context: "href"
    }).then((opt) => {
      const e3 = new MouseEvent(event2.type, event2), a4 = domCreate3(null, "a");
      for (const name in opt)
        a4.setAttribute(name, opt[name]);
      a4.dispatchEvent(e3);
    }).catch(() => {
    });
  }
  /**
   * Handle tooltip display in response to an item.tooltip value.
   * @param {Event} event - The event triggering tooltip display.
   * @param {Item} item - The scenegraph item.
   * @param {boolean} show - A boolean flag indicating whether
   *   to show or hide a tooltip for the given item.
   */
  handleTooltip(event2, item, show) {
    if (item && item.tooltip != null) {
      item = resolveItem3(item, event2, this.canvas(), this._origin);
      const value7 = show && item && item.tooltip || null;
      this._tooltip.call(this._obj, this, event2, item, value7);
    }
  }
  /**
   * Returns the size of a scenegraph item and its position relative
   * to the viewport.
   * @param {Item} item - The scenegraph item.
   * @return {object} - A bounding box object (compatible with the
   *   DOMRect type) consisting of x, y, width, heigh, top, left,
   *   right, and bottom properties.
   */
  getItemBoundingClientRect(item) {
    const el = this.canvas();
    if (!el)
      return;
    const rect7 = el.getBoundingClientRect(), origin = this._origin, bounds6 = item.bounds, width2 = bounds6.width(), height2 = bounds6.height();
    let x9 = bounds6.x1 + origin[0] + rect7.left, y9 = bounds6.y1 + origin[1] + rect7.top;
    while (item.mark && (item = item.mark.group)) {
      x9 += item.x || 0;
      y9 += item.y || 0;
    }
    return {
      x: x9,
      y: y9,
      width: width2,
      height: height2,
      left: x9,
      top: y9,
      right: x9 + width2,
      bottom: y9 + height2
    };
  }
};
function defaultTooltip3(handler, event2, item, value7) {
  handler.element().setAttribute("title", value7 || "");
}
var Renderer3 = class {
  /**
   * Create a new Renderer instance.
   * @param {object} [loader] - Optional loader instance for
   *   image and href URL sanitization. If not specified, a
   *   standard loader instance will be generated.
   * @constructor
   */
  constructor(loader7) {
    this._el = null;
    this._bgcolor = null;
    this._loader = new ResourceLoader3(loader7);
  }
  /**
   * Initialize a new Renderer instance.
   * @param {DOMElement} el - The containing DOM element for the display.
   * @param {number} width - The coordinate width of the display, in pixels.
   * @param {number} height - The coordinate height of the display, in pixels.
   * @param {Array<number>} origin - The origin of the display, in pixels.
   *   The coordinate system will be translated to this point.
   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
   *   the width and height to determine the final pixel size.
   * @return {Renderer} - This renderer instance.
   */
  initialize(el, width2, height2, origin, scaleFactor) {
    this._el = el;
    return this.resize(width2, height2, origin, scaleFactor);
  }
  /**
   * Returns the parent container element for a visualization.
   * @return {DOMElement} - The containing DOM element.
   */
  element() {
    return this._el;
  }
  /**
   * Returns the scene element (e.g., canvas or SVG) of the visualization
   * Subclasses must override if the first child is not the scene element.
   * @return {DOMElement} - The scene (e.g., canvas or SVG) element.
   */
  canvas() {
    return this._el && this._el.firstChild;
  }
  /**
   * Get / set the background color.
   */
  background(bgcolor) {
    if (arguments.length === 0)
      return this._bgcolor;
    this._bgcolor = bgcolor;
    return this;
  }
  /**
   * Resize the display.
   * @param {number} width - The new coordinate width of the display, in pixels.
   * @param {number} height - The new coordinate height of the display, in pixels.
   * @param {Array<number>} origin - The new origin of the display, in pixels.
   *   The coordinate system will be translated to this point.
   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
   *   the width and height to determine the final pixel size.
   * @return {Renderer} - This renderer instance;
   */
  resize(width2, height2, origin, scaleFactor) {
    this._width = width2;
    this._height = height2;
    this._origin = origin || [0, 0];
    this._scale = scaleFactor || 1;
    return this;
  }
  /**
   * Report a dirty item whose bounds should be redrawn.
   * This base class method does nothing. Subclasses that perform
   * incremental should implement this method.
   * @param {Item} item - The dirty item whose bounds should be redrawn.
   */
  dirty() {
  }
  /**
   * Render an input scenegraph, potentially with a set of dirty items.
   * This method will perform an immediate rendering with available resources.
   * The renderer may also need to perform image loading to perform a complete
   * render. This process can lead to asynchronous re-rendering of the scene
   * after this method returns. To receive notification when rendering is
   * complete, use the renderAsync method instead.
   * @param {object} scene - The root mark of a scenegraph to render.
   * @param {Array} markTypes - Array of the mark types to render.
   *                            If undefined, render all mark types
   * @return {Renderer} - This renderer instance.
   */
  render(scene, markTypes) {
    const r = this;
    r._call = function() {
      r._render(scene, markTypes);
    };
    r._call();
    r._call = null;
    return r;
  }
  /**
   * Internal rendering method. Renderer subclasses should override this
   * method to actually perform rendering.
   * @param {object} scene - The root mark of a scenegraph to render.
   * @param {Array} markTypes - Array of the mark types to render.
   *                            If undefined, render all mark types
   */
  _render() {
  }
  /**
   * Asynchronous rendering method. Similar to render, but returns a Promise
   * that resolves when all rendering is completed. Sometimes a renderer must
   * perform image loading to get a complete rendering. The returned
   * Promise will not resolve until this process completes.
   * @param {object} scene - The root mark of a scenegraph to render.
   * @param {Array} markTypes - Array of the mark types to render.
   *                            If undefined, render all mark types
   * @return {Promise} - A Promise that resolves when rendering is complete.
   */
  renderAsync(scene, markTypes) {
    const r = this.render(scene, markTypes);
    return this._ready ? this._ready.then(() => r) : Promise.resolve(r);
  }
  /**
   * Internal method for asynchronous resource loading.
   * Proxies method calls to the ImageLoader, and tracks loading
   * progress to invoke a re-render once complete.
   * @param {string} method - The method name to invoke on the ImageLoader.
   * @param {string} uri - The URI for the requested resource.
   * @return {Promise} - A Promise that resolves to the requested resource.
   */
  _load(method10, uri) {
    var r = this, p = r._loader[method10](uri);
    if (!r._ready) {
      const call = r._call;
      r._ready = r._loader.ready().then((redraw) => {
        if (redraw)
          call();
        r._ready = null;
      });
    }
    return p;
  }
  /**
   * Sanitize a URL to include as a hyperlink in the rendered scene.
   * This method proxies a call to ImageLoader.sanitizeURL, but also tracks
   * image loading progress and invokes a re-render once complete.
   * @param {string} uri - The URI string to sanitize.
   * @return {Promise} - A Promise that resolves to the sanitized URL.
   */
  sanitizeURL(uri) {
    return this._load("sanitizeURL", uri);
  }
  /**
   * Requests an image to include in the rendered scene.
   * This method proxies a call to ImageLoader.loadImage, but also tracks
   * image loading progress and invokes a re-render once complete.
   * @param {string} uri - The URI string of the image.
   * @return {Promise} - A Promise that resolves to the loaded Image.
   */
  loadImage(uri) {
    return this._load("loadImage", uri);
  }
};
var KeyDownEvent3 = "keydown";
var KeyPressEvent3 = "keypress";
var KeyUpEvent3 = "keyup";
var DragEnterEvent3 = "dragenter";
var DragLeaveEvent3 = "dragleave";
var DragOverEvent3 = "dragover";
var PointerDownEvent3 = "pointerdown";
var PointerUpEvent3 = "pointerup";
var PointerMoveEvent3 = "pointermove";
var PointerOutEvent3 = "pointerout";
var PointerOverEvent3 = "pointerover";
var MouseDownEvent3 = "mousedown";
var MouseUpEvent3 = "mouseup";
var MouseMoveEvent3 = "mousemove";
var MouseOutEvent3 = "mouseout";
var MouseOverEvent3 = "mouseover";
var ClickEvent3 = "click";
var DoubleClickEvent3 = "dblclick";
var WheelEvent3 = "wheel";
var MouseWheelEvent3 = "mousewheel";
var TouchStartEvent3 = "touchstart";
var TouchMoveEvent3 = "touchmove";
var TouchEndEvent3 = "touchend";
var Events3 = [KeyDownEvent3, KeyPressEvent3, KeyUpEvent3, DragEnterEvent3, DragLeaveEvent3, DragOverEvent3, PointerDownEvent3, PointerUpEvent3, PointerMoveEvent3, PointerOutEvent3, PointerOverEvent3, MouseDownEvent3, MouseUpEvent3, MouseMoveEvent3, MouseOutEvent3, MouseOverEvent3, ClickEvent3, DoubleClickEvent3, WheelEvent3, MouseWheelEvent3, TouchStartEvent3, TouchMoveEvent3, TouchEndEvent3];
var TooltipShowEvent3 = PointerMoveEvent3;
var TooltipHideEvent3 = MouseOutEvent3;
var HrefEvent3 = ClickEvent3;
var CanvasHandler3 = class extends Handler3 {
  constructor(loader7, tooltip2) {
    super(loader7, tooltip2);
    this._down = null;
    this._touch = null;
    this._first = true;
    this._events = {};
    this.events = Events3;
    this.pointermove = move3([PointerMoveEvent3, MouseMoveEvent3], [PointerOverEvent3, MouseOverEvent3], [PointerOutEvent3, MouseOutEvent3]);
    this.dragover = move3([DragOverEvent3], [DragEnterEvent3], [DragLeaveEvent3]), this.pointerout = inactive3([PointerOutEvent3, MouseOutEvent3]);
    this.dragleave = inactive3([DragLeaveEvent3]);
  }
  initialize(el, origin, obj) {
    this._canvas = el && domFind3(el, "canvas");
    [ClickEvent3, MouseDownEvent3, PointerDownEvent3, PointerMoveEvent3, PointerOutEvent3, DragLeaveEvent3].forEach((type7) => eventListenerCheck3(this, type7));
    return super.initialize(el, origin, obj);
  }
  // return the backing canvas instance
  canvas() {
    return this._canvas;
  }
  // retrieve the current canvas context
  context() {
    return this._canvas.getContext("2d");
  }
  // to keep old versions of firefox happy
  DOMMouseScroll(evt) {
    this.fire(MouseWheelEvent3, evt);
  }
  pointerdown(evt) {
    this._down = this._active;
    this.fire(PointerDownEvent3, evt);
  }
  mousedown(evt) {
    this._down = this._active;
    this.fire(MouseDownEvent3, evt);
  }
  click(evt) {
    if (this._down === this._active) {
      this.fire(ClickEvent3, evt);
      this._down = null;
    }
  }
  touchstart(evt) {
    this._touch = this.pickEvent(evt.changedTouches[0]);
    if (this._first) {
      this._active = this._touch;
      this._first = false;
    }
    this.fire(TouchStartEvent3, evt, true);
  }
  touchmove(evt) {
    this.fire(TouchMoveEvent3, evt, true);
  }
  touchend(evt) {
    this.fire(TouchEndEvent3, evt, true);
    this._touch = null;
  }
  // fire an event
  fire(type7, evt, touch2) {
    const a4 = touch2 ? this._touch : this._active, h6 = this._handlers[type7];
    evt.vegaType = type7;
    if (type7 === HrefEvent3 && a4 && a4.href) {
      this.handleHref(evt, a4, a4.href);
    } else if (type7 === TooltipShowEvent3 || type7 === TooltipHideEvent3) {
      this.handleTooltip(evt, a4, type7 !== TooltipHideEvent3);
    }
    if (h6) {
      for (let i = 0, len = h6.length; i < len; ++i) {
        h6[i].handler.call(this._obj, evt, a4);
      }
    }
  }
  // add an event handler
  on(type7, handler) {
    const name = this.eventName(type7), h6 = this._handlers, i = this._handlerIndex(h6[name], type7, handler);
    if (i < 0) {
      eventListenerCheck3(this, type7);
      (h6[name] || (h6[name] = [])).push({
        type: type7,
        handler
      });
    }
    return this;
  }
  // remove an event handler
  off(type7, handler) {
    const name = this.eventName(type7), h6 = this._handlers[name], i = this._handlerIndex(h6, type7, handler);
    if (i >= 0) {
      h6.splice(i, 1);
    }
    return this;
  }
  pickEvent(evt) {
    const p = point14(evt, this._canvas), o = this._origin;
    return this.pick(this._scene, p[0], p[1], p[0] - o[0], p[1] - o[1]);
  }
  // find the scenegraph item at the current pointer position
  // x, y -- the absolute x, y pointer coordinates on the canvas element
  // gx, gy -- the relative coordinates within the current group
  pick(scene, x9, y9, gx, gy) {
    const g = this.context(), mark = Marks3[scene.marktype];
    return mark.pick.call(this, g, scene, x9, y9, gx, gy);
  }
};
var eventBundle3 = (type7) => type7 === TouchStartEvent3 || type7 === TouchMoveEvent3 || type7 === TouchEndEvent3 ? [TouchStartEvent3, TouchMoveEvent3, TouchEndEvent3] : [type7];
function eventListenerCheck3(handler, type7) {
  eventBundle3(type7).forEach((_) => addEventListener3(handler, _));
}
function addEventListener3(handler, type7) {
  const canvas = handler.canvas();
  if (canvas && !handler._events[type7]) {
    handler._events[type7] = 1;
    canvas.addEventListener(type7, handler[type7] ? (evt) => handler[type7](evt) : (evt) => handler.fire(type7, evt));
  }
}
function fireAll3(handler, types, event2) {
  types.forEach((type7) => handler.fire(type7, event2));
}
function move3(moveEvents, overEvents, outEvents) {
  return function(evt) {
    const a4 = this._active, p = this.pickEvent(evt);
    if (p === a4) {
      fireAll3(this, moveEvents, evt);
    } else {
      if (!a4 || !a4.exit) {
        fireAll3(this, outEvents, evt);
      }
      this._active = p;
      fireAll3(this, overEvents, evt);
      fireAll3(this, moveEvents, evt);
    }
  };
}
function inactive3(types) {
  return function(evt) {
    fireAll3(this, types, evt);
    this._active = null;
  };
}
function devicePixelRatio3() {
  return typeof window !== "undefined" ? window.devicePixelRatio || 1 : 1;
}
function resize3(canvas, width2, height2, origin, scaleFactor, opt) {
  const inDOM = typeof HTMLElement !== "undefined" && canvas instanceof HTMLElement && canvas.parentNode != null, context7 = canvas.getContext("2d"), ratio = inDOM ? devicePixelRatio3() : scaleFactor;
  canvas.width = width2 * ratio;
  canvas.height = height2 * ratio;
  for (const key4 in opt) {
    context7[key4] = opt[key4];
  }
  if (inDOM && ratio !== 1) {
    canvas.style.width = width2 + "px";
    canvas.style.height = height2 + "px";
  }
  context7.pixelRatio = ratio;
  context7.setTransform(ratio, 0, 0, ratio, ratio * origin[0], ratio * origin[1]);
  return canvas;
}
var CanvasRenderer3 = class extends Renderer3 {
  constructor(loader7) {
    super(loader7);
    this._options = {};
    this._redraw = false;
    this._dirty = new Bounds3();
    this._tempb = new Bounds3();
  }
  initialize(el, width2, height2, origin, scaleFactor, options) {
    this._options = options || {};
    this._canvas = this._options.externalContext ? null : domCanvas5(1, 1, this._options.type);
    if (el && this._canvas) {
      domClear3(el, 0).appendChild(this._canvas);
      this._canvas.setAttribute("class", "marks");
    }
    return super.initialize(el, width2, height2, origin, scaleFactor);
  }
  resize(width2, height2, origin, scaleFactor) {
    super.resize(width2, height2, origin, scaleFactor);
    if (this._canvas) {
      resize3(this._canvas, this._width, this._height, this._origin, this._scale, this._options.context);
    } else {
      const ctx = this._options.externalContext;
      if (!ctx)
        error("CanvasRenderer is missing a valid canvas or context");
      ctx.scale(this._scale, this._scale);
      ctx.translate(this._origin[0], this._origin[1]);
    }
    this._redraw = true;
    return this;
  }
  canvas() {
    return this._canvas;
  }
  context() {
    return this._options.externalContext || (this._canvas ? this._canvas.getContext("2d") : null);
  }
  dirty(item) {
    const b6 = this._tempb.clear().union(item.bounds);
    let g = item.mark.group;
    while (g) {
      b6.translate(g.x || 0, g.y || 0);
      g = g.mark.group;
    }
    this._dirty.union(b6);
  }
  _render(scene, markTypes) {
    const g = this.context(), o = this._origin, w8 = this._width, h6 = this._height, db = this._dirty, vb = viewBounds3(o, w8, h6);
    g.save();
    const b6 = this._redraw || db.empty() ? (this._redraw = false, vb.expand(1)) : clipToBounds3(g, vb.intersect(db), o);
    this.clear(-o[0], -o[1], w8, h6);
    this.draw(g, scene, b6, markTypes);
    g.restore();
    db.clear();
    return this;
  }
  draw(ctx, scene, bounds6, markTypes) {
    if (scene.marktype !== "group" && markTypes != null && !markTypes.includes(scene.marktype)) {
      return;
    }
    const mark = Marks3[scene.marktype];
    if (scene.clip)
      clip3(ctx, scene);
    mark.draw.call(this, ctx, scene, bounds6, markTypes);
    if (scene.clip)
      ctx.restore();
  }
  clear(x9, y9, w8, h6) {
    const opt = this._options, g = this.context();
    if (opt.type !== "pdf" && !opt.externalContext) {
      g.clearRect(x9, y9, w8, h6);
    }
    if (this._bgcolor != null) {
      g.fillStyle = this._bgcolor;
      g.fillRect(x9, y9, w8, h6);
    }
  }
};
var viewBounds3 = (origin, width2, height2) => new Bounds3().set(0, 0, width2, height2).translate(-origin[0], -origin[1]);
function clipToBounds3(g, b6, origin) {
  b6.expand(1).round();
  if (g.pixelRatio % 1) {
    b6.scale(g.pixelRatio).round().scale(1 / g.pixelRatio);
  }
  b6.translate(-(origin[0] % 1), -(origin[1] % 1));
  g.beginPath();
  g.rect(b6.x1, b6.y1, b6.width(), b6.height());
  g.clip();
  return b6;
}
var SVGHandler3 = class extends Handler3 {
  constructor(loader7, tooltip2) {
    super(loader7, tooltip2);
    const h6 = this;
    h6._hrefHandler = listener3(h6, (evt, item) => {
      if (item && item.href)
        h6.handleHref(evt, item, item.href);
    });
    h6._tooltipHandler = listener3(h6, (evt, item) => {
      h6.handleTooltip(evt, item, evt.type !== TooltipHideEvent3);
    });
  }
  initialize(el, origin, obj) {
    let svg = this._svg;
    if (svg) {
      svg.removeEventListener(HrefEvent3, this._hrefHandler);
      svg.removeEventListener(TooltipShowEvent3, this._tooltipHandler);
      svg.removeEventListener(TooltipHideEvent3, this._tooltipHandler);
    }
    this._svg = svg = el && domFind3(el, "svg");
    if (svg) {
      svg.addEventListener(HrefEvent3, this._hrefHandler);
      svg.addEventListener(TooltipShowEvent3, this._tooltipHandler);
      svg.addEventListener(TooltipHideEvent3, this._tooltipHandler);
    }
    return super.initialize(el, origin, obj);
  }
  canvas() {
    return this._svg;
  }
  // add an event handler
  on(type7, handler) {
    const name = this.eventName(type7), h6 = this._handlers, i = this._handlerIndex(h6[name], type7, handler);
    if (i < 0) {
      const x9 = {
        type: type7,
        handler,
        listener: listener3(this, handler)
      };
      (h6[name] || (h6[name] = [])).push(x9);
      if (this._svg) {
        this._svg.addEventListener(name, x9.listener);
      }
    }
    return this;
  }
  // remove an event handler
  off(type7, handler) {
    const name = this.eventName(type7), h6 = this._handlers[name], i = this._handlerIndex(h6, type7, handler);
    if (i >= 0) {
      if (this._svg) {
        this._svg.removeEventListener(name, h6[i].listener);
      }
      h6.splice(i, 1);
    }
    return this;
  }
};
var listener3 = (context7, handler) => (evt) => {
  let item = evt.target.__data__;
  item = Array.isArray(item) ? item[0] : item;
  evt.vegaType = evt.type;
  handler.call(context7._obj, evt, item);
};
var ARIA_HIDDEN3 = "aria-hidden";
var ARIA_LABEL3 = "aria-label";
var ARIA_ROLE3 = "role";
var ARIA_ROLEDESCRIPTION3 = "aria-roledescription";
var GRAPHICS_OBJECT3 = "graphics-object";
var GRAPHICS_SYMBOL3 = "graphics-symbol";
var bundle3 = (role, roledesc, label) => ({
  [ARIA_ROLE3]: role,
  [ARIA_ROLEDESCRIPTION3]: roledesc,
  [ARIA_LABEL3]: label || void 0
});
var AriaIgnore3 = toSet(["axis-domain", "axis-grid", "axis-label", "axis-tick", "axis-title", "legend-band", "legend-entry", "legend-gradient", "legend-label", "legend-title", "legend-symbol", "title"]);
var AriaGuides3 = {
  "axis": {
    desc: "axis",
    caption: axisCaption3
  },
  "legend": {
    desc: "legend",
    caption: legendCaption3
  },
  "title-text": {
    desc: "title",
    caption: (item) => `Title text '${titleCaption3(item)}'`
  },
  "title-subtitle": {
    desc: "subtitle",
    caption: (item) => `Subtitle text '${titleCaption3(item)}'`
  }
};
var AriaEncode3 = {
  ariaRole: ARIA_ROLE3,
  ariaRoleDescription: ARIA_ROLEDESCRIPTION3,
  description: ARIA_LABEL3
};
function ariaItemAttributes3(emit6, item) {
  const hide = item.aria === false;
  emit6(ARIA_HIDDEN3, hide || void 0);
  if (hide || item.description == null) {
    for (const prop in AriaEncode3) {
      emit6(AriaEncode3[prop], void 0);
    }
  } else {
    const type7 = item.mark.marktype;
    emit6(ARIA_LABEL3, item.description);
    emit6(ARIA_ROLE3, item.ariaRole || (type7 === "group" ? GRAPHICS_OBJECT3 : GRAPHICS_SYMBOL3));
    emit6(ARIA_ROLEDESCRIPTION3, item.ariaRoleDescription || `${type7} mark`);
  }
}
function ariaMarkAttributes3(mark) {
  return mark.aria === false ? {
    [ARIA_HIDDEN3]: true
  } : AriaIgnore3[mark.role] ? null : AriaGuides3[mark.role] ? ariaGuide3(mark, AriaGuides3[mark.role]) : ariaMark3(mark);
}
function ariaMark3(mark) {
  const type7 = mark.marktype;
  const recurse6 = type7 === "group" || type7 === "text" || mark.items.some((_) => _.description != null && _.aria !== false);
  return bundle3(recurse6 ? GRAPHICS_OBJECT3 : GRAPHICS_SYMBOL3, `${type7} mark container`, mark.description);
}
function ariaGuide3(mark, opt) {
  try {
    const item = mark.items[0], caption = opt.caption || (() => "");
    return bundle3(opt.role || GRAPHICS_SYMBOL3, opt.desc, item.description || caption(item));
  } catch (err) {
    return null;
  }
}
function titleCaption3(item) {
  return array(item.text).join(" ");
}
function axisCaption3(item) {
  const datum2 = item.datum, orient2 = item.orient, title2 = datum2.title ? extractTitle3(item) : null, ctx = item.context, scale19 = ctx.scales[datum2.scale].value, locale5 = ctx.dataflow.locale(), type7 = scale19.type, xy = orient2 === "left" || orient2 === "right" ? "Y" : "X";
  return `${xy}-axis` + (title2 ? ` titled '${title2}'` : "") + ` for a ${isDiscrete3(type7) ? "discrete" : type7} scale with ${domainCaption3(locale5, scale19, item)}`;
}
function legendCaption3(item) {
  const datum2 = item.datum, title2 = datum2.title ? extractTitle3(item) : null, type7 = `${datum2.type || ""} legend`.trim(), scales10 = datum2.scales, props = Object.keys(scales10), ctx = item.context, scale19 = ctx.scales[scales10[props[0]]].value, locale5 = ctx.dataflow.locale();
  return capitalize3(type7) + (title2 ? ` titled '${title2}'` : "") + ` for ${channelCaption3(props)} with ${domainCaption3(locale5, scale19, item)}`;
}
function extractTitle3(item) {
  try {
    return array(peek(item.items).items[0].text).join(" ");
  } catch (err) {
    return null;
  }
}
function channelCaption3(props) {
  props = props.map((p) => p + (p === "fill" || p === "stroke" ? " color" : ""));
  return props.length < 2 ? props[0] : props.slice(0, -1).join(", ") + " and " + peek(props);
}
function capitalize3(s2) {
  return s2.length ? s2[0].toUpperCase() + s2.slice(1) : s2;
}
var innerText3 = (val) => (val + "").replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
var attrText3 = (val) => innerText3(val).replace(/"/g, "&quot;").replace(/\t/g, "&#x9;").replace(/\n/g, "&#xA;").replace(/\r/g, "&#xD;");
function markup3() {
  let buf = "", outer = "", inner = "";
  const stack2 = [], clear2 = () => outer = inner = "", push = (tag) => {
    if (outer) {
      buf += `${outer}>${inner}`;
      clear2();
    }
    stack2.push(tag);
  }, attr6 = (name, value7) => {
    if (value7 != null)
      outer += ` ${name}="${attrText3(value7)}"`;
    return m3;
  }, m3 = {
    open(tag, ...attrs) {
      push(tag);
      outer = "<" + tag;
      for (const set7 of attrs) {
        for (const key4 in set7)
          attr6(key4, set7[key4]);
      }
      return m3;
    },
    close() {
      const tag = stack2.pop();
      if (outer) {
        buf += outer + (inner ? `>${inner}</${tag}>` : "/>");
      } else {
        buf += `</${tag}>`;
      }
      clear2();
      return m3;
    },
    attr: attr6,
    text: (t) => (inner += innerText3(t), m3),
    toString: () => buf
  };
  return m3;
}
var serializeXML3 = (node) => _serialize3(markup3(), node) + "";
function _serialize3(m3, node) {
  m3.open(node.tagName);
  if (node.hasAttributes()) {
    const attrs = node.attributes, n = attrs.length;
    for (let i = 0; i < n; ++i) {
      m3.attr(attrs[i].name, attrs[i].value);
    }
  }
  if (node.hasChildNodes()) {
    const children3 = node.childNodes;
    for (const child of children3) {
      child.nodeType === 3 ? m3.text(child.nodeValue) : _serialize3(m3, child);
    }
  }
  return m3.close();
}
var stylesAttr3 = {
  fill: "fill",
  fillOpacity: "fill-opacity",
  stroke: "stroke",
  strokeOpacity: "stroke-opacity",
  strokeWidth: "stroke-width",
  strokeCap: "stroke-linecap",
  strokeJoin: "stroke-linejoin",
  strokeDash: "stroke-dasharray",
  strokeDashOffset: "stroke-dashoffset",
  strokeMiterLimit: "stroke-miterlimit",
  opacity: "opacity"
};
var stylesCss3 = {
  blend: "mix-blend-mode"
};
var rootAttributes3 = {
  "fill": "none",
  "stroke-miterlimit": 10
};
var RootIndex3 = 0;
var xmlns3 = "http://www.w3.org/2000/xmlns/";
var svgns3 = metadata3.xmlns;
var SVGRenderer3 = class extends Renderer3 {
  constructor(loader7) {
    super(loader7);
    this._dirtyID = 0;
    this._dirty = [];
    this._svg = null;
    this._root = null;
    this._defs = null;
  }
  /**
   * Initialize a new SVGRenderer instance.
   * @param {DOMElement} el - The containing DOM element for the display.
   * @param {number} width - The coordinate width of the display, in pixels.
   * @param {number} height - The coordinate height of the display, in pixels.
   * @param {Array<number>} origin - The origin of the display, in pixels.
   *   The coordinate system will be translated to this point.
   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
   *   the width and height to determine the final pixel size.
   * @return {SVGRenderer} - This renderer instance.
   */
  initialize(el, width2, height2, origin, scaleFactor) {
    this._defs = {};
    this._clearDefs();
    if (el) {
      this._svg = domChild3(el, 0, "svg", svgns3);
      this._svg.setAttributeNS(xmlns3, "xmlns", svgns3);
      this._svg.setAttributeNS(xmlns3, "xmlns:xlink", metadata3["xmlns:xlink"]);
      this._svg.setAttribute("version", metadata3["version"]);
      this._svg.setAttribute("class", "marks");
      domClear3(el, 1);
      this._root = domChild3(this._svg, RootIndex3, "g", svgns3);
      setAttributes3(this._root, rootAttributes3);
      domClear3(this._svg, RootIndex3 + 1);
    }
    this.background(this._bgcolor);
    return super.initialize(el, width2, height2, origin, scaleFactor);
  }
  /**
   * Get / set the background color.
   */
  background(bgcolor) {
    if (arguments.length && this._svg) {
      this._svg.style.setProperty("background-color", bgcolor);
    }
    return super.background(...arguments);
  }
  /**
   * Resize the display.
   * @param {number} width - The new coordinate width of the display, in pixels.
   * @param {number} height - The new coordinate height of the display, in pixels.
   * @param {Array<number>} origin - The new origin of the display, in pixels.
   *   The coordinate system will be translated to this point.
   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
   *   the width and height to determine the final pixel size.
   * @return {SVGRenderer} - This renderer instance;
   */
  resize(width2, height2, origin, scaleFactor) {
    super.resize(width2, height2, origin, scaleFactor);
    if (this._svg) {
      setAttributes3(this._svg, {
        width: this._width * this._scale,
        height: this._height * this._scale,
        viewBox: `0 0 ${this._width} ${this._height}`
      });
      this._root.setAttribute("transform", `translate(${this._origin})`);
    }
    this._dirty = [];
    return this;
  }
  /**
   * Returns the SVG element of the visualization.
   * @return {DOMElement} - The SVG element.
   */
  canvas() {
    return this._svg;
  }
  /**
   * Returns an SVG text string for the rendered content,
   * or null if this renderer is currently headless.
   */
  svg() {
    const svg = this._svg, bg = this._bgcolor;
    if (!svg)
      return null;
    let node;
    if (bg) {
      svg.removeAttribute("style");
      node = domChild3(svg, RootIndex3, "rect", svgns3);
      setAttributes3(node, {
        width: this._width,
        height: this._height,
        fill: bg
      });
    }
    const text7 = serializeXML3(svg);
    if (bg) {
      svg.removeChild(node);
      this._svg.style.setProperty("background-color", bg);
    }
    return text7;
  }
  /**
   * Internal rendering method.
   * @param {object} scene - The root mark of a scenegraph to render.
   * @param {Array} markTypes - Array of the mark types to render.
   *                            If undefined, render all mark types
   */
  _render(scene, markTypes) {
    if (this._dirtyCheck()) {
      if (this._dirtyAll)
        this._clearDefs();
      this.mark(this._root, scene, void 0, markTypes);
      domClear3(this._root, 1);
    }
    this.defs();
    this._dirty = [];
    ++this._dirtyID;
    return this;
  }
  // -- Manage rendering of items marked as dirty --
  /**
   * Flag a mark item as dirty.
   * @param {Item} item - The mark item.
   */
  dirty(item) {
    if (item.dirty !== this._dirtyID) {
      item.dirty = this._dirtyID;
      this._dirty.push(item);
    }
  }
  /**
   * Check if a mark item is considered dirty.
   * @param {Item} item - The mark item.
   */
  isDirty(item) {
    return this._dirtyAll || !item._svg || !item._svg.ownerSVGElement || item.dirty === this._dirtyID;
  }
  /**
   * Internal method to check dirty status and, if possible,
   * make targetted updates without a full rendering pass.
   */
  _dirtyCheck() {
    this._dirtyAll = true;
    const items = this._dirty;
    if (!items.length || !this._dirtyID)
      return true;
    const id24 = ++this._dirtyID;
    let item, mark, type7, mdef, i, n, o;
    for (i = 0, n = items.length; i < n; ++i) {
      item = items[i];
      mark = item.mark;
      if (mark.marktype !== type7) {
        type7 = mark.marktype;
        mdef = Marks3[type7];
      }
      if (mark.zdirty && mark.dirty !== id24) {
        this._dirtyAll = false;
        dirtyParents3(item, id24);
        mark.items.forEach((i2) => {
          i2.dirty = id24;
        });
      }
      if (mark.zdirty)
        continue;
      if (item.exit) {
        if (mdef.nested && mark.items.length) {
          o = mark.items[0];
          if (o._svg)
            this._update(mdef, o._svg, o);
        } else if (item._svg) {
          o = item._svg.parentNode;
          if (o)
            o.removeChild(item._svg);
        }
        item._svg = null;
        continue;
      }
      item = mdef.nested ? mark.items[0] : item;
      if (item._update === id24)
        continue;
      if (!item._svg || !item._svg.ownerSVGElement) {
        this._dirtyAll = false;
        dirtyParents3(item, id24);
      } else {
        this._update(mdef, item._svg, item);
      }
      item._update = id24;
    }
    return !this._dirtyAll;
  }
  // -- Construct & maintain scenegraph to SVG mapping ---
  /**
   * Render a set of mark items.
   * @param {SVGElement} el - The parent element in the SVG tree.
   * @param {object} scene - The mark parent to render.
   * @param {SVGElement} prev - The previous sibling in the SVG tree.
   * @param {Array} markTypes - Array of the mark types to render.
   *                            If undefined, render all mark types
   */
  mark(el, scene, prev, markTypes) {
    if (!this.isDirty(scene)) {
      return scene._svg;
    }
    const svg = this._svg, markType2 = scene.marktype, mdef = Marks3[markType2], events3 = scene.interactive === false ? "none" : null, isGroup = mdef.tag === "g";
    const parent = bind3(scene, el, prev, "g", svg);
    if (markType2 !== "group" && markTypes != null && !markTypes.includes(markType2)) {
      domClear3(parent, 0);
      return scene._svg;
    }
    parent.setAttribute("class", cssClass3(scene));
    const aria2 = ariaMarkAttributes3(scene);
    for (const key4 in aria2)
      setAttribute3(parent, key4, aria2[key4]);
    if (!isGroup) {
      setAttribute3(parent, "pointer-events", events3);
    }
    setAttribute3(parent, "clip-path", scene.clip ? clip$13(this, scene, scene.group) : null);
    let sibling = null, i = 0;
    const process2 = (item) => {
      const dirty = this.isDirty(item), node = bind3(item, parent, sibling, mdef.tag, svg);
      if (dirty) {
        this._update(mdef, node, item);
        if (isGroup)
          recurse3(this, node, item, markTypes);
      }
      sibling = node;
      ++i;
    };
    if (mdef.nested) {
      if (scene.items.length)
        process2(scene.items[0]);
    } else {
      visit3(scene, process2);
    }
    domClear3(parent, i);
    return parent;
  }
  /**
   * Update the attributes of an SVG element for a mark item.
   * @param {object} mdef - The mark definition object
   * @param {SVGElement} el - The SVG element.
   * @param {Item} item - The mark item.
   */
  _update(mdef, el, item) {
    element3 = el;
    values3 = el.__values__;
    ariaItemAttributes3(emit3, item);
    mdef.attr(emit3, item, this);
    const extra = mark_extras3[mdef.type];
    if (extra)
      extra.call(this, mdef, el, item);
    if (element3)
      this.style(element3, item);
  }
  /**
   * Update the presentation attributes of an SVG element for a mark item.
   * @param {SVGElement} el - The SVG element.
   * @param {Item} item - The mark item.
   */
  style(el, item) {
    if (item == null)
      return;
    for (const prop in stylesAttr3) {
      let value7 = prop === "font" ? fontFamily3(item) : item[prop];
      if (value7 === values3[prop])
        continue;
      const name = stylesAttr3[prop];
      if (value7 == null) {
        el.removeAttribute(name);
      } else {
        if (isGradient3(value7)) {
          value7 = gradientRef3(value7, this._defs.gradient, href3());
        }
        el.setAttribute(name, value7 + "");
      }
      values3[prop] = value7;
    }
    for (const prop in stylesCss3) {
      setStyle3(el, stylesCss3[prop], item[prop]);
    }
  }
  /**
   * Render SVG defs, as needed.
   * Must be called *after* marks have been processed to ensure the
   * collected state is current and accurate.
   */
  defs() {
    const svg = this._svg, defs = this._defs;
    let el = defs.el, index4 = 0;
    for (const id24 in defs.gradient) {
      if (!el)
        defs.el = el = domChild3(svg, RootIndex3 + 1, "defs", svgns3);
      index4 = updateGradient3(el, defs.gradient[id24], index4);
    }
    for (const id24 in defs.clipping) {
      if (!el)
        defs.el = el = domChild3(svg, RootIndex3 + 1, "defs", svgns3);
      index4 = updateClipping3(el, defs.clipping[id24], index4);
    }
    if (el) {
      index4 === 0 ? (svg.removeChild(el), defs.el = null) : domClear3(el, index4);
    }
  }
  /**
   * Clear defs caches.
   */
  _clearDefs() {
    const def6 = this._defs;
    def6.gradient = {};
    def6.clipping = {};
  }
};
function dirtyParents3(item, id24) {
  for (; item && item.dirty !== id24; item = item.mark.group) {
    item.dirty = id24;
    if (item.mark && item.mark.dirty !== id24) {
      item.mark.dirty = id24;
    } else
      return;
  }
}
function updateGradient3(el, grad, index4) {
  let i, n, stop2;
  if (grad.gradient === "radial") {
    let pt = domChild3(el, index4++, "pattern", svgns3);
    setAttributes3(pt, {
      id: patternPrefix3 + grad.id,
      viewBox: "0,0,1,1",
      width: "100%",
      height: "100%",
      preserveAspectRatio: "xMidYMid slice"
    });
    pt = domChild3(pt, 0, "rect", svgns3);
    setAttributes3(pt, {
      width: 1,
      height: 1,
      fill: `url(${href3()}#${grad.id})`
    });
    el = domChild3(el, index4++, "radialGradient", svgns3);
    setAttributes3(el, {
      id: grad.id,
      fx: grad.x1,
      fy: grad.y1,
      fr: grad.r1,
      cx: grad.x2,
      cy: grad.y2,
      r: grad.r2
    });
  } else {
    el = domChild3(el, index4++, "linearGradient", svgns3);
    setAttributes3(el, {
      id: grad.id,
      x1: grad.x1,
      x2: grad.x2,
      y1: grad.y1,
      y2: grad.y2
    });
  }
  for (i = 0, n = grad.stops.length; i < n; ++i) {
    stop2 = domChild3(el, i, "stop", svgns3);
    stop2.setAttribute("offset", grad.stops[i].offset);
    stop2.setAttribute("stop-color", grad.stops[i].color);
  }
  domClear3(el, i);
  return index4;
}
function updateClipping3(el, clip7, index4) {
  let mask;
  el = domChild3(el, index4, "clipPath", svgns3);
  el.setAttribute("id", clip7.id);
  if (clip7.path) {
    mask = domChild3(el, 0, "path", svgns3);
    mask.setAttribute("d", clip7.path);
  } else {
    mask = domChild3(el, 0, "rect", svgns3);
    setAttributes3(mask, {
      x: 0,
      y: 0,
      width: clip7.width,
      height: clip7.height
    });
  }
  domClear3(el, 1);
  return index4 + 1;
}
function recurse3(renderer, el, group7, markTypes) {
  el = el.lastChild.previousSibling;
  let prev, idx = 0;
  visit3(group7, (item) => {
    prev = renderer.mark(el, item, prev, markTypes);
    ++idx;
  });
  domClear3(el, 1 + idx);
}
function bind3(item, el, sibling, tag, svg) {
  let node = item._svg, doc;
  if (!node) {
    doc = el.ownerDocument;
    node = domCreate3(doc, tag, svgns3);
    item._svg = node;
    if (item.mark) {
      node.__data__ = item;
      node.__values__ = {
        fill: "default"
      };
      if (tag === "g") {
        const bg = domCreate3(doc, "path", svgns3);
        node.appendChild(bg);
        bg.__data__ = item;
        const cg = domCreate3(doc, "g", svgns3);
        node.appendChild(cg);
        cg.__data__ = item;
        const fg = domCreate3(doc, "path", svgns3);
        node.appendChild(fg);
        fg.__data__ = item;
        fg.__values__ = {
          fill: "default"
        };
      }
    }
  }
  if (node.ownerSVGElement !== svg || siblingCheck3(node, sibling)) {
    el.insertBefore(node, sibling ? sibling.nextSibling : el.firstChild);
  }
  return node;
}
function siblingCheck3(node, sibling) {
  return node.parentNode && node.parentNode.childNodes.length > 1 && node.previousSibling != sibling;
}
var element3 = null;
var values3 = null;
var mark_extras3 = {
  group(mdef, el, item) {
    const fg = element3 = el.childNodes[2];
    values3 = fg.__values__;
    mdef.foreground(emit3, item, this);
    values3 = el.__values__;
    element3 = el.childNodes[1];
    mdef.content(emit3, item, this);
    const bg = element3 = el.childNodes[0];
    mdef.background(emit3, item, this);
    const value7 = item.mark.interactive === false ? "none" : null;
    if (value7 !== values3.events) {
      setAttribute3(fg, "pointer-events", value7);
      setAttribute3(bg, "pointer-events", value7);
      values3.events = value7;
    }
    if (item.strokeForeground && item.stroke) {
      const fill6 = item.fill;
      setAttribute3(fg, "display", null);
      this.style(bg, item);
      setAttribute3(bg, "stroke", null);
      if (fill6)
        item.fill = null;
      values3 = fg.__values__;
      this.style(fg, item);
      if (fill6)
        item.fill = fill6;
      element3 = null;
    } else {
      setAttribute3(fg, "display", "none");
    }
  },
  image(mdef, el, item) {
    if (item.smooth === false) {
      setStyle3(el, "image-rendering", "optimizeSpeed");
      setStyle3(el, "image-rendering", "pixelated");
    } else {
      setStyle3(el, "image-rendering", null);
    }
  },
  text(mdef, el, item) {
    const tl6 = textLines3(item);
    let key4, value7, doc, lh;
    if (isArray(tl6)) {
      value7 = tl6.map((_) => textValue3(item, _));
      key4 = value7.join("\n");
      if (key4 !== values3.text) {
        domClear3(el, 0);
        doc = el.ownerDocument;
        lh = lineHeight3(item);
        value7.forEach((t, i) => {
          const ts6 = domCreate3(doc, "tspan", svgns3);
          ts6.__data__ = item;
          ts6.textContent = t;
          if (i) {
            ts6.setAttribute("x", 0);
            ts6.setAttribute("dy", lh);
          }
          el.appendChild(ts6);
        });
        values3.text = key4;
      }
    } else {
      value7 = textValue3(item, tl6);
      if (value7 !== values3.text) {
        el.textContent = value7;
        values3.text = value7;
      }
    }
    setAttribute3(el, "font-family", fontFamily3(item));
    setAttribute3(el, "font-size", fontSize3(item) + "px");
    setAttribute3(el, "font-style", item.fontStyle);
    setAttribute3(el, "font-variant", item.fontVariant);
    setAttribute3(el, "font-weight", item.fontWeight);
  }
};
function emit3(name, value7, ns) {
  if (value7 === values3[name])
    return;
  if (ns) {
    setAttributeNS3(element3, name, value7, ns);
  } else {
    setAttribute3(element3, name, value7);
  }
  values3[name] = value7;
}
function setStyle3(el, name, value7) {
  if (value7 !== values3[name]) {
    if (value7 == null) {
      el.style.removeProperty(name);
    } else {
      el.style.setProperty(name, value7 + "");
    }
    values3[name] = value7;
  }
}
function setAttributes3(el, attrs) {
  for (const key4 in attrs) {
    setAttribute3(el, key4, attrs[key4]);
  }
}
function setAttribute3(el, name, value7) {
  if (value7 != null) {
    el.setAttribute(name, value7);
  } else {
    el.removeAttribute(name);
  }
}
function setAttributeNS3(el, name, value7, ns) {
  if (value7 != null) {
    el.setAttributeNS(ns, name, value7);
  } else {
    el.removeAttributeNS(ns, name);
  }
}
function href3() {
  let loc;
  return typeof window === "undefined" ? "" : (loc = window.location).hash ? loc.href.slice(0, -loc.hash.length) : loc.href;
}
var SVGStringRenderer3 = class extends Renderer3 {
  constructor(loader7) {
    super(loader7);
    this._text = null;
    this._defs = {
      gradient: {},
      clipping: {}
    };
  }
  /**
   * Returns the rendered SVG text string,
   * or null if rendering has not yet occurred.
   */
  svg() {
    return this._text;
  }
  /**
   * Internal rendering method.
   * @param {object} scene - The root mark of a scenegraph to render.
   */
  _render(scene) {
    const m3 = markup3();
    m3.open("svg", extend({}, metadata3, {
      class: "marks",
      width: this._width * this._scale,
      height: this._height * this._scale,
      viewBox: `0 0 ${this._width} ${this._height}`
    }));
    const bg = this._bgcolor;
    if (bg && bg !== "transparent" && bg !== "none") {
      m3.open("rect", {
        width: this._width,
        height: this._height,
        fill: bg
      }).close();
    }
    m3.open("g", rootAttributes3, {
      transform: "translate(" + this._origin + ")"
    });
    this.mark(m3, scene);
    m3.close();
    this.defs(m3);
    this._text = m3.close() + "";
    return this;
  }
  /**
   * Render a set of mark items.
   * @param {object} m - The markup context.
   * @param {object} scene - The mark parent to render.
   */
  mark(m3, scene) {
    const mdef = Marks3[scene.marktype], tag = mdef.tag, attrList = [ariaItemAttributes3, mdef.attr];
    m3.open("g", {
      "class": cssClass3(scene),
      "clip-path": scene.clip ? clip$13(this, scene, scene.group) : null
    }, ariaMarkAttributes3(scene), {
      "pointer-events": tag !== "g" && scene.interactive === false ? "none" : null
    });
    const process2 = (item) => {
      const href6 = this.href(item);
      if (href6)
        m3.open("a", href6);
      m3.open(tag, this.attr(scene, item, attrList, tag !== "g" ? tag : null));
      if (tag === "text") {
        const tl6 = textLines3(item);
        if (isArray(tl6)) {
          const attrs = {
            x: 0,
            dy: lineHeight3(item)
          };
          for (let i = 0; i < tl6.length; ++i) {
            m3.open("tspan", i ? attrs : null).text(textValue3(item, tl6[i])).close();
          }
        } else {
          m3.text(textValue3(item, tl6));
        }
      } else if (tag === "g") {
        const fore = item.strokeForeground, fill6 = item.fill, stroke6 = item.stroke;
        if (fore && stroke6) {
          item.stroke = null;
        }
        m3.open("path", this.attr(scene, item, mdef.background, "bgrect")).close();
        m3.open("g", this.attr(scene, item, mdef.content));
        visit3(item, (scene2) => this.mark(m3, scene2));
        m3.close();
        if (fore && stroke6) {
          if (fill6)
            item.fill = null;
          item.stroke = stroke6;
          m3.open("path", this.attr(scene, item, mdef.foreground, "bgrect")).close();
          if (fill6)
            item.fill = fill6;
        } else {
          m3.open("path", this.attr(scene, item, mdef.foreground, "bgfore")).close();
        }
      }
      m3.close();
      if (href6)
        m3.close();
    };
    if (mdef.nested) {
      if (scene.items && scene.items.length)
        process2(scene.items[0]);
    } else {
      visit3(scene, process2);
    }
    return m3.close();
  }
  /**
   * Get href attributes for a hyperlinked mark item.
   * @param {Item} item - The mark item.
   */
  href(item) {
    const href6 = item.href;
    let attr6;
    if (href6) {
      if (attr6 = this._hrefs && this._hrefs[href6]) {
        return attr6;
      } else {
        this.sanitizeURL(href6).then((attr7) => {
          attr7["xlink:href"] = attr7.href;
          attr7.href = null;
          (this._hrefs || (this._hrefs = {}))[href6] = attr7;
        });
      }
    }
    return null;
  }
  /**
   * Get an object of SVG attributes for a mark item.
   * @param {object} scene - The mark parent.
   * @param {Item} item - The mark item.
   * @param {array|function} attrs - One or more attribute emitters.
   * @param {string} tag - The tag being rendered.
   */
  attr(scene, item, attrs, tag) {
    const object2 = {}, emit6 = (name, value7, ns, prefixed) => {
      object2[prefixed || name] = value7;
    };
    if (Array.isArray(attrs)) {
      attrs.forEach((fn) => fn(emit6, item, this));
    } else {
      attrs(emit6, item, this);
    }
    if (tag) {
      style3(object2, item, scene, tag, this._defs);
    }
    return object2;
  }
  /**
   * Render SVG defs, as needed.
   * Must be called *after* marks have been processed to ensure the
   * collected state is current and accurate.
   * @param {object} m - The markup context.
   */
  defs(m3) {
    const gradient8 = this._defs.gradient, clipping = this._defs.clipping, count3 = Object.keys(gradient8).length + Object.keys(clipping).length;
    if (count3 === 0)
      return;
    m3.open("defs");
    for (const id24 in gradient8) {
      const def6 = gradient8[id24], stops = def6.stops;
      if (def6.gradient === "radial") {
        m3.open("pattern", {
          id: patternPrefix3 + id24,
          viewBox: "0,0,1,1",
          width: "100%",
          height: "100%",
          preserveAspectRatio: "xMidYMid slice"
        });
        m3.open("rect", {
          width: "1",
          height: "1",
          fill: "url(#" + id24 + ")"
        }).close();
        m3.close();
        m3.open("radialGradient", {
          id: id24,
          fx: def6.x1,
          fy: def6.y1,
          fr: def6.r1,
          cx: def6.x2,
          cy: def6.y2,
          r: def6.r2
        });
      } else {
        m3.open("linearGradient", {
          id: id24,
          x1: def6.x1,
          x2: def6.x2,
          y1: def6.y1,
          y2: def6.y2
        });
      }
      for (let i = 0; i < stops.length; ++i) {
        m3.open("stop", {
          offset: stops[i].offset,
          "stop-color": stops[i].color
        }).close();
      }
      m3.close();
    }
    for (const id24 in clipping) {
      const def6 = clipping[id24];
      m3.open("clipPath", {
        id: id24
      });
      if (def6.path) {
        m3.open("path", {
          d: def6.path
        }).close();
      } else {
        m3.open("rect", {
          x: 0,
          y: 0,
          width: def6.width,
          height: def6.height
        }).close();
      }
      m3.close();
    }
    m3.close();
  }
};
function style3(s2, item, scene, tag, defs) {
  let styleList;
  if (item == null)
    return s2;
  if (tag === "bgrect" && scene.interactive === false) {
    s2["pointer-events"] = "none";
  }
  if (tag === "bgfore") {
    if (scene.interactive === false) {
      s2["pointer-events"] = "none";
    }
    s2.display = "none";
    if (item.fill !== null)
      return s2;
  }
  if (tag === "image" && item.smooth === false) {
    styleList = ["image-rendering: optimizeSpeed;", "image-rendering: pixelated;"];
  }
  if (tag === "text") {
    s2["font-family"] = fontFamily3(item);
    s2["font-size"] = fontSize3(item) + "px";
    s2["font-style"] = item.fontStyle;
    s2["font-variant"] = item.fontVariant;
    s2["font-weight"] = item.fontWeight;
  }
  for (const prop in stylesAttr3) {
    let value7 = item[prop];
    const name = stylesAttr3[prop];
    if (value7 === "transparent" && (name === "fill" || name === "stroke"))
      ;
    else if (value7 != null) {
      if (isGradient3(value7)) {
        value7 = gradientRef3(value7, defs.gradient, "");
      }
      s2[name] = value7;
    }
  }
  for (const prop in stylesCss3) {
    const value7 = item[prop];
    if (value7 != null) {
      styleList = styleList || [];
      styleList.push(`${stylesCss3[prop]}: ${value7};`);
    }
  }
  if (styleList) {
    s2.style = styleList.join(" ");
  }
  return s2;
}
var OPTS3 = {
  svgMarkTypes: ["text"],
  svgOnTop: true,
  debug: false
};
function setHybridRendererOptions(options) {
  OPTS3["svgMarkTypes"] = options.svgMarkTypes ?? ["text"];
  OPTS3["svgOnTop"] = options.svgOnTop ?? true;
  OPTS3["debug"] = options.debug ?? false;
}
var HybridRenderer3 = class extends Renderer3 {
  constructor(loader7) {
    super(loader7);
    this._svgRenderer = new SVGRenderer3(loader7);
    this._canvasRenderer = new CanvasRenderer3(loader7);
  }
  /**
   * Initialize a new HybridRenderer instance.
   * @param {DOMElement} el - The containing DOM element for the display.
   * @param {number} width - The coordinate width of the display, in pixels.
   * @param {number} height - The coordinate height of the display, in pixels.
   * @param {Array<number>} origin - The origin of the display, in pixels.
   *   The coordinate system will be translated to this point.
   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
   *   the width and height to determine the final pixel size.
   * @return {HybridRenderer} - This renderer instance.
   */
  initialize(el, width2, height2, origin, scaleFactor) {
    this._root_el = domChild3(el, 0, "div");
    const bottomEl = domChild3(this._root_el, 0, "div");
    const topEl = domChild3(this._root_el, 1, "div");
    this._root_el.style.position = "relative";
    if (!OPTS3.debug) {
      bottomEl.style.height = "100%";
      topEl.style.position = "absolute";
      topEl.style.top = "0";
      topEl.style.left = "0";
      topEl.style.height = "100%";
      topEl.style.width = "100%";
    }
    this._svgEl = OPTS3.svgOnTop ? topEl : bottomEl;
    this._canvasEl = OPTS3.svgOnTop ? bottomEl : topEl;
    this._svgEl.style.pointerEvents = "none";
    this._canvasRenderer.initialize(this._canvasEl, width2, height2, origin, scaleFactor);
    this._svgRenderer.initialize(this._svgEl, width2, height2, origin, scaleFactor);
    return super.initialize(el, width2, height2, origin, scaleFactor);
  }
  /**
   * Flag a mark item as dirty.
   * @param {Item} item - The mark item.
   */
  dirty(item) {
    if (OPTS3.svgMarkTypes.includes(item.mark.marktype)) {
      this._svgRenderer.dirty(item);
    } else {
      this._canvasRenderer.dirty(item);
    }
    return this;
  }
  /**
   * Internal rendering method.
   * @param {object} scene - The root mark of a scenegraph to render.
   * @param {Array} markTypes - Array of the mark types to render.
   *                            If undefined, render all mark types
   */
  _render(scene, markTypes) {
    const allMarkTypes = markTypes ?? ["arc", "area", "image", "line", "path", "rect", "rule", "shape", "symbol", "text", "trail"];
    const canvasMarkTypes = allMarkTypes.filter((m3) => !OPTS3.svgMarkTypes.includes(m3));
    this._svgRenderer.render(scene, OPTS3.svgMarkTypes);
    this._canvasRenderer.render(scene, canvasMarkTypes);
  }
  /**
   * Resize the display.
   * @param {number} width - The new coordinate width of the display, in pixels.
   * @param {number} height - The new coordinate height of the display, in pixels.
   * @param {Array<number>} origin - The new origin of the display, in pixels.
   *   The coordinate system will be translated to this point.
   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
   *   the width and height to determine the final pixel size.
   * @return {SVGRenderer} - This renderer instance;
   */
  resize(width2, height2, origin, scaleFactor) {
    super.resize(width2, height2, origin, scaleFactor);
    this._svgRenderer.resize(width2, height2, origin, scaleFactor);
    this._canvasRenderer.resize(width2, height2, origin, scaleFactor);
    return this;
  }
  background(bgcolor) {
    if (OPTS3.svgOnTop) {
      this._canvasRenderer.background(bgcolor);
    } else {
      this._svgRenderer.background(bgcolor);
    }
    return this;
  }
};
var HybridHandler3 = class extends CanvasHandler3 {
  constructor(loader7, tooltip2) {
    super(loader7, tooltip2);
  }
  initialize(el, origin, obj) {
    const canvas = domChild3(domChild3(el, 0, "div"), OPTS3.svgOnTop ? 0 : 1, "div");
    return super.initialize(canvas, origin, obj);
  }
};
var Canvas3 = "canvas";
var Hybrid3 = "hybrid";
var PNG3 = "png";
var SVG3 = "svg";
var None6 = "none";
var RenderType = {
  Canvas: Canvas3,
  PNG: PNG3,
  SVG: SVG3,
  Hybrid: Hybrid3,
  None: None6
};
var modules3 = {};
modules3[Canvas3] = modules3[PNG3] = {
  renderer: CanvasRenderer3,
  headless: CanvasRenderer3,
  handler: CanvasHandler3
};
modules3[SVG3] = {
  renderer: SVGRenderer3,
  headless: SVGStringRenderer3,
  handler: SVGHandler3
};
modules3[Hybrid3] = {
  renderer: HybridRenderer3,
  headless: HybridRenderer3,
  handler: HybridHandler3
};
modules3[None6] = {};
function renderModule(name, _) {
  name = String(name || "").toLowerCase();
  if (arguments.length > 1) {
    modules3[name] = _;
    return this;
  } else {
    return modules3[name];
  }
}
function intersect3(scene, bounds6, filter4) {
  const hits = [], box = new Bounds3().union(bounds6), type7 = scene.marktype;
  return type7 ? intersectMark(scene, box, filter4, hits) : type7 === "group" ? intersectGroup(scene, box, filter4, hits) : error("Intersect scene must be mark node or group item.");
}
function intersectMark(mark, box, filter4, hits) {
  if (visitMark(mark, box, filter4)) {
    const items = mark.items, type7 = mark.marktype, n = items.length;
    let i = 0;
    if (type7 === "group") {
      for (; i < n; ++i) {
        intersectGroup(items[i], box, filter4, hits);
      }
    } else {
      for (const test2 = Marks3[type7].isect; i < n; ++i) {
        const item = items[i];
        if (intersectItem(item, box, test2))
          hits.push(item);
      }
    }
  }
  return hits;
}
function visitMark(mark, box, filter4) {
  return mark.bounds && box.intersects(mark.bounds) && (mark.marktype === "group" || mark.interactive !== false && (!filter4 || filter4(mark)));
}
function intersectGroup(group7, box, filter4, hits) {
  if (filter4 && filter4(group7.mark) && intersectItem(group7, box, Marks3.group.isect)) {
    hits.push(group7);
  }
  const marks = group7.items, n = marks && marks.length;
  if (n) {
    const x9 = group7.x || 0, y9 = group7.y || 0;
    box.translate(-x9, -y9);
    for (let i = 0; i < n; ++i) {
      intersectMark(marks[i], box, filter4, hits);
    }
    box.translate(x9, y9);
  }
  return hits;
}
function intersectItem(item, box, test2) {
  const bounds6 = item.bounds;
  return box.encloses(bounds6) || box.intersects(bounds6) && test2(item, box);
}
var clipBounds3 = new Bounds3();
function boundClip2(mark) {
  const clip7 = mark.clip;
  if (isFunction(clip7)) {
    clip7(boundContext3(clipBounds3.clear()));
  } else if (clip7) {
    clipBounds3.set(0, 0, mark.group.width, mark.group.height);
  } else
    return;
  mark.bounds.intersect(clipBounds3);
}
var TOLERANCE = 1e-9;
function sceneEqual(a4, b6, key4) {
  return a4 === b6 ? true : key4 === "path" ? pathEqual(a4, b6) : a4 instanceof Date && b6 instanceof Date ? +a4 === +b6 : isNumber(a4) && isNumber(b6) ? Math.abs(a4 - b6) <= TOLERANCE : !a4 || !b6 || !isObject(a4) && !isObject(b6) ? a4 == b6 : objectEqual(a4, b6);
}
function pathEqual(a4, b6) {
  return sceneEqual(parse7(a4), parse7(b6));
}
function objectEqual(a4, b6) {
  var ka = Object.keys(a4), kb = Object.keys(b6), key4, i;
  if (ka.length !== kb.length)
    return false;
  ka.sort();
  kb.sort();
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i])
      return false;
  }
  for (i = ka.length - 1; i >= 0; i--) {
    key4 = ka[i];
    if (!sceneEqual(a4[key4], b6[key4], key4))
      return false;
  }
  return typeof a4 === typeof b6;
}
function resetSVGDefIds() {
  resetSVGClipId();
  resetSVGGradientId();
}

// node_modules/vega-view/node_modules/vega-util/build/vega-util.js
function accessor15(fn, fields, name) {
  fn.fields = fields || [];
  fn.fname = name;
  return fn;
}
function getter15(path7) {
  return path7.length === 1 ? get115(path7[0]) : getN15(path7);
}
var get115 = (field25) => function(obj) {
  return obj[field25];
};
var getN15 = (path7) => {
  const len = path7.length;
  return function(obj) {
    for (let i = 0; i < len; ++i) {
      obj = obj[path7[i]];
    }
    return obj;
  };
};
function error15(message) {
  throw Error(message);
}
function splitAccessPath15(p) {
  const path7 = [], n = p.length;
  let q = null, b6 = 0, s2 = "", i, j, c5;
  p = p + "";
  function push() {
    path7.push(s2 + p.substring(i, j));
    s2 = "";
    i = j + 1;
  }
  for (i = j = 0; j < n; ++j) {
    c5 = p[j];
    if (c5 === "\\") {
      s2 += p.substring(i, j++);
      i = j;
    } else if (c5 === q) {
      push();
      q = null;
      b6 = -1;
    } else if (q) {
      continue;
    } else if (i === b6 && c5 === '"') {
      i = j + 1;
      q = c5;
    } else if (i === b6 && c5 === "'") {
      i = j + 1;
      q = c5;
    } else if (c5 === "." && !b6) {
      if (j > i) {
        push();
      } else {
        i = j + 1;
      }
    } else if (c5 === "[") {
      if (j > i)
        push();
      b6 = i = j + 1;
    } else if (c5 === "]") {
      if (!b6)
        error15("Access path missing open bracket: " + p);
      if (b6 > 0)
        push();
      b6 = 0;
      i = j + 1;
    }
  }
  if (b6)
    error15("Access path missing closing bracket: " + p);
  if (q)
    error15("Access path missing closing quote: " + p);
  if (j > i) {
    j++;
    push();
  }
  return path7;
}
function field15(field25, name, opt) {
  const path7 = splitAccessPath15(field25);
  field25 = path7.length === 1 ? path7[0] : field25;
  return accessor15((opt && opt.get || getter15)(path7), [field25], name || field25);
}
var id15 = field15("id");
var identity19 = accessor15((_) => _, [], "identity");
var zero17 = accessor15(() => 0, [], "zero");
var one16 = accessor15(() => 1, [], "one");
var truthy15 = accessor15(() => true, [], "true");
var falsy15 = accessor15(() => false, [], "false");
var DisallowedObjectProperties15 = /* @__PURE__ */ new Set([...Object.getOwnPropertyNames(Object.prototype).filter((name) => typeof Object.prototype[name] === "function"), "__proto__"]);
var isArray15 = Array.isArray;
function isObject8(_) {
  return _ === Object(_);
}
function peek9(array22) {
  return array22[array22.length - 1];
}
function toNumber9(_) {
  return _ == null || _ === "" ? null : +_;
}
function array14(_) {
  return _ != null ? isArray15(_) ? _ : [_] : [];
}
function isFunction10(_) {
  return typeof _ === "function";
}
function constant12(_) {
  return isFunction10(_) ? _ : () => _;
}
function debounce3(delay, handler) {
  let tid;
  return (e3) => {
    if (tid)
      clearTimeout(tid);
    tid = setTimeout(() => (handler(e3), tid = null), delay);
  };
}
function extend16(_) {
  for (let x9, k3, i = 1, len = arguments.length; i < len; ++i) {
    x9 = arguments[i];
    for (k3 in x9) {
      _[k3] = x9[k3];
    }
  }
  return _;
}
function has12(object2, property2) {
  return Object.hasOwn(object2, property2);
}
function inherits14(child, parent, members) {
  const proto = child.prototype = Object.create(parent.prototype);
  Object.defineProperty(proto, "constructor", {
    value: child,
    writable: true,
    enumerable: true,
    configurable: true
  });
  return extend16(proto, members);
}
function isDate5(_) {
  return Object.prototype.toString.call(_) === "[object Date]";
}
function isIterable5(_) {
  return _ && isFunction10(_[Symbol.iterator]);
}
function isString8(_) {
  return typeof _ === "string";
}
var DEFAULT_MAX_SIZE4 = 1e4;
function lruCache4(maxsize) {
  maxsize = +maxsize || DEFAULT_MAX_SIZE4;
  let curr, prev, size;
  const clear2 = () => {
    curr = {};
    prev = {};
    size = 0;
  };
  const update3 = (key4, value7) => {
    if (++size > maxsize) {
      prev = curr;
      curr = {};
      size = 1;
    }
    return curr[key4] = value7;
  };
  clear2();
  return {
    clear: clear2,
    has: (key4) => has12(curr, key4) || has12(prev, key4),
    get: (key4) => has12(curr, key4) ? curr[key4] : has12(prev, key4) ? update3(key4, prev[key4]) : void 0,
    set: (key4, value7) => has12(curr, key4) ? curr[key4] = value7 : update3(key4, value7)
  };
}
function $6(x9) {
  return isArray15(x9) ? `[${x9.map((v2) => v2 === null ? "null" : $6(v2))}]` : isObject8(x9) || isString8(x9) ? (
    // Output valid JSON and JS source strings.
    // See https://github.com/judofyr/timeless/blob/master/posts/json-isnt-a-javascript-subset.md
    JSON.stringify(x9).replaceAll("\u2028", "\\u2028").replaceAll("\u2029", "\\u2029")
  ) : x9;
}
function toSet10(_) {
  const s2 = {}, n = _.length;
  for (let i = 0; i < n; ++i)
    s2[_[i]] = true;
  return s2;
}

// node_modules/vega-view/node_modules/vega-canvas/build/vega-canvas.browser.js
function domCanvas6(w8, h6) {
  if (typeof document !== "undefined" && document.createElement) {
    const c5 = document.createElement("canvas");
    if (c5 && c5.getContext) {
      c5.width = w8;
      c5.height = h6;
      return c5;
    }
  }
  return null;
}
var domImage4 = () => typeof Image !== "undefined" ? Image : null;

// node_modules/vega-view/node_modules/vega-time/build/vega-time.js
var YEAR9 = "year";
var QUARTER9 = "quarter";
var MONTH9 = "month";
var WEEK9 = "week";
var DATE9 = "date";
var DAY9 = "day";
var DAYOFYEAR9 = "dayofyear";
var HOURS9 = "hours";
var MINUTES9 = "minutes";
var SECONDS9 = "seconds";
var MILLISECONDS9 = "milliseconds";
var TIME_UNITS9 = [YEAR9, QUARTER9, MONTH9, WEEK9, DATE9, DAY9, DAYOFYEAR9, HOURS9, MINUTES9, SECONDS9, MILLISECONDS9];
var UNITS9 = TIME_UNITS9.reduce((o, u4, i) => (o[u4] = 1 + i, o), {});
var defaultSpecifiers9 = {
  [YEAR9]: "%Y ",
  [QUARTER9]: "Q%q ",
  [MONTH9]: "%b ",
  [DATE9]: "%d ",
  [WEEK9]: "W%U ",
  [DAY9]: "%a ",
  [DAYOFYEAR9]: "%j ",
  [HOURS9]: "%H:00",
  [MINUTES9]: "00:%M",
  [SECONDS9]: ":%S",
  [MILLISECONDS9]: ".%L",
  [`${YEAR9}-${MONTH9}`]: "%Y-%m ",
  [`${YEAR9}-${MONTH9}-${DATE9}`]: "%Y-%m-%d ",
  [`${HOURS9}-${MINUTES9}`]: "%H:%M"
};
var t011 = /* @__PURE__ */ new Date();
function localYear9(y9) {
  t011.setFullYear(y9);
  t011.setMonth(0);
  t011.setDate(1);
  t011.setHours(0, 0, 0, 0);
  return t011;
}
function localDayOfYear9(d) {
  return timeDay.count(localYear9(d.getFullYear()) - 1, d);
}
function localWeekNum9(d) {
  return timeSunday.count(localYear9(d.getFullYear()) - 1, d);
}
function localFirst9(y9) {
  return localYear9(y9).getDay();
}
function utcDayOfYear9(d) {
  const y9 = Date.UTC(d.getUTCFullYear(), 0, 1);
  return utcDay.count(y9 - 1, d);
}
function utcWeekNum9(d) {
  const y9 = Date.UTC(d.getUTCFullYear(), 0, 1);
  return utcSunday.count(y9 - 1, d);
}
function utcFirst9(y9) {
  t011.setTime(Date.UTC(y9, 0, 1));
  return t011.getUTCDay();
}
function weekday9(week3, day, firstDay) {
  return day + week3 * 7 - (firstDay + 6) % 7;
}
var localGet9 = {
  [YEAR9]: (d) => d.getFullYear(),
  [QUARTER9]: (d) => Math.floor(d.getMonth() / 3),
  [MONTH9]: (d) => d.getMonth(),
  [DATE9]: (d) => d.getDate(),
  [HOURS9]: (d) => d.getHours(),
  [MINUTES9]: (d) => d.getMinutes(),
  [SECONDS9]: (d) => d.getSeconds(),
  [MILLISECONDS9]: (d) => d.getMilliseconds(),
  [DAYOFYEAR9]: (d) => localDayOfYear9(d),
  [WEEK9]: (d) => localWeekNum9(d),
  [WEEK9 + DAY9]: (d, y9) => weekday9(localWeekNum9(d), d.getDay(), localFirst9(y9)),
  [DAY9]: (d, y9) => weekday9(1, d.getDay(), localFirst9(y9))
};
var localInv9 = {
  [QUARTER9]: (q) => 3 * q,
  [WEEK9]: (w8, y9) => weekday9(w8, 0, localFirst9(y9))
};
var utcGet9 = {
  [YEAR9]: (d) => d.getUTCFullYear(),
  [QUARTER9]: (d) => Math.floor(d.getUTCMonth() / 3),
  [MONTH9]: (d) => d.getUTCMonth(),
  [DATE9]: (d) => d.getUTCDate(),
  [HOURS9]: (d) => d.getUTCHours(),
  [MINUTES9]: (d) => d.getUTCMinutes(),
  [SECONDS9]: (d) => d.getUTCSeconds(),
  [MILLISECONDS9]: (d) => d.getUTCMilliseconds(),
  [DAYOFYEAR9]: (d) => utcDayOfYear9(d),
  [WEEK9]: (d) => utcWeekNum9(d),
  [DAY9]: (d, y9) => weekday9(1, d.getUTCDay(), utcFirst9(y9)),
  [WEEK9 + DAY9]: (d, y9) => weekday9(utcWeekNum9(d), d.getUTCDay(), utcFirst9(y9))
};
var utcInv9 = {
  [QUARTER9]: (q) => 3 * q,
  [WEEK9]: (w8, y9) => weekday9(w8, 0, utcFirst9(y9))
};
var timeIntervals9 = {
  [YEAR9]: timeYear,
  [QUARTER9]: timeMonth.every(3),
  [MONTH9]: timeMonth,
  [WEEK9]: timeSunday,
  [DATE9]: timeDay,
  [DAY9]: timeDay,
  [DAYOFYEAR9]: timeDay,
  [HOURS9]: timeHour,
  [MINUTES9]: timeMinute,
  [SECONDS9]: second,
  [MILLISECONDS9]: millisecond
};
var utcIntervals9 = {
  [YEAR9]: utcYear,
  [QUARTER9]: utcMonth.every(3),
  [MONTH9]: utcMonth,
  [WEEK9]: utcSunday,
  [DATE9]: utcDay,
  [DAY9]: utcDay,
  [DAYOFYEAR9]: utcDay,
  [HOURS9]: utcHour,
  [MINUTES9]: utcMinute,
  [SECONDS9]: second,
  [MILLISECONDS9]: millisecond
};
function timeInterval10(unit2) {
  return timeIntervals9[unit2];
}
function utcInterval9(unit2) {
  return utcIntervals9[unit2];
}
var durationSecond10 = 1e3;
var durationMinute10 = durationSecond10 * 60;
var durationHour10 = durationMinute10 * 60;
var durationDay10 = durationHour10 * 24;
var durationWeek10 = durationDay10 * 7;
var durationMonth10 = durationDay10 * 30;
var durationYear10 = durationDay10 * 365;
var Milli9 = [YEAR9, MONTH9, DATE9, HOURS9, MINUTES9, SECONDS9, MILLISECONDS9];
var Seconds9 = Milli9.slice(0, -1);
var Minutes9 = Seconds9.slice(0, -1);
var Hours9 = Minutes9.slice(0, -1);
var Day9 = Hours9.slice(0, -1);
var Week9 = [YEAR9, WEEK9];
var Month9 = [YEAR9, MONTH9];
var Year9 = [YEAR9];
var intervals9 = [[Seconds9, 1, durationSecond10], [Seconds9, 5, 5 * durationSecond10], [Seconds9, 15, 15 * durationSecond10], [Seconds9, 30, 30 * durationSecond10], [Minutes9, 1, durationMinute10], [Minutes9, 5, 5 * durationMinute10], [Minutes9, 15, 15 * durationMinute10], [Minutes9, 30, 30 * durationMinute10], [Hours9, 1, durationHour10], [Hours9, 3, 3 * durationHour10], [Hours9, 6, 6 * durationHour10], [Hours9, 12, 12 * durationHour10], [Day9, 1, durationDay10], [Week9, 1, durationWeek10], [Month9, 1, durationMonth10], [Month9, 3, 3 * durationMonth10], [Year9, 1, durationYear10]];

// node_modules/vega-view/node_modules/vega-format/build/vega-format.js
function memoize5(method10) {
  const cache2 = {};
  return (spec) => cache2[spec] || (cache2[spec] = method10(spec));
}
function trimZeroes5(numberFormat2, decimalChar) {
  return (x9) => {
    const str = numberFormat2(x9), dec = str.indexOf(decimalChar);
    if (dec < 0)
      return str;
    let idx = rightmostDigit5(str, dec);
    const end = idx < str.length ? str.slice(idx) : "";
    while (--idx > dec)
      if (str[idx] !== "0") {
        ++idx;
        break;
      }
    return str.slice(0, idx) + end;
  };
}
function rightmostDigit5(str, dec) {
  let i = str.lastIndexOf("e"), c5;
  if (i > 0)
    return i;
  for (i = str.length; --i > dec; ) {
    c5 = str.charCodeAt(i);
    if (c5 >= 48 && c5 <= 57)
      return i + 1;
  }
}
function numberLocale5(locale5) {
  const format14 = memoize5(locale5.format), formatPrefix2 = locale5.formatPrefix;
  return {
    format: format14,
    formatPrefix: formatPrefix2,
    formatFloat(spec) {
      const s2 = formatSpecifier(spec || ",");
      if (s2.precision == null) {
        s2.precision = 12;
        switch (s2.type) {
          case "%":
            s2.precision -= 2;
            break;
          case "e":
            s2.precision -= 1;
            break;
        }
        return trimZeroes5(
          format14(s2),
          // number format
          format14(".1f")(1)[1]
          // decimal point character
        );
      } else {
        return format14(s2);
      }
    },
    formatSpan(start, stop2, count3, specifier) {
      specifier = formatSpecifier(specifier == null ? ",f" : specifier);
      const step = tickStep(start, stop2, count3), value7 = Math.max(Math.abs(start), Math.abs(stop2));
      let precision;
      if (specifier.precision == null) {
        switch (specifier.type) {
          case "s": {
            if (!isNaN(precision = precisionPrefix_default(step, value7))) {
              specifier.precision = precision;
            }
            return formatPrefix2(specifier, value7);
          }
          case "":
          case "e":
          case "g":
          case "p":
          case "r": {
            if (!isNaN(precision = precisionRound_default(step, value7))) {
              specifier.precision = precision - (specifier.type === "e");
            }
            break;
          }
          case "f":
          case "%": {
            if (!isNaN(precision = precisionFixed_default(step))) {
              specifier.precision = precision - (specifier.type === "%") * 2;
            }
            break;
          }
        }
      }
      return format14(specifier);
    }
  };
}
var defaultNumberLocale5;
resetNumberFormatDefaultLocale5();
function resetNumberFormatDefaultLocale5() {
  return defaultNumberLocale5 = numberLocale5({
    format,
    formatPrefix
  });
}
function numberFormatLocale3(definition3) {
  return numberLocale5(locale_default(definition3));
}
function numberFormatDefaultLocale3(definition3) {
  return arguments.length ? defaultNumberLocale5 = numberFormatLocale3(definition3) : defaultNumberLocale5;
}
function timeMultiFormat5(format14, interval3, spec) {
  spec = spec || {};
  if (!isObject8(spec)) {
    error15(`Invalid time multi-format specifier: ${spec}`);
  }
  const second2 = interval3(SECONDS9), minute = interval3(MINUTES9), hour = interval3(HOURS9), day = interval3(DATE9), week3 = interval3(WEEK9), month = interval3(MONTH9), quarter3 = interval3(QUARTER9), year = interval3(YEAR9), L = format14(spec[MILLISECONDS9] || ".%L"), S = format14(spec[SECONDS9] || ":%S"), M2 = format14(spec[MINUTES9] || "%I:%M"), H = format14(spec[HOURS9] || "%I %p"), d = format14(spec[DATE9] || spec[DAY9] || "%a %d"), w8 = format14(spec[WEEK9] || "%b %d"), m3 = format14(spec[MONTH9] || "%B"), q = format14(spec[QUARTER9] || "%B"), y9 = format14(spec[YEAR9] || "%Y");
  return (date2) => (second2(date2) < date2 ? L : minute(date2) < date2 ? S : hour(date2) < date2 ? M2 : day(date2) < date2 ? H : month(date2) < date2 ? week3(date2) < date2 ? d : w8 : year(date2) < date2 ? quarter3(date2) < date2 ? m3 : q : y9)(date2);
}
function timeLocale5(locale5) {
  const timeFormat4 = memoize5(locale5.format), utcFormat3 = memoize5(locale5.utcFormat);
  return {
    timeFormat: (spec) => isString8(spec) ? timeFormat4(spec) : timeMultiFormat5(timeFormat4, timeInterval10, spec),
    utcFormat: (spec) => isString8(spec) ? utcFormat3(spec) : timeMultiFormat5(utcFormat3, utcInterval9, spec),
    timeParse: memoize5(locale5.parse),
    utcParse: memoize5(locale5.utcParse)
  };
}
var defaultTimeLocale5;
resetTimeFormatDefaultLocale5();
function resetTimeFormatDefaultLocale5() {
  return defaultTimeLocale5 = timeLocale5({
    format: timeFormat,
    parse: timeParse,
    utcFormat,
    utcParse
  });
}
function timeFormatLocale3(definition3) {
  return timeLocale5(formatLocale(definition3));
}
function timeFormatDefaultLocale5(definition3) {
  return arguments.length ? defaultTimeLocale5 = timeFormatLocale3(definition3) : defaultTimeLocale5;
}
var createLocale3 = (number12, time3) => extend16({}, number12, time3);
function locale4(numberSpec, timeSpec) {
  const number12 = numberSpec ? numberFormatLocale3(numberSpec) : numberFormatDefaultLocale3();
  const time3 = timeSpec ? timeFormatLocale3(timeSpec) : timeFormatDefaultLocale5();
  return createLocale3(number12, time3);
}

// node_modules/vega-view/node_modules/vega-loader/build/vega-loader.browser.js
var protocol_re5 = /^(data:|([A-Za-z]+:)?\/\/)/;
var allowed_re5 = /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp|file|data):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i;
var whitespace_re5 = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205f\u3000]/g;
var fileProtocol5 = "file://";
function loaderFactory5(fs) {
  return (options) => ({
    options: options || {},
    sanitize: sanitize5,
    load: load5,
    fileAccess: false,
    file: fileLoader5(),
    http: httpLoader5
  });
}
async function load5(uri, options) {
  const opt = await this.sanitize(uri, options), url = opt.href;
  return opt.localFile ? this.file(url) : this.http(url, options == null ? void 0 : options.http);
}
async function sanitize5(uri, options) {
  options = extend16({}, this.options, options);
  const fileAccess = this.fileAccess, result = {
    href: null
  };
  let isFile, loadFile, base;
  const isAllowed = allowed_re5.test(uri.replace(whitespace_re5, ""));
  if (uri == null || typeof uri !== "string" || !isAllowed) {
    error15("Sanitize failure, invalid URI: " + $6(uri));
  }
  const hasProtocol = protocol_re5.test(uri);
  if ((base = options.baseURL) && !hasProtocol) {
    if (!uri.startsWith("/") && !base.endsWith("/")) {
      uri = "/" + uri;
    }
    uri = base + uri;
  }
  loadFile = (isFile = uri.startsWith(fileProtocol5)) || options.mode === "file" || options.mode !== "http" && !hasProtocol && fileAccess;
  if (isFile) {
    uri = uri.slice(fileProtocol5.length);
  } else if (uri.startsWith("//")) {
    if (options.defaultProtocol === "file") {
      uri = uri.slice(2);
      loadFile = true;
    } else {
      uri = (options.defaultProtocol || "http") + ":" + uri;
    }
  }
  Object.defineProperty(result, "localFile", {
    value: !!loadFile
  });
  result.href = uri;
  if (options.target) {
    result.target = options.target + "";
  }
  if (options.rel) {
    result.rel = options.rel + "";
  }
  if (options.context === "image" && options.crossOrigin) {
    result.crossOrigin = options.crossOrigin + "";
  }
  return result;
}
function fileLoader5(fs) {
  return fileReject5;
}
async function fileReject5() {
  error15("No file system access.");
}
async function httpLoader5(url, options) {
  const opt = extend16({}, this.options.http, options), type7 = options && options.response, response = await fetch(url, opt);
  return !response.ok ? error15(response.status + "" + response.statusText) : isFunction10(response[type7]) ? response[type7]() : response.text();
}
function delimitedFormat5(delimiter) {
  const parse12 = function(data3, format14) {
    const delim = {
      delimiter
    };
    return dsv5(data3, format14 ? extend16(format14, delim) : delim);
  };
  parse12.responseType = "text";
  return parse12;
}
function dsv5(data3, format14) {
  if (format14.header) {
    data3 = format14.header.map($6).join(format14.delimiter) + "\n" + data3;
  }
  return dsv_default(format14.delimiter).parse(data3 + "");
}
dsv5.responseType = "text";
function isBuffer5(_) {
  return typeof Buffer === "function" && isFunction10(Buffer.isBuffer) ? Buffer.isBuffer(_) : false;
}
function json5(data3, format14) {
  const prop = format14 && format14.property ? field15(format14.property) : identity19;
  return isObject8(data3) && !isBuffer5(data3) ? parseJSON5(prop(data3), format14) : prop(JSON.parse(data3));
}
json5.responseType = "json";
function parseJSON5(data3, format14) {
  if (!isArray15(data3) && isIterable5(data3)) {
    data3 = [...data3];
  }
  return format14 && format14.copy ? JSON.parse(JSON.stringify(data3)) : data3;
}
var filters5 = {
  interior: (a4, b6) => a4 !== b6,
  exterior: (a4, b6) => a4 === b6
};
function topojson5(data3, format14) {
  let method10, object2, property2, filter4;
  data3 = json5(data3, format14);
  if (format14 && format14.feature) {
    method10 = feature_default;
    property2 = format14.feature;
  } else if (format14 && format14.mesh) {
    method10 = mesh_default;
    property2 = format14.mesh;
    filter4 = filters5[format14.filter];
  } else {
    error15("Missing TopoJSON feature or mesh parameter.");
  }
  object2 = (object2 = data3.objects[property2]) ? method10(data3, object2, filter4) : error15("Invalid TopoJSON object: " + property2);
  return object2 && object2.features || [object2];
}
topojson5.responseType = "json";
var format9 = {
  dsv: dsv5,
  csv: delimitedFormat5(","),
  tsv: delimitedFormat5("	"),
  json: json5,
  topojson: topojson5
};
var loader5 = loaderFactory5();

// node_modules/vega-view/node_modules/vega-scale/build/vega-scale.js
function bandSpace7(count3, paddingInner2, paddingOuter2) {
  const space = count3 - paddingInner2 + paddingOuter2 * 2;
  return count3 ? space > 0 ? space : 1 : 0;
}
var Identity7 = "identity";
var Linear8 = "linear";
var Log7 = "log";
var Pow7 = "pow";
var Sqrt7 = "sqrt";
var Symlog7 = "symlog";
var Time7 = "time";
var UTC7 = "utc";
var Sequential7 = "sequential";
var Diverging7 = "diverging";
var Quantile8 = "quantile";
var Quantize7 = "quantize";
var Threshold7 = "threshold";
var Ordinal7 = "ordinal";
var Point7 = "point";
var Band7 = "band";
var BinOrdinal7 = "bin-ordinal";
var Continuous7 = "continuous";
var Discrete7 = "discrete";
var Discretizing7 = "discretizing";
var Interpolating7 = "interpolating";
var Temporal7 = "temporal";
function invertRange7(scale19) {
  return function(_) {
    let lo = _[0], hi = _[1], t;
    if (hi < lo) {
      t = lo;
      lo = hi;
      hi = t;
    }
    return [scale19.invert(lo), scale19.invert(hi)];
  };
}
function invertRangeExtent7(scale19) {
  return function(_) {
    const range7 = scale19.range();
    let lo = _[0], hi = _[1], min5 = -1, max5, t, i, n;
    if (hi < lo) {
      t = lo;
      lo = hi;
      hi = t;
    }
    for (i = 0, n = range7.length; i < n; ++i) {
      if (range7[i] >= lo && range7[i] <= hi) {
        if (min5 < 0)
          min5 = i;
        max5 = i;
      }
    }
    if (min5 < 0)
      return void 0;
    lo = scale19.invertExtent(range7[min5]);
    hi = scale19.invertExtent(range7[max5]);
    return [lo[0] === void 0 ? lo[1] : lo[0], hi[1] === void 0 ? hi[0] : hi[1]];
  };
}
function band8() {
  const scale19 = ordinal().unknown(void 0), domain3 = scale19.domain, ordinalRange = scale19.range;
  let range$1 = [0, 1], step, bandwidth2, round2 = false, paddingInner2 = 0, paddingOuter2 = 0, align2 = 0.5;
  delete scale19.unknown;
  function rescale() {
    const n = domain3().length, reverse4 = range$1[1] < range$1[0], stop2 = range$1[1 - reverse4], space = bandSpace7(n, paddingInner2, paddingOuter2);
    let start = range$1[reverse4 - 0];
    step = (stop2 - start) / (space || 1);
    if (round2) {
      step = Math.floor(step);
    }
    start += (stop2 - start - step * (n - paddingInner2)) * align2;
    bandwidth2 = step * (1 - paddingInner2);
    if (round2) {
      start = Math.round(start);
      bandwidth2 = Math.round(bandwidth2);
    }
    const values7 = range(n).map((i) => start + step * i);
    return ordinalRange(reverse4 ? values7.reverse() : values7);
  }
  scale19.domain = function(_) {
    if (arguments.length) {
      domain3(_);
      return rescale();
    } else {
      return domain3();
    }
  };
  scale19.range = function(_) {
    if (arguments.length) {
      range$1 = [+_[0], +_[1]];
      return rescale();
    } else {
      return range$1.slice();
    }
  };
  scale19.rangeRound = function(_) {
    range$1 = [+_[0], +_[1]];
    round2 = true;
    return rescale();
  };
  scale19.bandwidth = function() {
    return bandwidth2;
  };
  scale19.step = function() {
    return step;
  };
  scale19.round = function(_) {
    if (arguments.length) {
      round2 = !!_;
      return rescale();
    } else {
      return round2;
    }
  };
  scale19.padding = function(_) {
    if (arguments.length) {
      paddingOuter2 = Math.max(0, Math.min(1, _));
      paddingInner2 = paddingOuter2;
      return rescale();
    } else {
      return paddingInner2;
    }
  };
  scale19.paddingInner = function(_) {
    if (arguments.length) {
      paddingInner2 = Math.max(0, Math.min(1, _));
      return rescale();
    } else {
      return paddingInner2;
    }
  };
  scale19.paddingOuter = function(_) {
    if (arguments.length) {
      paddingOuter2 = Math.max(0, Math.min(1, _));
      return rescale();
    } else {
      return paddingOuter2;
    }
  };
  scale19.align = function(_) {
    if (arguments.length) {
      align2 = Math.max(0, Math.min(1, _));
      return rescale();
    } else {
      return align2;
    }
  };
  scale19.invertRange = function(_) {
    if (_[0] == null || _[1] == null)
      return;
    const reverse4 = range$1[1] < range$1[0], values7 = reverse4 ? ordinalRange().reverse() : ordinalRange(), n = values7.length - 1;
    let lo = +_[0], hi = +_[1], a4, b6, t;
    if (lo !== lo || hi !== hi)
      return;
    if (hi < lo) {
      t = lo;
      lo = hi;
      hi = t;
    }
    if (hi < values7[0] || lo > range$1[1 - reverse4])
      return;
    a4 = Math.max(0, bisectRight(values7, lo) - 1);
    b6 = lo === hi ? a4 : bisectRight(values7, hi) - 1;
    if (lo - values7[a4] > bandwidth2 + 1e-10)
      ++a4;
    if (reverse4) {
      t = a4;
      a4 = n - b6;
      b6 = n - t;
    }
    return a4 > b6 ? void 0 : domain3().slice(a4, b6 + 1);
  };
  scale19.invert = function(_) {
    const value7 = scale19.invertRange([_, _]);
    return value7 ? value7[0] : value7;
  };
  scale19.copy = function() {
    return band8().domain(domain3()).range(range$1).round(round2).paddingInner(paddingInner2).paddingOuter(paddingOuter2).align(align2);
  };
  return rescale();
}
function pointish7(scale19) {
  const copy4 = scale19.copy;
  scale19.padding = scale19.paddingOuter;
  delete scale19.paddingInner;
  scale19.copy = function() {
    return pointish7(copy4());
  };
  return scale19;
}
function point15() {
  return pointish7(band8().paddingInner(1));
}
var map10 = Array.prototype.map;
function numbers9(_) {
  return map10.call(_, toNumber9);
}
var slice9 = Array.prototype.slice;
function scaleBinOrdinal7() {
  let domain3 = [], range7 = [];
  function scale19(x9) {
    return x9 == null || x9 !== x9 ? void 0 : range7[(bisect_default2(domain3, x9) - 1) % range7.length];
  }
  scale19.domain = function(_) {
    if (arguments.length) {
      domain3 = numbers9(_);
      return scale19;
    } else {
      return domain3.slice();
    }
  };
  scale19.range = function(_) {
    if (arguments.length) {
      range7 = slice9.call(_);
      return scale19;
    } else {
      return range7.slice();
    }
  };
  scale19.tickFormat = function(count3, specifier) {
    return tickFormat(domain3[0], peek9(domain3), count3 == null ? 10 : count3, specifier);
  };
  scale19.copy = function() {
    return scaleBinOrdinal7().domain(scale19.domain()).range(scale19.range());
  };
  return scale19;
}
var scales7 = /* @__PURE__ */ new Map();
var VEGA_SCALE7 = Symbol("vega_scale");
function registerScale7(scale19) {
  scale19[VEGA_SCALE7] = true;
  return scale19;
}
function create9(type7, constructor, metadata6) {
  const ctr = function scale19() {
    const s2 = constructor();
    if (!s2.invertRange) {
      s2.invertRange = s2.invert ? invertRange7(s2) : s2.invertExtent ? invertRangeExtent7(s2) : void 0;
    }
    s2.type = type7;
    return registerScale7(s2);
  };
  ctr.metadata = toSet10(array14(metadata6));
  return ctr;
}
function scale11(type7, scale19, metadata6) {
  if (arguments.length > 1) {
    scales7.set(type7, create9(type7, scale19, metadata6));
    return this;
  } else {
    return isValidScaleType7(type7) ? scales7.get(type7) : void 0;
  }
}
scale11(Identity7, identity8);
scale11(Linear8, linear3, Continuous7);
scale11(Log7, log3, [Continuous7, Log7]);
scale11(Pow7, pow3, Continuous7);
scale11(Sqrt7, sqrt2, Continuous7);
scale11(Symlog7, symlog2, Continuous7);
scale11(Time7, time, [Continuous7, Temporal7]);
scale11(UTC7, utcTime, [Continuous7, Temporal7]);
scale11(Sequential7, sequential, [Continuous7, Interpolating7]);
scale11(`${Sequential7}-${Linear8}`, sequential, [Continuous7, Interpolating7]);
scale11(`${Sequential7}-${Log7}`, sequentialLog, [Continuous7, Interpolating7, Log7]);
scale11(`${Sequential7}-${Pow7}`, sequentialPow, [Continuous7, Interpolating7]);
scale11(`${Sequential7}-${Sqrt7}`, sequentialSqrt, [Continuous7, Interpolating7]);
scale11(`${Sequential7}-${Symlog7}`, sequentialSymlog, [Continuous7, Interpolating7]);
scale11(`${Diverging7}-${Linear8}`, diverging, [Continuous7, Interpolating7]);
scale11(`${Diverging7}-${Log7}`, divergingLog, [Continuous7, Interpolating7, Log7]);
scale11(`${Diverging7}-${Pow7}`, divergingPow, [Continuous7, Interpolating7]);
scale11(`${Diverging7}-${Sqrt7}`, divergingSqrt, [Continuous7, Interpolating7]);
scale11(`${Diverging7}-${Symlog7}`, divergingSymlog, [Continuous7, Interpolating7]);
scale11(Quantile8, quantile2, [Discretizing7, Quantile8]);
scale11(Quantize7, quantize, Discretizing7);
scale11(Threshold7, threshold, Discretizing7);
scale11(BinOrdinal7, scaleBinOrdinal7, [Discrete7, Discretizing7]);
scale11(Ordinal7, ordinal, Discrete7);
scale11(Band7, band8, Discrete7);
scale11(Point7, point15, Discrete7);
function isValidScaleType7(type7) {
  return scales7.has(type7);
}
function hasType5(key4, type7) {
  const s2 = scales7.get(key4);
  return s2 && s2.metadata[type7];
}
function isDiscrete4(key4) {
  return hasType5(key4, Discrete7);
}
function isDiscretizing4(key4) {
  return hasType5(key4, Discretizing7);
}
function isLogarithmic5(key4) {
  return hasType5(key4, Log7);
}
function isTemporal4(key4) {
  return hasType5(key4, Temporal7);
}
function interpolateColors7(colors10, type7, gamma2) {
  return piecewise(interpolate7(type7 || "rgb", gamma2), colors10);
}
function interpolate7(type7, gamma2) {
  const interp = src_exports[method7(type7)];
  return gamma2 != null && interp && interp.gamma ? interp.gamma(gamma2) : interp;
}
function method7(type7) {
  return "interpolate" + type7.toLowerCase().split("-").map((s2) => s2[0].toUpperCase() + s2.slice(1)).join("");
}
var continuous8 = {
  blues: "cfe1f2bed8eca8cee58fc1de74b2d75ba3cf4592c63181bd206fb2125ca40a4a90",
  greens: "d3eecdc0e6baabdda594d3917bc77d60ba6c46ab5e329a512089430e7735036429",
  greys: "e2e2e2d4d4d4c4c4c4b1b1b19d9d9d8888887575756262624d4d4d3535351e1e1e",
  oranges: "fdd8b3fdc998fdb87bfda55efc9244f87f2cf06b18e4580bd14904b93d029f3303",
  purples: "e2e1efd4d4e8c4c5e0b4b3d6a3a0cc928ec3827cb97566ae684ea25c3696501f8c",
  reds: "fdc9b4fcb49afc9e80fc8767fa7051f6573fec3f2fdc2a25c81b1db21218970b13",
  blueGreen: "d5efedc1e8e0a7ddd18bd2be70c6a958ba9144ad77319c5d2089460e7736036429",
  bluePurple: "ccddecbad0e4a8c2dd9ab0d4919cc98d85be8b6db28a55a6873c99822287730f71",
  greenBlue: "d3eecec5e8c3b1e1bb9bd8bb82cec269c2ca51b2cd3c9fc7288abd1675b10b60a1",
  orangeRed: "fddcaffdcf9bfdc18afdad77fb9562f67d53ee6545e24932d32d1ebf130da70403",
  purpleBlue: "dbdaebc8cee4b1c3de97b7d87bacd15b9fc93a90c01e7fb70b70ab056199045281",
  purpleBlueGreen: "dbd8eac8cee4b0c3de93b7d872acd1549fc83892bb1c88a3097f8702736b016353",
  purpleRed: "dcc9e2d3b3d7ce9eccd186c0da6bb2e14da0e23189d91e6fc61159ab07498f023a",
  redPurple: "fccfccfcbec0faa9b8f98faff571a5ec539ddb3695c41b8aa908808d0179700174",
  yellowGreen: "e4f4acd1eca0b9e2949ed68880c97c62bb6e47aa5e3297502083440e723b036034",
  yellowOrangeBrown: "feeaa1fedd84fecc63feb746fca031f68921eb7215db5e0bc54c05ab3d038f3204",
  yellowOrangeRed: "fee087fed16ffebd59fea849fd903efc7335f9522bee3423de1b20ca0b22af0225",
  blueOrange: "134b852f78b35da2cb9dcae1d2e5eff2f0ebfce0bafbbf74e8932fc5690d994a07",
  brownBlueGreen: "704108a0651ac79548e3c78af3e6c6eef1eac9e9e48ed1c74da79e187a72025147",
  purpleGreen: "5b1667834792a67fb6c9aed3e6d6e8eff0efd9efd5aedda971bb75368e490e5e29",
  purpleOrange: "4114696647968f83b7b9b4d6dadbebf3eeeafce0bafbbf74e8932fc5690d994a07",
  redBlue: "8c0d25bf363adf745ef4ae91fbdbc9f2efeed2e5ef9dcae15da2cb2f78b3134b85",
  redGrey: "8c0d25bf363adf745ef4ae91fcdccbfaf4f1e2e2e2c0c0c0969696646464343434",
  yellowGreenBlue: "eff9bddbf1b4bde5b594d5b969c5be45b4c22c9ec02182b82163aa23479c1c3185",
  redYellowBlue: "a50026d4322cf16e43fcac64fedd90faf8c1dcf1ecabd6e875abd04a74b4313695",
  redYellowGreen: "a50026d4322cf16e43fcac63fedd8df9f7aed7ee8ea4d86e64bc6122964f006837",
  pinkYellowGreen: "8e0152c0267edd72adf0b3d6faddedf5f3efe1f2cab6de8780bb474f9125276419",
  spectral: "9e0142d13c4bf0704afcac63fedd8dfbf8b0e0f3a1a9dda269bda94288b55e4fa2",
  viridis: "440154470e61481a6c482575472f7d443a834144873d4e8a39568c35608d31688e2d708e2a788e27818e23888e21918d1f988b1fa08822a8842ab07f35b77943bf7154c56866cc5d7ad1518fd744a5db36bcdf27d2e21be9e51afde725",
  magma: "0000040404130b0924150e3720114b2c11603b0f704a107957157e651a80721f817f24828c29819a2e80a8327db6377ac43c75d1426fde4968e95462f1605df76f5cfa7f5efc8f65fe9f6dfeaf78febf84fece91fddea0fcedaffcfdbf",
  inferno: "0000040403130c0826170c3b240c4f330a5f420a68500d6c5d126e6b176e781c6d86216b932667a12b62ae305cbb3755c73e4cd24644dd513ae65c30ed6925f3771af8850ffb9506fca50afcb519fac62df6d645f2e661f3f484fcffa4",
  plasma: "0d088723069033059742039d5002a25d01a66a00a87801a88405a7900da49c179ea72198b12a90ba3488c33d80cb4779d35171da5a69e16462e76e5bed7953f2834cf68f44fa9a3dfca636fdb32ffec029fcce25f9dc24f5ea27f0f921",
  cividis: "00205100235800265d002961012b65042e670831690d346b11366c16396d1c3c6e213f6e26426e2c456e31476e374a6e3c4d6e42506e47536d4c566d51586e555b6e5a5e6e5e616e62646f66676f6a6a706e6d717270717573727976737c79747f7c75827f758682768985778c8877908b78938e789691789a94789e9778a19b78a59e77a9a177aea575b2a874b6ab73bbaf71c0b26fc5b66dc9b96acebd68d3c065d8c462ddc85fe2cb5ce7cf58ebd355f0d652f3da4ff7de4cfae249fce647",
  rainbow: "6e40aa883eb1a43db3bf3cafd83fa4ee4395fe4b83ff576eff6659ff7847ff8c38f3a130e2b72fcfcc36bee044aff05b8ff4576ff65b52f6673af27828ea8d1ddfa319d0b81cbecb23abd82f96e03d82e14c6edb5a5dd0664dbf6e40aa",
  sinebow: "ff4040fc582af47218e78d0bd5a703bfbf00a7d5038de70b72f41858fc2a40ff402afc5818f4720be78d03d5a700bfbf03a7d50b8de71872f42a58fc4040ff582afc7218f48d0be7a703d5bf00bfd503a7e70b8df41872fc2a58ff4040",
  turbo: "23171b32204a3e2a71453493493eae4b49c54a53d7485ee44569ee4074f53c7ff8378af93295f72e9ff42ba9ef28b3e926bce125c5d925cdcf27d5c629dcbc2de3b232e9a738ee9d3ff39347f68950f9805afc7765fd6e70fe667cfd5e88fc5795fb51a1f84badf545b9f140c5ec3cd0e637dae034e4d931ecd12ef4c92bfac029ffb626ffad24ffa223ff9821ff8d1fff821dff771cfd6c1af76118f05616e84b14df4111d5380fcb2f0dc0260ab61f07ac1805a313029b0f00950c00910b00",
  browns: "eedbbdecca96e9b97ae4a865dc9856d18954c7784cc0673fb85536ad44339f3632",
  tealBlues: "bce4d89dd3d181c3cb65b3c245a2b9368fae347da0306a932c5985",
  teals: "bbdfdfa2d4d58ac9c975bcbb61b0af4da5a43799982b8b8c1e7f7f127273006667",
  warmGreys: "dcd4d0cec5c1c0b8b4b3aaa7a59c9998908c8b827f7e7673726866665c5a59504e",
  goldGreen: "f4d166d5ca60b6c35c98bb597cb25760a6564b9c533f8f4f33834a257740146c36",
  goldOrange: "f4d166f8be5cf8aa4cf5983bf3852aef701be2621fd65322c54923b142239e3a26",
  goldRed: "f4d166f6be59f9aa51fc964ef6834bee734ae56249db5247cf4244c43141b71d3e",
  lightGreyRed: "efe9e6e1dad7d5cbc8c8bdb9bbaea9cd967ddc7b43e15f19df4011dc000b",
  lightGreyTeal: "e4eaead6dcddc8ced2b7c2c7a6b4bc64b0bf22a6c32295c11f85be1876bc",
  lightMulti: "e0f1f2c4e9d0b0de9fd0e181f6e072f6c053f3993ef77440ef4a3c",
  lightOrange: "f2e7daf7d5baf9c499fab184fa9c73f68967ef7860e8645bde515bd43d5b",
  lightTealBlue: "e3e9e0c0dccf9aceca7abfc859afc0389fb9328dad2f7ca0276b95255988",
  darkBlue: "3232322d46681a5c930074af008cbf05a7ce25c0dd38daed50f3faffffff",
  darkGold: "3c3c3c584b37725e348c7631ae8b2bcfa424ecc31ef9de30fff184ffffff",
  darkGreen: "3a3a3a215748006f4d048942489e4276b340a6c63dd2d836ffeb2cffffaa",
  darkMulti: "3737371f5287197d8c29a86995ce3fffe800ffffff",
  darkRed: "3434347036339e3c38cc4037e75d1eec8620eeab29f0ce32ffeb2c"
};
var discrete7 = {
  accent: Accent_default,
  category10: category10_default,
  category20: "1f77b4aec7e8ff7f0effbb782ca02c98df8ad62728ff98969467bdc5b0d58c564bc49c94e377c2f7b6d27f7f7fc7c7c7bcbd22dbdb8d17becf9edae5",
  category20b: "393b795254a36b6ecf9c9ede6379398ca252b5cf6bcedb9c8c6d31bd9e39e7ba52e7cb94843c39ad494ad6616be7969c7b4173a55194ce6dbdde9ed6",
  category20c: "3182bd6baed69ecae1c6dbefe6550dfd8d3cfdae6bfdd0a231a35474c476a1d99bc7e9c0756bb19e9ac8bcbddcdadaeb636363969696bdbdbdd9d9d9",
  dark2: Dark2_default,
  observable10: observable10_default,
  paired: Paired_default,
  pastel1: Pastel1_default,
  pastel2: Pastel2_default,
  set1: Set1_default,
  set2: Set2_default,
  set3: Set3_default,
  tableau10: "4c78a8f58518e4575672b7b254a24beeca3bb279a2ff9da69d755dbab0ac",
  tableau20: "4c78a89ecae9f58518ffbf7954a24b88d27ab79a20f2cf5b43989483bcb6e45756ff9d9879706ebab0acd67195fcbfd2b279a2d6a5c99e765fd8b5a5"
};
function colors7(palette) {
  if (isArray15(palette))
    return palette;
  const n = palette.length / 6 | 0, c5 = new Array(n);
  for (let i = 0; i < n; ) {
    c5[i] = "#" + palette.slice(i * 6, ++i * 6);
  }
  return c5;
}
function apply7(_, f) {
  for (const k3 in _)
    scheme34(k3, f(_[k3]));
}
var schemes7 = {};
apply7(discrete7, colors7);
apply7(continuous8, (_) => interpolateColors7(colors7(_)));
function scheme34(name, scheme38) {
  name = name && name.toLowerCase();
  if (arguments.length > 1) {
    schemes7[name] = scheme38;
    return this;
  } else {
    return schemes7[name];
  }
}
var SymbolLegend5 = "symbol";
var DiscreteLegend5 = "discrete";
var defaultFormatter5 = (value7) => isArray15(value7) ? value7.map((v2) => String(v2)) : String(value7);
var ascending8 = (a4, b6) => a4[1] - b6[1];
var descending6 = (a4, b6) => b6[1] - a4[1];
function validTicks5(scale19, ticks2, count3) {
  let range7 = scale19.range(), lo = range7[0], hi = peek9(range7), cmp = ascending8;
  if (lo > hi) {
    range7 = hi;
    hi = lo;
    lo = range7;
    cmp = descending6;
  }
  lo = Math.floor(lo);
  hi = Math.ceil(hi);
  ticks2 = ticks2.map((v2) => [v2, scale19(v2)]).filter((_) => lo <= _[1] && _[1] <= hi).sort(cmp).map((_) => _[0]);
  if (count3 > 0 && ticks2.length > 1) {
    const endpoints = [ticks2[0], peek9(ticks2)];
    while (ticks2.length > count3 && ticks2.length >= 3) {
      ticks2 = ticks2.filter((_, i) => !(i % 2));
    }
    if (ticks2.length < 3) {
      ticks2 = endpoints;
    }
  }
  return ticks2;
}
function tickValues5(scale19, count3) {
  return scale19.bins ? validTicks5(scale19, scale19.bins, count3) : scale19.ticks ? scale19.ticks(count3) : scale19.domain();
}
function tickFormat6(locale5, scale19, count3, specifier, formatType, noSkip) {
  const type7 = scale19.type;
  let format14 = defaultFormatter5;
  if (type7 === Time7 || formatType === Time7) {
    format14 = locale5.timeFormat(specifier);
  } else if (type7 === UTC7 || formatType === UTC7) {
    format14 = locale5.utcFormat(specifier);
  } else if (isLogarithmic5(type7)) {
    const varfmt = locale5.formatFloat(specifier);
    if (noSkip || scale19.bins) {
      format14 = varfmt;
    } else {
      const test2 = tickLog5(scale19, count3, false);
      format14 = (_) => test2(_) ? varfmt(_) : "";
    }
  } else if (scale19.tickFormat) {
    const d = scale19.domain();
    format14 = locale5.formatSpan(d[0], d[d.length - 1], count3, specifier);
  } else if (specifier) {
    format14 = locale5.format(specifier);
  }
  return format14;
}
function tickLog5(scale19, count3, values7) {
  const ticks2 = tickValues5(scale19, count3), base = scale19.base(), logb = Math.log(base), k3 = Math.max(1, base * count3 / ticks2.length);
  const test2 = (d) => {
    let i = d / Math.pow(base, Math.round(Math.log(d) / logb));
    if (i * base < base - 0.5)
      i *= base;
    return i <= k3;
  };
  return values7 ? ticks2.filter(test2) : test2;
}
var symbols10 = {
  [Quantile8]: "quantiles",
  [Quantize7]: "thresholds",
  [Threshold7]: "domain"
};
var formats9 = {
  [Quantile8]: "quantiles",
  [Quantize7]: "domain"
};
function labelValues5(scale19, count3) {
  return scale19.bins ? binValues5(scale19.bins) : scale19.type === Log7 ? tickLog5(scale19, count3, true) : symbols10[scale19.type] ? thresholdValues5(scale19[symbols10[scale19.type]]()) : tickValues5(scale19, count3);
}
function thresholdFormat5(locale5, scale19, specifier) {
  const _ = scale19[formats9[scale19.type]](), n = _.length;
  let d = n > 1 ? _[1] - _[0] : _[0], i;
  for (i = 1; i < n; ++i) {
    d = Math.min(d, _[i] - _[i - 1]);
  }
  return locale5.formatSpan(0, d, 3 * 10, specifier);
}
function thresholdValues5(thresholds) {
  const values7 = [-Infinity].concat(thresholds);
  values7.max = Infinity;
  return values7;
}
function binValues5(bins2) {
  const values7 = bins2.slice(0, -1);
  values7.max = peek9(bins2);
  return values7;
}
var isDiscreteRange5 = (scale19) => symbols10[scale19.type] || scale19.bins;
function labelFormat5(locale5, scale19, count3, type7, specifier, formatType, noSkip) {
  const format14 = formats9[scale19.type] && formatType !== Time7 && formatType !== UTC7 ? thresholdFormat5(locale5, scale19, specifier) : tickFormat6(locale5, scale19, count3, specifier, formatType, noSkip);
  return type7 === SymbolLegend5 && isDiscreteRange5(scale19) ? formatRange5(format14) : type7 === DiscreteLegend5 ? formatDiscrete5(format14) : formatPoint5(format14);
}
var formatRange5 = (format14) => (value7, index4, array22) => {
  const limit = get11(array22[index4 + 1], get11(array22.max, Infinity)), lo = formatValue5(value7, format14), hi = formatValue5(limit, format14);
  return lo && hi ? lo + " – " + hi : hi ? "< " + hi : "≥ " + lo;
};
var get11 = (value7, dflt) => value7 != null ? value7 : dflt;
var formatDiscrete5 = (format14) => (value7, index4) => index4 ? format14(value7) : null;
var formatPoint5 = (format14) => (value7) => format14(value7);
var formatValue5 = (value7, format14) => Number.isFinite(value7) ? format14(value7) : null;
function format10(locale5, scale19, specifier, formatType) {
  const type7 = formatType || scale19.type;
  if (isString8(specifier) && isTemporal4(type7)) {
    specifier = specifier.replace(/%a/g, "%A").replace(/%b/g, "%B");
  }
  return !specifier && type7 === Time7 ? locale5.timeFormat("%A, %d %B %Y, %X") : !specifier && type7 === UTC7 ? locale5.utcFormat("%A, %d %B %Y, %X UTC") : labelFormat5(locale5, scale19, 5, null, specifier, formatType, true);
}
function domainCaption4(locale5, scale19, opt) {
  opt = opt || {};
  const max5 = Math.max(3, opt.maxlen || 7), fmt = format10(locale5, scale19, opt.format, opt.formatType);
  if (isDiscretizing4(scale19.type)) {
    const v2 = labelValues5(scale19).slice(1).map(fmt), n = v2.length;
    return `${n} boundar${n === 1 ? "y" : "ies"}: ${v2.join(", ")}`;
  } else if (isDiscrete4(scale19.type)) {
    const d = scale19.domain(), n = d.length, v2 = n > max5 ? d.slice(0, max5 - 2).map(fmt).join(", ") + ", ending with " + d.slice(-1).map(fmt) : d.map(fmt).join(", ");
    return `${n} value${n === 1 ? "" : "s"}: ${v2}`;
  } else {
    const d = scale19.domain();
    return `values from ${fmt(d[0])} to ${fmt(peek9(d))}`;
  }
}

// node_modules/vega-view/node_modules/vega-scenegraph/build/vega-scenegraph.js
var gradient_id4 = 0;
var patternPrefix4 = "p_";
function isGradient4(value7) {
  return value7 && value7.gradient;
}
function gradientRef4(g, defs, base) {
  const type7 = g.gradient;
  let id24 = g.id, prefix = type7 === "radial" ? patternPrefix4 : "";
  if (!id24) {
    id24 = g.id = "gradient_" + gradient_id4++;
    if (type7 === "radial") {
      g.x1 = get20(g.x1, 0.5);
      g.y1 = get20(g.y1, 0.5);
      g.r1 = get20(g.r1, 0);
      g.x2 = get20(g.x2, 0.5);
      g.y2 = get20(g.y2, 0.5);
      g.r2 = get20(g.r2, 0.5);
      prefix = patternPrefix4;
    } else {
      g.x1 = get20(g.x1, 0);
      g.y1 = get20(g.y1, 0);
      g.x2 = get20(g.x2, 1);
      g.y2 = get20(g.y2, 0);
    }
  }
  defs[id24] = g;
  return "url(" + (base || "") + "#" + prefix + id24 + ")";
}
function get20(val, def6) {
  return val != null ? val : def6;
}
var lookup6 = {
  "basis": {
    curve: basis_default
  },
  "basis-closed": {
    curve: basisClosed_default
  },
  "basis-open": {
    curve: basisOpen_default
  },
  "bundle": {
    curve: bundle_default,
    tension: "beta",
    value: 0.85
  },
  "cardinal": {
    curve: cardinal_default,
    tension: "tension",
    value: 0
  },
  "cardinal-open": {
    curve: cardinalOpen_default,
    tension: "tension",
    value: 0
  },
  "cardinal-closed": {
    curve: cardinalClosed_default,
    tension: "tension",
    value: 0
  },
  "catmull-rom": {
    curve: catmullRom_default,
    tension: "alpha",
    value: 0.5
  },
  "catmull-rom-closed": {
    curve: catmullRomClosed_default,
    tension: "alpha",
    value: 0.5
  },
  "catmull-rom-open": {
    curve: catmullRomOpen_default,
    tension: "alpha",
    value: 0.5
  },
  "linear": {
    curve: linear_default
  },
  "linear-closed": {
    curve: linearClosed_default
  },
  "monotone": {
    horizontal: monotoneY,
    vertical: monotoneX
  },
  "natural": {
    curve: natural_default
  },
  "step": {
    curve: step_default
  },
  "step-after": {
    curve: stepAfter
  },
  "step-before": {
    curve: stepBefore
  }
};
function curves4(type7, orientation, tension) {
  var entry2 = has12(lookup6, type7) && lookup6[type7], curve2 = null;
  if (entry2) {
    curve2 = entry2.curve || entry2[orientation || "vertical"];
    if (entry2.tension && tension != null) {
      curve2 = curve2[entry2.tension](tension);
    }
  }
  return curve2;
}
var paramCounts4 = {
  m: 2,
  l: 2,
  h: 1,
  v: 1,
  z: 0,
  c: 6,
  s: 4,
  q: 4,
  t: 2,
  a: 7
};
var commandPattern4 = /[mlhvzcsqta]([^mlhvzcsqta]+|$)/gi;
var numberPattern4 = /^[+-]?(([0-9]*\.[0-9]+)|([0-9]+\.)|([0-9]+))([eE][+-]?[0-9]+)?/;
var spacePattern4 = /^((\s+,?\s*)|(,\s*))/;
var flagPattern4 = /^[01]/;
function parse8(path7) {
  const commands = [];
  const matches = path7.match(commandPattern4) || [];
  matches.forEach((str) => {
    let cmd = str[0];
    const type7 = cmd.toLowerCase();
    const paramCount = paramCounts4[type7];
    const params2 = parseParams4(type7, paramCount, str.slice(1).trim());
    const count3 = params2.length;
    if (count3 < paramCount || count3 && count3 % paramCount !== 0) {
      throw Error("Invalid SVG path, incorrect parameter count");
    }
    commands.push([cmd, ...params2.slice(0, paramCount)]);
    if (count3 === paramCount) {
      return;
    }
    if (type7 === "m") {
      cmd = cmd === "M" ? "L" : "l";
    }
    for (let i = paramCount; i < count3; i += paramCount) {
      commands.push([cmd, ...params2.slice(i, i + paramCount)]);
    }
  });
  return commands;
}
function parseParams4(type7, paramCount, segment) {
  const params2 = [];
  for (let index4 = 0; paramCount && index4 < segment.length; ) {
    for (let i = 0; i < paramCount; ++i) {
      const pattern = type7 === "a" && (i === 3 || i === 4) ? flagPattern4 : numberPattern4;
      const match2 = segment.slice(index4).match(pattern);
      if (match2 === null) {
        throw Error("Invalid SVG path, incorrect parameter type");
      }
      index4 += match2[0].length;
      params2.push(+match2[0]);
      const ws = segment.slice(index4).match(spacePattern4);
      if (ws !== null) {
        index4 += ws[0].length;
      }
    }
  }
  return params2;
}
var DegToRad4 = Math.PI / 180;
var Epsilon4 = 1e-14;
var HalfPi4 = Math.PI / 2;
var Tau4 = Math.PI * 2;
var HalfSqrt34 = Math.sqrt(3) / 2;
var segmentCache4 = {};
var bezierCache4 = {};
var join4 = [].join;
function segments4(x9, y9, rx, ry, large, sweep, rotateX, ox, oy) {
  const key4 = join4.call(arguments);
  if (segmentCache4[key4]) {
    return segmentCache4[key4];
  }
  const th = rotateX * DegToRad4;
  const sin_th = Math.sin(th);
  const cos_th = Math.cos(th);
  rx = Math.abs(rx);
  ry = Math.abs(ry);
  const px6 = cos_th * (ox - x9) * 0.5 + sin_th * (oy - y9) * 0.5;
  const py6 = cos_th * (oy - y9) * 0.5 - sin_th * (ox - x9) * 0.5;
  let pl = px6 * px6 / (rx * rx) + py6 * py6 / (ry * ry);
  if (pl > 1) {
    pl = Math.sqrt(pl);
    rx *= pl;
    ry *= pl;
  }
  const a00 = cos_th / rx;
  const a01 = sin_th / rx;
  const a10 = -sin_th / ry;
  const a11 = cos_th / ry;
  const x07 = a00 * ox + a01 * oy;
  const y07 = a10 * ox + a11 * oy;
  const x13 = a00 * x9 + a01 * y9;
  const y13 = a10 * x9 + a11 * y9;
  const d = (x13 - x07) * (x13 - x07) + (y13 - y07) * (y13 - y07);
  let sfactor_sq = 1 / d - 0.25;
  if (sfactor_sq < 0)
    sfactor_sq = 0;
  let sfactor = Math.sqrt(sfactor_sq);
  if (sweep == large)
    sfactor = -sfactor;
  const xc = 0.5 * (x07 + x13) - sfactor * (y13 - y07);
  const yc = 0.5 * (y07 + y13) + sfactor * (x13 - x07);
  const th0 = Math.atan2(y07 - yc, x07 - xc);
  const th1 = Math.atan2(y13 - yc, x13 - xc);
  let th_arc = th1 - th0;
  if (th_arc < 0 && sweep === 1) {
    th_arc += Tau4;
  } else if (th_arc > 0 && sweep === 0) {
    th_arc -= Tau4;
  }
  const segs = Math.ceil(Math.abs(th_arc / (HalfPi4 + 1e-3)));
  const result = [];
  for (let i = 0; i < segs; ++i) {
    const th2 = th0 + i * th_arc / segs;
    const th3 = th0 + (i + 1) * th_arc / segs;
    result[i] = [xc, yc, th2, th3, rx, ry, sin_th, cos_th];
  }
  return segmentCache4[key4] = result;
}
function bezier4(params2) {
  const key4 = join4.call(params2);
  if (bezierCache4[key4]) {
    return bezierCache4[key4];
  }
  var cx = params2[0], cy = params2[1], th0 = params2[2], th1 = params2[3], rx = params2[4], ry = params2[5], sin_th = params2[6], cos_th = params2[7];
  const a00 = cos_th * rx;
  const a01 = -sin_th * ry;
  const a10 = sin_th * rx;
  const a11 = cos_th * ry;
  const cos_th0 = Math.cos(th0);
  const sin_th0 = Math.sin(th0);
  const cos_th1 = Math.cos(th1);
  const sin_th1 = Math.sin(th1);
  const th_half = 0.5 * (th1 - th0);
  const sin_th_h2 = Math.sin(th_half * 0.5);
  const t = 8 / 3 * sin_th_h2 * sin_th_h2 / Math.sin(th_half);
  const x13 = cx + cos_th0 - t * sin_th0;
  const y13 = cy + sin_th0 + t * cos_th0;
  const x32 = cx + cos_th1;
  const y32 = cy + sin_th1;
  const x22 = x32 + t * sin_th1;
  const y22 = y32 - t * cos_th1;
  return bezierCache4[key4] = [a00 * x13 + a01 * y13, a10 * x13 + a11 * y13, a00 * x22 + a01 * y22, a10 * x22 + a11 * y22, a00 * x32 + a01 * y32, a10 * x32 + a11 * y32];
}
var temp4 = ["l", 0, 0, 0, 0, 0, 0, 0];
function scale$14(current2, sX, sY) {
  const c5 = temp4[0] = current2[0];
  if (c5 === "a" || c5 === "A") {
    temp4[1] = sX * current2[1];
    temp4[2] = sY * current2[2];
    temp4[3] = current2[3];
    temp4[4] = current2[4];
    temp4[5] = current2[5];
    temp4[6] = sX * current2[6];
    temp4[7] = sY * current2[7];
  } else if (c5 === "h" || c5 === "H") {
    temp4[1] = sX * current2[1];
  } else if (c5 === "v" || c5 === "V") {
    temp4[1] = sY * current2[1];
  } else {
    for (var i = 1, n = current2.length; i < n; ++i) {
      temp4[i] = (i % 2 == 1 ? sX : sY) * current2[i];
    }
  }
  return temp4;
}
function pathRender4(context7, path7, l, t, sX, sY) {
  var current2, previous = null, x9 = 0, y9 = 0, controlX = 0, controlY = 0, tempX, tempY, tempControlX, tempControlY, anchorX = 0, anchorY = 0;
  if (l == null)
    l = 0;
  if (t == null)
    t = 0;
  if (sX == null)
    sX = 1;
  if (sY == null)
    sY = sX;
  if (context7.beginPath)
    context7.beginPath();
  for (var i = 0, len = path7.length; i < len; ++i) {
    current2 = path7[i];
    if (sX !== 1 || sY !== 1) {
      current2 = scale$14(current2, sX, sY);
    }
    switch (current2[0]) {
      case "l":
        x9 += current2[1];
        y9 += current2[2];
        context7.lineTo(x9 + l, y9 + t);
        break;
      case "L":
        x9 = current2[1];
        y9 = current2[2];
        context7.lineTo(x9 + l, y9 + t);
        break;
      case "h":
        x9 += current2[1];
        context7.lineTo(x9 + l, y9 + t);
        break;
      case "H":
        x9 = current2[1];
        context7.lineTo(x9 + l, y9 + t);
        break;
      case "v":
        y9 += current2[1];
        context7.lineTo(x9 + l, y9 + t);
        break;
      case "V":
        y9 = current2[1];
        context7.lineTo(x9 + l, y9 + t);
        break;
      case "m":
        x9 += current2[1];
        y9 += current2[2];
        anchorX = x9;
        anchorY = y9;
        context7.moveTo(x9 + l, y9 + t);
        break;
      case "M":
        x9 = current2[1];
        y9 = current2[2];
        anchorX = x9;
        anchorY = y9;
        context7.moveTo(x9 + l, y9 + t);
        break;
      case "c":
        tempX = x9 + current2[5];
        tempY = y9 + current2[6];
        controlX = x9 + current2[3];
        controlY = y9 + current2[4];
        context7.bezierCurveTo(
          x9 + current2[1] + l,
          // x1
          y9 + current2[2] + t,
          // y1
          controlX + l,
          // x2
          controlY + t,
          // y2
          tempX + l,
          tempY + t
        );
        x9 = tempX;
        y9 = tempY;
        break;
      case "C":
        x9 = current2[5];
        y9 = current2[6];
        controlX = current2[3];
        controlY = current2[4];
        context7.bezierCurveTo(current2[1] + l, current2[2] + t, controlX + l, controlY + t, x9 + l, y9 + t);
        break;
      case "s":
        tempX = x9 + current2[3];
        tempY = y9 + current2[4];
        controlX = 2 * x9 - controlX;
        controlY = 2 * y9 - controlY;
        context7.bezierCurveTo(controlX + l, controlY + t, x9 + current2[1] + l, y9 + current2[2] + t, tempX + l, tempY + t);
        controlX = x9 + current2[1];
        controlY = y9 + current2[2];
        x9 = tempX;
        y9 = tempY;
        break;
      case "S":
        tempX = current2[3];
        tempY = current2[4];
        controlX = 2 * x9 - controlX;
        controlY = 2 * y9 - controlY;
        context7.bezierCurveTo(controlX + l, controlY + t, current2[1] + l, current2[2] + t, tempX + l, tempY + t);
        x9 = tempX;
        y9 = tempY;
        controlX = current2[1];
        controlY = current2[2];
        break;
      case "q":
        tempX = x9 + current2[3];
        tempY = y9 + current2[4];
        controlX = x9 + current2[1];
        controlY = y9 + current2[2];
        context7.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t);
        x9 = tempX;
        y9 = tempY;
        break;
      case "Q":
        tempX = current2[3];
        tempY = current2[4];
        context7.quadraticCurveTo(current2[1] + l, current2[2] + t, tempX + l, tempY + t);
        x9 = tempX;
        y9 = tempY;
        controlX = current2[1];
        controlY = current2[2];
        break;
      case "t":
        tempX = x9 + current2[1];
        tempY = y9 + current2[2];
        if (previous[0].match(/[QqTt]/) === null) {
          controlX = x9;
          controlY = y9;
        } else if (previous[0] === "t") {
          controlX = 2 * x9 - tempControlX;
          controlY = 2 * y9 - tempControlY;
        } else if (previous[0] === "q") {
          controlX = 2 * x9 - controlX;
          controlY = 2 * y9 - controlY;
        }
        tempControlX = controlX;
        tempControlY = controlY;
        context7.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t);
        x9 = tempX;
        y9 = tempY;
        controlX = x9 + current2[1];
        controlY = y9 + current2[2];
        break;
      case "T":
        tempX = current2[1];
        tempY = current2[2];
        controlX = 2 * x9 - controlX;
        controlY = 2 * y9 - controlY;
        context7.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t);
        x9 = tempX;
        y9 = tempY;
        break;
      case "a":
        drawArc4(context7, x9 + l, y9 + t, [current2[1], current2[2], current2[3], current2[4], current2[5], current2[6] + x9 + l, current2[7] + y9 + t]);
        x9 += current2[6];
        y9 += current2[7];
        break;
      case "A":
        drawArc4(context7, x9 + l, y9 + t, [current2[1], current2[2], current2[3], current2[4], current2[5], current2[6] + l, current2[7] + t]);
        x9 = current2[6];
        y9 = current2[7];
        break;
      case "z":
      case "Z":
        x9 = anchorX;
        y9 = anchorY;
        context7.closePath();
        break;
    }
    previous = current2;
  }
}
function drawArc4(context7, x9, y9, coords) {
  const seg = segments4(
    coords[5],
    // end x
    coords[6],
    // end y
    coords[0],
    // radius x
    coords[1],
    // radius y
    coords[3],
    // large flag
    coords[4],
    // sweep flag
    coords[2],
    // rotation
    x9,
    y9
  );
  for (let i = 0; i < seg.length; ++i) {
    const bez = bezier4(seg[i]);
    context7.bezierCurveTo(bez[0], bez[1], bez[2], bez[3], bez[4], bez[5]);
  }
}
var Tan304 = 0.5773502691896257;
var builtins4 = {
  "circle": {
    draw: function(context7, size) {
      const r = Math.sqrt(size) / 2;
      context7.moveTo(r, 0);
      context7.arc(0, 0, r, 0, Tau4);
    }
  },
  "cross": {
    draw: function(context7, size) {
      var r = Math.sqrt(size) / 2, s2 = r / 2.5;
      context7.moveTo(-r, -s2);
      context7.lineTo(-r, s2);
      context7.lineTo(-s2, s2);
      context7.lineTo(-s2, r);
      context7.lineTo(s2, r);
      context7.lineTo(s2, s2);
      context7.lineTo(r, s2);
      context7.lineTo(r, -s2);
      context7.lineTo(s2, -s2);
      context7.lineTo(s2, -r);
      context7.lineTo(-s2, -r);
      context7.lineTo(-s2, -s2);
      context7.closePath();
    }
  },
  "diamond": {
    draw: function(context7, size) {
      const r = Math.sqrt(size) / 2;
      context7.moveTo(-r, 0);
      context7.lineTo(0, -r);
      context7.lineTo(r, 0);
      context7.lineTo(0, r);
      context7.closePath();
    }
  },
  "square": {
    draw: function(context7, size) {
      var w8 = Math.sqrt(size), x9 = -w8 / 2;
      context7.rect(x9, x9, w8, w8);
    }
  },
  "arrow": {
    draw: function(context7, size) {
      var r = Math.sqrt(size) / 2, s2 = r / 7, t = r / 2.5, v2 = r / 8;
      context7.moveTo(-s2, r);
      context7.lineTo(s2, r);
      context7.lineTo(s2, -v2);
      context7.lineTo(t, -v2);
      context7.lineTo(0, -r);
      context7.lineTo(-t, -v2);
      context7.lineTo(-s2, -v2);
      context7.closePath();
    }
  },
  "wedge": {
    draw: function(context7, size) {
      var r = Math.sqrt(size) / 2, h6 = HalfSqrt34 * r, o = h6 - r * Tan304, b6 = r / 4;
      context7.moveTo(0, -h6 - o);
      context7.lineTo(-b6, h6 - o);
      context7.lineTo(b6, h6 - o);
      context7.closePath();
    }
  },
  "triangle": {
    draw: function(context7, size) {
      var r = Math.sqrt(size) / 2, h6 = HalfSqrt34 * r, o = h6 - r * Tan304;
      context7.moveTo(0, -h6 - o);
      context7.lineTo(-r, h6 - o);
      context7.lineTo(r, h6 - o);
      context7.closePath();
    }
  },
  "triangle-up": {
    draw: function(context7, size) {
      var r = Math.sqrt(size) / 2, h6 = HalfSqrt34 * r;
      context7.moveTo(0, -h6);
      context7.lineTo(-r, h6);
      context7.lineTo(r, h6);
      context7.closePath();
    }
  },
  "triangle-down": {
    draw: function(context7, size) {
      var r = Math.sqrt(size) / 2, h6 = HalfSqrt34 * r;
      context7.moveTo(0, h6);
      context7.lineTo(-r, -h6);
      context7.lineTo(r, -h6);
      context7.closePath();
    }
  },
  "triangle-right": {
    draw: function(context7, size) {
      var r = Math.sqrt(size) / 2, h6 = HalfSqrt34 * r;
      context7.moveTo(h6, 0);
      context7.lineTo(-h6, -r);
      context7.lineTo(-h6, r);
      context7.closePath();
    }
  },
  "triangle-left": {
    draw: function(context7, size) {
      var r = Math.sqrt(size) / 2, h6 = HalfSqrt34 * r;
      context7.moveTo(-h6, 0);
      context7.lineTo(h6, -r);
      context7.lineTo(h6, r);
      context7.closePath();
    }
  },
  "stroke": {
    draw: function(context7, size) {
      const r = Math.sqrt(size) / 2;
      context7.moveTo(-r, 0);
      context7.lineTo(r, 0);
    }
  }
};
function symbols11(_) {
  return has12(builtins4, _) ? builtins4[_] : customSymbol4(_);
}
var custom13 = {};
function customSymbol4(path7) {
  if (!has12(custom13, path7)) {
    const parsed = parse8(path7);
    custom13[path7] = {
      draw: function(context7, size) {
        pathRender4(context7, parsed, 0, 0, Math.sqrt(size) / 2);
      }
    };
  }
  return custom13[path7];
}
var C5 = 0.448084975506;
function rectangleX4(d) {
  return d.x;
}
function rectangleY4(d) {
  return d.y;
}
function rectangleWidth4(d) {
  return d.width;
}
function rectangleHeight4(d) {
  return d.height;
}
function number8(_) {
  return typeof _ === "function" ? _ : () => +_;
}
function clamp4(value7, min5, max5) {
  return Math.max(min5, Math.min(value7, max5));
}
function vg_rect4() {
  var x9 = rectangleX4, y9 = rectangleY4, width2 = rectangleWidth4, height2 = rectangleHeight4, crTL = number8(0), crTR = crTL, crBL = crTL, crBR = crTL, context7 = null;
  function rectangle6(_, x07, y07) {
    var buffer, x13 = x07 != null ? x07 : +x9.call(this, _), y13 = y07 != null ? y07 : +y9.call(this, _), w8 = +width2.call(this, _), h6 = +height2.call(this, _), s2 = Math.min(w8, h6) / 2, tl6 = clamp4(+crTL.call(this, _), 0, s2), tr6 = clamp4(+crTR.call(this, _), 0, s2), bl6 = clamp4(+crBL.call(this, _), 0, s2), br6 = clamp4(+crBR.call(this, _), 0, s2);
    if (!context7)
      context7 = buffer = path();
    if (tl6 <= 0 && tr6 <= 0 && bl6 <= 0 && br6 <= 0) {
      context7.rect(x13, y13, w8, h6);
    } else {
      var x22 = x13 + w8, y22 = y13 + h6;
      context7.moveTo(x13 + tl6, y13);
      context7.lineTo(x22 - tr6, y13);
      context7.bezierCurveTo(x22 - C5 * tr6, y13, x22, y13 + C5 * tr6, x22, y13 + tr6);
      context7.lineTo(x22, y22 - br6);
      context7.bezierCurveTo(x22, y22 - C5 * br6, x22 - C5 * br6, y22, x22 - br6, y22);
      context7.lineTo(x13 + bl6, y22);
      context7.bezierCurveTo(x13 + C5 * bl6, y22, x13, y22 - C5 * bl6, x13, y22 - bl6);
      context7.lineTo(x13, y13 + tl6);
      context7.bezierCurveTo(x13, y13 + C5 * tl6, x13 + C5 * tl6, y13, x13 + tl6, y13);
      context7.closePath();
    }
    if (buffer) {
      context7 = null;
      return buffer + "" || null;
    }
  }
  rectangle6.x = function(_) {
    if (arguments.length) {
      x9 = number8(_);
      return rectangle6;
    } else {
      return x9;
    }
  };
  rectangle6.y = function(_) {
    if (arguments.length) {
      y9 = number8(_);
      return rectangle6;
    } else {
      return y9;
    }
  };
  rectangle6.width = function(_) {
    if (arguments.length) {
      width2 = number8(_);
      return rectangle6;
    } else {
      return width2;
    }
  };
  rectangle6.height = function(_) {
    if (arguments.length) {
      height2 = number8(_);
      return rectangle6;
    } else {
      return height2;
    }
  };
  rectangle6.cornerRadius = function(tl6, tr6, br6, bl6) {
    if (arguments.length) {
      crTL = number8(tl6);
      crTR = tr6 != null ? number8(tr6) : crTL;
      crBR = br6 != null ? number8(br6) : crTL;
      crBL = bl6 != null ? number8(bl6) : crTR;
      return rectangle6;
    } else {
      return crTL;
    }
  };
  rectangle6.context = function(_) {
    if (arguments.length) {
      context7 = _ == null ? null : _;
      return rectangle6;
    } else {
      return context7;
    }
  };
  return rectangle6;
}
function vg_trail4() {
  var x9, y9, size, defined2, context7 = null, ready, x13, y13, r1;
  function point21(x22, y22, w22) {
    const r2 = w22 / 2;
    if (ready) {
      var ux = y13 - y22, uy = x22 - x13;
      if (ux || uy) {
        var ud = Math.hypot(ux, uy), rx = (ux /= ud) * r1, ry = (uy /= ud) * r1, t = Math.atan2(uy, ux);
        context7.moveTo(x13 - rx, y13 - ry);
        context7.lineTo(x22 - ux * r2, y22 - uy * r2);
        context7.arc(x22, y22, r2, t - Math.PI, t);
        context7.lineTo(x13 + rx, y13 + ry);
        context7.arc(x13, y13, r1, t, t + Math.PI);
      } else {
        context7.arc(x22, y22, r2, 0, Tau4);
      }
      context7.closePath();
    } else {
      ready = 1;
    }
    x13 = x22;
    y13 = y22;
    r1 = r2;
  }
  function trail7(data3) {
    var i, n = data3.length, d, defined0 = false, buffer;
    if (context7 == null)
      context7 = buffer = path();
    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined2(d = data3[i], i, data3)) === defined0) {
        if (defined0 = !defined0)
          ready = 0;
      }
      if (defined0)
        point21(+x9(d, i, data3), +y9(d, i, data3), +size(d, i, data3));
    }
    if (buffer) {
      context7 = null;
      return buffer + "" || null;
    }
  }
  trail7.x = function(_) {
    if (arguments.length) {
      x9 = _;
      return trail7;
    } else {
      return x9;
    }
  };
  trail7.y = function(_) {
    if (arguments.length) {
      y9 = _;
      return trail7;
    } else {
      return y9;
    }
  };
  trail7.size = function(_) {
    if (arguments.length) {
      size = _;
      return trail7;
    } else {
      return size;
    }
  };
  trail7.defined = function(_) {
    if (arguments.length) {
      defined2 = _;
      return trail7;
    } else {
      return defined2;
    }
  };
  trail7.context = function(_) {
    if (arguments.length) {
      if (_ == null) {
        context7 = null;
      } else {
        context7 = _;
      }
      return trail7;
    } else {
      return context7;
    }
  };
  return trail7;
}
function value$14(a4, b6) {
  return a4 != null ? a4 : b6;
}
var x7 = (item) => item.x || 0;
var y7 = (item) => item.y || 0;
var w5 = (item) => item.width || 0;
var h4 = (item) => item.height || 0;
var xw4 = (item) => (item.x || 0) + (item.width || 0);
var yh4 = (item) => (item.y || 0) + (item.height || 0);
var sa4 = (item) => item.startAngle || 0;
var ea5 = (item) => item.endAngle || 0;
var pa4 = (item) => item.padAngle || 0;
var ir4 = (item) => item.innerRadius || 0;
var or4 = (item) => item.outerRadius || 0;
var cr4 = (item) => item.cornerRadius || 0;
var tl4 = (item) => value$14(item.cornerRadiusTopLeft, item.cornerRadius) || 0;
var tr4 = (item) => value$14(item.cornerRadiusTopRight, item.cornerRadius) || 0;
var br4 = (item) => value$14(item.cornerRadiusBottomRight, item.cornerRadius) || 0;
var bl4 = (item) => value$14(item.cornerRadiusBottomLeft, item.cornerRadius) || 0;
var sz4 = (item) => value$14(item.size, 64);
var ts4 = (item) => item.size || 1;
var def4 = (item) => !(item.defined === false);
var type4 = (item) => symbols11(item.shape || "circle");
var arcShape4 = arc_default().startAngle(sa4).endAngle(ea5).padAngle(pa4).innerRadius(ir4).outerRadius(or4).cornerRadius(cr4);
var areavShape4 = area_default().x(x7).y1(y7).y0(yh4).defined(def4);
var areahShape4 = area_default().y(y7).x1(x7).x0(xw4).defined(def4);
var lineShape4 = line_default().x(x7).y(y7).defined(def4);
var rectShape4 = vg_rect4().x(x7).y(y7).width(w5).height(h4).cornerRadius(tl4, tr4, br4, bl4);
var symbolShape4 = Symbol2().type(type4).size(sz4);
var trailShape4 = vg_trail4().x(x7).y(y7).defined(def4).size(ts4);
function hasCornerRadius4(item) {
  return item.cornerRadius || item.cornerRadiusTopLeft || item.cornerRadiusTopRight || item.cornerRadiusBottomRight || item.cornerRadiusBottomLeft;
}
function arc$14(context7, item) {
  return arcShape4.context(context7)(item);
}
function area$14(context7, items) {
  const item = items[0], interp = item.interpolate || "linear";
  return (item.orient === "horizontal" ? areahShape4 : areavShape4).curve(curves4(interp, item.orient, item.tension)).context(context7)(items);
}
function line$14(context7, items) {
  const item = items[0], interp = item.interpolate || "linear";
  return lineShape4.curve(curves4(interp, item.orient, item.tension)).context(context7)(items);
}
function rectangle4(context7, item, x9, y9) {
  return rectShape4.context(context7)(item, x9, y9);
}
function shape$14(context7, item) {
  return (item.mark.shape || item.shape).context(context7)(item);
}
function symbol$14(context7, item) {
  return symbolShape4.context(context7)(item);
}
function trail$14(context7, items) {
  return trailShape4.context(context7)(items);
}
var clip_id4 = 1;
function clip$14(renderer, item, size) {
  var clip7 = item.clip, defs = renderer._defs, id24 = item.clip_id || (item.clip_id = "clip" + clip_id4++), c5 = defs.clipping[id24] || (defs.clipping[id24] = {
    id: id24
  });
  if (isFunction10(clip7)) {
    c5.path = clip7(null);
  } else if (hasCornerRadius4(size)) {
    c5.path = rectangle4(null, size, 0, 0);
  } else {
    c5.width = size.width || 0;
    c5.height = size.height || 0;
  }
  return "url(#" + id24 + ")";
}
function Bounds4(b6) {
  this.clear();
  if (b6)
    this.union(b6);
}
Bounds4.prototype = {
  clone() {
    return new Bounds4(this);
  },
  clear() {
    this.x1 = +Number.MAX_VALUE;
    this.y1 = +Number.MAX_VALUE;
    this.x2 = -Number.MAX_VALUE;
    this.y2 = -Number.MAX_VALUE;
    return this;
  },
  empty() {
    return this.x1 === +Number.MAX_VALUE && this.y1 === +Number.MAX_VALUE && this.x2 === -Number.MAX_VALUE && this.y2 === -Number.MAX_VALUE;
  },
  equals(b6) {
    return this.x1 === b6.x1 && this.y1 === b6.y1 && this.x2 === b6.x2 && this.y2 === b6.y2;
  },
  set(x13, y13, x22, y22) {
    if (x22 < x13) {
      this.x2 = x13;
      this.x1 = x22;
    } else {
      this.x1 = x13;
      this.x2 = x22;
    }
    if (y22 < y13) {
      this.y2 = y13;
      this.y1 = y22;
    } else {
      this.y1 = y13;
      this.y2 = y22;
    }
    return this;
  },
  add(x9, y9) {
    if (x9 < this.x1)
      this.x1 = x9;
    if (y9 < this.y1)
      this.y1 = y9;
    if (x9 > this.x2)
      this.x2 = x9;
    if (y9 > this.y2)
      this.y2 = y9;
    return this;
  },
  expand(d) {
    this.x1 -= d;
    this.y1 -= d;
    this.x2 += d;
    this.y2 += d;
    return this;
  },
  round() {
    this.x1 = Math.floor(this.x1);
    this.y1 = Math.floor(this.y1);
    this.x2 = Math.ceil(this.x2);
    this.y2 = Math.ceil(this.y2);
    return this;
  },
  scale(s2) {
    this.x1 *= s2;
    this.y1 *= s2;
    this.x2 *= s2;
    this.y2 *= s2;
    return this;
  },
  translate(dx, dy) {
    this.x1 += dx;
    this.x2 += dx;
    this.y1 += dy;
    this.y2 += dy;
    return this;
  },
  rotate(angle2, x9, y9) {
    const p = this.rotatedPoints(angle2, x9, y9);
    return this.clear().add(p[0], p[1]).add(p[2], p[3]).add(p[4], p[5]).add(p[6], p[7]);
  },
  rotatedPoints(angle2, x9, y9) {
    var {
      x1: x13,
      y1: y13,
      x2: x22,
      y2: y22
    } = this, cos4 = Math.cos(angle2), sin4 = Math.sin(angle2), cx = x9 - x9 * cos4 + y9 * sin4, cy = y9 - x9 * sin4 - y9 * cos4;
    return [cos4 * x13 - sin4 * y13 + cx, sin4 * x13 + cos4 * y13 + cy, cos4 * x13 - sin4 * y22 + cx, sin4 * x13 + cos4 * y22 + cy, cos4 * x22 - sin4 * y13 + cx, sin4 * x22 + cos4 * y13 + cy, cos4 * x22 - sin4 * y22 + cx, sin4 * x22 + cos4 * y22 + cy];
  },
  union(b6) {
    if (b6.x1 < this.x1)
      this.x1 = b6.x1;
    if (b6.y1 < this.y1)
      this.y1 = b6.y1;
    if (b6.x2 > this.x2)
      this.x2 = b6.x2;
    if (b6.y2 > this.y2)
      this.y2 = b6.y2;
    return this;
  },
  intersect(b6) {
    if (b6.x1 > this.x1)
      this.x1 = b6.x1;
    if (b6.y1 > this.y1)
      this.y1 = b6.y1;
    if (b6.x2 < this.x2)
      this.x2 = b6.x2;
    if (b6.y2 < this.y2)
      this.y2 = b6.y2;
    return this;
  },
  encloses(b6) {
    return b6 && this.x1 <= b6.x1 && this.x2 >= b6.x2 && this.y1 <= b6.y1 && this.y2 >= b6.y2;
  },
  alignsWith(b6) {
    return b6 && (this.x1 == b6.x1 || this.x2 == b6.x2 || this.y1 == b6.y1 || this.y2 == b6.y2);
  },
  intersects(b6) {
    return b6 && !(this.x2 < b6.x1 || this.x1 > b6.x2 || this.y2 < b6.y1 || this.y1 > b6.y2);
  },
  contains(x9, y9) {
    return !(x9 < this.x1 || x9 > this.x2 || y9 < this.y1 || y9 > this.y2);
  },
  width() {
    return this.x2 - this.x1;
  },
  height() {
    return this.y2 - this.y1;
  }
};
function Item4(mark) {
  this.mark = mark;
  this.bounds = this.bounds || new Bounds4();
}
function GroupItem4(mark) {
  Item4.call(this, mark);
  this.items = this.items || [];
}
inherits14(GroupItem4, Item4);
var ResourceLoader4 = class {
  constructor(customLoader) {
    this._pending = 0;
    this._loader = customLoader || loader5();
  }
  pending() {
    return this._pending;
  }
  sanitizeURL(uri) {
    const loader7 = this;
    increment4(loader7);
    return loader7._loader.sanitize(uri, {
      context: "href"
    }).then((opt) => {
      decrement4(loader7);
      return opt;
    }).catch(() => {
      decrement4(loader7);
      return null;
    });
  }
  loadImage(uri) {
    const loader7 = this, Image2 = domImage4();
    increment4(loader7);
    return loader7._loader.sanitize(uri, {
      context: "image"
    }).then((opt) => {
      const url = opt.href;
      if (!url || !Image2)
        throw {
          url
        };
      const img = new Image2();
      const cors = has12(opt, "crossOrigin") ? opt.crossOrigin : "anonymous";
      if (cors != null)
        img.crossOrigin = cors;
      img.onload = () => decrement4(loader7);
      img.onerror = () => decrement4(loader7);
      img.src = url;
      return img;
    }).catch((e3) => {
      decrement4(loader7);
      return {
        complete: false,
        width: 0,
        height: 0,
        src: e3 && e3.url || ""
      };
    });
  }
  ready() {
    const loader7 = this;
    return new Promise((accept) => {
      function poll(value7) {
        if (!loader7.pending())
          accept(value7);
        else
          setTimeout(() => {
            poll(true);
          }, 10);
      }
      poll(false);
    });
  }
};
function increment4(loader7) {
  loader7._pending += 1;
}
function decrement4(loader7) {
  loader7._pending -= 1;
}
function boundStroke4(bounds6, item, miter) {
  if (item.stroke && item.opacity !== 0 && item.strokeOpacity !== 0) {
    const sw = item.strokeWidth != null ? +item.strokeWidth : 1;
    bounds6.expand(sw + (miter ? miterAdjustment4(item, sw) : 0));
  }
  return bounds6;
}
function miterAdjustment4(item, strokeWidth) {
  return item.strokeJoin && item.strokeJoin !== "miter" ? 0 : strokeWidth;
}
var circleThreshold4 = Tau4 - 1e-8;
var bounds4;
var lx4;
var ly4;
var rot4;
var ma4;
var mb4;
var mc4;
var md4;
var add7 = (x9, y9) => bounds4.add(x9, y9);
var addL4 = (x9, y9) => add7(lx4 = x9, ly4 = y9);
var addX4 = (x9) => add7(x9, bounds4.y1);
var addY4 = (y9) => add7(bounds4.x1, y9);
var px4 = (x9, y9) => ma4 * x9 + mc4 * y9;
var py4 = (x9, y9) => mb4 * x9 + md4 * y9;
var addp4 = (x9, y9) => add7(px4(x9, y9), py4(x9, y9));
var addpL4 = (x9, y9) => addL4(px4(x9, y9), py4(x9, y9));
function boundContext4(_, deg) {
  bounds4 = _;
  if (deg) {
    rot4 = deg * DegToRad4;
    ma4 = md4 = Math.cos(rot4);
    mb4 = Math.sin(rot4);
    mc4 = -mb4;
  } else {
    ma4 = md4 = 1;
    rot4 = mb4 = mc4 = 0;
  }
  return context$14;
}
var context$14 = {
  beginPath() {
  },
  closePath() {
  },
  moveTo: addpL4,
  lineTo: addpL4,
  rect(x9, y9, w8, h6) {
    if (rot4) {
      addp4(x9 + w8, y9);
      addp4(x9 + w8, y9 + h6);
      addp4(x9, y9 + h6);
      addpL4(x9, y9);
    } else {
      add7(x9 + w8, y9 + h6);
      addL4(x9, y9);
    }
  },
  quadraticCurveTo(x13, y13, x22, y22) {
    const px1 = px4(x13, y13), py1 = py4(x13, y13), px22 = px4(x22, y22), py22 = py4(x22, y22);
    quadExtrema4(lx4, px1, px22, addX4);
    quadExtrema4(ly4, py1, py22, addY4);
    addL4(px22, py22);
  },
  bezierCurveTo(x13, y13, x22, y22, x32, y32) {
    const px1 = px4(x13, y13), py1 = py4(x13, y13), px22 = px4(x22, y22), py22 = py4(x22, y22), px32 = px4(x32, y32), py32 = py4(x32, y32);
    cubicExtrema4(lx4, px1, px22, px32, addX4);
    cubicExtrema4(ly4, py1, py22, py32, addY4);
    addL4(px32, py32);
  },
  arc(cx, cy, r, sa6, ea7, ccw) {
    sa6 += rot4;
    ea7 += rot4;
    lx4 = r * Math.cos(ea7) + cx;
    ly4 = r * Math.sin(ea7) + cy;
    if (Math.abs(ea7 - sa6) > circleThreshold4) {
      add7(cx - r, cy - r);
      add7(cx + r, cy + r);
    } else {
      const update3 = (a4) => add7(r * Math.cos(a4) + cx, r * Math.sin(a4) + cy);
      let s2, i;
      update3(sa6);
      update3(ea7);
      if (ea7 !== sa6) {
        sa6 = sa6 % Tau4;
        if (sa6 < 0)
          sa6 += Tau4;
        ea7 = ea7 % Tau4;
        if (ea7 < 0)
          ea7 += Tau4;
        if (ea7 < sa6) {
          ccw = !ccw;
          s2 = sa6;
          sa6 = ea7;
          ea7 = s2;
        }
        if (ccw) {
          ea7 -= Tau4;
          s2 = sa6 - sa6 % HalfPi4;
          for (i = 0; i < 4 && s2 > ea7; ++i, s2 -= HalfPi4)
            update3(s2);
        } else {
          s2 = sa6 - sa6 % HalfPi4 + HalfPi4;
          for (i = 0; i < 4 && s2 < ea7; ++i, s2 = s2 + HalfPi4)
            update3(s2);
        }
      }
    }
  }
};
function quadExtrema4(x07, x13, x22, cb) {
  const t = (x07 - x13) / (x07 + x22 - 2 * x13);
  if (0 < t && t < 1)
    cb(x07 + (x13 - x07) * t);
}
function cubicExtrema4(x07, x13, x22, x32, cb) {
  const a4 = x32 - x07 + 3 * x13 - 3 * x22, b6 = x07 + x22 - 2 * x13, c5 = x07 - x13;
  let t014 = 0, t13 = 0, r;
  if (Math.abs(a4) > Epsilon4) {
    r = b6 * b6 + c5 * a4;
    if (r >= 0) {
      r = Math.sqrt(r);
      t014 = (-b6 + r) / a4;
      t13 = (-b6 - r) / a4;
    }
  } else {
    t014 = 0.5 * c5 / b6;
  }
  if (0 < t014 && t014 < 1)
    cb(cubic4(t014, x07, x13, x22, x32));
  if (0 < t13 && t13 < 1)
    cb(cubic4(t13, x07, x13, x22, x32));
}
function cubic4(t, x07, x13, x22, x32) {
  const s2 = 1 - t, s22 = s2 * s2, t22 = t * t;
  return s22 * s2 * x07 + 3 * s22 * t * x13 + 3 * s2 * t22 * x22 + t22 * t * x32;
}
var context4 = (context4 = domCanvas6(1, 1)) ? context4.getContext("2d") : null;
var b4 = new Bounds4();
function intersectPath4(draw7) {
  return function(item, brush) {
    if (!context4)
      return true;
    draw7(context4, item);
    b4.clear().union(item.bounds).intersect(brush).round();
    const {
      x1: x13,
      y1: y13,
      x2: x22,
      y2: y22
    } = b4;
    for (let y9 = y13; y9 <= y22; ++y9) {
      for (let x9 = x13; x9 <= x22; ++x9) {
        if (context4.isPointInPath(x9, y9)) {
          return true;
        }
      }
    }
    return false;
  };
}
function intersectPoint4(item, box) {
  return box.contains(item.x || 0, item.y || 0);
}
function intersectRect4(item, box) {
  const x9 = item.x || 0, y9 = item.y || 0, w8 = item.width || 0, h6 = item.height || 0;
  return box.intersects(b4.set(x9, y9, x9 + w8, y9 + h6));
}
function intersectRule4(item, box) {
  const x9 = item.x || 0, y9 = item.y || 0, x22 = item.x2 != null ? item.x2 : x9, y22 = item.y2 != null ? item.y2 : y9;
  return intersectBoxLine4(box, x9, y9, x22, y22);
}
function intersectBoxLine4(box, x9, y9, u4, v2) {
  const {
    x1: x13,
    y1: y13,
    x2: x22,
    y2: y22
  } = box, dx = u4 - x9, dy = v2 - y9;
  let t014 = 0, t13 = 1, p, q, r, e3;
  for (e3 = 0; e3 < 4; ++e3) {
    if (e3 === 0) {
      p = -dx;
      q = -(x13 - x9);
    }
    if (e3 === 1) {
      p = dx;
      q = x22 - x9;
    }
    if (e3 === 2) {
      p = -dy;
      q = -(y13 - y9);
    }
    if (e3 === 3) {
      p = dy;
      q = y22 - y9;
    }
    if (Math.abs(p) < 1e-10 && q < 0)
      return false;
    r = q / p;
    if (p < 0) {
      if (r > t13)
        return false;
      else if (r > t014)
        t014 = r;
    } else if (p > 0) {
      if (r < t014)
        return false;
      else if (r < t13)
        t13 = r;
    }
  }
  return true;
}
function blend4(context7, item) {
  context7.globalCompositeOperation = item.blend || "source-over";
}
function value4(value7, dflt) {
  return value7 == null ? dflt : value7;
}
function addStops4(gradient8, stops) {
  const n = stops.length;
  for (let i = 0; i < n; ++i) {
    gradient8.addColorStop(stops[i].offset, stops[i].color);
  }
  return gradient8;
}
function gradient4(context7, spec, bounds6) {
  const w8 = bounds6.width(), h6 = bounds6.height();
  let gradient8;
  if (spec.gradient === "radial") {
    gradient8 = context7.createRadialGradient(bounds6.x1 + value4(spec.x1, 0.5) * w8, bounds6.y1 + value4(spec.y1, 0.5) * h6, Math.max(w8, h6) * value4(spec.r1, 0), bounds6.x1 + value4(spec.x2, 0.5) * w8, bounds6.y1 + value4(spec.y2, 0.5) * h6, Math.max(w8, h6) * value4(spec.r2, 0.5));
  } else {
    const x13 = value4(spec.x1, 0), y13 = value4(spec.y1, 0), x22 = value4(spec.x2, 1), y22 = value4(spec.y2, 0);
    if (x13 === x22 || y13 === y22 || w8 === h6) {
      gradient8 = context7.createLinearGradient(bounds6.x1 + x13 * w8, bounds6.y1 + y13 * h6, bounds6.x1 + x22 * w8, bounds6.y1 + y22 * h6);
    } else {
      const image7 = domCanvas6(Math.ceil(w8), Math.ceil(h6)), ictx = image7.getContext("2d");
      ictx.scale(w8, h6);
      ictx.fillStyle = addStops4(ictx.createLinearGradient(x13, y13, x22, y22), spec.stops);
      ictx.fillRect(0, 0, w8, h6);
      return context7.createPattern(image7, "no-repeat");
    }
  }
  return addStops4(gradient8, spec.stops);
}
function color5(context7, item, value7) {
  return isGradient4(value7) ? gradient4(context7, value7, item.bounds) : value7;
}
function fill4(context7, item, opacity2) {
  opacity2 *= item.fillOpacity == null ? 1 : item.fillOpacity;
  if (opacity2 > 0) {
    context7.globalAlpha = opacity2;
    context7.fillStyle = color5(context7, item, item.fill);
    return true;
  } else {
    return false;
  }
}
var Empty5 = [];
function stroke4(context7, item, opacity2) {
  var lw = (lw = item.strokeWidth) != null ? lw : 1;
  if (lw <= 0)
    return false;
  opacity2 *= item.strokeOpacity == null ? 1 : item.strokeOpacity;
  if (opacity2 > 0) {
    context7.globalAlpha = opacity2;
    context7.strokeStyle = color5(context7, item, item.stroke);
    context7.lineWidth = lw;
    context7.lineCap = item.strokeCap || "butt";
    context7.lineJoin = item.strokeJoin || "miter";
    context7.miterLimit = item.strokeMiterLimit || 10;
    if (context7.setLineDash) {
      context7.setLineDash(item.strokeDash || Empty5);
      context7.lineDashOffset = item.strokeDashOffset || 0;
    }
    return true;
  } else {
    return false;
  }
}
function compare6(a4, b6) {
  return a4.zindex - b6.zindex || a4.index - b6.index;
}
function zorder4(scene) {
  if (!scene.zdirty)
    return scene.zitems;
  var items = scene.items, output3 = [], item, i, n;
  for (i = 0, n = items.length; i < n; ++i) {
    item = items[i];
    item.index = i;
    if (item.zindex)
      output3.push(item);
  }
  scene.zdirty = false;
  return scene.zitems = output3.sort(compare6);
}
function visit4(scene, visitor) {
  var items = scene.items, i, n;
  if (!items || !items.length)
    return;
  const zitems = zorder4(scene);
  if (zitems && zitems.length) {
    for (i = 0, n = items.length; i < n; ++i) {
      if (!items[i].zindex)
        visitor(items[i]);
    }
    items = zitems;
  }
  for (i = 0, n = items.length; i < n; ++i) {
    visitor(items[i]);
  }
}
function pickVisit4(scene, visitor) {
  var items = scene.items, hit6, i;
  if (!items || !items.length)
    return null;
  const zitems = zorder4(scene);
  if (zitems && zitems.length)
    items = zitems;
  for (i = items.length; --i >= 0; ) {
    if (hit6 = visitor(items[i]))
      return hit6;
  }
  if (items === zitems) {
    for (items = scene.items, i = items.length; --i >= 0; ) {
      if (!items[i].zindex) {
        if (hit6 = visitor(items[i]))
          return hit6;
      }
    }
  }
  return null;
}
function drawAll4(path7) {
  return function(context7, scene, bounds6) {
    visit4(scene, (item) => {
      if (!bounds6 || bounds6.intersects(item.bounds)) {
        drawPath4(path7, context7, item, item);
      }
    });
  };
}
function drawOne4(path7) {
  return function(context7, scene, bounds6) {
    if (scene.items.length && (!bounds6 || bounds6.intersects(scene.bounds))) {
      drawPath4(path7, context7, scene.items[0], scene.items);
    }
  };
}
function drawPath4(path7, context7, item, items) {
  var opacity2 = item.opacity == null ? 1 : item.opacity;
  if (opacity2 === 0)
    return;
  if (path7(context7, items))
    return;
  blend4(context7, item);
  if (item.fill && fill4(context7, item, opacity2)) {
    context7.fill();
  }
  if (item.stroke && stroke4(context7, item, opacity2)) {
    context7.stroke();
  }
}
function pick$14(test2) {
  test2 = test2 || truthy15;
  return function(context7, scene, x9, y9, gx, gy) {
    x9 *= context7.pixelRatio;
    y9 *= context7.pixelRatio;
    return pickVisit4(scene, (item) => {
      const b6 = item.bounds;
      if (b6 && !b6.contains(gx, gy) || !b6)
        return;
      if (test2(context7, item, x9, y9, gx, gy))
        return item;
    });
  };
}
function hitPath4(path7, filled) {
  return function(context7, o, x9, y9) {
    var item = Array.isArray(o) ? o[0] : o, fill6 = filled == null ? item.fill : filled, stroke6 = item.stroke && context7.isPointInStroke, lw, lc;
    if (stroke6) {
      lw = item.strokeWidth;
      lc = item.strokeCap;
      context7.lineWidth = lw != null ? lw : 1;
      context7.lineCap = lc != null ? lc : "butt";
    }
    return path7(context7, o) ? false : fill6 && context7.isPointInPath(x9, y9) || stroke6 && context7.isPointInStroke(x9, y9);
  };
}
function pickPath4(path7) {
  return pick$14(hitPath4(path7));
}
function translate5(x9, y9) {
  return "translate(" + x9 + "," + y9 + ")";
}
function rotate4(a4) {
  return "rotate(" + a4 + ")";
}
function scale12(scaleX, scaleY2) {
  return "scale(" + scaleX + "," + scaleY2 + ")";
}
function translateItem4(item) {
  return translate5(item.x || 0, item.y || 0);
}
function rotateItem4(item) {
  return translate5(item.x || 0, item.y || 0) + (item.angle ? " " + rotate4(item.angle) : "");
}
function transformItem4(item) {
  return translate5(item.x || 0, item.y || 0) + (item.angle ? " " + rotate4(item.angle) : "") + (item.scaleX || item.scaleY ? " " + scale12(item.scaleX || 1, item.scaleY || 1) : "");
}
function markItemPath4(type7, shape6, isect) {
  function attr6(emit6, item) {
    emit6("transform", rotateItem4(item));
    emit6("d", shape6(null, item));
  }
  function bound6(bounds6, item) {
    shape6(boundContext4(bounds6, item.angle), item);
    return boundStroke4(bounds6, item).translate(item.x || 0, item.y || 0);
  }
  function draw7(context7, item) {
    var x9 = item.x || 0, y9 = item.y || 0, a4 = item.angle || 0;
    context7.translate(x9, y9);
    if (a4)
      context7.rotate(a4 *= DegToRad4);
    context7.beginPath();
    shape6(context7, item);
    if (a4)
      context7.rotate(-a4);
    context7.translate(-x9, -y9);
  }
  return {
    type: type7,
    tag: "path",
    nested: false,
    attr: attr6,
    bound: bound6,
    draw: drawAll4(draw7),
    pick: pickPath4(draw7),
    isect: isect || intersectPath4(draw7)
  };
}
var arc5 = markItemPath4("arc", arc$14);
function pickArea4(a4, p) {
  var v2 = a4[0].orient === "horizontal" ? p[1] : p[0], z = a4[0].orient === "horizontal" ? "y" : "x", i = a4.length, min5 = Infinity, hit6, d;
  while (--i >= 0) {
    if (a4[i].defined === false)
      continue;
    d = Math.abs(a4[i][z] - v2);
    if (d < min5) {
      min5 = d;
      hit6 = a4[i];
    }
  }
  return hit6;
}
function pickLine4(a4, p) {
  var t = Math.pow(a4[0].strokeWidth || 1, 2), i = a4.length, dx, dy, dd;
  while (--i >= 0) {
    if (a4[i].defined === false)
      continue;
    dx = a4[i].x - p[0];
    dy = a4[i].y - p[1];
    dd = dx * dx + dy * dy;
    if (dd < t)
      return a4[i];
  }
  return null;
}
function pickTrail4(a4, p) {
  var i = a4.length, dx, dy, dd;
  while (--i >= 0) {
    if (a4[i].defined === false)
      continue;
    dx = a4[i].x - p[0];
    dy = a4[i].y - p[1];
    dd = dx * dx + dy * dy;
    dx = a4[i].size || 1;
    if (dd < dx * dx)
      return a4[i];
  }
  return null;
}
function markMultiItemPath4(type7, shape6, tip) {
  function attr6(emit6, item) {
    var items = item.mark.items;
    if (items.length)
      emit6("d", shape6(null, items));
  }
  function bound6(bounds6, mark) {
    var items = mark.items;
    if (items.length === 0) {
      return bounds6;
    } else {
      shape6(boundContext4(bounds6), items);
      return boundStroke4(bounds6, items[0]);
    }
  }
  function draw7(context7, items) {
    context7.beginPath();
    shape6(context7, items);
  }
  const hit6 = hitPath4(draw7);
  function pick7(context7, scene, x9, y9, gx, gy) {
    var items = scene.items, b6 = scene.bounds;
    if (!items || !items.length || b6 && !b6.contains(gx, gy)) {
      return null;
    }
    x9 *= context7.pixelRatio;
    y9 *= context7.pixelRatio;
    return hit6(context7, items, x9, y9) ? items[0] : null;
  }
  return {
    type: type7,
    tag: "path",
    nested: true,
    attr: attr6,
    bound: bound6,
    draw: drawOne4(draw7),
    pick: pick7,
    isect: intersectPoint4,
    tip
  };
}
var area5 = markMultiItemPath4("area", area$14, pickArea4);
function clip4(context7, scene) {
  var clip7 = scene.clip;
  context7.save();
  if (isFunction10(clip7)) {
    context7.beginPath();
    clip7(context7);
    context7.clip();
  } else {
    clipGroup4(context7, scene.group);
  }
}
function clipGroup4(context7, group7) {
  context7.beginPath();
  hasCornerRadius4(group7) ? rectangle4(context7, group7, 0, 0) : context7.rect(0, 0, group7.width || 0, group7.height || 0);
  context7.clip();
}
function offset$14(item) {
  const sw = value4(item.strokeWidth, 1);
  return item.strokeOffset != null ? item.strokeOffset : item.stroke && sw > 0.5 && sw < 1.5 ? 0.5 - Math.abs(sw - 1) : 0;
}
function attr$54(emit6, item) {
  emit6("transform", translateItem4(item));
}
function emitRectangle4(emit6, item) {
  const off = offset$14(item);
  emit6("d", rectangle4(null, item, off, off));
}
function background4(emit6, item) {
  emit6("class", "background");
  emit6("aria-hidden", true);
  emitRectangle4(emit6, item);
}
function foreground4(emit6, item) {
  emit6("class", "foreground");
  emit6("aria-hidden", true);
  if (item.strokeForeground) {
    emitRectangle4(emit6, item);
  } else {
    emit6("d", "");
  }
}
function content4(emit6, item, renderer) {
  const url = item.clip ? clip$14(renderer, item, item) : null;
  emit6("clip-path", url);
}
function bound$54(bounds6, group7) {
  if (!group7.clip && group7.items) {
    const items = group7.items, m3 = items.length;
    for (let j = 0; j < m3; ++j) {
      bounds6.union(items[j].bounds);
    }
  }
  if ((group7.clip || group7.width || group7.height) && !group7.noBound) {
    bounds6.add(0, 0).add(group7.width || 0, group7.height || 0);
  }
  boundStroke4(bounds6, group7);
  return bounds6.translate(group7.x || 0, group7.y || 0);
}
function rectanglePath4(context7, group7, x9, y9) {
  const off = offset$14(group7);
  context7.beginPath();
  rectangle4(context7, group7, (x9 || 0) + off, (y9 || 0) + off);
}
var hitBackground4 = hitPath4(rectanglePath4);
var hitForeground4 = hitPath4(rectanglePath4, false);
var hitCorner4 = hitPath4(rectanglePath4, true);
function draw$44(context7, scene, bounds6, markTypes) {
  visit4(scene, (group7) => {
    const gx = group7.x || 0, gy = group7.y || 0, fore = group7.strokeForeground, opacity2 = group7.opacity == null ? 1 : group7.opacity;
    if ((group7.stroke || group7.fill) && opacity2) {
      rectanglePath4(context7, group7, gx, gy);
      blend4(context7, group7);
      if (group7.fill && fill4(context7, group7, opacity2)) {
        context7.fill();
      }
      if (group7.stroke && !fore && stroke4(context7, group7, opacity2)) {
        context7.stroke();
      }
    }
    context7.save();
    context7.translate(gx, gy);
    if (group7.clip)
      clipGroup4(context7, group7);
    if (bounds6)
      bounds6.translate(-gx, -gy);
    visit4(group7, (item) => {
      if (item.marktype === "group" || markTypes == null || markTypes.includes(item.marktype)) {
        this.draw(context7, item, bounds6, markTypes);
      }
    });
    if (bounds6)
      bounds6.translate(gx, gy);
    context7.restore();
    if (fore && group7.stroke && opacity2) {
      rectanglePath4(context7, group7, gx, gy);
      blend4(context7, group7);
      if (stroke4(context7, group7, opacity2)) {
        context7.stroke();
      }
    }
  });
}
function pick4(context7, scene, x9, y9, gx, gy) {
  if (scene.bounds && !scene.bounds.contains(gx, gy) || !scene.items) {
    return null;
  }
  const cx = x9 * context7.pixelRatio, cy = y9 * context7.pixelRatio;
  return pickVisit4(scene, (group7) => {
    let hit6, dx, dy;
    const b6 = group7.bounds;
    if (b6 && !b6.contains(gx, gy))
      return;
    dx = group7.x || 0;
    dy = group7.y || 0;
    const dw = dx + (group7.width || 0), dh = dy + (group7.height || 0), c5 = group7.clip;
    if (c5 && (gx < dx || gx > dw || gy < dy || gy > dh))
      return;
    context7.save();
    context7.translate(dx, dy);
    dx = gx - dx;
    dy = gy - dy;
    if (c5 && hasCornerRadius4(group7) && !hitCorner4(context7, group7, cx, cy)) {
      context7.restore();
      return null;
    }
    const fore = group7.strokeForeground, ix = scene.interactive !== false;
    if (ix && fore && group7.stroke && hitForeground4(context7, group7, cx, cy)) {
      context7.restore();
      return group7;
    }
    hit6 = pickVisit4(group7, (mark) => pickMark4(mark, dx, dy) ? this.pick(mark, x9, y9, dx, dy) : null);
    if (!hit6 && ix && (group7.fill || !fore && group7.stroke) && hitBackground4(context7, group7, cx, cy)) {
      hit6 = group7;
    }
    context7.restore();
    return hit6 || null;
  });
}
function pickMark4(mark, x9, y9) {
  return (mark.interactive !== false || mark.marktype === "group") && mark.bounds && mark.bounds.contains(x9, y9);
}
var group5 = {
  type: "group",
  tag: "g",
  nested: false,
  attr: attr$54,
  bound: bound$54,
  draw: draw$44,
  pick: pick4,
  isect: intersectRect4,
  content: content4,
  background: background4,
  foreground: foreground4
};
var metadata4 = {
  "xmlns": "http://www.w3.org/2000/svg",
  "xmlns:xlink": "http://www.w3.org/1999/xlink",
  "version": "1.1"
};
function getImage4(item, renderer) {
  var image7 = item.image;
  if (!image7 || item.url && item.url !== image7.url) {
    image7 = {
      complete: false,
      width: 0,
      height: 0
    };
    renderer.loadImage(item.url).then((image8) => {
      item.image = image8;
      item.image.url = item.url;
    });
  }
  return image7;
}
function imageWidth4(item, image7) {
  return item.width != null ? item.width : !image7 || !image7.width ? 0 : item.aspect !== false && item.height ? item.height * image7.width / image7.height : image7.width;
}
function imageHeight4(item, image7) {
  return item.height != null ? item.height : !image7 || !image7.height ? 0 : item.aspect !== false && item.width ? item.width * image7.height / image7.width : image7.height;
}
function imageXOffset4(align2, w8) {
  return align2 === "center" ? w8 / 2 : align2 === "right" ? w8 : 0;
}
function imageYOffset4(baseline3, h6) {
  return baseline3 === "middle" ? h6 / 2 : baseline3 === "bottom" ? h6 : 0;
}
function attr$44(emit6, item, renderer) {
  const img = getImage4(item, renderer), w8 = imageWidth4(item, img), h6 = imageHeight4(item, img), x9 = (item.x || 0) - imageXOffset4(item.align, w8), y9 = (item.y || 0) - imageYOffset4(item.baseline, h6), i = !img.src && img.toDataURL ? img.toDataURL() : img.src || "";
  emit6("href", i, metadata4["xmlns:xlink"], "xlink:href");
  emit6("transform", translate5(x9, y9));
  emit6("width", w8);
  emit6("height", h6);
  emit6("preserveAspectRatio", item.aspect === false ? "none" : "xMidYMid");
}
function bound$44(bounds6, item) {
  const img = item.image, w8 = imageWidth4(item, img), h6 = imageHeight4(item, img), x9 = (item.x || 0) - imageXOffset4(item.align, w8), y9 = (item.y || 0) - imageYOffset4(item.baseline, h6);
  return bounds6.set(x9, y9, x9 + w8, y9 + h6);
}
function draw$34(context7, scene, bounds6) {
  visit4(scene, (item) => {
    if (bounds6 && !bounds6.intersects(item.bounds))
      return;
    const img = getImage4(item, this);
    let w8 = imageWidth4(item, img);
    let h6 = imageHeight4(item, img);
    if (w8 === 0 || h6 === 0)
      return;
    let x9 = (item.x || 0) - imageXOffset4(item.align, w8), y9 = (item.y || 0) - imageYOffset4(item.baseline, h6), opacity2, ar0, ar1, t;
    if (item.aspect !== false) {
      ar0 = img.width / img.height;
      ar1 = item.width / item.height;
      if (ar0 === ar0 && ar1 === ar1 && ar0 !== ar1) {
        if (ar1 < ar0) {
          t = w8 / ar0;
          y9 += (h6 - t) / 2;
          h6 = t;
        } else {
          t = h6 * ar0;
          x9 += (w8 - t) / 2;
          w8 = t;
        }
      }
    }
    if (img.complete || img.toDataURL) {
      blend4(context7, item);
      context7.globalAlpha = (opacity2 = item.opacity) != null ? opacity2 : 1;
      context7.imageSmoothingEnabled = item.smooth !== false;
      context7.drawImage(img, x9, y9, w8, h6);
    }
  });
}
var image4 = {
  type: "image",
  tag: "image",
  nested: false,
  attr: attr$44,
  bound: bound$44,
  draw: draw$34,
  pick: pick$14(),
  isect: truthy15,
  // bounds check is sufficient
  get: getImage4,
  xOffset: imageXOffset4,
  yOffset: imageYOffset4
};
var line5 = markMultiItemPath4("line", line$14, pickLine4);
function attr$34(emit6, item) {
  var sx = item.scaleX || 1, sy = item.scaleY || 1;
  if (sx !== 1 || sy !== 1) {
    emit6("vector-effect", "non-scaling-stroke");
  }
  emit6("transform", transformItem4(item));
  emit6("d", item.path);
}
function path$14(context7, item) {
  var path7 = item.path;
  if (path7 == null)
    return true;
  var x9 = item.x || 0, y9 = item.y || 0, sx = item.scaleX || 1, sy = item.scaleY || 1, a4 = (item.angle || 0) * DegToRad4, cache2 = item.pathCache;
  if (!cache2 || cache2.path !== path7) {
    (item.pathCache = cache2 = parse8(path7)).path = path7;
  }
  if (a4 && context7.rotate && context7.translate) {
    context7.translate(x9, y9);
    context7.rotate(a4);
    pathRender4(context7, cache2, 0, 0, sx, sy);
    context7.rotate(-a4);
    context7.translate(-x9, -y9);
  } else {
    pathRender4(context7, cache2, x9, y9, sx, sy);
  }
}
function bound$34(bounds6, item) {
  return path$14(boundContext4(bounds6, item.angle), item) ? bounds6.set(0, 0, 0, 0) : boundStroke4(bounds6, item, true);
}
var path$24 = {
  type: "path",
  tag: "path",
  nested: false,
  attr: attr$34,
  bound: bound$34,
  draw: drawAll4(path$14),
  pick: pickPath4(path$14),
  isect: intersectPath4(path$14)
};
function attr$24(emit6, item) {
  emit6("d", rectangle4(null, item));
}
function bound$24(bounds6, item) {
  var x9, y9;
  return boundStroke4(bounds6.set(x9 = item.x || 0, y9 = item.y || 0, x9 + item.width || 0, y9 + item.height || 0), item);
}
function draw$24(context7, item) {
  context7.beginPath();
  rectangle4(context7, item);
}
var rect4 = {
  type: "rect",
  tag: "path",
  nested: false,
  attr: attr$24,
  bound: bound$24,
  draw: drawAll4(draw$24),
  pick: pickPath4(draw$24),
  isect: intersectRect4
};
function attr$14(emit6, item) {
  emit6("transform", translateItem4(item));
  emit6("x2", item.x2 != null ? item.x2 - (item.x || 0) : 0);
  emit6("y2", item.y2 != null ? item.y2 - (item.y || 0) : 0);
}
function bound$14(bounds6, item) {
  var x13, y13;
  return boundStroke4(bounds6.set(x13 = item.x || 0, y13 = item.y || 0, item.x2 != null ? item.x2 : x13, item.y2 != null ? item.y2 : y13), item);
}
function path5(context7, item, opacity2) {
  var x13, y13, x22, y22;
  if (item.stroke && stroke4(context7, item, opacity2)) {
    x13 = item.x || 0;
    y13 = item.y || 0;
    x22 = item.x2 != null ? item.x2 : x13;
    y22 = item.y2 != null ? item.y2 : y13;
    context7.beginPath();
    context7.moveTo(x13, y13);
    context7.lineTo(x22, y22);
    return true;
  }
  return false;
}
function draw$14(context7, scene, bounds6) {
  visit4(scene, (item) => {
    if (bounds6 && !bounds6.intersects(item.bounds))
      return;
    var opacity2 = item.opacity == null ? 1 : item.opacity;
    if (opacity2 && path5(context7, item, opacity2)) {
      blend4(context7, item);
      context7.stroke();
    }
  });
}
function hit$14(context7, item, x9, y9) {
  if (!context7.isPointInStroke)
    return false;
  return path5(context7, item, 1) && context7.isPointInStroke(x9, y9);
}
var rule4 = {
  type: "rule",
  tag: "line",
  nested: false,
  attr: attr$14,
  bound: bound$14,
  draw: draw$14,
  pick: pick$14(hit$14),
  isect: intersectRule4
};
var shape4 = markItemPath4("shape", shape$14);
var symbol4 = markItemPath4("symbol", symbol$14, intersectPoint4);
var widthCache4 = lruCache4();
var textMetrics4 = {
  height: fontSize4,
  measureWidth: measureWidth4,
  estimateWidth: estimateWidth4,
  width: estimateWidth4,
  canvas: useCanvas4
};
useCanvas4(true);
function useCanvas4(use) {
  textMetrics4.width = use && context4 ? measureWidth4 : estimateWidth4;
}
function estimateWidth4(item, text7) {
  return _estimateWidth4(textValue4(item, text7), fontSize4(item));
}
function _estimateWidth4(text7, currentFontHeight) {
  return ~~(0.8 * text7.length * currentFontHeight);
}
function measureWidth4(item, text7) {
  return fontSize4(item) <= 0 || !(text7 = textValue4(item, text7)) ? 0 : _measureWidth4(text7, font4(item));
}
function _measureWidth4(text7, currentFont) {
  const key4 = `(${currentFont}) ${text7}`;
  let width2 = widthCache4.get(key4);
  if (width2 === void 0) {
    context4.font = currentFont;
    width2 = context4.measureText(text7).width;
    widthCache4.set(key4, width2);
  }
  return width2;
}
function fontSize4(item) {
  return item.fontSize != null ? +item.fontSize || 0 : 11;
}
function lineHeight4(item) {
  return item.lineHeight != null ? item.lineHeight : fontSize4(item) + 2;
}
function lineArray4(_) {
  return isArray15(_) ? _.length > 1 ? _ : _[0] : _;
}
function textLines4(item) {
  return lineArray4(item.lineBreak && item.text && !isArray15(item.text) ? item.text.split(item.lineBreak) : item.text);
}
function textValue4(item, line8) {
  const text7 = line8 == null ? "" : (line8 + "").trim();
  return item.limit > 0 && text7.length ? truncate5(item, text7) : text7;
}
function widthGetter4(item) {
  if (textMetrics4.width === measureWidth4) {
    const currentFont = font4(item);
    return (text7) => _measureWidth4(text7, currentFont);
  } else if (textMetrics4.width === estimateWidth4) {
    const currentFontHeight = fontSize4(item);
    return (text7) => _estimateWidth4(text7, currentFontHeight);
  } else {
    return (text7) => textMetrics4.width(item, text7);
  }
}
function truncate5(item, text7) {
  var limit = +item.limit, width2 = widthGetter4(item);
  if (width2(text7) < limit)
    return text7;
  var ellipsis = item.ellipsis || "…", rtl = item.dir === "rtl", lo = 0, hi = text7.length, mid;
  limit -= width2(ellipsis);
  if (rtl) {
    while (lo < hi) {
      mid = lo + hi >>> 1;
      if (width2(text7.slice(mid)) > limit)
        lo = mid + 1;
      else
        hi = mid;
    }
    return ellipsis + text7.slice(lo);
  } else {
    while (lo < hi) {
      mid = 1 + (lo + hi >>> 1);
      if (width2(text7.slice(0, mid)) < limit)
        lo = mid;
      else
        hi = mid - 1;
    }
    return text7.slice(0, lo) + ellipsis;
  }
}
function fontFamily4(item, quote) {
  var font7 = item.font;
  return (quote && font7 ? String(font7).replace(/"/g, "'") : font7) || "sans-serif";
}
function font4(item, quote) {
  return (item.fontStyle ? item.fontStyle + " " : "") + (item.fontVariant ? item.fontVariant + " " : "") + (item.fontWeight ? item.fontWeight + " " : "") + fontSize4(item) + "px " + fontFamily4(item, quote);
}
function offset5(item) {
  var baseline3 = item.baseline, h6 = fontSize4(item);
  return Math.round(baseline3 === "top" ? 0.79 * h6 : baseline3 === "middle" ? 0.3 * h6 : baseline3 === "bottom" ? -0.21 * h6 : baseline3 === "line-top" ? 0.29 * h6 + 0.5 * lineHeight4(item) : baseline3 === "line-bottom" ? 0.29 * h6 - 0.5 * lineHeight4(item) : 0);
}
var textAlign4 = {
  "left": "start",
  "center": "middle",
  "right": "end"
};
var tempBounds5 = new Bounds4();
function anchorPoint4(item) {
  var x9 = item.x || 0, y9 = item.y || 0, r = item.radius || 0, t;
  if (r) {
    t = (item.theta || 0) - HalfPi4;
    x9 += r * Math.cos(t);
    y9 += r * Math.sin(t);
  }
  tempBounds5.x1 = x9;
  tempBounds5.y1 = y9;
  return tempBounds5;
}
function attr4(emit6, item) {
  var dx = item.dx || 0, dy = (item.dy || 0) + offset5(item), p = anchorPoint4(item), x9 = p.x1, y9 = p.y1, a4 = item.angle || 0, t;
  emit6("text-anchor", textAlign4[item.align] || "start");
  if (a4) {
    t = translate5(x9, y9) + " " + rotate4(a4);
    if (dx || dy)
      t += " " + translate5(dx, dy);
  } else {
    t = translate5(x9 + dx, y9 + dy);
  }
  emit6("transform", t);
}
function bound4(bounds6, item, mode2) {
  var h6 = textMetrics4.height(item), a4 = item.align, p = anchorPoint4(item), x9 = p.x1, y9 = p.y1, dx = item.dx || 0, dy = (item.dy || 0) + offset5(item) - Math.round(0.8 * h6), tl6 = textLines4(item), w8;
  if (isArray15(tl6)) {
    h6 += lineHeight4(item) * (tl6.length - 1);
    w8 = tl6.reduce((w9, t) => Math.max(w9, textMetrics4.width(item, t)), 0);
  } else {
    w8 = textMetrics4.width(item, tl6);
  }
  if (a4 === "center") {
    dx -= w8 / 2;
  } else if (a4 === "right") {
    dx -= w8;
  } else
    ;
  bounds6.set(dx += x9, dy += y9, dx + w8, dy + h6);
  if (item.angle && !mode2) {
    bounds6.rotate(item.angle * DegToRad4, x9, y9);
  } else if (mode2 === 2) {
    return bounds6.rotatedPoints(item.angle * DegToRad4, x9, y9);
  }
  return bounds6;
}
function draw5(context7, scene, bounds6) {
  visit4(scene, (item) => {
    var opacity2 = item.opacity == null ? 1 : item.opacity, p, x9, y9, i, lh, tl6, str;
    if (bounds6 && !bounds6.intersects(item.bounds) || // bounds check
    opacity2 === 0 || item.fontSize <= 0 || item.text == null || item.text.length === 0)
      return;
    context7.font = font4(item);
    context7.textAlign = item.align || "left";
    p = anchorPoint4(item);
    x9 = p.x1, y9 = p.y1;
    if (item.angle) {
      context7.save();
      context7.translate(x9, y9);
      context7.rotate(item.angle * DegToRad4);
      x9 = y9 = 0;
    }
    x9 += item.dx || 0;
    y9 += (item.dy || 0) + offset5(item);
    tl6 = textLines4(item);
    blend4(context7, item);
    if (isArray15(tl6)) {
      lh = lineHeight4(item);
      for (i = 0; i < tl6.length; ++i) {
        str = textValue4(item, tl6[i]);
        if (item.fill && fill4(context7, item, opacity2)) {
          context7.fillText(str, x9, y9);
        }
        if (item.stroke && stroke4(context7, item, opacity2)) {
          context7.strokeText(str, x9, y9);
        }
        y9 += lh;
      }
    } else {
      str = textValue4(item, tl6);
      if (item.fill && fill4(context7, item, opacity2)) {
        context7.fillText(str, x9, y9);
      }
      if (item.stroke && stroke4(context7, item, opacity2)) {
        context7.strokeText(str, x9, y9);
      }
    }
    if (item.angle)
      context7.restore();
  });
}
function hit4(context7, item, x9, y9, gx, gy) {
  if (item.fontSize <= 0)
    return false;
  if (!item.angle)
    return true;
  var p = anchorPoint4(item), ax = p.x1, ay = p.y1, b6 = bound4(tempBounds5, item, 1), a4 = -item.angle * DegToRad4, cos4 = Math.cos(a4), sin4 = Math.sin(a4), px6 = cos4 * gx - sin4 * gy + (ax - cos4 * ax + sin4 * ay), py6 = sin4 * gx + cos4 * gy + (ay - sin4 * ax - cos4 * ay);
  return b6.contains(px6, py6);
}
function intersectText4(item, box) {
  const p = bound4(tempBounds5, item, 2);
  return intersectBoxLine4(box, p[0], p[1], p[2], p[3]) || intersectBoxLine4(box, p[0], p[1], p[4], p[5]) || intersectBoxLine4(box, p[4], p[5], p[6], p[7]) || intersectBoxLine4(box, p[2], p[3], p[6], p[7]);
}
var text4 = {
  type: "text",
  tag: "text",
  nested: false,
  attr: attr4,
  bound: bound4,
  draw: draw5,
  pick: pick$14(hit4),
  isect: intersectText4
};
var trail4 = markMultiItemPath4("trail", trail$14, pickTrail4);
var Marks4 = {
  arc: arc5,
  area: area5,
  group: group5,
  image: image4,
  line: line5,
  path: path$24,
  rect: rect4,
  rule: rule4,
  shape: shape4,
  symbol: symbol4,
  text: text4,
  trail: trail4
};
function boundItem3(item, func, opt) {
  var type7 = Marks4[item.mark.marktype], bound6 = func || type7.bound;
  if (type7.nested)
    item = item.mark;
  return bound6(item.bounds || (item.bounds = new Bounds4()), item, opt);
}
var DUMMY2 = {
  mark: null
};
function boundMark2(mark, bounds6, opt) {
  var type7 = Marks4[mark.marktype], bound6 = type7.bound, items = mark.items, hasItems = items && items.length, i, n, item, b6;
  if (type7.nested) {
    if (hasItems) {
      item = items[0];
    } else {
      DUMMY2.mark = mark;
      item = DUMMY2;
    }
    b6 = boundItem3(item, bound6, opt);
    bounds6 = bounds6 && bounds6.union(b6) || b6;
    return bounds6;
  }
  bounds6 = bounds6 || mark.bounds && mark.bounds.clear() || new Bounds4();
  if (hasItems) {
    for (i = 0, n = items.length; i < n; ++i) {
      bounds6.union(boundItem3(items[i], bound6, opt));
    }
  }
  return mark.bounds = bounds6;
}
var keys2 = [
  "marktype",
  "name",
  "role",
  "interactive",
  "clip",
  "items",
  "zindex",
  "x",
  "y",
  "width",
  "height",
  "align",
  "baseline",
  // layout
  "fill",
  "fillOpacity",
  "opacity",
  "blend",
  // fill
  "stroke",
  "strokeOpacity",
  "strokeWidth",
  "strokeCap",
  // stroke
  "strokeDash",
  "strokeDashOffset",
  // stroke dash
  "strokeForeground",
  "strokeOffset",
  // group
  "startAngle",
  "endAngle",
  "innerRadius",
  "outerRadius",
  // arc
  "cornerRadius",
  "padAngle",
  // arc, rect
  "cornerRadiusTopLeft",
  "cornerRadiusTopRight",
  // rect, group
  "cornerRadiusBottomLeft",
  "cornerRadiusBottomRight",
  "interpolate",
  "tension",
  "orient",
  "defined",
  // area, line
  "url",
  "aspect",
  "smooth",
  // image
  "path",
  "scaleX",
  "scaleY",
  // path
  "x2",
  "y2",
  // rule
  "size",
  "shape",
  // symbol
  "text",
  "angle",
  "theta",
  "radius",
  "dir",
  "dx",
  "dy",
  // text
  "ellipsis",
  "limit",
  "lineBreak",
  "lineHeight",
  "font",
  "fontSize",
  "fontWeight",
  "fontStyle",
  "fontVariant",
  // font
  "description",
  "aria",
  "ariaRole",
  "ariaRoleDescription"
  // aria
];
function sceneToJSON2(scene, indent) {
  return JSON.stringify(scene, keys2, indent);
}
function sceneFromJSON2(json7) {
  const scene = typeof json7 === "string" ? JSON.parse(json7) : json7;
  return initialize2(scene);
}
function initialize2(scene) {
  var type7 = scene.marktype, items = scene.items, parent, i, n;
  if (items) {
    for (i = 0, n = items.length; i < n; ++i) {
      parent = type7 ? "mark" : "group";
      items[i][parent] = scene;
      if (items[i].zindex)
        items[i][parent].zdirty = true;
      if ("group" === (type7 || parent))
        initialize2(items[i]);
    }
  }
  if (type7)
    boundMark2(scene);
  return scene;
}
var Scenegraph2 = class {
  constructor(scene) {
    if (arguments.length) {
      this.root = sceneFromJSON2(scene);
    } else {
      this.root = createMark2({
        marktype: "group",
        name: "root",
        role: "frame"
      });
      this.root.items = [new GroupItem4(this.root)];
    }
  }
  toJSON(indent) {
    return sceneToJSON2(this.root, indent || 0);
  }
  mark(markdef, group7, index4) {
    group7 = group7 || this.root.items[0];
    const mark = createMark2(markdef, group7);
    group7.items[index4] = mark;
    if (mark.zindex)
      mark.group.zdirty = true;
    return mark;
  }
};
function createMark2(def6, group7) {
  const mark = {
    bounds: new Bounds4(),
    clip: !!def6.clip,
    group: group7,
    interactive: def6.interactive === false ? false : true,
    items: [],
    marktype: def6.marktype,
    name: def6.name || void 0,
    role: def6.role || void 0,
    zindex: def6.zindex || 0
  };
  if (def6.aria != null) {
    mark.aria = def6.aria;
  }
  if (def6.description) {
    mark.description = def6.description;
  }
  return mark;
}
function domCreate4(doc, tag, ns) {
  if (!doc && typeof document !== "undefined" && document.createElement) {
    doc = document;
  }
  return doc ? ns ? doc.createElementNS(ns, tag) : doc.createElement(tag) : null;
}
function domFind4(el, tag) {
  tag = tag.toLowerCase();
  var nodes = el.childNodes, i = 0, n = nodes.length;
  for (; i < n; ++i)
    if (nodes[i].tagName.toLowerCase() === tag) {
      return nodes[i];
    }
}
function domChild4(el, index4, tag, ns) {
  var a4 = el.childNodes[index4], b6;
  if (!a4 || a4.tagName.toLowerCase() !== tag.toLowerCase()) {
    b6 = a4 || null;
    a4 = domCreate4(el.ownerDocument, tag, ns);
    el.insertBefore(a4, b6);
  }
  return a4;
}
function domClear4(el, index4) {
  var nodes = el.childNodes, curr = nodes.length;
  while (curr > index4)
    el.removeChild(nodes[--curr]);
  return el;
}
function cssClass4(mark) {
  return "mark-" + mark.marktype + (mark.role ? " role-" + mark.role : "") + (mark.name ? " " + mark.name : "");
}
function point16(event2, el) {
  const rect7 = el.getBoundingClientRect();
  return [event2.clientX - rect7.left - (el.clientLeft || 0), event2.clientY - rect7.top - (el.clientTop || 0)];
}
function resolveItem4(item, event2, el, origin) {
  var mark = item && item.mark, mdef, p;
  if (mark && (mdef = Marks4[mark.marktype]).tip) {
    p = point16(event2, el);
    p[0] -= origin[0];
    p[1] -= origin[1];
    while (item = item.mark.group) {
      p[0] -= item.x || 0;
      p[1] -= item.y || 0;
    }
    item = mdef.tip(mark.items, p);
  }
  return item;
}
var Handler4 = class {
  /**
   * Create a new Handler instance.
   * @param {object} [customLoader] - Optional loader instance for
   *   href URL sanitization. If not specified, a standard loader
   *   instance will be generated.
   * @param {function} [customTooltip] - Optional tooltip handler
   *   function for custom tooltip display.
   * @constructor
   */
  constructor(customLoader, customTooltip) {
    this._active = null;
    this._handlers = {};
    this._loader = customLoader || loader5();
    this._tooltip = customTooltip || defaultTooltip4;
  }
  /**
   * Initialize a new Handler instance.
   * @param {DOMElement} el - The containing DOM element for the display.
   * @param {Array<number>} origin - The origin of the display, in pixels.
   *   The coordinate system will be translated to this point.
   * @param {object} [obj] - Optional context object that should serve as
   *   the "this" context for event callbacks.
   * @return {Handler} - This handler instance.
   */
  initialize(el, origin, obj) {
    this._el = el;
    this._obj = obj || null;
    return this.origin(origin);
  }
  /**
   * Returns the parent container element for a visualization.
   * @return {DOMElement} - The containing DOM element.
   */
  element() {
    return this._el;
  }
  /**
   * Returns the scene element (e.g., canvas or SVG) of the visualization
   * Subclasses must override if the first child is not the scene element.
   * @return {DOMElement} - The scene (e.g., canvas or SVG) element.
   */
  canvas() {
    return this._el && this._el.firstChild;
  }
  /**
   * Get / set the origin coordinates of the visualization.
   */
  origin(origin) {
    if (arguments.length) {
      this._origin = origin || [0, 0];
      return this;
    } else {
      return this._origin.slice();
    }
  }
  /**
   * Get / set the scenegraph root.
   */
  scene(scene) {
    if (!arguments.length)
      return this._scene;
    this._scene = scene;
    return this;
  }
  /**
   * Add an event handler. Subclasses should override this method.
   */
  on() {
  }
  /**
   * Remove an event handler. Subclasses should override this method.
   */
  off() {
  }
  /**
   * Utility method for finding the array index of an event handler.
   * @param {Array} h - An array of registered event handlers.
   * @param {string} type - The event type.
   * @param {function} handler - The event handler instance to find.
   * @return {number} - The handler's array index or -1 if not registered.
   */
  _handlerIndex(h6, type7, handler) {
    for (let i = h6 ? h6.length : 0; --i >= 0; ) {
      if (h6[i].type === type7 && (!handler || h6[i].handler === handler)) {
        return i;
      }
    }
    return -1;
  }
  /**
   * Returns an array with registered event handlers.
   * @param {string} [type] - The event type to query. Any annotations
   *   are ignored; for example, for the argument "click.foo", ".foo" will
   *   be ignored and the method returns all "click" handlers. If type is
   *   null or unspecified, this method returns handlers for all types.
   * @return {Array} - A new array containing all registered event handlers.
   */
  handlers(type7) {
    const h6 = this._handlers, a4 = [];
    if (type7) {
      a4.push(...h6[this.eventName(type7)]);
    } else {
      for (const k3 in h6) {
        a4.push(...h6[k3]);
      }
    }
    return a4;
  }
  /**
   * Parses an event name string to return the specific event type.
   * For example, given "click.foo" returns "click"
   * @param {string} name - The input event type string.
   * @return {string} - A string with the event type only.
   */
  eventName(name) {
    const i = name.indexOf(".");
    return i < 0 ? name : name.slice(0, i);
  }
  /**
   * Handle hyperlink navigation in response to an item.href value.
   * @param {Event} event - The event triggering hyperlink navigation.
   * @param {Item} item - The scenegraph item.
   * @param {string} href - The URL to navigate to.
   */
  handleHref(event2, item, href6) {
    this._loader.sanitize(href6, {
      context: "href"
    }).then((opt) => {
      const e3 = new MouseEvent(event2.type, event2), a4 = domCreate4(null, "a");
      for (const name in opt)
        a4.setAttribute(name, opt[name]);
      a4.dispatchEvent(e3);
    }).catch(() => {
    });
  }
  /**
   * Handle tooltip display in response to an item.tooltip value.
   * @param {Event} event - The event triggering tooltip display.
   * @param {Item} item - The scenegraph item.
   * @param {boolean} show - A boolean flag indicating whether
   *   to show or hide a tooltip for the given item.
   */
  handleTooltip(event2, item, show) {
    if (item && item.tooltip != null) {
      item = resolveItem4(item, event2, this.canvas(), this._origin);
      const value7 = show && item && item.tooltip || null;
      this._tooltip.call(this._obj, this, event2, item, value7);
    }
  }
  /**
   * Returns the size of a scenegraph item and its position relative
   * to the viewport.
   * @param {Item} item - The scenegraph item.
   * @return {object} - A bounding box object (compatible with the
   *   DOMRect type) consisting of x, y, width, heigh, top, left,
   *   right, and bottom properties.
   */
  getItemBoundingClientRect(item) {
    const el = this.canvas();
    if (!el)
      return;
    const rect7 = el.getBoundingClientRect(), origin = this._origin, bounds6 = item.bounds, width2 = bounds6.width(), height2 = bounds6.height();
    let x9 = bounds6.x1 + origin[0] + rect7.left, y9 = bounds6.y1 + origin[1] + rect7.top;
    while (item.mark && (item = item.mark.group)) {
      x9 += item.x || 0;
      y9 += item.y || 0;
    }
    return {
      x: x9,
      y: y9,
      width: width2,
      height: height2,
      left: x9,
      top: y9,
      right: x9 + width2,
      bottom: y9 + height2
    };
  }
};
function defaultTooltip4(handler, event2, item, value7) {
  handler.element().setAttribute("title", value7 || "");
}
var Renderer4 = class {
  /**
   * Create a new Renderer instance.
   * @param {object} [loader] - Optional loader instance for
   *   image and href URL sanitization. If not specified, a
   *   standard loader instance will be generated.
   * @constructor
   */
  constructor(loader7) {
    this._el = null;
    this._bgcolor = null;
    this._loader = new ResourceLoader4(loader7);
  }
  /**
   * Initialize a new Renderer instance.
   * @param {DOMElement} el - The containing DOM element for the display.
   * @param {number} width - The coordinate width of the display, in pixels.
   * @param {number} height - The coordinate height of the display, in pixels.
   * @param {Array<number>} origin - The origin of the display, in pixels.
   *   The coordinate system will be translated to this point.
   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
   *   the width and height to determine the final pixel size.
   * @return {Renderer} - This renderer instance.
   */
  initialize(el, width2, height2, origin, scaleFactor) {
    this._el = el;
    return this.resize(width2, height2, origin, scaleFactor);
  }
  /**
   * Returns the parent container element for a visualization.
   * @return {DOMElement} - The containing DOM element.
   */
  element() {
    return this._el;
  }
  /**
   * Returns the scene element (e.g., canvas or SVG) of the visualization
   * Subclasses must override if the first child is not the scene element.
   * @return {DOMElement} - The scene (e.g., canvas or SVG) element.
   */
  canvas() {
    return this._el && this._el.firstChild;
  }
  /**
   * Get / set the background color.
   */
  background(bgcolor) {
    if (arguments.length === 0)
      return this._bgcolor;
    this._bgcolor = bgcolor;
    return this;
  }
  /**
   * Resize the display.
   * @param {number} width - The new coordinate width of the display, in pixels.
   * @param {number} height - The new coordinate height of the display, in pixels.
   * @param {Array<number>} origin - The new origin of the display, in pixels.
   *   The coordinate system will be translated to this point.
   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
   *   the width and height to determine the final pixel size.
   * @return {Renderer} - This renderer instance;
   */
  resize(width2, height2, origin, scaleFactor) {
    this._width = width2;
    this._height = height2;
    this._origin = origin || [0, 0];
    this._scale = scaleFactor || 1;
    return this;
  }
  /**
   * Report a dirty item whose bounds should be redrawn.
   * This base class method does nothing. Subclasses that perform
   * incremental should implement this method.
   * @param {Item} item - The dirty item whose bounds should be redrawn.
   */
  dirty() {
  }
  /**
   * Render an input scenegraph, potentially with a set of dirty items.
   * This method will perform an immediate rendering with available resources.
   * The renderer may also need to perform image loading to perform a complete
   * render. This process can lead to asynchronous re-rendering of the scene
   * after this method returns. To receive notification when rendering is
   * complete, use the renderAsync method instead.
   * @param {object} scene - The root mark of a scenegraph to render.
   * @param {Array} markTypes - Array of the mark types to render.
   *                            If undefined, render all mark types
   * @return {Renderer} - This renderer instance.
   */
  render(scene, markTypes) {
    const r = this;
    r._call = function() {
      r._render(scene, markTypes);
    };
    r._call();
    r._call = null;
    return r;
  }
  /**
   * Internal rendering method. Renderer subclasses should override this
   * method to actually perform rendering.
   * @param {object} scene - The root mark of a scenegraph to render.
   * @param {Array} markTypes - Array of the mark types to render.
   *                            If undefined, render all mark types
   */
  _render() {
  }
  /**
   * Asynchronous rendering method. Similar to render, but returns a Promise
   * that resolves when all rendering is completed. Sometimes a renderer must
   * perform image loading to get a complete rendering. The returned
   * Promise will not resolve until this process completes.
   * @param {object} scene - The root mark of a scenegraph to render.
   * @param {Array} markTypes - Array of the mark types to render.
   *                            If undefined, render all mark types
   * @return {Promise} - A Promise that resolves when rendering is complete.
   */
  renderAsync(scene, markTypes) {
    const r = this.render(scene, markTypes);
    return this._ready ? this._ready.then(() => r) : Promise.resolve(r);
  }
  /**
   * Internal method for asynchronous resource loading.
   * Proxies method calls to the ImageLoader, and tracks loading
   * progress to invoke a re-render once complete.
   * @param {string} method - The method name to invoke on the ImageLoader.
   * @param {string} uri - The URI for the requested resource.
   * @return {Promise} - A Promise that resolves to the requested resource.
   */
  _load(method10, uri) {
    var r = this, p = r._loader[method10](uri);
    if (!r._ready) {
      const call = r._call;
      r._ready = r._loader.ready().then((redraw) => {
        if (redraw)
          call();
        r._ready = null;
      });
    }
    return p;
  }
  /**
   * Sanitize a URL to include as a hyperlink in the rendered scene.
   * This method proxies a call to ImageLoader.sanitizeURL, but also tracks
   * image loading progress and invokes a re-render once complete.
   * @param {string} uri - The URI string to sanitize.
   * @return {Promise} - A Promise that resolves to the sanitized URL.
   */
  sanitizeURL(uri) {
    return this._load("sanitizeURL", uri);
  }
  /**
   * Requests an image to include in the rendered scene.
   * This method proxies a call to ImageLoader.loadImage, but also tracks
   * image loading progress and invokes a re-render once complete.
   * @param {string} uri - The URI string of the image.
   * @return {Promise} - A Promise that resolves to the loaded Image.
   */
  loadImage(uri) {
    return this._load("loadImage", uri);
  }
};
var KeyDownEvent4 = "keydown";
var KeyPressEvent4 = "keypress";
var KeyUpEvent4 = "keyup";
var DragEnterEvent4 = "dragenter";
var DragLeaveEvent4 = "dragleave";
var DragOverEvent4 = "dragover";
var PointerDownEvent4 = "pointerdown";
var PointerUpEvent4 = "pointerup";
var PointerMoveEvent4 = "pointermove";
var PointerOutEvent4 = "pointerout";
var PointerOverEvent4 = "pointerover";
var MouseDownEvent4 = "mousedown";
var MouseUpEvent4 = "mouseup";
var MouseMoveEvent4 = "mousemove";
var MouseOutEvent4 = "mouseout";
var MouseOverEvent4 = "mouseover";
var ClickEvent4 = "click";
var DoubleClickEvent4 = "dblclick";
var WheelEvent4 = "wheel";
var MouseWheelEvent4 = "mousewheel";
var TouchStartEvent4 = "touchstart";
var TouchMoveEvent4 = "touchmove";
var TouchEndEvent4 = "touchend";
var Events4 = [KeyDownEvent4, KeyPressEvent4, KeyUpEvent4, DragEnterEvent4, DragLeaveEvent4, DragOverEvent4, PointerDownEvent4, PointerUpEvent4, PointerMoveEvent4, PointerOutEvent4, PointerOverEvent4, MouseDownEvent4, MouseUpEvent4, MouseMoveEvent4, MouseOutEvent4, MouseOverEvent4, ClickEvent4, DoubleClickEvent4, WheelEvent4, MouseWheelEvent4, TouchStartEvent4, TouchMoveEvent4, TouchEndEvent4];
var TooltipShowEvent4 = PointerMoveEvent4;
var TooltipHideEvent4 = MouseOutEvent4;
var HrefEvent4 = ClickEvent4;
var CanvasHandler4 = class extends Handler4 {
  constructor(loader7, tooltip2) {
    super(loader7, tooltip2);
    this._down = null;
    this._touch = null;
    this._first = true;
    this._events = {};
    this.events = Events4;
    this.pointermove = move4([PointerMoveEvent4, MouseMoveEvent4], [PointerOverEvent4, MouseOverEvent4], [PointerOutEvent4, MouseOutEvent4]);
    this.dragover = move4([DragOverEvent4], [DragEnterEvent4], [DragLeaveEvent4]), this.pointerout = inactive4([PointerOutEvent4, MouseOutEvent4]);
    this.dragleave = inactive4([DragLeaveEvent4]);
  }
  initialize(el, origin, obj) {
    this._canvas = el && domFind4(el, "canvas");
    [ClickEvent4, MouseDownEvent4, PointerDownEvent4, PointerMoveEvent4, PointerOutEvent4, DragLeaveEvent4].forEach((type7) => eventListenerCheck4(this, type7));
    return super.initialize(el, origin, obj);
  }
  // return the backing canvas instance
  canvas() {
    return this._canvas;
  }
  // retrieve the current canvas context
  context() {
    return this._canvas.getContext("2d");
  }
  // to keep old versions of firefox happy
  DOMMouseScroll(evt) {
    this.fire(MouseWheelEvent4, evt);
  }
  pointerdown(evt) {
    this._down = this._active;
    this.fire(PointerDownEvent4, evt);
  }
  mousedown(evt) {
    this._down = this._active;
    this.fire(MouseDownEvent4, evt);
  }
  click(evt) {
    if (this._down === this._active) {
      this.fire(ClickEvent4, evt);
      this._down = null;
    }
  }
  touchstart(evt) {
    this._touch = this.pickEvent(evt.changedTouches[0]);
    if (this._first) {
      this._active = this._touch;
      this._first = false;
    }
    this.fire(TouchStartEvent4, evt, true);
  }
  touchmove(evt) {
    this.fire(TouchMoveEvent4, evt, true);
  }
  touchend(evt) {
    this.fire(TouchEndEvent4, evt, true);
    this._touch = null;
  }
  // fire an event
  fire(type7, evt, touch2) {
    const a4 = touch2 ? this._touch : this._active, h6 = this._handlers[type7];
    evt.vegaType = type7;
    if (type7 === HrefEvent4 && a4 && a4.href) {
      this.handleHref(evt, a4, a4.href);
    } else if (type7 === TooltipShowEvent4 || type7 === TooltipHideEvent4) {
      this.handleTooltip(evt, a4, type7 !== TooltipHideEvent4);
    }
    if (h6) {
      for (let i = 0, len = h6.length; i < len; ++i) {
        h6[i].handler.call(this._obj, evt, a4);
      }
    }
  }
  // add an event handler
  on(type7, handler) {
    const name = this.eventName(type7), h6 = this._handlers, i = this._handlerIndex(h6[name], type7, handler);
    if (i < 0) {
      eventListenerCheck4(this, type7);
      (h6[name] || (h6[name] = [])).push({
        type: type7,
        handler
      });
    }
    return this;
  }
  // remove an event handler
  off(type7, handler) {
    const name = this.eventName(type7), h6 = this._handlers[name], i = this._handlerIndex(h6, type7, handler);
    if (i >= 0) {
      h6.splice(i, 1);
    }
    return this;
  }
  pickEvent(evt) {
    const p = point16(evt, this._canvas), o = this._origin;
    return this.pick(this._scene, p[0], p[1], p[0] - o[0], p[1] - o[1]);
  }
  // find the scenegraph item at the current pointer position
  // x, y -- the absolute x, y pointer coordinates on the canvas element
  // gx, gy -- the relative coordinates within the current group
  pick(scene, x9, y9, gx, gy) {
    const g = this.context(), mark = Marks4[scene.marktype];
    return mark.pick.call(this, g, scene, x9, y9, gx, gy);
  }
};
var eventBundle4 = (type7) => type7 === TouchStartEvent4 || type7 === TouchMoveEvent4 || type7 === TouchEndEvent4 ? [TouchStartEvent4, TouchMoveEvent4, TouchEndEvent4] : [type7];
function eventListenerCheck4(handler, type7) {
  eventBundle4(type7).forEach((_) => addEventListener4(handler, _));
}
function addEventListener4(handler, type7) {
  const canvas = handler.canvas();
  if (canvas && !handler._events[type7]) {
    handler._events[type7] = 1;
    canvas.addEventListener(type7, handler[type7] ? (evt) => handler[type7](evt) : (evt) => handler.fire(type7, evt));
  }
}
function fireAll4(handler, types, event2) {
  types.forEach((type7) => handler.fire(type7, event2));
}
function move4(moveEvents, overEvents, outEvents) {
  return function(evt) {
    const a4 = this._active, p = this.pickEvent(evt);
    if (p === a4) {
      fireAll4(this, moveEvents, evt);
    } else {
      if (!a4 || !a4.exit) {
        fireAll4(this, outEvents, evt);
      }
      this._active = p;
      fireAll4(this, overEvents, evt);
      fireAll4(this, moveEvents, evt);
    }
  };
}
function inactive4(types) {
  return function(evt) {
    fireAll4(this, types, evt);
    this._active = null;
  };
}
function devicePixelRatio4() {
  return typeof window !== "undefined" ? window.devicePixelRatio || 1 : 1;
}
function resize4(canvas, width2, height2, origin, scaleFactor, opt) {
  const inDOM = typeof HTMLElement !== "undefined" && canvas instanceof HTMLElement && canvas.parentNode != null, context7 = canvas.getContext("2d"), ratio = inDOM ? devicePixelRatio4() : scaleFactor;
  canvas.width = width2 * ratio;
  canvas.height = height2 * ratio;
  for (const key4 in opt) {
    context7[key4] = opt[key4];
  }
  if (inDOM && ratio !== 1) {
    canvas.style.width = width2 + "px";
    canvas.style.height = height2 + "px";
  }
  context7.pixelRatio = ratio;
  context7.setTransform(ratio, 0, 0, ratio, ratio * origin[0], ratio * origin[1]);
  return canvas;
}
var CanvasRenderer4 = class extends Renderer4 {
  constructor(loader7) {
    super(loader7);
    this._options = {};
    this._redraw = false;
    this._dirty = new Bounds4();
    this._tempb = new Bounds4();
  }
  initialize(el, width2, height2, origin, scaleFactor, options) {
    this._options = options || {};
    this._canvas = this._options.externalContext ? null : domCanvas6(1, 1, this._options.type);
    if (el && this._canvas) {
      domClear4(el, 0).appendChild(this._canvas);
      this._canvas.setAttribute("class", "marks");
    }
    return super.initialize(el, width2, height2, origin, scaleFactor);
  }
  resize(width2, height2, origin, scaleFactor) {
    super.resize(width2, height2, origin, scaleFactor);
    if (this._canvas) {
      resize4(this._canvas, this._width, this._height, this._origin, this._scale, this._options.context);
    } else {
      const ctx = this._options.externalContext;
      if (!ctx)
        error15("CanvasRenderer is missing a valid canvas or context");
      ctx.scale(this._scale, this._scale);
      ctx.translate(this._origin[0], this._origin[1]);
    }
    this._redraw = true;
    return this;
  }
  canvas() {
    return this._canvas;
  }
  context() {
    return this._options.externalContext || (this._canvas ? this._canvas.getContext("2d") : null);
  }
  dirty(item) {
    const b6 = this._tempb.clear().union(item.bounds);
    let g = item.mark.group;
    while (g) {
      b6.translate(g.x || 0, g.y || 0);
      g = g.mark.group;
    }
    this._dirty.union(b6);
  }
  _render(scene, markTypes) {
    const g = this.context(), o = this._origin, w8 = this._width, h6 = this._height, db = this._dirty, vb = viewBounds4(o, w8, h6);
    g.save();
    const b6 = this._redraw || db.empty() ? (this._redraw = false, vb.expand(1)) : clipToBounds4(g, vb.intersect(db), o);
    this.clear(-o[0], -o[1], w8, h6);
    this.draw(g, scene, b6, markTypes);
    g.restore();
    db.clear();
    return this;
  }
  draw(ctx, scene, bounds6, markTypes) {
    if (scene.marktype !== "group" && markTypes != null && !markTypes.includes(scene.marktype)) {
      return;
    }
    const mark = Marks4[scene.marktype];
    if (scene.clip)
      clip4(ctx, scene);
    mark.draw.call(this, ctx, scene, bounds6, markTypes);
    if (scene.clip)
      ctx.restore();
  }
  clear(x9, y9, w8, h6) {
    const opt = this._options, g = this.context();
    if (opt.type !== "pdf" && !opt.externalContext) {
      g.clearRect(x9, y9, w8, h6);
    }
    if (this._bgcolor != null) {
      g.fillStyle = this._bgcolor;
      g.fillRect(x9, y9, w8, h6);
    }
  }
};
var viewBounds4 = (origin, width2, height2) => new Bounds4().set(0, 0, width2, height2).translate(-origin[0], -origin[1]);
function clipToBounds4(g, b6, origin) {
  b6.expand(1).round();
  if (g.pixelRatio % 1) {
    b6.scale(g.pixelRatio).round().scale(1 / g.pixelRatio);
  }
  b6.translate(-(origin[0] % 1), -(origin[1] % 1));
  g.beginPath();
  g.rect(b6.x1, b6.y1, b6.width(), b6.height());
  g.clip();
  return b6;
}
var SVGHandler4 = class extends Handler4 {
  constructor(loader7, tooltip2) {
    super(loader7, tooltip2);
    const h6 = this;
    h6._hrefHandler = listener4(h6, (evt, item) => {
      if (item && item.href)
        h6.handleHref(evt, item, item.href);
    });
    h6._tooltipHandler = listener4(h6, (evt, item) => {
      h6.handleTooltip(evt, item, evt.type !== TooltipHideEvent4);
    });
  }
  initialize(el, origin, obj) {
    let svg = this._svg;
    if (svg) {
      svg.removeEventListener(HrefEvent4, this._hrefHandler);
      svg.removeEventListener(TooltipShowEvent4, this._tooltipHandler);
      svg.removeEventListener(TooltipHideEvent4, this._tooltipHandler);
    }
    this._svg = svg = el && domFind4(el, "svg");
    if (svg) {
      svg.addEventListener(HrefEvent4, this._hrefHandler);
      svg.addEventListener(TooltipShowEvent4, this._tooltipHandler);
      svg.addEventListener(TooltipHideEvent4, this._tooltipHandler);
    }
    return super.initialize(el, origin, obj);
  }
  canvas() {
    return this._svg;
  }
  // add an event handler
  on(type7, handler) {
    const name = this.eventName(type7), h6 = this._handlers, i = this._handlerIndex(h6[name], type7, handler);
    if (i < 0) {
      const x9 = {
        type: type7,
        handler,
        listener: listener4(this, handler)
      };
      (h6[name] || (h6[name] = [])).push(x9);
      if (this._svg) {
        this._svg.addEventListener(name, x9.listener);
      }
    }
    return this;
  }
  // remove an event handler
  off(type7, handler) {
    const name = this.eventName(type7), h6 = this._handlers[name], i = this._handlerIndex(h6, type7, handler);
    if (i >= 0) {
      if (this._svg) {
        this._svg.removeEventListener(name, h6[i].listener);
      }
      h6.splice(i, 1);
    }
    return this;
  }
};
var listener4 = (context7, handler) => (evt) => {
  let item = evt.target.__data__;
  item = Array.isArray(item) ? item[0] : item;
  evt.vegaType = evt.type;
  handler.call(context7._obj, evt, item);
};
var ARIA_HIDDEN4 = "aria-hidden";
var ARIA_LABEL4 = "aria-label";
var ARIA_ROLE4 = "role";
var ARIA_ROLEDESCRIPTION4 = "aria-roledescription";
var GRAPHICS_OBJECT4 = "graphics-object";
var GRAPHICS_SYMBOL4 = "graphics-symbol";
var bundle4 = (role, roledesc, label) => ({
  [ARIA_ROLE4]: role,
  [ARIA_ROLEDESCRIPTION4]: roledesc,
  [ARIA_LABEL4]: label || void 0
});
var AriaIgnore4 = toSet10(["axis-domain", "axis-grid", "axis-label", "axis-tick", "axis-title", "legend-band", "legend-entry", "legend-gradient", "legend-label", "legend-title", "legend-symbol", "title"]);
var AriaGuides4 = {
  "axis": {
    desc: "axis",
    caption: axisCaption4
  },
  "legend": {
    desc: "legend",
    caption: legendCaption4
  },
  "title-text": {
    desc: "title",
    caption: (item) => `Title text '${titleCaption4(item)}'`
  },
  "title-subtitle": {
    desc: "subtitle",
    caption: (item) => `Subtitle text '${titleCaption4(item)}'`
  }
};
var AriaEncode4 = {
  ariaRole: ARIA_ROLE4,
  ariaRoleDescription: ARIA_ROLEDESCRIPTION4,
  description: ARIA_LABEL4
};
function ariaItemAttributes4(emit6, item) {
  const hide = item.aria === false;
  emit6(ARIA_HIDDEN4, hide || void 0);
  if (hide || item.description == null) {
    for (const prop in AriaEncode4) {
      emit6(AriaEncode4[prop], void 0);
    }
  } else {
    const type7 = item.mark.marktype;
    emit6(ARIA_LABEL4, item.description);
    emit6(ARIA_ROLE4, item.ariaRole || (type7 === "group" ? GRAPHICS_OBJECT4 : GRAPHICS_SYMBOL4));
    emit6(ARIA_ROLEDESCRIPTION4, item.ariaRoleDescription || `${type7} mark`);
  }
}
function ariaMarkAttributes4(mark) {
  return mark.aria === false ? {
    [ARIA_HIDDEN4]: true
  } : AriaIgnore4[mark.role] ? null : AriaGuides4[mark.role] ? ariaGuide4(mark, AriaGuides4[mark.role]) : ariaMark4(mark);
}
function ariaMark4(mark) {
  const type7 = mark.marktype;
  const recurse6 = type7 === "group" || type7 === "text" || mark.items.some((_) => _.description != null && _.aria !== false);
  return bundle4(recurse6 ? GRAPHICS_OBJECT4 : GRAPHICS_SYMBOL4, `${type7} mark container`, mark.description);
}
function ariaGuide4(mark, opt) {
  try {
    const item = mark.items[0], caption = opt.caption || (() => "");
    return bundle4(opt.role || GRAPHICS_SYMBOL4, opt.desc, item.description || caption(item));
  } catch (err) {
    return null;
  }
}
function titleCaption4(item) {
  return array14(item.text).join(" ");
}
function axisCaption4(item) {
  const datum2 = item.datum, orient2 = item.orient, title2 = datum2.title ? extractTitle4(item) : null, ctx = item.context, scale19 = ctx.scales[datum2.scale].value, locale5 = ctx.dataflow.locale(), type7 = scale19.type, xy = orient2 === "left" || orient2 === "right" ? "Y" : "X";
  return `${xy}-axis` + (title2 ? ` titled '${title2}'` : "") + ` for a ${isDiscrete4(type7) ? "discrete" : type7} scale with ${domainCaption4(locale5, scale19, item)}`;
}
function legendCaption4(item) {
  const datum2 = item.datum, title2 = datum2.title ? extractTitle4(item) : null, type7 = `${datum2.type || ""} legend`.trim(), scales10 = datum2.scales, props = Object.keys(scales10), ctx = item.context, scale19 = ctx.scales[scales10[props[0]]].value, locale5 = ctx.dataflow.locale();
  return capitalize4(type7) + (title2 ? ` titled '${title2}'` : "") + ` for ${channelCaption4(props)} with ${domainCaption4(locale5, scale19, item)}`;
}
function extractTitle4(item) {
  try {
    return array14(peek9(item.items).items[0].text).join(" ");
  } catch (err) {
    return null;
  }
}
function channelCaption4(props) {
  props = props.map((p) => p + (p === "fill" || p === "stroke" ? " color" : ""));
  return props.length < 2 ? props[0] : props.slice(0, -1).join(", ") + " and " + peek9(props);
}
function capitalize4(s2) {
  return s2.length ? s2[0].toUpperCase() + s2.slice(1) : s2;
}
var innerText4 = (val) => (val + "").replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
var attrText4 = (val) => innerText4(val).replace(/"/g, "&quot;").replace(/\t/g, "&#x9;").replace(/\n/g, "&#xA;").replace(/\r/g, "&#xD;");
function markup4() {
  let buf = "", outer = "", inner = "";
  const stack2 = [], clear2 = () => outer = inner = "", push = (tag) => {
    if (outer) {
      buf += `${outer}>${inner}`;
      clear2();
    }
    stack2.push(tag);
  }, attr6 = (name, value7) => {
    if (value7 != null)
      outer += ` ${name}="${attrText4(value7)}"`;
    return m3;
  }, m3 = {
    open(tag, ...attrs) {
      push(tag);
      outer = "<" + tag;
      for (const set7 of attrs) {
        for (const key4 in set7)
          attr6(key4, set7[key4]);
      }
      return m3;
    },
    close() {
      const tag = stack2.pop();
      if (outer) {
        buf += outer + (inner ? `>${inner}</${tag}>` : "/>");
      } else {
        buf += `</${tag}>`;
      }
      clear2();
      return m3;
    },
    attr: attr6,
    text: (t) => (inner += innerText4(t), m3),
    toString: () => buf
  };
  return m3;
}
var serializeXML4 = (node) => _serialize4(markup4(), node) + "";
function _serialize4(m3, node) {
  m3.open(node.tagName);
  if (node.hasAttributes()) {
    const attrs = node.attributes, n = attrs.length;
    for (let i = 0; i < n; ++i) {
      m3.attr(attrs[i].name, attrs[i].value);
    }
  }
  if (node.hasChildNodes()) {
    const children3 = node.childNodes;
    for (const child of children3) {
      child.nodeType === 3 ? m3.text(child.nodeValue) : _serialize4(m3, child);
    }
  }
  return m3.close();
}
var stylesAttr4 = {
  fill: "fill",
  fillOpacity: "fill-opacity",
  stroke: "stroke",
  strokeOpacity: "stroke-opacity",
  strokeWidth: "stroke-width",
  strokeCap: "stroke-linecap",
  strokeJoin: "stroke-linejoin",
  strokeDash: "stroke-dasharray",
  strokeDashOffset: "stroke-dashoffset",
  strokeMiterLimit: "stroke-miterlimit",
  opacity: "opacity"
};
var stylesCss4 = {
  blend: "mix-blend-mode"
};
var rootAttributes4 = {
  "fill": "none",
  "stroke-miterlimit": 10
};
var RootIndex4 = 0;
var xmlns4 = "http://www.w3.org/2000/xmlns/";
var svgns4 = metadata4.xmlns;
var SVGRenderer4 = class extends Renderer4 {
  constructor(loader7) {
    super(loader7);
    this._dirtyID = 0;
    this._dirty = [];
    this._svg = null;
    this._root = null;
    this._defs = null;
  }
  /**
   * Initialize a new SVGRenderer instance.
   * @param {DOMElement} el - The containing DOM element for the display.
   * @param {number} width - The coordinate width of the display, in pixels.
   * @param {number} height - The coordinate height of the display, in pixels.
   * @param {Array<number>} origin - The origin of the display, in pixels.
   *   The coordinate system will be translated to this point.
   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
   *   the width and height to determine the final pixel size.
   * @return {SVGRenderer} - This renderer instance.
   */
  initialize(el, width2, height2, origin, scaleFactor) {
    this._defs = {};
    this._clearDefs();
    if (el) {
      this._svg = domChild4(el, 0, "svg", svgns4);
      this._svg.setAttributeNS(xmlns4, "xmlns", svgns4);
      this._svg.setAttributeNS(xmlns4, "xmlns:xlink", metadata4["xmlns:xlink"]);
      this._svg.setAttribute("version", metadata4["version"]);
      this._svg.setAttribute("class", "marks");
      domClear4(el, 1);
      this._root = domChild4(this._svg, RootIndex4, "g", svgns4);
      setAttributes4(this._root, rootAttributes4);
      domClear4(this._svg, RootIndex4 + 1);
    }
    this.background(this._bgcolor);
    return super.initialize(el, width2, height2, origin, scaleFactor);
  }
  /**
   * Get / set the background color.
   */
  background(bgcolor) {
    if (arguments.length && this._svg) {
      this._svg.style.setProperty("background-color", bgcolor);
    }
    return super.background(...arguments);
  }
  /**
   * Resize the display.
   * @param {number} width - The new coordinate width of the display, in pixels.
   * @param {number} height - The new coordinate height of the display, in pixels.
   * @param {Array<number>} origin - The new origin of the display, in pixels.
   *   The coordinate system will be translated to this point.
   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
   *   the width and height to determine the final pixel size.
   * @return {SVGRenderer} - This renderer instance;
   */
  resize(width2, height2, origin, scaleFactor) {
    super.resize(width2, height2, origin, scaleFactor);
    if (this._svg) {
      setAttributes4(this._svg, {
        width: this._width * this._scale,
        height: this._height * this._scale,
        viewBox: `0 0 ${this._width} ${this._height}`
      });
      this._root.setAttribute("transform", `translate(${this._origin})`);
    }
    this._dirty = [];
    return this;
  }
  /**
   * Returns the SVG element of the visualization.
   * @return {DOMElement} - The SVG element.
   */
  canvas() {
    return this._svg;
  }
  /**
   * Returns an SVG text string for the rendered content,
   * or null if this renderer is currently headless.
   */
  svg() {
    const svg = this._svg, bg = this._bgcolor;
    if (!svg)
      return null;
    let node;
    if (bg) {
      svg.removeAttribute("style");
      node = domChild4(svg, RootIndex4, "rect", svgns4);
      setAttributes4(node, {
        width: this._width,
        height: this._height,
        fill: bg
      });
    }
    const text7 = serializeXML4(svg);
    if (bg) {
      svg.removeChild(node);
      this._svg.style.setProperty("background-color", bg);
    }
    return text7;
  }
  /**
   * Internal rendering method.
   * @param {object} scene - The root mark of a scenegraph to render.
   * @param {Array} markTypes - Array of the mark types to render.
   *                            If undefined, render all mark types
   */
  _render(scene, markTypes) {
    if (this._dirtyCheck()) {
      if (this._dirtyAll)
        this._clearDefs();
      this.mark(this._root, scene, void 0, markTypes);
      domClear4(this._root, 1);
    }
    this.defs();
    this._dirty = [];
    ++this._dirtyID;
    return this;
  }
  // -- Manage rendering of items marked as dirty --
  /**
   * Flag a mark item as dirty.
   * @param {Item} item - The mark item.
   */
  dirty(item) {
    if (item.dirty !== this._dirtyID) {
      item.dirty = this._dirtyID;
      this._dirty.push(item);
    }
  }
  /**
   * Check if a mark item is considered dirty.
   * @param {Item} item - The mark item.
   */
  isDirty(item) {
    return this._dirtyAll || !item._svg || !item._svg.ownerSVGElement || item.dirty === this._dirtyID;
  }
  /**
   * Internal method to check dirty status and, if possible,
   * make targetted updates without a full rendering pass.
   */
  _dirtyCheck() {
    this._dirtyAll = true;
    const items = this._dirty;
    if (!items.length || !this._dirtyID)
      return true;
    const id24 = ++this._dirtyID;
    let item, mark, type7, mdef, i, n, o;
    for (i = 0, n = items.length; i < n; ++i) {
      item = items[i];
      mark = item.mark;
      if (mark.marktype !== type7) {
        type7 = mark.marktype;
        mdef = Marks4[type7];
      }
      if (mark.zdirty && mark.dirty !== id24) {
        this._dirtyAll = false;
        dirtyParents4(item, id24);
        mark.items.forEach((i2) => {
          i2.dirty = id24;
        });
      }
      if (mark.zdirty)
        continue;
      if (item.exit) {
        if (mdef.nested && mark.items.length) {
          o = mark.items[0];
          if (o._svg)
            this._update(mdef, o._svg, o);
        } else if (item._svg) {
          o = item._svg.parentNode;
          if (o)
            o.removeChild(item._svg);
        }
        item._svg = null;
        continue;
      }
      item = mdef.nested ? mark.items[0] : item;
      if (item._update === id24)
        continue;
      if (!item._svg || !item._svg.ownerSVGElement) {
        this._dirtyAll = false;
        dirtyParents4(item, id24);
      } else {
        this._update(mdef, item._svg, item);
      }
      item._update = id24;
    }
    return !this._dirtyAll;
  }
  // -- Construct & maintain scenegraph to SVG mapping ---
  /**
   * Render a set of mark items.
   * @param {SVGElement} el - The parent element in the SVG tree.
   * @param {object} scene - The mark parent to render.
   * @param {SVGElement} prev - The previous sibling in the SVG tree.
   * @param {Array} markTypes - Array of the mark types to render.
   *                            If undefined, render all mark types
   */
  mark(el, scene, prev, markTypes) {
    if (!this.isDirty(scene)) {
      return scene._svg;
    }
    const svg = this._svg, markType2 = scene.marktype, mdef = Marks4[markType2], events3 = scene.interactive === false ? "none" : null, isGroup = mdef.tag === "g";
    const parent = bind4(scene, el, prev, "g", svg);
    if (markType2 !== "group" && markTypes != null && !markTypes.includes(markType2)) {
      domClear4(parent, 0);
      return scene._svg;
    }
    parent.setAttribute("class", cssClass4(scene));
    const aria2 = ariaMarkAttributes4(scene);
    for (const key4 in aria2)
      setAttribute4(parent, key4, aria2[key4]);
    if (!isGroup) {
      setAttribute4(parent, "pointer-events", events3);
    }
    setAttribute4(parent, "clip-path", scene.clip ? clip$14(this, scene, scene.group) : null);
    let sibling = null, i = 0;
    const process2 = (item) => {
      const dirty = this.isDirty(item), node = bind4(item, parent, sibling, mdef.tag, svg);
      if (dirty) {
        this._update(mdef, node, item);
        if (isGroup)
          recurse4(this, node, item, markTypes);
      }
      sibling = node;
      ++i;
    };
    if (mdef.nested) {
      if (scene.items.length)
        process2(scene.items[0]);
    } else {
      visit4(scene, process2);
    }
    domClear4(parent, i);
    return parent;
  }
  /**
   * Update the attributes of an SVG element for a mark item.
   * @param {object} mdef - The mark definition object
   * @param {SVGElement} el - The SVG element.
   * @param {Item} item - The mark item.
   */
  _update(mdef, el, item) {
    element4 = el;
    values4 = el.__values__;
    ariaItemAttributes4(emit4, item);
    mdef.attr(emit4, item, this);
    const extra = mark_extras4[mdef.type];
    if (extra)
      extra.call(this, mdef, el, item);
    if (element4)
      this.style(element4, item);
  }
  /**
   * Update the presentation attributes of an SVG element for a mark item.
   * @param {SVGElement} el - The SVG element.
   * @param {Item} item - The mark item.
   */
  style(el, item) {
    if (item == null)
      return;
    for (const prop in stylesAttr4) {
      let value7 = prop === "font" ? fontFamily4(item) : item[prop];
      if (value7 === values4[prop])
        continue;
      const name = stylesAttr4[prop];
      if (value7 == null) {
        el.removeAttribute(name);
      } else {
        if (isGradient4(value7)) {
          value7 = gradientRef4(value7, this._defs.gradient, href4());
        }
        el.setAttribute(name, value7 + "");
      }
      values4[prop] = value7;
    }
    for (const prop in stylesCss4) {
      setStyle4(el, stylesCss4[prop], item[prop]);
    }
  }
  /**
   * Render SVG defs, as needed.
   * Must be called *after* marks have been processed to ensure the
   * collected state is current and accurate.
   */
  defs() {
    const svg = this._svg, defs = this._defs;
    let el = defs.el, index4 = 0;
    for (const id24 in defs.gradient) {
      if (!el)
        defs.el = el = domChild4(svg, RootIndex4 + 1, "defs", svgns4);
      index4 = updateGradient4(el, defs.gradient[id24], index4);
    }
    for (const id24 in defs.clipping) {
      if (!el)
        defs.el = el = domChild4(svg, RootIndex4 + 1, "defs", svgns4);
      index4 = updateClipping4(el, defs.clipping[id24], index4);
    }
    if (el) {
      index4 === 0 ? (svg.removeChild(el), defs.el = null) : domClear4(el, index4);
    }
  }
  /**
   * Clear defs caches.
   */
  _clearDefs() {
    const def6 = this._defs;
    def6.gradient = {};
    def6.clipping = {};
  }
};
function dirtyParents4(item, id24) {
  for (; item && item.dirty !== id24; item = item.mark.group) {
    item.dirty = id24;
    if (item.mark && item.mark.dirty !== id24) {
      item.mark.dirty = id24;
    } else
      return;
  }
}
function updateGradient4(el, grad, index4) {
  let i, n, stop2;
  if (grad.gradient === "radial") {
    let pt = domChild4(el, index4++, "pattern", svgns4);
    setAttributes4(pt, {
      id: patternPrefix4 + grad.id,
      viewBox: "0,0,1,1",
      width: "100%",
      height: "100%",
      preserveAspectRatio: "xMidYMid slice"
    });
    pt = domChild4(pt, 0, "rect", svgns4);
    setAttributes4(pt, {
      width: 1,
      height: 1,
      fill: `url(${href4()}#${grad.id})`
    });
    el = domChild4(el, index4++, "radialGradient", svgns4);
    setAttributes4(el, {
      id: grad.id,
      fx: grad.x1,
      fy: grad.y1,
      fr: grad.r1,
      cx: grad.x2,
      cy: grad.y2,
      r: grad.r2
    });
  } else {
    el = domChild4(el, index4++, "linearGradient", svgns4);
    setAttributes4(el, {
      id: grad.id,
      x1: grad.x1,
      x2: grad.x2,
      y1: grad.y1,
      y2: grad.y2
    });
  }
  for (i = 0, n = grad.stops.length; i < n; ++i) {
    stop2 = domChild4(el, i, "stop", svgns4);
    stop2.setAttribute("offset", grad.stops[i].offset);
    stop2.setAttribute("stop-color", grad.stops[i].color);
  }
  domClear4(el, i);
  return index4;
}
function updateClipping4(el, clip7, index4) {
  let mask;
  el = domChild4(el, index4, "clipPath", svgns4);
  el.setAttribute("id", clip7.id);
  if (clip7.path) {
    mask = domChild4(el, 0, "path", svgns4);
    mask.setAttribute("d", clip7.path);
  } else {
    mask = domChild4(el, 0, "rect", svgns4);
    setAttributes4(mask, {
      x: 0,
      y: 0,
      width: clip7.width,
      height: clip7.height
    });
  }
  domClear4(el, 1);
  return index4 + 1;
}
function recurse4(renderer, el, group7, markTypes) {
  el = el.lastChild.previousSibling;
  let prev, idx = 0;
  visit4(group7, (item) => {
    prev = renderer.mark(el, item, prev, markTypes);
    ++idx;
  });
  domClear4(el, 1 + idx);
}
function bind4(item, el, sibling, tag, svg) {
  let node = item._svg, doc;
  if (!node) {
    doc = el.ownerDocument;
    node = domCreate4(doc, tag, svgns4);
    item._svg = node;
    if (item.mark) {
      node.__data__ = item;
      node.__values__ = {
        fill: "default"
      };
      if (tag === "g") {
        const bg = domCreate4(doc, "path", svgns4);
        node.appendChild(bg);
        bg.__data__ = item;
        const cg = domCreate4(doc, "g", svgns4);
        node.appendChild(cg);
        cg.__data__ = item;
        const fg = domCreate4(doc, "path", svgns4);
        node.appendChild(fg);
        fg.__data__ = item;
        fg.__values__ = {
          fill: "default"
        };
      }
    }
  }
  if (node.ownerSVGElement !== svg || siblingCheck4(node, sibling)) {
    el.insertBefore(node, sibling ? sibling.nextSibling : el.firstChild);
  }
  return node;
}
function siblingCheck4(node, sibling) {
  return node.parentNode && node.parentNode.childNodes.length > 1 && node.previousSibling != sibling;
}
var element4 = null;
var values4 = null;
var mark_extras4 = {
  group(mdef, el, item) {
    const fg = element4 = el.childNodes[2];
    values4 = fg.__values__;
    mdef.foreground(emit4, item, this);
    values4 = el.__values__;
    element4 = el.childNodes[1];
    mdef.content(emit4, item, this);
    const bg = element4 = el.childNodes[0];
    mdef.background(emit4, item, this);
    const value7 = item.mark.interactive === false ? "none" : null;
    if (value7 !== values4.events) {
      setAttribute4(fg, "pointer-events", value7);
      setAttribute4(bg, "pointer-events", value7);
      values4.events = value7;
    }
    if (item.strokeForeground && item.stroke) {
      const fill6 = item.fill;
      setAttribute4(fg, "display", null);
      this.style(bg, item);
      setAttribute4(bg, "stroke", null);
      if (fill6)
        item.fill = null;
      values4 = fg.__values__;
      this.style(fg, item);
      if (fill6)
        item.fill = fill6;
      element4 = null;
    } else {
      setAttribute4(fg, "display", "none");
    }
  },
  image(mdef, el, item) {
    if (item.smooth === false) {
      setStyle4(el, "image-rendering", "optimizeSpeed");
      setStyle4(el, "image-rendering", "pixelated");
    } else {
      setStyle4(el, "image-rendering", null);
    }
  },
  text(mdef, el, item) {
    const tl6 = textLines4(item);
    let key4, value7, doc, lh;
    if (isArray15(tl6)) {
      value7 = tl6.map((_) => textValue4(item, _));
      key4 = value7.join("\n");
      if (key4 !== values4.text) {
        domClear4(el, 0);
        doc = el.ownerDocument;
        lh = lineHeight4(item);
        value7.forEach((t, i) => {
          const ts6 = domCreate4(doc, "tspan", svgns4);
          ts6.__data__ = item;
          ts6.textContent = t;
          if (i) {
            ts6.setAttribute("x", 0);
            ts6.setAttribute("dy", lh);
          }
          el.appendChild(ts6);
        });
        values4.text = key4;
      }
    } else {
      value7 = textValue4(item, tl6);
      if (value7 !== values4.text) {
        el.textContent = value7;
        values4.text = value7;
      }
    }
    setAttribute4(el, "font-family", fontFamily4(item));
    setAttribute4(el, "font-size", fontSize4(item) + "px");
    setAttribute4(el, "font-style", item.fontStyle);
    setAttribute4(el, "font-variant", item.fontVariant);
    setAttribute4(el, "font-weight", item.fontWeight);
  }
};
function emit4(name, value7, ns) {
  if (value7 === values4[name])
    return;
  if (ns) {
    setAttributeNS4(element4, name, value7, ns);
  } else {
    setAttribute4(element4, name, value7);
  }
  values4[name] = value7;
}
function setStyle4(el, name, value7) {
  if (value7 !== values4[name]) {
    if (value7 == null) {
      el.style.removeProperty(name);
    } else {
      el.style.setProperty(name, value7 + "");
    }
    values4[name] = value7;
  }
}
function setAttributes4(el, attrs) {
  for (const key4 in attrs) {
    setAttribute4(el, key4, attrs[key4]);
  }
}
function setAttribute4(el, name, value7) {
  if (value7 != null) {
    el.setAttribute(name, value7);
  } else {
    el.removeAttribute(name);
  }
}
function setAttributeNS4(el, name, value7, ns) {
  if (value7 != null) {
    el.setAttributeNS(ns, name, value7);
  } else {
    el.removeAttributeNS(ns, name);
  }
}
function href4() {
  let loc;
  return typeof window === "undefined" ? "" : (loc = window.location).hash ? loc.href.slice(0, -loc.hash.length) : loc.href;
}
var SVGStringRenderer4 = class extends Renderer4 {
  constructor(loader7) {
    super(loader7);
    this._text = null;
    this._defs = {
      gradient: {},
      clipping: {}
    };
  }
  /**
   * Returns the rendered SVG text string,
   * or null if rendering has not yet occurred.
   */
  svg() {
    return this._text;
  }
  /**
   * Internal rendering method.
   * @param {object} scene - The root mark of a scenegraph to render.
   */
  _render(scene) {
    const m3 = markup4();
    m3.open("svg", extend16({}, metadata4, {
      class: "marks",
      width: this._width * this._scale,
      height: this._height * this._scale,
      viewBox: `0 0 ${this._width} ${this._height}`
    }));
    const bg = this._bgcolor;
    if (bg && bg !== "transparent" && bg !== "none") {
      m3.open("rect", {
        width: this._width,
        height: this._height,
        fill: bg
      }).close();
    }
    m3.open("g", rootAttributes4, {
      transform: "translate(" + this._origin + ")"
    });
    this.mark(m3, scene);
    m3.close();
    this.defs(m3);
    this._text = m3.close() + "";
    return this;
  }
  /**
   * Render a set of mark items.
   * @param {object} m - The markup context.
   * @param {object} scene - The mark parent to render.
   */
  mark(m3, scene) {
    const mdef = Marks4[scene.marktype], tag = mdef.tag, attrList = [ariaItemAttributes4, mdef.attr];
    m3.open("g", {
      "class": cssClass4(scene),
      "clip-path": scene.clip ? clip$14(this, scene, scene.group) : null
    }, ariaMarkAttributes4(scene), {
      "pointer-events": tag !== "g" && scene.interactive === false ? "none" : null
    });
    const process2 = (item) => {
      const href6 = this.href(item);
      if (href6)
        m3.open("a", href6);
      m3.open(tag, this.attr(scene, item, attrList, tag !== "g" ? tag : null));
      if (tag === "text") {
        const tl6 = textLines4(item);
        if (isArray15(tl6)) {
          const attrs = {
            x: 0,
            dy: lineHeight4(item)
          };
          for (let i = 0; i < tl6.length; ++i) {
            m3.open("tspan", i ? attrs : null).text(textValue4(item, tl6[i])).close();
          }
        } else {
          m3.text(textValue4(item, tl6));
        }
      } else if (tag === "g") {
        const fore = item.strokeForeground, fill6 = item.fill, stroke6 = item.stroke;
        if (fore && stroke6) {
          item.stroke = null;
        }
        m3.open("path", this.attr(scene, item, mdef.background, "bgrect")).close();
        m3.open("g", this.attr(scene, item, mdef.content));
        visit4(item, (scene2) => this.mark(m3, scene2));
        m3.close();
        if (fore && stroke6) {
          if (fill6)
            item.fill = null;
          item.stroke = stroke6;
          m3.open("path", this.attr(scene, item, mdef.foreground, "bgrect")).close();
          if (fill6)
            item.fill = fill6;
        } else {
          m3.open("path", this.attr(scene, item, mdef.foreground, "bgfore")).close();
        }
      }
      m3.close();
      if (href6)
        m3.close();
    };
    if (mdef.nested) {
      if (scene.items && scene.items.length)
        process2(scene.items[0]);
    } else {
      visit4(scene, process2);
    }
    return m3.close();
  }
  /**
   * Get href attributes for a hyperlinked mark item.
   * @param {Item} item - The mark item.
   */
  href(item) {
    const href6 = item.href;
    let attr6;
    if (href6) {
      if (attr6 = this._hrefs && this._hrefs[href6]) {
        return attr6;
      } else {
        this.sanitizeURL(href6).then((attr7) => {
          attr7["xlink:href"] = attr7.href;
          attr7.href = null;
          (this._hrefs || (this._hrefs = {}))[href6] = attr7;
        });
      }
    }
    return null;
  }
  /**
   * Get an object of SVG attributes for a mark item.
   * @param {object} scene - The mark parent.
   * @param {Item} item - The mark item.
   * @param {array|function} attrs - One or more attribute emitters.
   * @param {string} tag - The tag being rendered.
   */
  attr(scene, item, attrs, tag) {
    const object2 = {}, emit6 = (name, value7, ns, prefixed) => {
      object2[prefixed || name] = value7;
    };
    if (Array.isArray(attrs)) {
      attrs.forEach((fn) => fn(emit6, item, this));
    } else {
      attrs(emit6, item, this);
    }
    if (tag) {
      style4(object2, item, scene, tag, this._defs);
    }
    return object2;
  }
  /**
   * Render SVG defs, as needed.
   * Must be called *after* marks have been processed to ensure the
   * collected state is current and accurate.
   * @param {object} m - The markup context.
   */
  defs(m3) {
    const gradient8 = this._defs.gradient, clipping = this._defs.clipping, count3 = Object.keys(gradient8).length + Object.keys(clipping).length;
    if (count3 === 0)
      return;
    m3.open("defs");
    for (const id24 in gradient8) {
      const def6 = gradient8[id24], stops = def6.stops;
      if (def6.gradient === "radial") {
        m3.open("pattern", {
          id: patternPrefix4 + id24,
          viewBox: "0,0,1,1",
          width: "100%",
          height: "100%",
          preserveAspectRatio: "xMidYMid slice"
        });
        m3.open("rect", {
          width: "1",
          height: "1",
          fill: "url(#" + id24 + ")"
        }).close();
        m3.close();
        m3.open("radialGradient", {
          id: id24,
          fx: def6.x1,
          fy: def6.y1,
          fr: def6.r1,
          cx: def6.x2,
          cy: def6.y2,
          r: def6.r2
        });
      } else {
        m3.open("linearGradient", {
          id: id24,
          x1: def6.x1,
          x2: def6.x2,
          y1: def6.y1,
          y2: def6.y2
        });
      }
      for (let i = 0; i < stops.length; ++i) {
        m3.open("stop", {
          offset: stops[i].offset,
          "stop-color": stops[i].color
        }).close();
      }
      m3.close();
    }
    for (const id24 in clipping) {
      const def6 = clipping[id24];
      m3.open("clipPath", {
        id: id24
      });
      if (def6.path) {
        m3.open("path", {
          d: def6.path
        }).close();
      } else {
        m3.open("rect", {
          x: 0,
          y: 0,
          width: def6.width,
          height: def6.height
        }).close();
      }
      m3.close();
    }
    m3.close();
  }
};
function style4(s2, item, scene, tag, defs) {
  let styleList;
  if (item == null)
    return s2;
  if (tag === "bgrect" && scene.interactive === false) {
    s2["pointer-events"] = "none";
  }
  if (tag === "bgfore") {
    if (scene.interactive === false) {
      s2["pointer-events"] = "none";
    }
    s2.display = "none";
    if (item.fill !== null)
      return s2;
  }
  if (tag === "image" && item.smooth === false) {
    styleList = ["image-rendering: optimizeSpeed;", "image-rendering: pixelated;"];
  }
  if (tag === "text") {
    s2["font-family"] = fontFamily4(item);
    s2["font-size"] = fontSize4(item) + "px";
    s2["font-style"] = item.fontStyle;
    s2["font-variant"] = item.fontVariant;
    s2["font-weight"] = item.fontWeight;
  }
  for (const prop in stylesAttr4) {
    let value7 = item[prop];
    const name = stylesAttr4[prop];
    if (value7 === "transparent" && (name === "fill" || name === "stroke"))
      ;
    else if (value7 != null) {
      if (isGradient4(value7)) {
        value7 = gradientRef4(value7, defs.gradient, "");
      }
      s2[name] = value7;
    }
  }
  for (const prop in stylesCss4) {
    const value7 = item[prop];
    if (value7 != null) {
      styleList = styleList || [];
      styleList.push(`${stylesCss4[prop]}: ${value7};`);
    }
  }
  if (styleList) {
    s2.style = styleList.join(" ");
  }
  return s2;
}
var OPTS4 = {
  svgMarkTypes: ["text"],
  svgOnTop: true,
  debug: false
};
var HybridRenderer4 = class extends Renderer4 {
  constructor(loader7) {
    super(loader7);
    this._svgRenderer = new SVGRenderer4(loader7);
    this._canvasRenderer = new CanvasRenderer4(loader7);
  }
  /**
   * Initialize a new HybridRenderer instance.
   * @param {DOMElement} el - The containing DOM element for the display.
   * @param {number} width - The coordinate width of the display, in pixels.
   * @param {number} height - The coordinate height of the display, in pixels.
   * @param {Array<number>} origin - The origin of the display, in pixels.
   *   The coordinate system will be translated to this point.
   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
   *   the width and height to determine the final pixel size.
   * @return {HybridRenderer} - This renderer instance.
   */
  initialize(el, width2, height2, origin, scaleFactor) {
    this._root_el = domChild4(el, 0, "div");
    const bottomEl = domChild4(this._root_el, 0, "div");
    const topEl = domChild4(this._root_el, 1, "div");
    this._root_el.style.position = "relative";
    if (!OPTS4.debug) {
      bottomEl.style.height = "100%";
      topEl.style.position = "absolute";
      topEl.style.top = "0";
      topEl.style.left = "0";
      topEl.style.height = "100%";
      topEl.style.width = "100%";
    }
    this._svgEl = OPTS4.svgOnTop ? topEl : bottomEl;
    this._canvasEl = OPTS4.svgOnTop ? bottomEl : topEl;
    this._svgEl.style.pointerEvents = "none";
    this._canvasRenderer.initialize(this._canvasEl, width2, height2, origin, scaleFactor);
    this._svgRenderer.initialize(this._svgEl, width2, height2, origin, scaleFactor);
    return super.initialize(el, width2, height2, origin, scaleFactor);
  }
  /**
   * Flag a mark item as dirty.
   * @param {Item} item - The mark item.
   */
  dirty(item) {
    if (OPTS4.svgMarkTypes.includes(item.mark.marktype)) {
      this._svgRenderer.dirty(item);
    } else {
      this._canvasRenderer.dirty(item);
    }
    return this;
  }
  /**
   * Internal rendering method.
   * @param {object} scene - The root mark of a scenegraph to render.
   * @param {Array} markTypes - Array of the mark types to render.
   *                            If undefined, render all mark types
   */
  _render(scene, markTypes) {
    const allMarkTypes = markTypes ?? ["arc", "area", "image", "line", "path", "rect", "rule", "shape", "symbol", "text", "trail"];
    const canvasMarkTypes = allMarkTypes.filter((m3) => !OPTS4.svgMarkTypes.includes(m3));
    this._svgRenderer.render(scene, OPTS4.svgMarkTypes);
    this._canvasRenderer.render(scene, canvasMarkTypes);
  }
  /**
   * Resize the display.
   * @param {number} width - The new coordinate width of the display, in pixels.
   * @param {number} height - The new coordinate height of the display, in pixels.
   * @param {Array<number>} origin - The new origin of the display, in pixels.
   *   The coordinate system will be translated to this point.
   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
   *   the width and height to determine the final pixel size.
   * @return {SVGRenderer} - This renderer instance;
   */
  resize(width2, height2, origin, scaleFactor) {
    super.resize(width2, height2, origin, scaleFactor);
    this._svgRenderer.resize(width2, height2, origin, scaleFactor);
    this._canvasRenderer.resize(width2, height2, origin, scaleFactor);
    return this;
  }
  background(bgcolor) {
    if (OPTS4.svgOnTop) {
      this._canvasRenderer.background(bgcolor);
    } else {
      this._svgRenderer.background(bgcolor);
    }
    return this;
  }
};
var HybridHandler4 = class extends CanvasHandler4 {
  constructor(loader7, tooltip2) {
    super(loader7, tooltip2);
  }
  initialize(el, origin, obj) {
    const canvas = domChild4(domChild4(el, 0, "div"), OPTS4.svgOnTop ? 0 : 1, "div");
    return super.initialize(canvas, origin, obj);
  }
};
var Canvas4 = "canvas";
var Hybrid4 = "hybrid";
var PNG4 = "png";
var SVG4 = "svg";
var None7 = "none";
var RenderType2 = {
  Canvas: Canvas4,
  PNG: PNG4,
  SVG: SVG4,
  Hybrid: Hybrid4,
  None: None7
};
var modules4 = {};
modules4[Canvas4] = modules4[PNG4] = {
  renderer: CanvasRenderer4,
  headless: CanvasRenderer4,
  handler: CanvasHandler4
};
modules4[SVG4] = {
  renderer: SVGRenderer4,
  headless: SVGStringRenderer4,
  handler: SVGHandler4
};
modules4[Hybrid4] = {
  renderer: HybridRenderer4,
  headless: HybridRenderer4,
  handler: HybridHandler4
};
modules4[None7] = {};
function renderModule2(name, _) {
  name = String(name || "").toLowerCase();
  if (arguments.length > 1) {
    modules4[name] = _;
    return this;
  } else {
    return modules4[name];
  }
}
var clipBounds4 = new Bounds4();

// node_modules/vega-functions/node_modules/vega-util/build/vega-util.js
function accessor16(fn, fields, name) {
  fn.fields = fields || [];
  fn.fname = name;
  return fn;
}
function getter16(path7) {
  return path7.length === 1 ? get116(path7[0]) : getN16(path7);
}
var get116 = (field25) => function(obj) {
  return obj[field25];
};
var getN16 = (path7) => {
  const len = path7.length;
  return function(obj) {
    for (let i = 0; i < len; ++i) {
      obj = obj[path7[i]];
    }
    return obj;
  };
};
function error16(message) {
  throw Error(message);
}
function splitAccessPath16(p) {
  const path7 = [], n = p.length;
  let q = null, b6 = 0, s2 = "", i, j, c5;
  p = p + "";
  function push() {
    path7.push(s2 + p.substring(i, j));
    s2 = "";
    i = j + 1;
  }
  for (i = j = 0; j < n; ++j) {
    c5 = p[j];
    if (c5 === "\\") {
      s2 += p.substring(i, j++);
      i = j;
    } else if (c5 === q) {
      push();
      q = null;
      b6 = -1;
    } else if (q) {
      continue;
    } else if (i === b6 && c5 === '"') {
      i = j + 1;
      q = c5;
    } else if (i === b6 && c5 === "'") {
      i = j + 1;
      q = c5;
    } else if (c5 === "." && !b6) {
      if (j > i) {
        push();
      } else {
        i = j + 1;
      }
    } else if (c5 === "[") {
      if (j > i)
        push();
      b6 = i = j + 1;
    } else if (c5 === "]") {
      if (!b6)
        error16("Access path missing open bracket: " + p);
      if (b6 > 0)
        push();
      b6 = 0;
      i = j + 1;
    }
  }
  if (b6)
    error16("Access path missing closing bracket: " + p);
  if (q)
    error16("Access path missing closing quote: " + p);
  if (j > i) {
    j++;
    push();
  }
  return path7;
}
function field16(field25, name, opt) {
  const path7 = splitAccessPath16(field25);
  field25 = path7.length === 1 ? path7[0] : field25;
  return accessor16((opt && opt.get || getter16)(path7), [field25], name || field25);
}
var id16 = field16("id");
var identity20 = accessor16((_) => _, [], "identity");
var zero18 = accessor16(() => 0, [], "zero");
var one17 = accessor16(() => 1, [], "one");
var truthy16 = accessor16(() => true, [], "true");
var falsy16 = accessor16(() => false, [], "false");
var DisallowedObjectProperties16 = /* @__PURE__ */ new Set([...Object.getOwnPropertyNames(Object.prototype).filter((name) => typeof Object.prototype[name] === "function"), "__proto__"]);
var isArray16 = Array.isArray;
function isObject9(_) {
  return _ === Object(_);
}
function peek10(array22) {
  return array22[array22.length - 1];
}
function toNumber10(_) {
  return _ == null || _ === "" ? null : +_;
}
var exp6 = (sign4) => (x9) => sign4 * Math.exp(x9);
var log7 = (sign4) => (x9) => Math.log(sign4 * x9);
var symlog4 = (c5) => (x9) => Math.sign(x9) * Math.log1p(Math.abs(x9 / c5));
var symexp3 = (c5) => (x9) => Math.sign(x9) * Math.expm1(Math.abs(x9)) * c5;
var pow8 = (exponent) => (x9) => x9 < 0 ? -Math.pow(-x9, exponent) : Math.pow(x9, exponent);
function pan2(domain3, delta, lift, ground) {
  const d0 = lift(domain3[0]), d1 = lift(peek10(domain3)), dd = (d1 - d0) * delta;
  return [ground(d0 - dd), ground(d1 - dd)];
}
function panLinear2(domain3, delta) {
  return pan2(domain3, delta, toNumber10, identity20);
}
function panLog2(domain3, delta) {
  var sign4 = Math.sign(domain3[0]);
  return pan2(domain3, delta, log7(sign4), exp6(sign4));
}
function panPow2(domain3, delta, exponent) {
  return pan2(domain3, delta, pow8(exponent), pow8(1 / exponent));
}
function panSymlog2(domain3, delta, constant15) {
  return pan2(domain3, delta, symlog4(constant15), symexp3(constant15));
}
function zoom3(domain3, anchor, scale19, lift, ground) {
  const d0 = lift(domain3[0]), d1 = lift(peek10(domain3)), da2 = anchor != null ? lift(anchor) : (d0 + d1) / 2;
  return [ground(da2 + (d0 - da2) * scale19), ground(da2 + (d1 - da2) * scale19)];
}
function zoomLinear3(domain3, anchor, scale19) {
  return zoom3(domain3, anchor, scale19, toNumber10, identity20);
}
function zoomLog3(domain3, anchor, scale19) {
  const sign4 = Math.sign(domain3[0]);
  return zoom3(domain3, anchor, scale19, log7(sign4), exp6(sign4));
}
function zoomPow3(domain3, anchor, scale19, exponent) {
  return zoom3(domain3, anchor, scale19, pow8(exponent), pow8(1 / exponent));
}
function zoomSymlog3(domain3, anchor, scale19, constant15) {
  return zoom3(domain3, anchor, scale19, symlog4(constant15), symexp3(constant15));
}
function quarter2(date2) {
  return 1 + ~~(new Date(date2).getMonth() / 3);
}
function utcquarter2(date2) {
  return 1 + ~~(new Date(date2).getUTCMonth() / 3);
}
function array15(_) {
  return _ != null ? isArray16(_) ? _ : [_] : [];
}
function clampRange2(range7, min5, max5) {
  let lo = range7[0], hi = range7[1], span12;
  if (hi < lo) {
    span12 = hi;
    hi = lo;
    lo = span12;
  }
  span12 = hi - lo;
  return span12 >= max5 - min5 ? [min5, max5] : [lo = Math.min(Math.max(lo, min5), max5 - span12), lo + span12];
}
function isFunction11(_) {
  return typeof _ === "function";
}
var ascending9 = (u4, v2) => (u4 < v2 || u4 == null) && v2 != null ? -1 : (u4 > v2 || v2 == null) && u4 != null ? 1 : (v2 = v2 instanceof Date ? +v2 : v2, u4 = u4 instanceof Date ? +u4 : u4) !== u4 && v2 === v2 ? -1 : v2 !== v2 && u4 === u4 ? 1 : 0;
function constant13(_) {
  return isFunction11(_) ? _ : () => _;
}
function extend17(_) {
  for (let x9, k3, i = 1, len = arguments.length; i < len; ++i) {
    x9 = arguments[i];
    for (k3 in x9) {
      _[k3] = x9[k3];
    }
  }
  return _;
}
function extent7(array22, f) {
  let i = 0, n, v2, min5, max5;
  if (array22 && (n = array22.length)) {
    if (f == null) {
      for (v2 = array22[i]; i < n && (v2 == null || v2 !== v2); v2 = array22[++i])
        ;
      min5 = max5 = v2;
      for (; i < n; ++i) {
        v2 = array22[i];
        if (v2 != null) {
          if (v2 < min5)
            min5 = v2;
          if (v2 > max5)
            max5 = v2;
        }
      }
    } else {
      for (v2 = f(array22[i]); i < n && (v2 == null || v2 !== v2); v2 = f(array22[++i]))
        ;
      min5 = max5 = v2;
      for (; i < n; ++i) {
        v2 = f(array22[i]);
        if (v2 != null) {
          if (v2 < min5)
            min5 = v2;
          if (v2 > max5)
            max5 = v2;
        }
      }
    }
  }
  return [min5, max5];
}
function has13(object2, property2) {
  return Object.hasOwn(object2, property2);
}
function flush2(range7, value7, threshold2, left, right, center) {
  if (!threshold2 && threshold2 !== 0)
    return center;
  const t = +threshold2;
  let a4 = range7[0], b6 = peek10(range7), l;
  if (b6 < a4) {
    l = a4;
    a4 = b6;
    b6 = l;
  }
  l = Math.abs(value7 - a4);
  const r = Math.abs(b6 - value7);
  return l < r && l <= t ? left : r <= t ? right : center;
}
function inherits15(child, parent, members) {
  const proto = child.prototype = Object.create(parent.prototype);
  Object.defineProperty(proto, "constructor", {
    value: child,
    writable: true,
    enumerable: true,
    configurable: true
  });
  return extend17(proto, members);
}
function inrange2(value7, range7, left, right) {
  let r0 = range7[0], r1 = range7[range7.length - 1], t;
  if (r0 > r1) {
    t = r0;
    r0 = r1;
    r1 = t;
  }
  left = left === void 0 || left;
  right = right === void 0 || right;
  return (left ? r0 <= value7 : r0 < value7) && (right ? value7 <= r1 : value7 < r1);
}
function isBoolean4(_) {
  return typeof _ === "boolean";
}
function isDate6(_) {
  return Object.prototype.toString.call(_) === "[object Date]";
}
function isIterable6(_) {
  return _ && isFunction11(_[Symbol.iterator]);
}
function isNumber12(_) {
  return typeof _ === "number";
}
function isRegExp2(_) {
  return Object.prototype.toString.call(_) === "[object RegExp]";
}
function isString9(_) {
  return typeof _ === "string";
}
function lerp2(array22, frac) {
  const lo = array22[0], hi = peek10(array22), f = +frac;
  return !f ? lo : f === 1 ? hi : lo + f * (hi - lo);
}
var DEFAULT_MAX_SIZE5 = 1e4;
function lruCache5(maxsize) {
  maxsize = +maxsize || DEFAULT_MAX_SIZE5;
  let curr, prev, size;
  const clear2 = () => {
    curr = {};
    prev = {};
    size = 0;
  };
  const update3 = (key4, value7) => {
    if (++size > maxsize) {
      prev = curr;
      curr = {};
      size = 1;
    }
    return curr[key4] = value7;
  };
  clear2();
  return {
    clear: clear2,
    has: (key4) => has13(curr, key4) || has13(prev, key4),
    get: (key4) => has13(curr, key4) ? curr[key4] : has13(prev, key4) ? update3(key4, prev[key4]) : void 0,
    set: (key4, value7) => has13(curr, key4) ? curr[key4] = value7 : update3(key4, value7)
  };
}
function repeat2(str, reps) {
  let s2 = "";
  while (--reps >= 0)
    s2 += str;
  return s2;
}
function pad4(str, length2, padchar, align2) {
  const c5 = padchar || " ", s2 = str + "", n = length2 - s2.length;
  return n <= 0 ? s2 : align2 === "left" ? repeat2(c5, n) + s2 : align2 === "center" ? repeat2(c5, ~~(n / 2)) + s2 + repeat2(c5, Math.ceil(n / 2)) : s2 + repeat2(c5, n);
}
function span10(array22) {
  return array22 && peek10(array22) - array22[0] || 0;
}
function $7(x9) {
  return isArray16(x9) ? `[${x9.map((v2) => v2 === null ? "null" : $7(v2))}]` : isObject9(x9) || isString9(x9) ? (
    // Output valid JSON and JS source strings.
    // See https://github.com/judofyr/timeless/blob/master/posts/json-isnt-a-javascript-subset.md
    JSON.stringify(x9).replaceAll("\u2028", "\\u2028").replaceAll("\u2029", "\\u2029")
  ) : x9;
}
function toBoolean6(_) {
  return _ == null || _ === "" ? null : !_ || _ === "false" || _ === "0" ? false : !!_;
}
var defaultParser3 = (_) => isNumber12(_) ? _ : isDate6(_) ? _ : Date.parse(_);
function toDate6(_, parser3) {
  parser3 = parser3 || defaultParser3;
  return _ == null || _ === "" ? null : parser3(_);
}
function toString6(_) {
  return _ == null || _ === "" ? null : _ + "";
}
function toSet11(_) {
  const s2 = {}, n = _.length;
  for (let i = 0; i < n; ++i)
    s2[_[i]] = true;
  return s2;
}
function truncate6(str, length2, align2, ellipsis) {
  const e3 = ellipsis != null ? ellipsis : "…", s2 = str + "", n = s2.length, l = Math.max(0, length2 - e3.length);
  return n <= length2 ? s2 : align2 === "left" ? e3 + s2.slice(n - l) : align2 === "center" ? s2.slice(0, Math.ceil(l / 2)) + e3 + s2.slice(n - ~~(l / 2)) : s2.slice(0, l) + e3;
}

// node_modules/vega-expression/node_modules/vega-util/build/vega-util.js
function accessor17(fn, fields, name) {
  fn.fields = fields || [];
  fn.fname = name;
  return fn;
}
function getter17(path7) {
  return path7.length === 1 ? get117(path7[0]) : getN17(path7);
}
var get117 = (field25) => function(obj) {
  return obj[field25];
};
var getN17 = (path7) => {
  const len = path7.length;
  return function(obj) {
    for (let i = 0; i < len; ++i) {
      obj = obj[path7[i]];
    }
    return obj;
  };
};
function error17(message) {
  throw Error(message);
}
function splitAccessPath17(p) {
  const path7 = [], n = p.length;
  let q = null, b6 = 0, s2 = "", i, j, c5;
  p = p + "";
  function push() {
    path7.push(s2 + p.substring(i, j));
    s2 = "";
    i = j + 1;
  }
  for (i = j = 0; j < n; ++j) {
    c5 = p[j];
    if (c5 === "\\") {
      s2 += p.substring(i, j++);
      i = j;
    } else if (c5 === q) {
      push();
      q = null;
      b6 = -1;
    } else if (q) {
      continue;
    } else if (i === b6 && c5 === '"') {
      i = j + 1;
      q = c5;
    } else if (i === b6 && c5 === "'") {
      i = j + 1;
      q = c5;
    } else if (c5 === "." && !b6) {
      if (j > i) {
        push();
      } else {
        i = j + 1;
      }
    } else if (c5 === "[") {
      if (j > i)
        push();
      b6 = i = j + 1;
    } else if (c5 === "]") {
      if (!b6)
        error17("Access path missing open bracket: " + p);
      if (b6 > 0)
        push();
      b6 = 0;
      i = j + 1;
    }
  }
  if (b6)
    error17("Access path missing closing bracket: " + p);
  if (q)
    error17("Access path missing closing quote: " + p);
  if (j > i) {
    j++;
    push();
  }
  return path7;
}
function field17(field25, name, opt) {
  const path7 = splitAccessPath17(field25);
  field25 = path7.length === 1 ? path7[0] : field25;
  return accessor17((opt && opt.get || getter17)(path7), [field25], name || field25);
}
var id17 = field17("id");
var identity21 = accessor17((_) => _, [], "identity");
var zero19 = accessor17(() => 0, [], "zero");
var one18 = accessor17(() => 1, [], "one");
var truthy17 = accessor17(() => true, [], "true");
var falsy17 = accessor17(() => false, [], "false");
var DisallowedObjectProperties17 = /* @__PURE__ */ new Set([...Object.getOwnPropertyNames(Object.prototype).filter((name) => typeof Object.prototype[name] === "function"), "__proto__"]);
var isArray17 = Array.isArray;
function isFunction12(_) {
  return typeof _ === "function";
}
function has14(object2, property2) {
  return Object.hasOwn(object2, property2);
}
function isString10(_) {
  return typeof _ === "string";
}
function toSet12(_) {
  const s2 = {}, n = _.length;
  for (let i = 0; i < n; ++i)
    s2[_[i]] = true;
  return s2;
}

// node_modules/vega-expression/build/vega-expression.js
var RawCode = "RawCode";
var Literal = "Literal";
var Property = "Property";
var Identifier2 = "Identifier";
var ArrayExpression = "ArrayExpression";
var BinaryExpression = "BinaryExpression";
var CallExpression = "CallExpression";
var ConditionalExpression = "ConditionalExpression";
var LogicalExpression = "LogicalExpression";
var MemberExpression = "MemberExpression";
var ObjectExpression = "ObjectExpression";
var UnaryExpression = "UnaryExpression";
function ASTNode(type7) {
  this.type = type7;
}
ASTNode.prototype.visit = function(visitor) {
  let c5, i, n;
  if (visitor(this))
    return 1;
  for (c5 = children2(this), i = 0, n = c5.length; i < n; ++i) {
    if (c5[i].visit(visitor))
      return 1;
  }
};
function children2(node) {
  switch (node.type) {
    case ArrayExpression:
      return node.elements;
    case BinaryExpression:
    case LogicalExpression:
      return [node.left, node.right];
    case CallExpression:
      return [node.callee].concat(node.arguments);
    case ConditionalExpression:
      return [node.test, node.consequent, node.alternate];
    case MemberExpression:
      return [node.object, node.property];
    case ObjectExpression:
      return node.properties;
    case Property:
      return [node.key, node.value];
    case UnaryExpression:
      return [node.argument];
    case Identifier2:
    case Literal:
    case RawCode:
    default:
      return [];
  }
}
var TokenName;
var source2;
var index3;
var length;
var lookahead;
var TokenBooleanLiteral = 1;
var TokenEOF = 2;
var TokenIdentifier = 3;
var TokenKeyword = 4;
var TokenNullLiteral = 5;
var TokenNumericLiteral = 6;
var TokenPunctuator = 7;
var TokenStringLiteral = 8;
var TokenRegularExpression = 9;
TokenName = {};
TokenName[TokenBooleanLiteral] = "Boolean";
TokenName[TokenEOF] = "<end>";
TokenName[TokenIdentifier] = "Identifier";
TokenName[TokenKeyword] = "Keyword";
TokenName[TokenNullLiteral] = "Null";
TokenName[TokenNumericLiteral] = "Numeric";
TokenName[TokenPunctuator] = "Punctuator";
TokenName[TokenStringLiteral] = "String";
TokenName[TokenRegularExpression] = "RegularExpression";
var SyntaxArrayExpression = "ArrayExpression";
var SyntaxBinaryExpression = "BinaryExpression";
var SyntaxCallExpression = "CallExpression";
var SyntaxConditionalExpression = "ConditionalExpression";
var SyntaxIdentifier = "Identifier";
var SyntaxLiteral = "Literal";
var SyntaxLogicalExpression = "LogicalExpression";
var SyntaxMemberExpression = "MemberExpression";
var SyntaxObjectExpression = "ObjectExpression";
var SyntaxProperty = "Property";
var SyntaxUnaryExpression = "UnaryExpression";
var MessageUnexpectedToken = "Unexpected token %0";
var MessageUnexpectedNumber = "Unexpected number";
var MessageUnexpectedString = "Unexpected string";
var MessageUnexpectedIdentifier = "Unexpected identifier";
var MessageUnexpectedReserved = "Unexpected reserved word";
var MessageUnexpectedEOS = "Unexpected end of input";
var MessageInvalidRegExp = "Invalid regular expression";
var MessageUnterminatedRegExp = "Invalid regular expression: missing /";
var MessageStrictOctalLiteral = "Octal literals are not allowed in strict mode.";
var MessageStrictDuplicateProperty = "Duplicate data property in object literal not allowed in strict mode";
var ILLEGAL = "ILLEGAL";
var DISABLED = "Disabled.";
var RegexNonAsciiIdentifierStart = new RegExp("[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0-\\u08B2\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]");
var RegexNonAsciiIdentifierPart = new RegExp("[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u0800-\\u082D\\u0840-\\u085B\\u08A0-\\u08B2\\u08E4-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58\\u0C59\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C81-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D01-\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D57\\u0D60-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB9\\u0EBB-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19D9\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1CD0-\\u1CD2\\u1CD4-\\u1CF6\\u1CF8\\u1CF9\\u1D00-\\u1DF5\\u1DFC-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u2E2F\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099\\u309A\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA69D\\uA69F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA827\\uA840-\\uA873\\uA880-\\uA8C4\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA900-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2D\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]");
function assert(condition, message) {
  if (!condition) {
    throw new Error("ASSERT: " + message);
  }
}
function isDecimalDigit(ch2) {
  return ch2 >= 48 && ch2 <= 57;
}
function isHexDigit(ch2) {
  return "0123456789abcdefABCDEF".includes(ch2);
}
function isOctalDigit(ch2) {
  return "01234567".includes(ch2);
}
function isWhiteSpace(ch2) {
  return ch2 === 32 || ch2 === 9 || ch2 === 11 || ch2 === 12 || ch2 === 160 || ch2 >= 5760 && [5760, 6158, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279].includes(ch2);
}
function isLineTerminator(ch2) {
  return ch2 === 10 || ch2 === 13 || ch2 === 8232 || ch2 === 8233;
}
function isIdentifierStart(ch2) {
  return ch2 === 36 || ch2 === 95 || // $ (dollar) and _ (underscore)
  ch2 >= 65 && ch2 <= 90 || // A..Z
  ch2 >= 97 && ch2 <= 122 || // a..z
  ch2 === 92 || // \ (backslash)
  ch2 >= 128 && RegexNonAsciiIdentifierStart.test(String.fromCharCode(ch2));
}
function isIdentifierPart(ch2) {
  return ch2 === 36 || ch2 === 95 || // $ (dollar) and _ (underscore)
  ch2 >= 65 && ch2 <= 90 || // A..Z
  ch2 >= 97 && ch2 <= 122 || // a..z
  ch2 >= 48 && ch2 <= 57 || // 0..9
  ch2 === 92 || // \ (backslash)
  ch2 >= 128 && RegexNonAsciiIdentifierPart.test(String.fromCharCode(ch2));
}
var keywords = {
  "if": 1,
  "in": 1,
  "do": 1,
  "var": 1,
  "for": 1,
  "new": 1,
  "try": 1,
  "let": 1,
  "this": 1,
  "else": 1,
  "case": 1,
  "void": 1,
  "with": 1,
  "enum": 1,
  "while": 1,
  "break": 1,
  "catch": 1,
  "throw": 1,
  "const": 1,
  "yield": 1,
  "class": 1,
  "super": 1,
  "return": 1,
  "typeof": 1,
  "delete": 1,
  "switch": 1,
  "export": 1,
  "import": 1,
  "public": 1,
  "static": 1,
  "default": 1,
  "finally": 1,
  "extends": 1,
  "package": 1,
  "private": 1,
  "function": 1,
  "continue": 1,
  "debugger": 1,
  "interface": 1,
  "protected": 1,
  "instanceof": 1,
  "implements": 1
};
function skipComment() {
  while (index3 < length) {
    const ch2 = source2.charCodeAt(index3);
    if (isWhiteSpace(ch2) || isLineTerminator(ch2)) {
      ++index3;
    } else {
      break;
    }
  }
}
function scanHexEscape(prefix) {
  var i, len, ch2, code = 0;
  len = prefix === "u" ? 4 : 2;
  for (i = 0; i < len; ++i) {
    if (index3 < length && isHexDigit(source2[index3])) {
      ch2 = source2[index3++];
      code = code * 16 + "0123456789abcdef".indexOf(ch2.toLowerCase());
    } else {
      throwError({}, MessageUnexpectedToken, ILLEGAL);
    }
  }
  return String.fromCharCode(code);
}
function scanUnicodeCodePointEscape() {
  var ch2, code, cu1, cu2;
  ch2 = source2[index3];
  code = 0;
  if (ch2 === "}") {
    throwError({}, MessageUnexpectedToken, ILLEGAL);
  }
  while (index3 < length) {
    ch2 = source2[index3++];
    if (!isHexDigit(ch2)) {
      break;
    }
    code = code * 16 + "0123456789abcdef".indexOf(ch2.toLowerCase());
  }
  if (code > 1114111 || ch2 !== "}") {
    throwError({}, MessageUnexpectedToken, ILLEGAL);
  }
  if (code <= 65535) {
    return String.fromCharCode(code);
  }
  cu1 = (code - 65536 >> 10) + 55296;
  cu2 = (code - 65536 & 1023) + 56320;
  return String.fromCharCode(cu1, cu2);
}
function getEscapedIdentifier() {
  var ch2, id24;
  ch2 = source2.charCodeAt(index3++);
  id24 = String.fromCharCode(ch2);
  if (ch2 === 92) {
    if (source2.charCodeAt(index3) !== 117) {
      throwError({}, MessageUnexpectedToken, ILLEGAL);
    }
    ++index3;
    ch2 = scanHexEscape("u");
    if (!ch2 || ch2 === "\\" || !isIdentifierStart(ch2.charCodeAt(0))) {
      throwError({}, MessageUnexpectedToken, ILLEGAL);
    }
    id24 = ch2;
  }
  while (index3 < length) {
    ch2 = source2.charCodeAt(index3);
    if (!isIdentifierPart(ch2)) {
      break;
    }
    ++index3;
    id24 += String.fromCharCode(ch2);
    if (ch2 === 92) {
      id24 = id24.substr(0, id24.length - 1);
      if (source2.charCodeAt(index3) !== 117) {
        throwError({}, MessageUnexpectedToken, ILLEGAL);
      }
      ++index3;
      ch2 = scanHexEscape("u");
      if (!ch2 || ch2 === "\\" || !isIdentifierPart(ch2.charCodeAt(0))) {
        throwError({}, MessageUnexpectedToken, ILLEGAL);
      }
      id24 += ch2;
    }
  }
  return id24;
}
function getIdentifier() {
  var start, ch2;
  start = index3++;
  while (index3 < length) {
    ch2 = source2.charCodeAt(index3);
    if (ch2 === 92) {
      index3 = start;
      return getEscapedIdentifier();
    }
    if (isIdentifierPart(ch2)) {
      ++index3;
    } else {
      break;
    }
  }
  return source2.slice(start, index3);
}
function scanIdentifier() {
  var start, id24, type7;
  start = index3;
  id24 = source2.charCodeAt(index3) === 92 ? getEscapedIdentifier() : getIdentifier();
  if (id24.length === 1) {
    type7 = TokenIdentifier;
  } else if (keywords.hasOwnProperty(id24)) {
    type7 = TokenKeyword;
  } else if (id24 === "null") {
    type7 = TokenNullLiteral;
  } else if (id24 === "true" || id24 === "false") {
    type7 = TokenBooleanLiteral;
  } else {
    type7 = TokenIdentifier;
  }
  return {
    type: type7,
    value: id24,
    start,
    end: index3
  };
}
function scanPunctuator() {
  var start = index3, code = source2.charCodeAt(index3), code2, ch1 = source2[index3], ch2, ch3, ch4;
  switch (code) {
    case 46:
    case 40:
    case 41:
    case 59:
    case 44:
    case 123:
    case 125:
    case 91:
    case 93:
    case 58:
    case 63:
    case 126:
      ++index3;
      return {
        type: TokenPunctuator,
        value: String.fromCharCode(code),
        start,
        end: index3
      };
    default:
      code2 = source2.charCodeAt(index3 + 1);
      if (code2 === 61) {
        switch (code) {
          case 43:
          case 45:
          case 47:
          case 60:
          case 62:
          case 94:
          case 124:
          case 37:
          case 38:
          case 42:
            index3 += 2;
            return {
              type: TokenPunctuator,
              value: String.fromCharCode(code) + String.fromCharCode(code2),
              start,
              end: index3
            };
          case 33:
          case 61:
            index3 += 2;
            if (source2.charCodeAt(index3) === 61) {
              ++index3;
            }
            return {
              type: TokenPunctuator,
              value: source2.slice(start, index3),
              start,
              end: index3
            };
        }
      }
  }
  ch4 = source2.substr(index3, 4);
  if (ch4 === ">>>=") {
    index3 += 4;
    return {
      type: TokenPunctuator,
      value: ch4,
      start,
      end: index3
    };
  }
  ch3 = ch4.substr(0, 3);
  if (ch3 === ">>>" || ch3 === "<<=" || ch3 === ">>=") {
    index3 += 3;
    return {
      type: TokenPunctuator,
      value: ch3,
      start,
      end: index3
    };
  }
  ch2 = ch3.substr(0, 2);
  if (ch1 === ch2[1] && "+-<>&|".includes(ch1) || ch2 === "=>") {
    index3 += 2;
    return {
      type: TokenPunctuator,
      value: ch2,
      start,
      end: index3
    };
  }
  if (ch2 === "//") {
    throwError({}, MessageUnexpectedToken, ILLEGAL);
  }
  if ("<>=!+-*%&|^/".includes(ch1)) {
    ++index3;
    return {
      type: TokenPunctuator,
      value: ch1,
      start,
      end: index3
    };
  }
  throwError({}, MessageUnexpectedToken, ILLEGAL);
}
function scanHexLiteral(start) {
  let number12 = "";
  while (index3 < length) {
    if (!isHexDigit(source2[index3])) {
      break;
    }
    number12 += source2[index3++];
  }
  if (number12.length === 0) {
    throwError({}, MessageUnexpectedToken, ILLEGAL);
  }
  if (isIdentifierStart(source2.charCodeAt(index3))) {
    throwError({}, MessageUnexpectedToken, ILLEGAL);
  }
  return {
    type: TokenNumericLiteral,
    value: parseInt("0x" + number12, 16),
    start,
    end: index3
  };
}
function scanOctalLiteral(start) {
  let number12 = "0" + source2[index3++];
  while (index3 < length) {
    if (!isOctalDigit(source2[index3])) {
      break;
    }
    number12 += source2[index3++];
  }
  if (isIdentifierStart(source2.charCodeAt(index3)) || isDecimalDigit(source2.charCodeAt(index3))) {
    throwError({}, MessageUnexpectedToken, ILLEGAL);
  }
  return {
    type: TokenNumericLiteral,
    value: parseInt(number12, 8),
    octal: true,
    start,
    end: index3
  };
}
function scanNumericLiteral() {
  var number12, start, ch2;
  ch2 = source2[index3];
  assert(isDecimalDigit(ch2.charCodeAt(0)) || ch2 === ".", "Numeric literal must start with a decimal digit or a decimal point");
  start = index3;
  number12 = "";
  if (ch2 !== ".") {
    number12 = source2[index3++];
    ch2 = source2[index3];
    if (number12 === "0") {
      if (ch2 === "x" || ch2 === "X") {
        ++index3;
        return scanHexLiteral(start);
      }
      if (isOctalDigit(ch2)) {
        return scanOctalLiteral(start);
      }
      if (ch2 && isDecimalDigit(ch2.charCodeAt(0))) {
        throwError({}, MessageUnexpectedToken, ILLEGAL);
      }
    }
    while (isDecimalDigit(source2.charCodeAt(index3))) {
      number12 += source2[index3++];
    }
    ch2 = source2[index3];
  }
  if (ch2 === ".") {
    number12 += source2[index3++];
    while (isDecimalDigit(source2.charCodeAt(index3))) {
      number12 += source2[index3++];
    }
    ch2 = source2[index3];
  }
  if (ch2 === "e" || ch2 === "E") {
    number12 += source2[index3++];
    ch2 = source2[index3];
    if (ch2 === "+" || ch2 === "-") {
      number12 += source2[index3++];
    }
    if (isDecimalDigit(source2.charCodeAt(index3))) {
      while (isDecimalDigit(source2.charCodeAt(index3))) {
        number12 += source2[index3++];
      }
    } else {
      throwError({}, MessageUnexpectedToken, ILLEGAL);
    }
  }
  if (isIdentifierStart(source2.charCodeAt(index3))) {
    throwError({}, MessageUnexpectedToken, ILLEGAL);
  }
  return {
    type: TokenNumericLiteral,
    value: parseFloat(number12),
    start,
    end: index3
  };
}
function scanStringLiteral() {
  var str = "", quote, start, ch2, code, octal = false;
  quote = source2[index3];
  assert(quote === "'" || quote === '"', "String literal must starts with a quote");
  start = index3;
  ++index3;
  while (index3 < length) {
    ch2 = source2[index3++];
    if (ch2 === quote) {
      quote = "";
      break;
    } else if (ch2 === "\\") {
      ch2 = source2[index3++];
      if (!ch2 || !isLineTerminator(ch2.charCodeAt(0))) {
        switch (ch2) {
          case "u":
          case "x":
            if (source2[index3] === "{") {
              ++index3;
              str += scanUnicodeCodePointEscape();
            } else {
              str += scanHexEscape(ch2);
            }
            break;
          case "n":
            str += "\n";
            break;
          case "r":
            str += "\r";
            break;
          case "t":
            str += "	";
            break;
          case "b":
            str += "\b";
            break;
          case "f":
            str += "\f";
            break;
          case "v":
            str += "\v";
            break;
          default:
            if (isOctalDigit(ch2)) {
              code = "01234567".indexOf(ch2);
              if (code !== 0) {
                octal = true;
              }
              if (index3 < length && isOctalDigit(source2[index3])) {
                octal = true;
                code = code * 8 + "01234567".indexOf(source2[index3++]);
                if ("0123".includes(ch2) && index3 < length && isOctalDigit(source2[index3])) {
                  code = code * 8 + "01234567".indexOf(source2[index3++]);
                }
              }
              str += String.fromCharCode(code);
            } else {
              str += ch2;
            }
            break;
        }
      } else {
        if (ch2 === "\r" && source2[index3] === "\n") {
          ++index3;
        }
      }
    } else if (isLineTerminator(ch2.charCodeAt(0))) {
      break;
    } else {
      str += ch2;
    }
  }
  if (quote !== "") {
    throwError({}, MessageUnexpectedToken, ILLEGAL);
  }
  return {
    type: TokenStringLiteral,
    value: str,
    octal,
    start,
    end: index3
  };
}
function testRegExp(pattern, flags) {
  let tmp = pattern;
  if (flags.includes("u")) {
    tmp = tmp.replace(/\\u\{([0-9a-fA-F]+)\}/g, ($0, $1) => {
      if (parseInt($1, 16) <= 1114111) {
        return "x";
      }
      throwError({}, MessageInvalidRegExp);
    }).replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, "x");
  }
  try {
    new RegExp(tmp);
  } catch (e3) {
    throwError({}, MessageInvalidRegExp);
  }
  try {
    return new RegExp(pattern, flags);
  } catch (exception) {
    return null;
  }
}
function scanRegExpBody() {
  var ch2, str, classMarker, terminated, body;
  ch2 = source2[index3];
  assert(ch2 === "/", "Regular expression literal must start with a slash");
  str = source2[index3++];
  classMarker = false;
  terminated = false;
  while (index3 < length) {
    ch2 = source2[index3++];
    str += ch2;
    if (ch2 === "\\") {
      ch2 = source2[index3++];
      if (isLineTerminator(ch2.charCodeAt(0))) {
        throwError({}, MessageUnterminatedRegExp);
      }
      str += ch2;
    } else if (isLineTerminator(ch2.charCodeAt(0))) {
      throwError({}, MessageUnterminatedRegExp);
    } else if (classMarker) {
      if (ch2 === "]") {
        classMarker = false;
      }
    } else {
      if (ch2 === "/") {
        terminated = true;
        break;
      } else if (ch2 === "[") {
        classMarker = true;
      }
    }
  }
  if (!terminated) {
    throwError({}, MessageUnterminatedRegExp);
  }
  body = str.substr(1, str.length - 2);
  return {
    value: body,
    literal: str
  };
}
function scanRegExpFlags() {
  var ch2, str, flags;
  str = "";
  flags = "";
  while (index3 < length) {
    ch2 = source2[index3];
    if (!isIdentifierPart(ch2.charCodeAt(0))) {
      break;
    }
    ++index3;
    if (ch2 === "\\" && index3 < length) {
      throwError({}, MessageUnexpectedToken, ILLEGAL);
    } else {
      flags += ch2;
      str += ch2;
    }
  }
  if (flags.search(/[^gimuy]/g) >= 0) {
    throwError({}, MessageInvalidRegExp, flags);
  }
  return {
    value: flags,
    literal: str
  };
}
function scanRegExp() {
  var start, body, flags, value7;
  lookahead = null;
  skipComment();
  start = index3;
  body = scanRegExpBody();
  flags = scanRegExpFlags();
  value7 = testRegExp(body.value, flags.value);
  return {
    literal: body.literal + flags.literal,
    value: value7,
    regex: {
      pattern: body.value,
      flags: flags.value
    },
    start,
    end: index3
  };
}
function isIdentifierName(token) {
  return token.type === TokenIdentifier || token.type === TokenKeyword || token.type === TokenBooleanLiteral || token.type === TokenNullLiteral;
}
function advance() {
  skipComment();
  if (index3 >= length) {
    return {
      type: TokenEOF,
      start: index3,
      end: index3
    };
  }
  const ch2 = source2.charCodeAt(index3);
  if (isIdentifierStart(ch2)) {
    return scanIdentifier();
  }
  if (ch2 === 40 || ch2 === 41 || ch2 === 59) {
    return scanPunctuator();
  }
  if (ch2 === 39 || ch2 === 34) {
    return scanStringLiteral();
  }
  if (ch2 === 46) {
    if (isDecimalDigit(source2.charCodeAt(index3 + 1))) {
      return scanNumericLiteral();
    }
    return scanPunctuator();
  }
  if (isDecimalDigit(ch2)) {
    return scanNumericLiteral();
  }
  return scanPunctuator();
}
function lex() {
  const token = lookahead;
  index3 = token.end;
  lookahead = advance();
  index3 = token.end;
  return token;
}
function peek11() {
  const pos = index3;
  lookahead = advance();
  index3 = pos;
}
function finishArrayExpression(elements) {
  const node = new ASTNode(SyntaxArrayExpression);
  node.elements = elements;
  return node;
}
function finishBinaryExpression(operator2, left, right) {
  const node = new ASTNode(operator2 === "||" || operator2 === "&&" ? SyntaxLogicalExpression : SyntaxBinaryExpression);
  node.operator = operator2;
  node.left = left;
  node.right = right;
  return node;
}
function finishCallExpression(callee, args) {
  const node = new ASTNode(SyntaxCallExpression);
  node.callee = callee;
  node.arguments = args;
  return node;
}
function finishConditionalExpression(test2, consequent, alternate) {
  const node = new ASTNode(SyntaxConditionalExpression);
  node.test = test2;
  node.consequent = consequent;
  node.alternate = alternate;
  return node;
}
function finishIdentifier(name) {
  const node = new ASTNode(SyntaxIdentifier);
  node.name = name;
  return node;
}
function finishLiteral(token) {
  const node = new ASTNode(SyntaxLiteral);
  node.value = token.value;
  node.raw = source2.slice(token.start, token.end);
  if (token.regex) {
    if (node.raw === "//") {
      node.raw = "/(?:)/";
    }
    node.regex = token.regex;
  }
  return node;
}
function finishMemberExpression(accessor24, object2, property2) {
  const node = new ASTNode(SyntaxMemberExpression);
  node.computed = accessor24 === "[";
  node.object = object2;
  node.property = property2;
  if (!node.computed)
    property2.member = true;
  return node;
}
function finishObjectExpression(properties) {
  const node = new ASTNode(SyntaxObjectExpression);
  node.properties = properties;
  return node;
}
function finishProperty(kind, key4, value7) {
  const node = new ASTNode(SyntaxProperty);
  node.key = key4;
  node.value = value7;
  node.kind = kind;
  return node;
}
function finishUnaryExpression(operator2, argument) {
  const node = new ASTNode(SyntaxUnaryExpression);
  node.operator = operator2;
  node.argument = argument;
  node.prefix = true;
  return node;
}
function throwError(token, messageFormat) {
  var error25, args = Array.prototype.slice.call(arguments, 2), msg = messageFormat.replace(/%(\d)/g, (whole, index4) => {
    assert(index4 < args.length, "Message reference must be in range");
    return args[index4];
  });
  error25 = new Error(msg);
  error25.index = index3;
  error25.description = msg;
  throw error25;
}
function throwUnexpected(token) {
  if (token.type === TokenEOF) {
    throwError(token, MessageUnexpectedEOS);
  }
  if (token.type === TokenNumericLiteral) {
    throwError(token, MessageUnexpectedNumber);
  }
  if (token.type === TokenStringLiteral) {
    throwError(token, MessageUnexpectedString);
  }
  if (token.type === TokenIdentifier) {
    throwError(token, MessageUnexpectedIdentifier);
  }
  if (token.type === TokenKeyword) {
    throwError(token, MessageUnexpectedReserved);
  }
  throwError(token, MessageUnexpectedToken, token.value);
}
function expect(value7) {
  const token = lex();
  if (token.type !== TokenPunctuator || token.value !== value7) {
    throwUnexpected(token);
  }
}
function match(value7) {
  return lookahead.type === TokenPunctuator && lookahead.value === value7;
}
function matchKeyword(keyword) {
  return lookahead.type === TokenKeyword && lookahead.value === keyword;
}
function parseArrayInitialiser() {
  const elements = [];
  index3 = lookahead.start;
  expect("[");
  while (!match("]")) {
    if (match(",")) {
      lex();
      elements.push(null);
    } else {
      elements.push(parseConditionalExpression());
      if (!match("]")) {
        expect(",");
      }
    }
  }
  lex();
  return finishArrayExpression(elements);
}
function parseObjectPropertyKey() {
  index3 = lookahead.start;
  const token = lex();
  if (token.type === TokenStringLiteral || token.type === TokenNumericLiteral) {
    if (token.octal) {
      throwError(token, MessageStrictOctalLiteral);
    }
    return finishLiteral(token);
  }
  return finishIdentifier(token.value);
}
function parseObjectProperty() {
  var token, key4, id24, value7;
  index3 = lookahead.start;
  token = lookahead;
  if (token.type === TokenIdentifier) {
    id24 = parseObjectPropertyKey();
    expect(":");
    value7 = parseConditionalExpression();
    return finishProperty("init", id24, value7);
  }
  if (token.type === TokenEOF || token.type === TokenPunctuator) {
    throwUnexpected(token);
  } else {
    key4 = parseObjectPropertyKey();
    expect(":");
    value7 = parseConditionalExpression();
    return finishProperty("init", key4, value7);
  }
}
function parseObjectInitialiser() {
  var properties = [], property2, name, key4, map13 = {}, toString7 = String;
  index3 = lookahead.start;
  expect("{");
  while (!match("}")) {
    property2 = parseObjectProperty();
    if (property2.key.type === SyntaxIdentifier) {
      name = property2.key.name;
    } else {
      name = toString7(property2.key.value);
    }
    key4 = "$" + name;
    if (Object.prototype.hasOwnProperty.call(map13, key4)) {
      throwError({}, MessageStrictDuplicateProperty);
    } else {
      map13[key4] = true;
    }
    properties.push(property2);
    if (!match("}")) {
      expect(",");
    }
  }
  expect("}");
  return finishObjectExpression(properties);
}
function parseGroupExpression() {
  expect("(");
  const expr2 = parseExpression();
  expect(")");
  return expr2;
}
var legalKeywords = {
  "if": 1
};
function parsePrimaryExpression() {
  var type7, token, expr2;
  if (match("(")) {
    return parseGroupExpression();
  }
  if (match("[")) {
    return parseArrayInitialiser();
  }
  if (match("{")) {
    return parseObjectInitialiser();
  }
  type7 = lookahead.type;
  index3 = lookahead.start;
  if (type7 === TokenIdentifier || legalKeywords[lookahead.value]) {
    expr2 = finishIdentifier(lex().value);
  } else if (type7 === TokenStringLiteral || type7 === TokenNumericLiteral) {
    if (lookahead.octal) {
      throwError(lookahead, MessageStrictOctalLiteral);
    }
    expr2 = finishLiteral(lex());
  } else if (type7 === TokenKeyword) {
    throw new Error(DISABLED);
  } else if (type7 === TokenBooleanLiteral) {
    token = lex();
    token.value = token.value === "true";
    expr2 = finishLiteral(token);
  } else if (type7 === TokenNullLiteral) {
    token = lex();
    token.value = null;
    expr2 = finishLiteral(token);
  } else if (match("/") || match("/=")) {
    expr2 = finishLiteral(scanRegExp());
    peek11();
  } else {
    throwUnexpected(lex());
  }
  return expr2;
}
function parseArguments() {
  const args = [];
  expect("(");
  if (!match(")")) {
    while (index3 < length) {
      args.push(parseConditionalExpression());
      if (match(")")) {
        break;
      }
      expect(",");
    }
  }
  expect(")");
  return args;
}
function parseNonComputedProperty() {
  index3 = lookahead.start;
  const token = lex();
  if (!isIdentifierName(token)) {
    throwUnexpected(token);
  }
  return finishIdentifier(token.value);
}
function parseNonComputedMember() {
  expect(".");
  return parseNonComputedProperty();
}
function parseComputedMember() {
  expect("[");
  const expr2 = parseExpression();
  expect("]");
  return expr2;
}
function parseLeftHandSideExpressionAllowCall() {
  var expr2, args, property2;
  expr2 = parsePrimaryExpression();
  for (; ; ) {
    if (match(".")) {
      property2 = parseNonComputedMember();
      expr2 = finishMemberExpression(".", expr2, property2);
    } else if (match("(")) {
      args = parseArguments();
      expr2 = finishCallExpression(expr2, args);
    } else if (match("[")) {
      property2 = parseComputedMember();
      expr2 = finishMemberExpression("[", expr2, property2);
    } else {
      break;
    }
  }
  return expr2;
}
function parsePostfixExpression() {
  const expr2 = parseLeftHandSideExpressionAllowCall();
  if (lookahead.type === TokenPunctuator) {
    if (match("++") || match("--")) {
      throw new Error(DISABLED);
    }
  }
  return expr2;
}
function parseUnaryExpression() {
  var token, expr2;
  if (lookahead.type !== TokenPunctuator && lookahead.type !== TokenKeyword) {
    expr2 = parsePostfixExpression();
  } else if (match("++") || match("--")) {
    throw new Error(DISABLED);
  } else if (match("+") || match("-") || match("~") || match("!")) {
    token = lex();
    expr2 = parseUnaryExpression();
    expr2 = finishUnaryExpression(token.value, expr2);
  } else if (matchKeyword("delete") || matchKeyword("void") || matchKeyword("typeof")) {
    throw new Error(DISABLED);
  } else {
    expr2 = parsePostfixExpression();
  }
  return expr2;
}
function binaryPrecedence(token) {
  let prec = 0;
  if (token.type !== TokenPunctuator && token.type !== TokenKeyword) {
    return 0;
  }
  switch (token.value) {
    case "||":
      prec = 1;
      break;
    case "&&":
      prec = 2;
      break;
    case "|":
      prec = 3;
      break;
    case "^":
      prec = 4;
      break;
    case "&":
      prec = 5;
      break;
    case "==":
    case "!=":
    case "===":
    case "!==":
      prec = 6;
      break;
    case "<":
    case ">":
    case "<=":
    case ">=":
    case "instanceof":
    case "in":
      prec = 7;
      break;
    case "<<":
    case ">>":
    case ">>>":
      prec = 8;
      break;
    case "+":
    case "-":
      prec = 9;
      break;
    case "*":
    case "/":
    case "%":
      prec = 11;
      break;
  }
  return prec;
}
function parseBinaryExpression() {
  var marker, markers, expr2, token, prec, stack2, right, operator2, left, i;
  marker = lookahead;
  left = parseUnaryExpression();
  token = lookahead;
  prec = binaryPrecedence(token);
  if (prec === 0) {
    return left;
  }
  token.prec = prec;
  lex();
  markers = [marker, lookahead];
  right = parseUnaryExpression();
  stack2 = [left, token, right];
  while ((prec = binaryPrecedence(lookahead)) > 0) {
    while (stack2.length > 2 && prec <= stack2[stack2.length - 2].prec) {
      right = stack2.pop();
      operator2 = stack2.pop().value;
      left = stack2.pop();
      markers.pop();
      expr2 = finishBinaryExpression(operator2, left, right);
      stack2.push(expr2);
    }
    token = lex();
    token.prec = prec;
    stack2.push(token);
    markers.push(lookahead);
    expr2 = parseUnaryExpression();
    stack2.push(expr2);
  }
  i = stack2.length - 1;
  expr2 = stack2[i];
  markers.pop();
  while (i > 1) {
    markers.pop();
    expr2 = finishBinaryExpression(stack2[i - 1].value, stack2[i - 2], expr2);
    i -= 2;
  }
  return expr2;
}
function parseConditionalExpression() {
  var expr2, consequent, alternate;
  expr2 = parseBinaryExpression();
  if (match("?")) {
    lex();
    consequent = parseConditionalExpression();
    expect(":");
    alternate = parseConditionalExpression();
    expr2 = finishConditionalExpression(expr2, consequent, alternate);
  }
  return expr2;
}
function parseExpression() {
  const expr2 = parseConditionalExpression();
  if (match(",")) {
    throw new Error(DISABLED);
  }
  return expr2;
}
function parser(code) {
  source2 = code;
  index3 = 0;
  length = source2.length;
  lookahead = null;
  peek11();
  const expr2 = parseExpression();
  if (lookahead.type !== TokenEOF) {
    throw new Error("Unexpect token after expression.");
  }
  return expr2;
}
var Constants = {
  NaN: "NaN",
  E: "Math.E",
  LN2: "Math.LN2",
  LN10: "Math.LN10",
  LOG2E: "Math.LOG2E",
  LOG10E: "Math.LOG10E",
  PI: "Math.PI",
  SQRT1_2: "Math.SQRT1_2",
  SQRT2: "Math.SQRT2",
  MIN_VALUE: "Number.MIN_VALUE",
  MAX_VALUE: "Number.MAX_VALUE"
};
function Functions(codegen2) {
  function fncall(name, args, cast, type7) {
    let obj = codegen2(args[0]);
    if (cast) {
      obj = cast + "(" + obj + ")";
      if (cast.lastIndexOf("new ", 0) === 0)
        obj = "(" + obj + ")";
    }
    return obj + "." + name + (type7 < 0 ? "" : type7 === 0 ? "()" : "(" + args.slice(1).map(codegen2).join(",") + ")");
  }
  function fn(name, cast, type7) {
    return (args) => fncall(name, args, cast, type7);
  }
  const DATE12 = "new Date", STRING = "String", REGEXP = "RegExp";
  return {
    // MATH functions
    isNaN: "Number.isNaN",
    isFinite: "Number.isFinite",
    abs: "Math.abs",
    acos: "Math.acos",
    asin: "Math.asin",
    atan: "Math.atan",
    atan2: "Math.atan2",
    ceil: "Math.ceil",
    cos: "Math.cos",
    exp: "Math.exp",
    floor: "Math.floor",
    hypot: "Math.hypot",
    log: "Math.log",
    max: "Math.max",
    min: "Math.min",
    pow: "Math.pow",
    random: "Math.random",
    round: "Math.round",
    sin: "Math.sin",
    sqrt: "Math.sqrt",
    tan: "Math.tan",
    clamp: function(args) {
      if (args.length < 3)
        error17("Missing arguments to clamp function.");
      if (args.length > 3)
        error17("Too many arguments to clamp function.");
      const a4 = args.map(codegen2);
      return "Math.max(" + a4[1] + ", Math.min(" + a4[2] + "," + a4[0] + "))";
    },
    // DATE functions
    now: "Date.now",
    utc: "Date.UTC",
    datetime: DATE12,
    date: fn("getDate", DATE12, 0),
    day: fn("getDay", DATE12, 0),
    year: fn("getFullYear", DATE12, 0),
    month: fn("getMonth", DATE12, 0),
    hours: fn("getHours", DATE12, 0),
    minutes: fn("getMinutes", DATE12, 0),
    seconds: fn("getSeconds", DATE12, 0),
    milliseconds: fn("getMilliseconds", DATE12, 0),
    time: fn("getTime", DATE12, 0),
    timezoneoffset: fn("getTimezoneOffset", DATE12, 0),
    utcdate: fn("getUTCDate", DATE12, 0),
    utcday: fn("getUTCDay", DATE12, 0),
    utcyear: fn("getUTCFullYear", DATE12, 0),
    utcmonth: fn("getUTCMonth", DATE12, 0),
    utchours: fn("getUTCHours", DATE12, 0),
    utcminutes: fn("getUTCMinutes", DATE12, 0),
    utcseconds: fn("getUTCSeconds", DATE12, 0),
    utcmilliseconds: fn("getUTCMilliseconds", DATE12, 0),
    // sequence functions
    length: fn("length", null, -1),
    // STRING functions
    parseFloat: "parseFloat",
    parseInt: "parseInt",
    upper: fn("toUpperCase", STRING, 0),
    lower: fn("toLowerCase", STRING, 0),
    substring: fn("substring", STRING),
    split: fn("split", STRING),
    trim: fn("trim", STRING, 0),
    // base64 encode/decode
    btoa: "btoa",
    atob: "atob",
    // REGEXP functions
    regexp: REGEXP,
    test: fn("test", REGEXP),
    // Control Flow functions
    if: function(args) {
      if (args.length < 3)
        error17("Missing arguments to if function.");
      if (args.length > 3)
        error17("Too many arguments to if function.");
      const a4 = args.map(codegen2);
      return "(" + a4[0] + "?" + a4[1] + ":" + a4[2] + ")";
    }
  };
}
function stripQuotes(s2) {
  const n = s2 && s2.length - 1;
  return n && (s2[0] === '"' && s2[n] === '"' || s2[0] === "'" && s2[n] === "'") ? s2.slice(1, -1) : s2;
}
function codegen(opt) {
  opt = opt || {};
  const allowed = opt.allowed ? toSet12(opt.allowed) : {}, forbidden = opt.forbidden ? toSet12(opt.forbidden) : {}, constants3 = opt.constants || Constants, functions = (opt.functions || Functions)(visit6), globalvar = opt.globalvar, fieldvar = opt.fieldvar, outputGlobal = isFunction12(globalvar) ? globalvar : (id24) => `${globalvar}["${id24}"]`;
  /* @__PURE__ */ new Set([...Object.getOwnPropertyNames(Object.prototype).filter((name) => typeof Object.prototype[name] === "function"), "__proto__"]);
  let globals = {}, fields = {}, memberDepth = 0;
  function visit6(ast) {
    if (isString10(ast))
      return ast;
    const generator = Generators[ast.type];
    if (generator == null)
      error17("Unsupported type: " + ast.type);
    return generator(ast);
  }
  const Generators = {
    Literal: (n) => n.raw,
    Identifier: (n) => {
      const id24 = n.name;
      if (memberDepth > 0) {
        return id24;
      } else if (has14(forbidden, id24)) {
        return error17("Illegal identifier: " + id24);
      } else if (has14(constants3, id24)) {
        return constants3[id24];
      } else if (has14(allowed, id24)) {
        return id24;
      } else {
        globals[id24] = 1;
        return outputGlobal(id24);
      }
    },
    MemberExpression: (n) => {
      const d = !n.computed, o = visit6(n.object);
      if (d)
        memberDepth += 1;
      const p = visit6(n.property);
      if (o === fieldvar) {
        fields[stripQuotes(p)] = 1;
      }
      if (d)
        memberDepth -= 1;
      return o + (d ? "." + p : "[" + p + "]");
    },
    CallExpression: (n) => {
      if (n.callee.type !== "Identifier") {
        error17("Illegal callee type: " + n.callee.type);
      }
      const callee = n.callee.name, args = n.arguments, fn = has14(functions, callee) && functions[callee];
      if (!fn)
        error17("Unrecognized function: " + callee);
      return isFunction12(fn) ? fn(args) : fn + "(" + args.map(visit6).join(",") + ")";
    },
    ArrayExpression: (n) => "[" + n.elements.map(visit6).join(",") + "]",
    BinaryExpression: (n) => "(" + visit6(n.left) + " " + n.operator + " " + visit6(n.right) + ")",
    UnaryExpression: (n) => "(" + n.operator + visit6(n.argument) + ")",
    ConditionalExpression: (n) => "(" + visit6(n.test) + "?" + visit6(n.consequent) + ":" + visit6(n.alternate) + ")",
    LogicalExpression: (n) => "(" + visit6(n.left) + n.operator + visit6(n.right) + ")",
    ObjectExpression: (n) => {
      for (const prop of n.properties) {
        const keyName = prop.key.name;
        if (DisallowedObjectProperties17.has(keyName)) {
          error17("Illegal property: " + keyName);
        }
      }
      return "{" + n.properties.map(visit6).join(",") + "}";
    },
    Property: (n) => {
      memberDepth += 1;
      const k3 = visit6(n.key);
      memberDepth -= 1;
      return k3 + ":" + visit6(n.value);
    }
  };
  function codegen2(ast) {
    const result = {
      code: visit6(ast),
      globals: Object.keys(globals),
      fields: Object.keys(fields)
    };
    globals = {};
    fields = {};
    return result;
  }
  codegen2.functions = functions;
  codegen2.constants = constants3;
  return codegen2;
}

// node_modules/vega-functions/node_modules/vega-time/build/vega-time.js
var YEAR10 = "year";
var QUARTER10 = "quarter";
var MONTH10 = "month";
var WEEK10 = "week";
var DATE10 = "date";
var DAY10 = "day";
var DAYOFYEAR10 = "dayofyear";
var HOURS10 = "hours";
var MINUTES10 = "minutes";
var SECONDS10 = "seconds";
var MILLISECONDS10 = "milliseconds";
var TIME_UNITS10 = [YEAR10, QUARTER10, MONTH10, WEEK10, DATE10, DAY10, DAYOFYEAR10, HOURS10, MINUTES10, SECONDS10, MILLISECONDS10];
var UNITS10 = TIME_UNITS10.reduce((o, u4, i) => (o[u4] = 1 + i, o), {});
function timeUnits3(units) {
  const u4 = array15(units).slice(), m3 = {};
  if (!u4.length)
    error16("Missing time unit.");
  u4.forEach((unit2) => {
    if (has13(UNITS10, unit2)) {
      m3[unit2] = 1;
    } else {
      error16(`Invalid time unit: ${unit2}.`);
    }
  });
  const numTypes = (m3[WEEK10] || m3[DAY10] ? 1 : 0) + (m3[QUARTER10] || m3[MONTH10] || m3[DATE10] ? 1 : 0) + (m3[DAYOFYEAR10] ? 1 : 0);
  if (numTypes > 1) {
    error16(`Incompatible time units: ${units}`);
  }
  u4.sort((a4, b6) => UNITS10[a4] - UNITS10[b6]);
  return u4;
}
var defaultSpecifiers10 = {
  [YEAR10]: "%Y ",
  [QUARTER10]: "Q%q ",
  [MONTH10]: "%b ",
  [DATE10]: "%d ",
  [WEEK10]: "W%U ",
  [DAY10]: "%a ",
  [DAYOFYEAR10]: "%j ",
  [HOURS10]: "%H:00",
  [MINUTES10]: "00:%M",
  [SECONDS10]: ":%S",
  [MILLISECONDS10]: ".%L",
  [`${YEAR10}-${MONTH10}`]: "%Y-%m ",
  [`${YEAR10}-${MONTH10}-${DATE10}`]: "%Y-%m-%d ",
  [`${HOURS10}-${MINUTES10}`]: "%H:%M"
};
function timeUnitSpecifier2(units, specifiers) {
  const s2 = extend17({}, defaultSpecifiers10, specifiers), u4 = timeUnits3(units), n = u4.length;
  let fmt = "", start = 0, end, key4;
  for (start = 0; start < n; ) {
    for (end = u4.length; end > start; --end) {
      key4 = u4.slice(start, end).join("-");
      if (s2[key4] != null) {
        fmt += s2[key4];
        start = end;
        break;
      }
    }
  }
  return fmt.trim();
}
var t012 = /* @__PURE__ */ new Date();
function localYear10(y9) {
  t012.setFullYear(y9);
  t012.setMonth(0);
  t012.setDate(1);
  t012.setHours(0, 0, 0, 0);
  return t012;
}
function dayofyear2(d) {
  return localDayOfYear10(new Date(d));
}
function week2(d) {
  return localWeekNum10(new Date(d));
}
function localDayOfYear10(d) {
  return timeDay.count(localYear10(d.getFullYear()) - 1, d);
}
function localWeekNum10(d) {
  return timeSunday.count(localYear10(d.getFullYear()) - 1, d);
}
function localFirst10(y9) {
  return localYear10(y9).getDay();
}
function utcdayofyear2(d) {
  return utcDayOfYear10(new Date(d));
}
function utcweek2(d) {
  return utcWeekNum10(new Date(d));
}
function utcDayOfYear10(d) {
  const y9 = Date.UTC(d.getUTCFullYear(), 0, 1);
  return utcDay.count(y9 - 1, d);
}
function utcWeekNum10(d) {
  const y9 = Date.UTC(d.getUTCFullYear(), 0, 1);
  return utcSunday.count(y9 - 1, d);
}
function utcFirst10(y9) {
  t012.setTime(Date.UTC(y9, 0, 1));
  return t012.getUTCDay();
}
function weekday10(week3, day, firstDay) {
  return day + week3 * 7 - (firstDay + 6) % 7;
}
var localGet10 = {
  [YEAR10]: (d) => d.getFullYear(),
  [QUARTER10]: (d) => Math.floor(d.getMonth() / 3),
  [MONTH10]: (d) => d.getMonth(),
  [DATE10]: (d) => d.getDate(),
  [HOURS10]: (d) => d.getHours(),
  [MINUTES10]: (d) => d.getMinutes(),
  [SECONDS10]: (d) => d.getSeconds(),
  [MILLISECONDS10]: (d) => d.getMilliseconds(),
  [DAYOFYEAR10]: (d) => localDayOfYear10(d),
  [WEEK10]: (d) => localWeekNum10(d),
  [WEEK10 + DAY10]: (d, y9) => weekday10(localWeekNum10(d), d.getDay(), localFirst10(y9)),
  [DAY10]: (d, y9) => weekday10(1, d.getDay(), localFirst10(y9))
};
var localInv10 = {
  [QUARTER10]: (q) => 3 * q,
  [WEEK10]: (w8, y9) => weekday10(w8, 0, localFirst10(y9))
};
var utcGet10 = {
  [YEAR10]: (d) => d.getUTCFullYear(),
  [QUARTER10]: (d) => Math.floor(d.getUTCMonth() / 3),
  [MONTH10]: (d) => d.getUTCMonth(),
  [DATE10]: (d) => d.getUTCDate(),
  [HOURS10]: (d) => d.getUTCHours(),
  [MINUTES10]: (d) => d.getUTCMinutes(),
  [SECONDS10]: (d) => d.getUTCSeconds(),
  [MILLISECONDS10]: (d) => d.getUTCMilliseconds(),
  [DAYOFYEAR10]: (d) => utcDayOfYear10(d),
  [WEEK10]: (d) => utcWeekNum10(d),
  [DAY10]: (d, y9) => weekday10(1, d.getUTCDay(), utcFirst10(y9)),
  [WEEK10 + DAY10]: (d, y9) => weekday10(utcWeekNum10(d), d.getUTCDay(), utcFirst10(y9))
};
var utcInv10 = {
  [QUARTER10]: (q) => 3 * q,
  [WEEK10]: (w8, y9) => weekday10(w8, 0, utcFirst10(y9))
};
var timeIntervals10 = {
  [YEAR10]: timeYear,
  [QUARTER10]: timeMonth.every(3),
  [MONTH10]: timeMonth,
  [WEEK10]: timeSunday,
  [DATE10]: timeDay,
  [DAY10]: timeDay,
  [DAYOFYEAR10]: timeDay,
  [HOURS10]: timeHour,
  [MINUTES10]: timeMinute,
  [SECONDS10]: second,
  [MILLISECONDS10]: millisecond
};
var utcIntervals10 = {
  [YEAR10]: utcYear,
  [QUARTER10]: utcMonth.every(3),
  [MONTH10]: utcMonth,
  [WEEK10]: utcSunday,
  [DATE10]: utcDay,
  [DAY10]: utcDay,
  [DAYOFYEAR10]: utcDay,
  [HOURS10]: utcHour,
  [MINUTES10]: utcMinute,
  [SECONDS10]: second,
  [MILLISECONDS10]: millisecond
};
function timeInterval11(unit2) {
  return timeIntervals10[unit2];
}
function utcInterval10(unit2) {
  return utcIntervals10[unit2];
}
function offset6(ival, date2, step) {
  return ival ? ival.offset(date2, step) : void 0;
}
function timeOffset2(unit2, date2, step) {
  return offset6(timeInterval11(unit2), date2, step);
}
function utcOffset2(unit2, date2, step) {
  return offset6(utcInterval10(unit2), date2, step);
}
function sequence2(ival, start, stop2, step) {
  return ival ? ival.range(start, stop2, step) : void 0;
}
function timeSequence2(unit2, start, stop2, step) {
  return sequence2(timeInterval11(unit2), start, stop2, step);
}
function utcSequence2(unit2, start, stop2, step) {
  return sequence2(utcInterval10(unit2), start, stop2, step);
}
var durationSecond11 = 1e3;
var durationMinute11 = durationSecond11 * 60;
var durationHour11 = durationMinute11 * 60;
var durationDay11 = durationHour11 * 24;
var durationWeek11 = durationDay11 * 7;
var durationMonth11 = durationDay11 * 30;
var durationYear11 = durationDay11 * 365;
var Milli10 = [YEAR10, MONTH10, DATE10, HOURS10, MINUTES10, SECONDS10, MILLISECONDS10];
var Seconds10 = Milli10.slice(0, -1);
var Minutes10 = Seconds10.slice(0, -1);
var Hours10 = Minutes10.slice(0, -1);
var Day10 = Hours10.slice(0, -1);
var Week10 = [YEAR10, WEEK10];
var Month10 = [YEAR10, MONTH10];
var Year10 = [YEAR10];
var intervals10 = [[Seconds10, 1, durationSecond11], [Seconds10, 5, 5 * durationSecond11], [Seconds10, 15, 15 * durationSecond11], [Seconds10, 30, 30 * durationSecond11], [Minutes10, 1, durationMinute11], [Minutes10, 5, 5 * durationMinute11], [Minutes10, 15, 15 * durationMinute11], [Minutes10, 30, 30 * durationMinute11], [Hours10, 1, durationHour11], [Hours10, 3, 3 * durationHour11], [Hours10, 6, 6 * durationHour11], [Hours10, 12, 12 * durationHour11], [Day10, 1, durationDay11], [Week10, 1, durationWeek11], [Month10, 1, durationMonth11], [Month10, 3, 3 * durationMonth11], [Year10, 1, durationYear11]];

// node_modules/vega-functions/node_modules/vega-scale/build/vega-scale.js
function bandSpace8(count3, paddingInner2, paddingOuter2) {
  const space = count3 - paddingInner2 + paddingOuter2 * 2;
  return count3 ? space > 0 ? space : 1 : 0;
}
var Identity8 = "identity";
var Linear9 = "linear";
var Log8 = "log";
var Pow8 = "pow";
var Sqrt8 = "sqrt";
var Symlog8 = "symlog";
var Time8 = "time";
var UTC8 = "utc";
var Sequential8 = "sequential";
var Diverging8 = "diverging";
var Quantile9 = "quantile";
var Quantize8 = "quantize";
var Threshold8 = "threshold";
var Ordinal8 = "ordinal";
var Point8 = "point";
var Band8 = "band";
var BinOrdinal8 = "bin-ordinal";
var Continuous8 = "continuous";
var Discrete8 = "discrete";
var Discretizing8 = "discretizing";
var Interpolating8 = "interpolating";
var Temporal8 = "temporal";
function invertRange8(scale19) {
  return function(_) {
    let lo = _[0], hi = _[1], t;
    if (hi < lo) {
      t = lo;
      lo = hi;
      hi = t;
    }
    return [scale19.invert(lo), scale19.invert(hi)];
  };
}
function invertRangeExtent8(scale19) {
  return function(_) {
    const range7 = scale19.range();
    let lo = _[0], hi = _[1], min5 = -1, max5, t, i, n;
    if (hi < lo) {
      t = lo;
      lo = hi;
      hi = t;
    }
    for (i = 0, n = range7.length; i < n; ++i) {
      if (range7[i] >= lo && range7[i] <= hi) {
        if (min5 < 0)
          min5 = i;
        max5 = i;
      }
    }
    if (min5 < 0)
      return void 0;
    lo = scale19.invertExtent(range7[min5]);
    hi = scale19.invertExtent(range7[max5]);
    return [lo[0] === void 0 ? lo[1] : lo[0], hi[1] === void 0 ? hi[0] : hi[1]];
  };
}
function band9() {
  const scale19 = ordinal().unknown(void 0), domain3 = scale19.domain, ordinalRange = scale19.range;
  let range$1 = [0, 1], step, bandwidth2, round2 = false, paddingInner2 = 0, paddingOuter2 = 0, align2 = 0.5;
  delete scale19.unknown;
  function rescale() {
    const n = domain3().length, reverse4 = range$1[1] < range$1[0], stop2 = range$1[1 - reverse4], space = bandSpace8(n, paddingInner2, paddingOuter2);
    let start = range$1[reverse4 - 0];
    step = (stop2 - start) / (space || 1);
    if (round2) {
      step = Math.floor(step);
    }
    start += (stop2 - start - step * (n - paddingInner2)) * align2;
    bandwidth2 = step * (1 - paddingInner2);
    if (round2) {
      start = Math.round(start);
      bandwidth2 = Math.round(bandwidth2);
    }
    const values7 = range(n).map((i) => start + step * i);
    return ordinalRange(reverse4 ? values7.reverse() : values7);
  }
  scale19.domain = function(_) {
    if (arguments.length) {
      domain3(_);
      return rescale();
    } else {
      return domain3();
    }
  };
  scale19.range = function(_) {
    if (arguments.length) {
      range$1 = [+_[0], +_[1]];
      return rescale();
    } else {
      return range$1.slice();
    }
  };
  scale19.rangeRound = function(_) {
    range$1 = [+_[0], +_[1]];
    round2 = true;
    return rescale();
  };
  scale19.bandwidth = function() {
    return bandwidth2;
  };
  scale19.step = function() {
    return step;
  };
  scale19.round = function(_) {
    if (arguments.length) {
      round2 = !!_;
      return rescale();
    } else {
      return round2;
    }
  };
  scale19.padding = function(_) {
    if (arguments.length) {
      paddingOuter2 = Math.max(0, Math.min(1, _));
      paddingInner2 = paddingOuter2;
      return rescale();
    } else {
      return paddingInner2;
    }
  };
  scale19.paddingInner = function(_) {
    if (arguments.length) {
      paddingInner2 = Math.max(0, Math.min(1, _));
      return rescale();
    } else {
      return paddingInner2;
    }
  };
  scale19.paddingOuter = function(_) {
    if (arguments.length) {
      paddingOuter2 = Math.max(0, Math.min(1, _));
      return rescale();
    } else {
      return paddingOuter2;
    }
  };
  scale19.align = function(_) {
    if (arguments.length) {
      align2 = Math.max(0, Math.min(1, _));
      return rescale();
    } else {
      return align2;
    }
  };
  scale19.invertRange = function(_) {
    if (_[0] == null || _[1] == null)
      return;
    const reverse4 = range$1[1] < range$1[0], values7 = reverse4 ? ordinalRange().reverse() : ordinalRange(), n = values7.length - 1;
    let lo = +_[0], hi = +_[1], a4, b6, t;
    if (lo !== lo || hi !== hi)
      return;
    if (hi < lo) {
      t = lo;
      lo = hi;
      hi = t;
    }
    if (hi < values7[0] || lo > range$1[1 - reverse4])
      return;
    a4 = Math.max(0, bisectRight(values7, lo) - 1);
    b6 = lo === hi ? a4 : bisectRight(values7, hi) - 1;
    if (lo - values7[a4] > bandwidth2 + 1e-10)
      ++a4;
    if (reverse4) {
      t = a4;
      a4 = n - b6;
      b6 = n - t;
    }
    return a4 > b6 ? void 0 : domain3().slice(a4, b6 + 1);
  };
  scale19.invert = function(_) {
    const value7 = scale19.invertRange([_, _]);
    return value7 ? value7[0] : value7;
  };
  scale19.copy = function() {
    return band9().domain(domain3()).range(range$1).round(round2).paddingInner(paddingInner2).paddingOuter(paddingOuter2).align(align2);
  };
  return rescale();
}
function pointish8(scale19) {
  const copy4 = scale19.copy;
  scale19.padding = scale19.paddingOuter;
  delete scale19.paddingInner;
  scale19.copy = function() {
    return pointish8(copy4());
  };
  return scale19;
}
function point17() {
  return pointish8(band9().paddingInner(1));
}
var map11 = Array.prototype.map;
function numbers10(_) {
  return map11.call(_, toNumber10);
}
var slice10 = Array.prototype.slice;
function scaleBinOrdinal8() {
  let domain3 = [], range7 = [];
  function scale19(x9) {
    return x9 == null || x9 !== x9 ? void 0 : range7[(bisect_default2(domain3, x9) - 1) % range7.length];
  }
  scale19.domain = function(_) {
    if (arguments.length) {
      domain3 = numbers10(_);
      return scale19;
    } else {
      return domain3.slice();
    }
  };
  scale19.range = function(_) {
    if (arguments.length) {
      range7 = slice10.call(_);
      return scale19;
    } else {
      return range7.slice();
    }
  };
  scale19.tickFormat = function(count3, specifier) {
    return tickFormat(domain3[0], peek10(domain3), count3 == null ? 10 : count3, specifier);
  };
  scale19.copy = function() {
    return scaleBinOrdinal8().domain(scale19.domain()).range(scale19.range());
  };
  return scale19;
}
var scales8 = /* @__PURE__ */ new Map();
var VEGA_SCALE8 = Symbol("vega_scale");
function registerScale8(scale19) {
  scale19[VEGA_SCALE8] = true;
  return scale19;
}
function isRegisteredScale(scale19) {
  return scale19 && scale19[VEGA_SCALE8] === true;
}
function create10(type7, constructor, metadata6) {
  const ctr = function scale19() {
    const s2 = constructor();
    if (!s2.invertRange) {
      s2.invertRange = s2.invert ? invertRange8(s2) : s2.invertExtent ? invertRangeExtent8(s2) : void 0;
    }
    s2.type = type7;
    return registerScale8(s2);
  };
  ctr.metadata = toSet11(array15(metadata6));
  return ctr;
}
function scale13(type7, scale19, metadata6) {
  if (arguments.length > 1) {
    scales8.set(type7, create10(type7, scale19, metadata6));
    return this;
  } else {
    return isValidScaleType8(type7) ? scales8.get(type7) : void 0;
  }
}
scale13(Identity8, identity8);
scale13(Linear9, linear3, Continuous8);
scale13(Log8, log3, [Continuous8, Log8]);
scale13(Pow8, pow3, Continuous8);
scale13(Sqrt8, sqrt2, Continuous8);
scale13(Symlog8, symlog2, Continuous8);
scale13(Time8, time, [Continuous8, Temporal8]);
scale13(UTC8, utcTime, [Continuous8, Temporal8]);
scale13(Sequential8, sequential, [Continuous8, Interpolating8]);
scale13(`${Sequential8}-${Linear9}`, sequential, [Continuous8, Interpolating8]);
scale13(`${Sequential8}-${Log8}`, sequentialLog, [Continuous8, Interpolating8, Log8]);
scale13(`${Sequential8}-${Pow8}`, sequentialPow, [Continuous8, Interpolating8]);
scale13(`${Sequential8}-${Sqrt8}`, sequentialSqrt, [Continuous8, Interpolating8]);
scale13(`${Sequential8}-${Symlog8}`, sequentialSymlog, [Continuous8, Interpolating8]);
scale13(`${Diverging8}-${Linear9}`, diverging, [Continuous8, Interpolating8]);
scale13(`${Diverging8}-${Log8}`, divergingLog, [Continuous8, Interpolating8, Log8]);
scale13(`${Diverging8}-${Pow8}`, divergingPow, [Continuous8, Interpolating8]);
scale13(`${Diverging8}-${Sqrt8}`, divergingSqrt, [Continuous8, Interpolating8]);
scale13(`${Diverging8}-${Symlog8}`, divergingSymlog, [Continuous8, Interpolating8]);
scale13(Quantile9, quantile2, [Discretizing8, Quantile9]);
scale13(Quantize8, quantize, Discretizing8);
scale13(Threshold8, threshold, Discretizing8);
scale13(BinOrdinal8, scaleBinOrdinal8, [Discrete8, Discretizing8]);
scale13(Ordinal8, ordinal, Discrete8);
scale13(Band8, band9, Discrete8);
scale13(Point8, point17, Discrete8);
function isValidScaleType8(type7) {
  return scales8.has(type7);
}
function hasType6(key4, type7) {
  const s2 = scales8.get(key4);
  return s2 && s2.metadata[type7];
}
function isDiscrete5(key4) {
  return hasType6(key4, Discrete8);
}
function isDiscretizing5(key4) {
  return hasType6(key4, Discretizing8);
}
function isLogarithmic6(key4) {
  return hasType6(key4, Log8);
}
function isTemporal5(key4) {
  return hasType6(key4, Temporal8);
}
var scaleProps2 = ["clamp", "base", "constant", "exponent"];
function interpolateColors8(colors10, type7, gamma2) {
  return piecewise(interpolate8(type7 || "rgb", gamma2), colors10);
}
function scaleFraction2(scale$16, min5, max5) {
  const delta = max5 - min5;
  let i, t, s2;
  if (!delta || !Number.isFinite(delta)) {
    return constant13(0.5);
  } else {
    i = (t = scale$16.type).indexOf("-");
    t = i < 0 ? t : t.slice(i + 1);
    s2 = scale13(t)().domain([min5, max5]).range([0, 1]);
    scaleProps2.forEach((m3) => scale$16[m3] ? s2[m3](scale$16[m3]()) : 0);
    return s2;
  }
}
function interpolate8(type7, gamma2) {
  const interp = src_exports[method8(type7)];
  return gamma2 != null && interp && interp.gamma ? interp.gamma(gamma2) : interp;
}
function method8(type7) {
  return "interpolate" + type7.toLowerCase().split("-").map((s2) => s2[0].toUpperCase() + s2.slice(1)).join("");
}
var continuous9 = {
  blues: "cfe1f2bed8eca8cee58fc1de74b2d75ba3cf4592c63181bd206fb2125ca40a4a90",
  greens: "d3eecdc0e6baabdda594d3917bc77d60ba6c46ab5e329a512089430e7735036429",
  greys: "e2e2e2d4d4d4c4c4c4b1b1b19d9d9d8888887575756262624d4d4d3535351e1e1e",
  oranges: "fdd8b3fdc998fdb87bfda55efc9244f87f2cf06b18e4580bd14904b93d029f3303",
  purples: "e2e1efd4d4e8c4c5e0b4b3d6a3a0cc928ec3827cb97566ae684ea25c3696501f8c",
  reds: "fdc9b4fcb49afc9e80fc8767fa7051f6573fec3f2fdc2a25c81b1db21218970b13",
  blueGreen: "d5efedc1e8e0a7ddd18bd2be70c6a958ba9144ad77319c5d2089460e7736036429",
  bluePurple: "ccddecbad0e4a8c2dd9ab0d4919cc98d85be8b6db28a55a6873c99822287730f71",
  greenBlue: "d3eecec5e8c3b1e1bb9bd8bb82cec269c2ca51b2cd3c9fc7288abd1675b10b60a1",
  orangeRed: "fddcaffdcf9bfdc18afdad77fb9562f67d53ee6545e24932d32d1ebf130da70403",
  purpleBlue: "dbdaebc8cee4b1c3de97b7d87bacd15b9fc93a90c01e7fb70b70ab056199045281",
  purpleBlueGreen: "dbd8eac8cee4b0c3de93b7d872acd1549fc83892bb1c88a3097f8702736b016353",
  purpleRed: "dcc9e2d3b3d7ce9eccd186c0da6bb2e14da0e23189d91e6fc61159ab07498f023a",
  redPurple: "fccfccfcbec0faa9b8f98faff571a5ec539ddb3695c41b8aa908808d0179700174",
  yellowGreen: "e4f4acd1eca0b9e2949ed68880c97c62bb6e47aa5e3297502083440e723b036034",
  yellowOrangeBrown: "feeaa1fedd84fecc63feb746fca031f68921eb7215db5e0bc54c05ab3d038f3204",
  yellowOrangeRed: "fee087fed16ffebd59fea849fd903efc7335f9522bee3423de1b20ca0b22af0225",
  blueOrange: "134b852f78b35da2cb9dcae1d2e5eff2f0ebfce0bafbbf74e8932fc5690d994a07",
  brownBlueGreen: "704108a0651ac79548e3c78af3e6c6eef1eac9e9e48ed1c74da79e187a72025147",
  purpleGreen: "5b1667834792a67fb6c9aed3e6d6e8eff0efd9efd5aedda971bb75368e490e5e29",
  purpleOrange: "4114696647968f83b7b9b4d6dadbebf3eeeafce0bafbbf74e8932fc5690d994a07",
  redBlue: "8c0d25bf363adf745ef4ae91fbdbc9f2efeed2e5ef9dcae15da2cb2f78b3134b85",
  redGrey: "8c0d25bf363adf745ef4ae91fcdccbfaf4f1e2e2e2c0c0c0969696646464343434",
  yellowGreenBlue: "eff9bddbf1b4bde5b594d5b969c5be45b4c22c9ec02182b82163aa23479c1c3185",
  redYellowBlue: "a50026d4322cf16e43fcac64fedd90faf8c1dcf1ecabd6e875abd04a74b4313695",
  redYellowGreen: "a50026d4322cf16e43fcac63fedd8df9f7aed7ee8ea4d86e64bc6122964f006837",
  pinkYellowGreen: "8e0152c0267edd72adf0b3d6faddedf5f3efe1f2cab6de8780bb474f9125276419",
  spectral: "9e0142d13c4bf0704afcac63fedd8dfbf8b0e0f3a1a9dda269bda94288b55e4fa2",
  viridis: "440154470e61481a6c482575472f7d443a834144873d4e8a39568c35608d31688e2d708e2a788e27818e23888e21918d1f988b1fa08822a8842ab07f35b77943bf7154c56866cc5d7ad1518fd744a5db36bcdf27d2e21be9e51afde725",
  magma: "0000040404130b0924150e3720114b2c11603b0f704a107957157e651a80721f817f24828c29819a2e80a8327db6377ac43c75d1426fde4968e95462f1605df76f5cfa7f5efc8f65fe9f6dfeaf78febf84fece91fddea0fcedaffcfdbf",
  inferno: "0000040403130c0826170c3b240c4f330a5f420a68500d6c5d126e6b176e781c6d86216b932667a12b62ae305cbb3755c73e4cd24644dd513ae65c30ed6925f3771af8850ffb9506fca50afcb519fac62df6d645f2e661f3f484fcffa4",
  plasma: "0d088723069033059742039d5002a25d01a66a00a87801a88405a7900da49c179ea72198b12a90ba3488c33d80cb4779d35171da5a69e16462e76e5bed7953f2834cf68f44fa9a3dfca636fdb32ffec029fcce25f9dc24f5ea27f0f921",
  cividis: "00205100235800265d002961012b65042e670831690d346b11366c16396d1c3c6e213f6e26426e2c456e31476e374a6e3c4d6e42506e47536d4c566d51586e555b6e5a5e6e5e616e62646f66676f6a6a706e6d717270717573727976737c79747f7c75827f758682768985778c8877908b78938e789691789a94789e9778a19b78a59e77a9a177aea575b2a874b6ab73bbaf71c0b26fc5b66dc9b96acebd68d3c065d8c462ddc85fe2cb5ce7cf58ebd355f0d652f3da4ff7de4cfae249fce647",
  rainbow: "6e40aa883eb1a43db3bf3cafd83fa4ee4395fe4b83ff576eff6659ff7847ff8c38f3a130e2b72fcfcc36bee044aff05b8ff4576ff65b52f6673af27828ea8d1ddfa319d0b81cbecb23abd82f96e03d82e14c6edb5a5dd0664dbf6e40aa",
  sinebow: "ff4040fc582af47218e78d0bd5a703bfbf00a7d5038de70b72f41858fc2a40ff402afc5818f4720be78d03d5a700bfbf03a7d50b8de71872f42a58fc4040ff582afc7218f48d0be7a703d5bf00bfd503a7e70b8df41872fc2a58ff4040",
  turbo: "23171b32204a3e2a71453493493eae4b49c54a53d7485ee44569ee4074f53c7ff8378af93295f72e9ff42ba9ef28b3e926bce125c5d925cdcf27d5c629dcbc2de3b232e9a738ee9d3ff39347f68950f9805afc7765fd6e70fe667cfd5e88fc5795fb51a1f84badf545b9f140c5ec3cd0e637dae034e4d931ecd12ef4c92bfac029ffb626ffad24ffa223ff9821ff8d1fff821dff771cfd6c1af76118f05616e84b14df4111d5380fcb2f0dc0260ab61f07ac1805a313029b0f00950c00910b00",
  browns: "eedbbdecca96e9b97ae4a865dc9856d18954c7784cc0673fb85536ad44339f3632",
  tealBlues: "bce4d89dd3d181c3cb65b3c245a2b9368fae347da0306a932c5985",
  teals: "bbdfdfa2d4d58ac9c975bcbb61b0af4da5a43799982b8b8c1e7f7f127273006667",
  warmGreys: "dcd4d0cec5c1c0b8b4b3aaa7a59c9998908c8b827f7e7673726866665c5a59504e",
  goldGreen: "f4d166d5ca60b6c35c98bb597cb25760a6564b9c533f8f4f33834a257740146c36",
  goldOrange: "f4d166f8be5cf8aa4cf5983bf3852aef701be2621fd65322c54923b142239e3a26",
  goldRed: "f4d166f6be59f9aa51fc964ef6834bee734ae56249db5247cf4244c43141b71d3e",
  lightGreyRed: "efe9e6e1dad7d5cbc8c8bdb9bbaea9cd967ddc7b43e15f19df4011dc000b",
  lightGreyTeal: "e4eaead6dcddc8ced2b7c2c7a6b4bc64b0bf22a6c32295c11f85be1876bc",
  lightMulti: "e0f1f2c4e9d0b0de9fd0e181f6e072f6c053f3993ef77440ef4a3c",
  lightOrange: "f2e7daf7d5baf9c499fab184fa9c73f68967ef7860e8645bde515bd43d5b",
  lightTealBlue: "e3e9e0c0dccf9aceca7abfc859afc0389fb9328dad2f7ca0276b95255988",
  darkBlue: "3232322d46681a5c930074af008cbf05a7ce25c0dd38daed50f3faffffff",
  darkGold: "3c3c3c584b37725e348c7631ae8b2bcfa424ecc31ef9de30fff184ffffff",
  darkGreen: "3a3a3a215748006f4d048942489e4276b340a6c63dd2d836ffeb2cffffaa",
  darkMulti: "3737371f5287197d8c29a86995ce3fffe800ffffff",
  darkRed: "3434347036339e3c38cc4037e75d1eec8620eeab29f0ce32ffeb2c"
};
var discrete8 = {
  accent: Accent_default,
  category10: category10_default,
  category20: "1f77b4aec7e8ff7f0effbb782ca02c98df8ad62728ff98969467bdc5b0d58c564bc49c94e377c2f7b6d27f7f7fc7c7c7bcbd22dbdb8d17becf9edae5",
  category20b: "393b795254a36b6ecf9c9ede6379398ca252b5cf6bcedb9c8c6d31bd9e39e7ba52e7cb94843c39ad494ad6616be7969c7b4173a55194ce6dbdde9ed6",
  category20c: "3182bd6baed69ecae1c6dbefe6550dfd8d3cfdae6bfdd0a231a35474c476a1d99bc7e9c0756bb19e9ac8bcbddcdadaeb636363969696bdbdbdd9d9d9",
  dark2: Dark2_default,
  observable10: observable10_default,
  paired: Paired_default,
  pastel1: Pastel1_default,
  pastel2: Pastel2_default,
  set1: Set1_default,
  set2: Set2_default,
  set3: Set3_default,
  tableau10: "4c78a8f58518e4575672b7b254a24beeca3bb279a2ff9da69d755dbab0ac",
  tableau20: "4c78a89ecae9f58518ffbf7954a24b88d27ab79a20f2cf5b43989483bcb6e45756ff9d9879706ebab0acd67195fcbfd2b279a2d6a5c99e765fd8b5a5"
};
function colors8(palette) {
  if (isArray16(palette))
    return palette;
  const n = palette.length / 6 | 0, c5 = new Array(n);
  for (let i = 0; i < n; ) {
    c5[i] = "#" + palette.slice(i * 6, ++i * 6);
  }
  return c5;
}
function apply8(_, f) {
  for (const k3 in _)
    scheme35(k3, f(_[k3]));
}
var schemes8 = {};
apply8(discrete8, colors8);
apply8(continuous9, (_) => interpolateColors8(colors8(_)));
function scheme35(name, scheme38) {
  name = name && name.toLowerCase();
  if (arguments.length > 1) {
    schemes8[name] = scheme38;
    return this;
  } else {
    return schemes8[name];
  }
}
var SymbolLegend6 = "symbol";
var DiscreteLegend6 = "discrete";
var defaultFormatter6 = (value7) => isArray16(value7) ? value7.map((v2) => String(v2)) : String(value7);
var ascending10 = (a4, b6) => a4[1] - b6[1];
var descending7 = (a4, b6) => b6[1] - a4[1];
function validTicks6(scale19, ticks2, count3) {
  let range7 = scale19.range(), lo = range7[0], hi = peek10(range7), cmp = ascending10;
  if (lo > hi) {
    range7 = hi;
    hi = lo;
    lo = range7;
    cmp = descending7;
  }
  lo = Math.floor(lo);
  hi = Math.ceil(hi);
  ticks2 = ticks2.map((v2) => [v2, scale19(v2)]).filter((_) => lo <= _[1] && _[1] <= hi).sort(cmp).map((_) => _[0]);
  if (count3 > 0 && ticks2.length > 1) {
    const endpoints = [ticks2[0], peek10(ticks2)];
    while (ticks2.length > count3 && ticks2.length >= 3) {
      ticks2 = ticks2.filter((_, i) => !(i % 2));
    }
    if (ticks2.length < 3) {
      ticks2 = endpoints;
    }
  }
  return ticks2;
}
function tickValues6(scale19, count3) {
  return scale19.bins ? validTicks6(scale19, scale19.bins, count3) : scale19.ticks ? scale19.ticks(count3) : scale19.domain();
}
function tickFormat7(locale5, scale19, count3, specifier, formatType, noSkip) {
  const type7 = scale19.type;
  let format14 = defaultFormatter6;
  if (type7 === Time8 || formatType === Time8) {
    format14 = locale5.timeFormat(specifier);
  } else if (type7 === UTC8 || formatType === UTC8) {
    format14 = locale5.utcFormat(specifier);
  } else if (isLogarithmic6(type7)) {
    const varfmt = locale5.formatFloat(specifier);
    if (noSkip || scale19.bins) {
      format14 = varfmt;
    } else {
      const test2 = tickLog6(scale19, count3, false);
      format14 = (_) => test2(_) ? varfmt(_) : "";
    }
  } else if (scale19.tickFormat) {
    const d = scale19.domain();
    format14 = locale5.formatSpan(d[0], d[d.length - 1], count3, specifier);
  } else if (specifier) {
    format14 = locale5.format(specifier);
  }
  return format14;
}
function tickLog6(scale19, count3, values7) {
  const ticks2 = tickValues6(scale19, count3), base = scale19.base(), logb = Math.log(base), k3 = Math.max(1, base * count3 / ticks2.length);
  const test2 = (d) => {
    let i = d / Math.pow(base, Math.round(Math.log(d) / logb));
    if (i * base < base - 0.5)
      i *= base;
    return i <= k3;
  };
  return values7 ? ticks2.filter(test2) : test2;
}
var symbols12 = {
  [Quantile9]: "quantiles",
  [Quantize8]: "thresholds",
  [Threshold8]: "domain"
};
var formats10 = {
  [Quantile9]: "quantiles",
  [Quantize8]: "domain"
};
function labelValues6(scale19, count3) {
  return scale19.bins ? binValues6(scale19.bins) : scale19.type === Log8 ? tickLog6(scale19, count3, true) : symbols12[scale19.type] ? thresholdValues6(scale19[symbols12[scale19.type]]()) : tickValues6(scale19, count3);
}
function thresholdFormat6(locale5, scale19, specifier) {
  const _ = scale19[formats10[scale19.type]](), n = _.length;
  let d = n > 1 ? _[1] - _[0] : _[0], i;
  for (i = 1; i < n; ++i) {
    d = Math.min(d, _[i] - _[i - 1]);
  }
  return locale5.formatSpan(0, d, 3 * 10, specifier);
}
function thresholdValues6(thresholds) {
  const values7 = [-Infinity].concat(thresholds);
  values7.max = Infinity;
  return values7;
}
function binValues6(bins2) {
  const values7 = bins2.slice(0, -1);
  values7.max = peek10(bins2);
  return values7;
}
var isDiscreteRange6 = (scale19) => symbols12[scale19.type] || scale19.bins;
function labelFormat6(locale5, scale19, count3, type7, specifier, formatType, noSkip) {
  const format14 = formats10[scale19.type] && formatType !== Time8 && formatType !== UTC8 ? thresholdFormat6(locale5, scale19, specifier) : tickFormat7(locale5, scale19, count3, specifier, formatType, noSkip);
  return type7 === SymbolLegend6 && isDiscreteRange6(scale19) ? formatRange6(format14) : type7 === DiscreteLegend6 ? formatDiscrete6(format14) : formatPoint6(format14);
}
var formatRange6 = (format14) => (value7, index4, array22) => {
  const limit = get21(array22[index4 + 1], get21(array22.max, Infinity)), lo = formatValue6(value7, format14), hi = formatValue6(limit, format14);
  return lo && hi ? lo + " – " + hi : hi ? "< " + hi : "≥ " + lo;
};
var get21 = (value7, dflt) => value7 != null ? value7 : dflt;
var formatDiscrete6 = (format14) => (value7, index4) => index4 ? format14(value7) : null;
var formatPoint6 = (format14) => (value7) => format14(value7);
var formatValue6 = (value7, format14) => Number.isFinite(value7) ? format14(value7) : null;
function format11(locale5, scale19, specifier, formatType) {
  const type7 = formatType || scale19.type;
  if (isString9(specifier) && isTemporal5(type7)) {
    specifier = specifier.replace(/%a/g, "%A").replace(/%b/g, "%B");
  }
  return !specifier && type7 === Time8 ? locale5.timeFormat("%A, %d %B %Y, %X") : !specifier && type7 === UTC8 ? locale5.utcFormat("%A, %d %B %Y, %X UTC") : labelFormat6(locale5, scale19, 5, null, specifier, formatType, true);
}
function domainCaption5(locale5, scale19, opt) {
  opt = opt || {};
  const max5 = Math.max(3, opt.maxlen || 7), fmt = format11(locale5, scale19, opt.format, opt.formatType);
  if (isDiscretizing5(scale19.type)) {
    const v2 = labelValues6(scale19).slice(1).map(fmt), n = v2.length;
    return `${n} boundar${n === 1 ? "y" : "ies"}: ${v2.join(", ")}`;
  } else if (isDiscrete5(scale19.type)) {
    const d = scale19.domain(), n = d.length, v2 = n > max5 ? d.slice(0, max5 - 2).map(fmt).join(", ") + ", ending with " + d.slice(-1).map(fmt) : d.map(fmt).join(", ");
    return `${n} value${n === 1 ? "" : "s"}: ${v2}`;
  } else {
    const d = scale19.domain();
    return `values from ${fmt(d[0])} to ${fmt(peek10(d))}`;
  }
}

// node_modules/vega-functions/node_modules/vega-canvas/build/vega-canvas.browser.js
function domCanvas7(w8, h6) {
  if (typeof document !== "undefined" && document.createElement) {
    const c5 = document.createElement("canvas");
    if (c5 && c5.getContext) {
      c5.width = w8;
      c5.height = h6;
      return c5;
    }
  }
  return null;
}
var domImage5 = () => typeof Image !== "undefined" ? Image : null;

// node_modules/vega-functions/node_modules/vega-format/build/vega-format.js
function memoize6(method10) {
  const cache2 = {};
  return (spec) => cache2[spec] || (cache2[spec] = method10(spec));
}
function trimZeroes6(numberFormat2, decimalChar) {
  return (x9) => {
    const str = numberFormat2(x9), dec = str.indexOf(decimalChar);
    if (dec < 0)
      return str;
    let idx = rightmostDigit6(str, dec);
    const end = idx < str.length ? str.slice(idx) : "";
    while (--idx > dec)
      if (str[idx] !== "0") {
        ++idx;
        break;
      }
    return str.slice(0, idx) + end;
  };
}
function rightmostDigit6(str, dec) {
  let i = str.lastIndexOf("e"), c5;
  if (i > 0)
    return i;
  for (i = str.length; --i > dec; ) {
    c5 = str.charCodeAt(i);
    if (c5 >= 48 && c5 <= 57)
      return i + 1;
  }
}
function numberLocale6(locale5) {
  const format14 = memoize6(locale5.format), formatPrefix2 = locale5.formatPrefix;
  return {
    format: format14,
    formatPrefix: formatPrefix2,
    formatFloat(spec) {
      const s2 = formatSpecifier(spec || ",");
      if (s2.precision == null) {
        s2.precision = 12;
        switch (s2.type) {
          case "%":
            s2.precision -= 2;
            break;
          case "e":
            s2.precision -= 1;
            break;
        }
        return trimZeroes6(
          format14(s2),
          // number format
          format14(".1f")(1)[1]
          // decimal point character
        );
      } else {
        return format14(s2);
      }
    },
    formatSpan(start, stop2, count3, specifier) {
      specifier = formatSpecifier(specifier == null ? ",f" : specifier);
      const step = tickStep(start, stop2, count3), value7 = Math.max(Math.abs(start), Math.abs(stop2));
      let precision;
      if (specifier.precision == null) {
        switch (specifier.type) {
          case "s": {
            if (!isNaN(precision = precisionPrefix_default(step, value7))) {
              specifier.precision = precision;
            }
            return formatPrefix2(specifier, value7);
          }
          case "":
          case "e":
          case "g":
          case "p":
          case "r": {
            if (!isNaN(precision = precisionRound_default(step, value7))) {
              specifier.precision = precision - (specifier.type === "e");
            }
            break;
          }
          case "f":
          case "%": {
            if (!isNaN(precision = precisionFixed_default(step))) {
              specifier.precision = precision - (specifier.type === "%") * 2;
            }
            break;
          }
        }
      }
      return format14(specifier);
    }
  };
}
var defaultNumberLocale6;
resetNumberFormatDefaultLocale6();
function resetNumberFormatDefaultLocale6() {
  return defaultNumberLocale6 = numberLocale6({
    format,
    formatPrefix
  });
}
function timeMultiFormat6(format14, interval3, spec) {
  spec = spec || {};
  if (!isObject9(spec)) {
    error16(`Invalid time multi-format specifier: ${spec}`);
  }
  const second2 = interval3(SECONDS10), minute = interval3(MINUTES10), hour = interval3(HOURS10), day = interval3(DATE10), week3 = interval3(WEEK10), month = interval3(MONTH10), quarter3 = interval3(QUARTER10), year = interval3(YEAR10), L = format14(spec[MILLISECONDS10] || ".%L"), S = format14(spec[SECONDS10] || ":%S"), M2 = format14(spec[MINUTES10] || "%I:%M"), H = format14(spec[HOURS10] || "%I %p"), d = format14(spec[DATE10] || spec[DAY10] || "%a %d"), w8 = format14(spec[WEEK10] || "%b %d"), m3 = format14(spec[MONTH10] || "%B"), q = format14(spec[QUARTER10] || "%B"), y9 = format14(spec[YEAR10] || "%Y");
  return (date2) => (second2(date2) < date2 ? L : minute(date2) < date2 ? S : hour(date2) < date2 ? M2 : day(date2) < date2 ? H : month(date2) < date2 ? week3(date2) < date2 ? d : w8 : year(date2) < date2 ? quarter3(date2) < date2 ? m3 : q : y9)(date2);
}
function timeLocale6(locale5) {
  const timeFormat4 = memoize6(locale5.format), utcFormat3 = memoize6(locale5.utcFormat);
  return {
    timeFormat: (spec) => isString9(spec) ? timeFormat4(spec) : timeMultiFormat6(timeFormat4, timeInterval11, spec),
    utcFormat: (spec) => isString9(spec) ? utcFormat3(spec) : timeMultiFormat6(utcFormat3, utcInterval10, spec),
    timeParse: memoize6(locale5.parse),
    utcParse: memoize6(locale5.utcParse)
  };
}
var defaultTimeLocale6;
resetTimeFormatDefaultLocale6();
function resetTimeFormatDefaultLocale6() {
  return defaultTimeLocale6 = timeLocale6({
    format: timeFormat,
    parse: timeParse,
    utcFormat,
    utcParse
  });
}

// node_modules/vega-functions/node_modules/vega-loader/build/vega-loader.browser.js
var protocol_re6 = /^(data:|([A-Za-z]+:)?\/\/)/;
var allowed_re6 = /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp|file|data):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i;
var whitespace_re6 = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205f\u3000]/g;
var fileProtocol6 = "file://";
function loaderFactory6(fs) {
  return (options) => ({
    options: options || {},
    sanitize: sanitize6,
    load: load6,
    fileAccess: false,
    file: fileLoader6(),
    http: httpLoader6
  });
}
async function load6(uri, options) {
  const opt = await this.sanitize(uri, options), url = opt.href;
  return opt.localFile ? this.file(url) : this.http(url, options == null ? void 0 : options.http);
}
async function sanitize6(uri, options) {
  options = extend17({}, this.options, options);
  const fileAccess = this.fileAccess, result = {
    href: null
  };
  let isFile, loadFile, base;
  const isAllowed = allowed_re6.test(uri.replace(whitespace_re6, ""));
  if (uri == null || typeof uri !== "string" || !isAllowed) {
    error16("Sanitize failure, invalid URI: " + $7(uri));
  }
  const hasProtocol = protocol_re6.test(uri);
  if ((base = options.baseURL) && !hasProtocol) {
    if (!uri.startsWith("/") && !base.endsWith("/")) {
      uri = "/" + uri;
    }
    uri = base + uri;
  }
  loadFile = (isFile = uri.startsWith(fileProtocol6)) || options.mode === "file" || options.mode !== "http" && !hasProtocol && fileAccess;
  if (isFile) {
    uri = uri.slice(fileProtocol6.length);
  } else if (uri.startsWith("//")) {
    if (options.defaultProtocol === "file") {
      uri = uri.slice(2);
      loadFile = true;
    } else {
      uri = (options.defaultProtocol || "http") + ":" + uri;
    }
  }
  Object.defineProperty(result, "localFile", {
    value: !!loadFile
  });
  result.href = uri;
  if (options.target) {
    result.target = options.target + "";
  }
  if (options.rel) {
    result.rel = options.rel + "";
  }
  if (options.context === "image" && options.crossOrigin) {
    result.crossOrigin = options.crossOrigin + "";
  }
  return result;
}
function fileLoader6(fs) {
  return fileReject6;
}
async function fileReject6() {
  error16("No file system access.");
}
async function httpLoader6(url, options) {
  const opt = extend17({}, this.options.http, options), type7 = options && options.response, response = await fetch(url, opt);
  return !response.ok ? error16(response.status + "" + response.statusText) : isFunction11(response[type7]) ? response[type7]() : response.text();
}
function delimitedFormat6(delimiter) {
  const parse12 = function(data3, format14) {
    const delim = {
      delimiter
    };
    return dsv6(data3, format14 ? extend17(format14, delim) : delim);
  };
  parse12.responseType = "text";
  return parse12;
}
function dsv6(data3, format14) {
  if (format14.header) {
    data3 = format14.header.map($7).join(format14.delimiter) + "\n" + data3;
  }
  return dsv_default(format14.delimiter).parse(data3 + "");
}
dsv6.responseType = "text";
function isBuffer6(_) {
  return typeof Buffer === "function" && isFunction11(Buffer.isBuffer) ? Buffer.isBuffer(_) : false;
}
function json6(data3, format14) {
  const prop = format14 && format14.property ? field16(format14.property) : identity20;
  return isObject9(data3) && !isBuffer6(data3) ? parseJSON6(prop(data3), format14) : prop(JSON.parse(data3));
}
json6.responseType = "json";
function parseJSON6(data3, format14) {
  if (!isArray16(data3) && isIterable6(data3)) {
    data3 = [...data3];
  }
  return format14 && format14.copy ? JSON.parse(JSON.stringify(data3)) : data3;
}
var filters6 = {
  interior: (a4, b6) => a4 !== b6,
  exterior: (a4, b6) => a4 === b6
};
function topojson6(data3, format14) {
  let method10, object2, property2, filter4;
  data3 = json6(data3, format14);
  if (format14 && format14.feature) {
    method10 = feature_default;
    property2 = format14.feature;
  } else if (format14 && format14.mesh) {
    method10 = mesh_default;
    property2 = format14.mesh;
    filter4 = filters6[format14.filter];
  } else {
    error16("Missing TopoJSON feature or mesh parameter.");
  }
  object2 = (object2 = data3.objects[property2]) ? method10(data3, object2, filter4) : error16("Invalid TopoJSON object: " + property2);
  return object2 && object2.features || [object2];
}
topojson6.responseType = "json";
var format12 = {
  dsv: dsv6,
  csv: delimitedFormat6(","),
  tsv: delimitedFormat6("	"),
  json: json6,
  topojson: topojson6
};
var loader6 = loaderFactory6();

// node_modules/vega-functions/node_modules/vega-scenegraph/build/vega-scenegraph.js
var gradient_id5 = 0;
var patternPrefix5 = "p_";
function isGradient5(value7) {
  return value7 && value7.gradient;
}
function gradientRef5(g, defs, base) {
  const type7 = g.gradient;
  let id24 = g.id, prefix = type7 === "radial" ? patternPrefix5 : "";
  if (!id24) {
    id24 = g.id = "gradient_" + gradient_id5++;
    if (type7 === "radial") {
      g.x1 = get22(g.x1, 0.5);
      g.y1 = get22(g.y1, 0.5);
      g.r1 = get22(g.r1, 0);
      g.x2 = get22(g.x2, 0.5);
      g.y2 = get22(g.y2, 0.5);
      g.r2 = get22(g.r2, 0.5);
      prefix = patternPrefix5;
    } else {
      g.x1 = get22(g.x1, 0);
      g.y1 = get22(g.y1, 0);
      g.x2 = get22(g.x2, 1);
      g.y2 = get22(g.y2, 0);
    }
  }
  defs[id24] = g;
  return "url(" + (base || "") + "#" + prefix + id24 + ")";
}
function get22(val, def6) {
  return val != null ? val : def6;
}
function Gradient2(p02, p1) {
  var stops = [], gradient8;
  return gradient8 = {
    gradient: "linear",
    x1: p02 ? p02[0] : 0,
    y1: p02 ? p02[1] : 0,
    x2: p1 ? p1[0] : 1,
    y2: p1 ? p1[1] : 0,
    stops,
    stop: function(offset9, color9) {
      stops.push({
        offset: offset9,
        color: color9
      });
      return gradient8;
    }
  };
}
var lookup7 = {
  "basis": {
    curve: basis_default
  },
  "basis-closed": {
    curve: basisClosed_default
  },
  "basis-open": {
    curve: basisOpen_default
  },
  "bundle": {
    curve: bundle_default,
    tension: "beta",
    value: 0.85
  },
  "cardinal": {
    curve: cardinal_default,
    tension: "tension",
    value: 0
  },
  "cardinal-open": {
    curve: cardinalOpen_default,
    tension: "tension",
    value: 0
  },
  "cardinal-closed": {
    curve: cardinalClosed_default,
    tension: "tension",
    value: 0
  },
  "catmull-rom": {
    curve: catmullRom_default,
    tension: "alpha",
    value: 0.5
  },
  "catmull-rom-closed": {
    curve: catmullRomClosed_default,
    tension: "alpha",
    value: 0.5
  },
  "catmull-rom-open": {
    curve: catmullRomOpen_default,
    tension: "alpha",
    value: 0.5
  },
  "linear": {
    curve: linear_default
  },
  "linear-closed": {
    curve: linearClosed_default
  },
  "monotone": {
    horizontal: monotoneY,
    vertical: monotoneX
  },
  "natural": {
    curve: natural_default
  },
  "step": {
    curve: step_default
  },
  "step-after": {
    curve: stepAfter
  },
  "step-before": {
    curve: stepBefore
  }
};
function curves5(type7, orientation, tension) {
  var entry2 = has13(lookup7, type7) && lookup7[type7], curve2 = null;
  if (entry2) {
    curve2 = entry2.curve || entry2[orientation || "vertical"];
    if (entry2.tension && tension != null) {
      curve2 = curve2[entry2.tension](tension);
    }
  }
  return curve2;
}
var paramCounts5 = {
  m: 2,
  l: 2,
  h: 1,
  v: 1,
  z: 0,
  c: 6,
  s: 4,
  q: 4,
  t: 2,
  a: 7
};
var commandPattern5 = /[mlhvzcsqta]([^mlhvzcsqta]+|$)/gi;
var numberPattern5 = /^[+-]?(([0-9]*\.[0-9]+)|([0-9]+\.)|([0-9]+))([eE][+-]?[0-9]+)?/;
var spacePattern5 = /^((\s+,?\s*)|(,\s*))/;
var flagPattern5 = /^[01]/;
function parse9(path7) {
  const commands = [];
  const matches = path7.match(commandPattern5) || [];
  matches.forEach((str) => {
    let cmd = str[0];
    const type7 = cmd.toLowerCase();
    const paramCount = paramCounts5[type7];
    const params2 = parseParams5(type7, paramCount, str.slice(1).trim());
    const count3 = params2.length;
    if (count3 < paramCount || count3 && count3 % paramCount !== 0) {
      throw Error("Invalid SVG path, incorrect parameter count");
    }
    commands.push([cmd, ...params2.slice(0, paramCount)]);
    if (count3 === paramCount) {
      return;
    }
    if (type7 === "m") {
      cmd = cmd === "M" ? "L" : "l";
    }
    for (let i = paramCount; i < count3; i += paramCount) {
      commands.push([cmd, ...params2.slice(i, i + paramCount)]);
    }
  });
  return commands;
}
function parseParams5(type7, paramCount, segment) {
  const params2 = [];
  for (let index4 = 0; paramCount && index4 < segment.length; ) {
    for (let i = 0; i < paramCount; ++i) {
      const pattern = type7 === "a" && (i === 3 || i === 4) ? flagPattern5 : numberPattern5;
      const match2 = segment.slice(index4).match(pattern);
      if (match2 === null) {
        throw Error("Invalid SVG path, incorrect parameter type");
      }
      index4 += match2[0].length;
      params2.push(+match2[0]);
      const ws = segment.slice(index4).match(spacePattern5);
      if (ws !== null) {
        index4 += ws[0].length;
      }
    }
  }
  return params2;
}
var DegToRad5 = Math.PI / 180;
var Epsilon5 = 1e-14;
var HalfPi5 = Math.PI / 2;
var Tau5 = Math.PI * 2;
var HalfSqrt35 = Math.sqrt(3) / 2;
var segmentCache5 = {};
var bezierCache5 = {};
var join5 = [].join;
function segments5(x9, y9, rx, ry, large, sweep, rotateX, ox, oy) {
  const key4 = join5.call(arguments);
  if (segmentCache5[key4]) {
    return segmentCache5[key4];
  }
  const th = rotateX * DegToRad5;
  const sin_th = Math.sin(th);
  const cos_th = Math.cos(th);
  rx = Math.abs(rx);
  ry = Math.abs(ry);
  const px6 = cos_th * (ox - x9) * 0.5 + sin_th * (oy - y9) * 0.5;
  const py6 = cos_th * (oy - y9) * 0.5 - sin_th * (ox - x9) * 0.5;
  let pl = px6 * px6 / (rx * rx) + py6 * py6 / (ry * ry);
  if (pl > 1) {
    pl = Math.sqrt(pl);
    rx *= pl;
    ry *= pl;
  }
  const a00 = cos_th / rx;
  const a01 = sin_th / rx;
  const a10 = -sin_th / ry;
  const a11 = cos_th / ry;
  const x07 = a00 * ox + a01 * oy;
  const y07 = a10 * ox + a11 * oy;
  const x13 = a00 * x9 + a01 * y9;
  const y13 = a10 * x9 + a11 * y9;
  const d = (x13 - x07) * (x13 - x07) + (y13 - y07) * (y13 - y07);
  let sfactor_sq = 1 / d - 0.25;
  if (sfactor_sq < 0)
    sfactor_sq = 0;
  let sfactor = Math.sqrt(sfactor_sq);
  if (sweep == large)
    sfactor = -sfactor;
  const xc = 0.5 * (x07 + x13) - sfactor * (y13 - y07);
  const yc = 0.5 * (y07 + y13) + sfactor * (x13 - x07);
  const th0 = Math.atan2(y07 - yc, x07 - xc);
  const th1 = Math.atan2(y13 - yc, x13 - xc);
  let th_arc = th1 - th0;
  if (th_arc < 0 && sweep === 1) {
    th_arc += Tau5;
  } else if (th_arc > 0 && sweep === 0) {
    th_arc -= Tau5;
  }
  const segs = Math.ceil(Math.abs(th_arc / (HalfPi5 + 1e-3)));
  const result = [];
  for (let i = 0; i < segs; ++i) {
    const th2 = th0 + i * th_arc / segs;
    const th3 = th0 + (i + 1) * th_arc / segs;
    result[i] = [xc, yc, th2, th3, rx, ry, sin_th, cos_th];
  }
  return segmentCache5[key4] = result;
}
function bezier5(params2) {
  const key4 = join5.call(params2);
  if (bezierCache5[key4]) {
    return bezierCache5[key4];
  }
  var cx = params2[0], cy = params2[1], th0 = params2[2], th1 = params2[3], rx = params2[4], ry = params2[5], sin_th = params2[6], cos_th = params2[7];
  const a00 = cos_th * rx;
  const a01 = -sin_th * ry;
  const a10 = sin_th * rx;
  const a11 = cos_th * ry;
  const cos_th0 = Math.cos(th0);
  const sin_th0 = Math.sin(th0);
  const cos_th1 = Math.cos(th1);
  const sin_th1 = Math.sin(th1);
  const th_half = 0.5 * (th1 - th0);
  const sin_th_h2 = Math.sin(th_half * 0.5);
  const t = 8 / 3 * sin_th_h2 * sin_th_h2 / Math.sin(th_half);
  const x13 = cx + cos_th0 - t * sin_th0;
  const y13 = cy + sin_th0 + t * cos_th0;
  const x32 = cx + cos_th1;
  const y32 = cy + sin_th1;
  const x22 = x32 + t * sin_th1;
  const y22 = y32 - t * cos_th1;
  return bezierCache5[key4] = [a00 * x13 + a01 * y13, a10 * x13 + a11 * y13, a00 * x22 + a01 * y22, a10 * x22 + a11 * y22, a00 * x32 + a01 * y32, a10 * x32 + a11 * y32];
}
var temp5 = ["l", 0, 0, 0, 0, 0, 0, 0];
function scale$15(current2, sX, sY) {
  const c5 = temp5[0] = current2[0];
  if (c5 === "a" || c5 === "A") {
    temp5[1] = sX * current2[1];
    temp5[2] = sY * current2[2];
    temp5[3] = current2[3];
    temp5[4] = current2[4];
    temp5[5] = current2[5];
    temp5[6] = sX * current2[6];
    temp5[7] = sY * current2[7];
  } else if (c5 === "h" || c5 === "H") {
    temp5[1] = sX * current2[1];
  } else if (c5 === "v" || c5 === "V") {
    temp5[1] = sY * current2[1];
  } else {
    for (var i = 1, n = current2.length; i < n; ++i) {
      temp5[i] = (i % 2 == 1 ? sX : sY) * current2[i];
    }
  }
  return temp5;
}
function pathRender5(context7, path7, l, t, sX, sY) {
  var current2, previous = null, x9 = 0, y9 = 0, controlX = 0, controlY = 0, tempX, tempY, tempControlX, tempControlY, anchorX = 0, anchorY = 0;
  if (l == null)
    l = 0;
  if (t == null)
    t = 0;
  if (sX == null)
    sX = 1;
  if (sY == null)
    sY = sX;
  if (context7.beginPath)
    context7.beginPath();
  for (var i = 0, len = path7.length; i < len; ++i) {
    current2 = path7[i];
    if (sX !== 1 || sY !== 1) {
      current2 = scale$15(current2, sX, sY);
    }
    switch (current2[0]) {
      case "l":
        x9 += current2[1];
        y9 += current2[2];
        context7.lineTo(x9 + l, y9 + t);
        break;
      case "L":
        x9 = current2[1];
        y9 = current2[2];
        context7.lineTo(x9 + l, y9 + t);
        break;
      case "h":
        x9 += current2[1];
        context7.lineTo(x9 + l, y9 + t);
        break;
      case "H":
        x9 = current2[1];
        context7.lineTo(x9 + l, y9 + t);
        break;
      case "v":
        y9 += current2[1];
        context7.lineTo(x9 + l, y9 + t);
        break;
      case "V":
        y9 = current2[1];
        context7.lineTo(x9 + l, y9 + t);
        break;
      case "m":
        x9 += current2[1];
        y9 += current2[2];
        anchorX = x9;
        anchorY = y9;
        context7.moveTo(x9 + l, y9 + t);
        break;
      case "M":
        x9 = current2[1];
        y9 = current2[2];
        anchorX = x9;
        anchorY = y9;
        context7.moveTo(x9 + l, y9 + t);
        break;
      case "c":
        tempX = x9 + current2[5];
        tempY = y9 + current2[6];
        controlX = x9 + current2[3];
        controlY = y9 + current2[4];
        context7.bezierCurveTo(
          x9 + current2[1] + l,
          // x1
          y9 + current2[2] + t,
          // y1
          controlX + l,
          // x2
          controlY + t,
          // y2
          tempX + l,
          tempY + t
        );
        x9 = tempX;
        y9 = tempY;
        break;
      case "C":
        x9 = current2[5];
        y9 = current2[6];
        controlX = current2[3];
        controlY = current2[4];
        context7.bezierCurveTo(current2[1] + l, current2[2] + t, controlX + l, controlY + t, x9 + l, y9 + t);
        break;
      case "s":
        tempX = x9 + current2[3];
        tempY = y9 + current2[4];
        controlX = 2 * x9 - controlX;
        controlY = 2 * y9 - controlY;
        context7.bezierCurveTo(controlX + l, controlY + t, x9 + current2[1] + l, y9 + current2[2] + t, tempX + l, tempY + t);
        controlX = x9 + current2[1];
        controlY = y9 + current2[2];
        x9 = tempX;
        y9 = tempY;
        break;
      case "S":
        tempX = current2[3];
        tempY = current2[4];
        controlX = 2 * x9 - controlX;
        controlY = 2 * y9 - controlY;
        context7.bezierCurveTo(controlX + l, controlY + t, current2[1] + l, current2[2] + t, tempX + l, tempY + t);
        x9 = tempX;
        y9 = tempY;
        controlX = current2[1];
        controlY = current2[2];
        break;
      case "q":
        tempX = x9 + current2[3];
        tempY = y9 + current2[4];
        controlX = x9 + current2[1];
        controlY = y9 + current2[2];
        context7.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t);
        x9 = tempX;
        y9 = tempY;
        break;
      case "Q":
        tempX = current2[3];
        tempY = current2[4];
        context7.quadraticCurveTo(current2[1] + l, current2[2] + t, tempX + l, tempY + t);
        x9 = tempX;
        y9 = tempY;
        controlX = current2[1];
        controlY = current2[2];
        break;
      case "t":
        tempX = x9 + current2[1];
        tempY = y9 + current2[2];
        if (previous[0].match(/[QqTt]/) === null) {
          controlX = x9;
          controlY = y9;
        } else if (previous[0] === "t") {
          controlX = 2 * x9 - tempControlX;
          controlY = 2 * y9 - tempControlY;
        } else if (previous[0] === "q") {
          controlX = 2 * x9 - controlX;
          controlY = 2 * y9 - controlY;
        }
        tempControlX = controlX;
        tempControlY = controlY;
        context7.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t);
        x9 = tempX;
        y9 = tempY;
        controlX = x9 + current2[1];
        controlY = y9 + current2[2];
        break;
      case "T":
        tempX = current2[1];
        tempY = current2[2];
        controlX = 2 * x9 - controlX;
        controlY = 2 * y9 - controlY;
        context7.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t);
        x9 = tempX;
        y9 = tempY;
        break;
      case "a":
        drawArc5(context7, x9 + l, y9 + t, [current2[1], current2[2], current2[3], current2[4], current2[5], current2[6] + x9 + l, current2[7] + y9 + t]);
        x9 += current2[6];
        y9 += current2[7];
        break;
      case "A":
        drawArc5(context7, x9 + l, y9 + t, [current2[1], current2[2], current2[3], current2[4], current2[5], current2[6] + l, current2[7] + t]);
        x9 = current2[6];
        y9 = current2[7];
        break;
      case "z":
      case "Z":
        x9 = anchorX;
        y9 = anchorY;
        context7.closePath();
        break;
    }
    previous = current2;
  }
}
function drawArc5(context7, x9, y9, coords) {
  const seg = segments5(
    coords[5],
    // end x
    coords[6],
    // end y
    coords[0],
    // radius x
    coords[1],
    // radius y
    coords[3],
    // large flag
    coords[4],
    // sweep flag
    coords[2],
    // rotation
    x9,
    y9
  );
  for (let i = 0; i < seg.length; ++i) {
    const bez = bezier5(seg[i]);
    context7.bezierCurveTo(bez[0], bez[1], bez[2], bez[3], bez[4], bez[5]);
  }
}
var Tan305 = 0.5773502691896257;
var builtins5 = {
  "circle": {
    draw: function(context7, size) {
      const r = Math.sqrt(size) / 2;
      context7.moveTo(r, 0);
      context7.arc(0, 0, r, 0, Tau5);
    }
  },
  "cross": {
    draw: function(context7, size) {
      var r = Math.sqrt(size) / 2, s2 = r / 2.5;
      context7.moveTo(-r, -s2);
      context7.lineTo(-r, s2);
      context7.lineTo(-s2, s2);
      context7.lineTo(-s2, r);
      context7.lineTo(s2, r);
      context7.lineTo(s2, s2);
      context7.lineTo(r, s2);
      context7.lineTo(r, -s2);
      context7.lineTo(s2, -s2);
      context7.lineTo(s2, -r);
      context7.lineTo(-s2, -r);
      context7.lineTo(-s2, -s2);
      context7.closePath();
    }
  },
  "diamond": {
    draw: function(context7, size) {
      const r = Math.sqrt(size) / 2;
      context7.moveTo(-r, 0);
      context7.lineTo(0, -r);
      context7.lineTo(r, 0);
      context7.lineTo(0, r);
      context7.closePath();
    }
  },
  "square": {
    draw: function(context7, size) {
      var w8 = Math.sqrt(size), x9 = -w8 / 2;
      context7.rect(x9, x9, w8, w8);
    }
  },
  "arrow": {
    draw: function(context7, size) {
      var r = Math.sqrt(size) / 2, s2 = r / 7, t = r / 2.5, v2 = r / 8;
      context7.moveTo(-s2, r);
      context7.lineTo(s2, r);
      context7.lineTo(s2, -v2);
      context7.lineTo(t, -v2);
      context7.lineTo(0, -r);
      context7.lineTo(-t, -v2);
      context7.lineTo(-s2, -v2);
      context7.closePath();
    }
  },
  "wedge": {
    draw: function(context7, size) {
      var r = Math.sqrt(size) / 2, h6 = HalfSqrt35 * r, o = h6 - r * Tan305, b6 = r / 4;
      context7.moveTo(0, -h6 - o);
      context7.lineTo(-b6, h6 - o);
      context7.lineTo(b6, h6 - o);
      context7.closePath();
    }
  },
  "triangle": {
    draw: function(context7, size) {
      var r = Math.sqrt(size) / 2, h6 = HalfSqrt35 * r, o = h6 - r * Tan305;
      context7.moveTo(0, -h6 - o);
      context7.lineTo(-r, h6 - o);
      context7.lineTo(r, h6 - o);
      context7.closePath();
    }
  },
  "triangle-up": {
    draw: function(context7, size) {
      var r = Math.sqrt(size) / 2, h6 = HalfSqrt35 * r;
      context7.moveTo(0, -h6);
      context7.lineTo(-r, h6);
      context7.lineTo(r, h6);
      context7.closePath();
    }
  },
  "triangle-down": {
    draw: function(context7, size) {
      var r = Math.sqrt(size) / 2, h6 = HalfSqrt35 * r;
      context7.moveTo(0, h6);
      context7.lineTo(-r, -h6);
      context7.lineTo(r, -h6);
      context7.closePath();
    }
  },
  "triangle-right": {
    draw: function(context7, size) {
      var r = Math.sqrt(size) / 2, h6 = HalfSqrt35 * r;
      context7.moveTo(h6, 0);
      context7.lineTo(-h6, -r);
      context7.lineTo(-h6, r);
      context7.closePath();
    }
  },
  "triangle-left": {
    draw: function(context7, size) {
      var r = Math.sqrt(size) / 2, h6 = HalfSqrt35 * r;
      context7.moveTo(-h6, 0);
      context7.lineTo(h6, -r);
      context7.lineTo(h6, r);
      context7.closePath();
    }
  },
  "stroke": {
    draw: function(context7, size) {
      const r = Math.sqrt(size) / 2;
      context7.moveTo(-r, 0);
      context7.lineTo(r, 0);
    }
  }
};
function symbols13(_) {
  return has13(builtins5, _) ? builtins5[_] : customSymbol5(_);
}
var custom14 = {};
function customSymbol5(path7) {
  if (!has13(custom14, path7)) {
    const parsed = parse9(path7);
    custom14[path7] = {
      draw: function(context7, size) {
        pathRender5(context7, parsed, 0, 0, Math.sqrt(size) / 2);
      }
    };
  }
  return custom14[path7];
}
var C6 = 0.448084975506;
function rectangleX5(d) {
  return d.x;
}
function rectangleY5(d) {
  return d.y;
}
function rectangleWidth5(d) {
  return d.width;
}
function rectangleHeight5(d) {
  return d.height;
}
function number9(_) {
  return typeof _ === "function" ? _ : () => +_;
}
function clamp5(value7, min5, max5) {
  return Math.max(min5, Math.min(value7, max5));
}
function vg_rect5() {
  var x9 = rectangleX5, y9 = rectangleY5, width2 = rectangleWidth5, height2 = rectangleHeight5, crTL = number9(0), crTR = crTL, crBL = crTL, crBR = crTL, context7 = null;
  function rectangle6(_, x07, y07) {
    var buffer, x13 = x07 != null ? x07 : +x9.call(this, _), y13 = y07 != null ? y07 : +y9.call(this, _), w8 = +width2.call(this, _), h6 = +height2.call(this, _), s2 = Math.min(w8, h6) / 2, tl6 = clamp5(+crTL.call(this, _), 0, s2), tr6 = clamp5(+crTR.call(this, _), 0, s2), bl6 = clamp5(+crBL.call(this, _), 0, s2), br6 = clamp5(+crBR.call(this, _), 0, s2);
    if (!context7)
      context7 = buffer = path();
    if (tl6 <= 0 && tr6 <= 0 && bl6 <= 0 && br6 <= 0) {
      context7.rect(x13, y13, w8, h6);
    } else {
      var x22 = x13 + w8, y22 = y13 + h6;
      context7.moveTo(x13 + tl6, y13);
      context7.lineTo(x22 - tr6, y13);
      context7.bezierCurveTo(x22 - C6 * tr6, y13, x22, y13 + C6 * tr6, x22, y13 + tr6);
      context7.lineTo(x22, y22 - br6);
      context7.bezierCurveTo(x22, y22 - C6 * br6, x22 - C6 * br6, y22, x22 - br6, y22);
      context7.lineTo(x13 + bl6, y22);
      context7.bezierCurveTo(x13 + C6 * bl6, y22, x13, y22 - C6 * bl6, x13, y22 - bl6);
      context7.lineTo(x13, y13 + tl6);
      context7.bezierCurveTo(x13, y13 + C6 * tl6, x13 + C6 * tl6, y13, x13 + tl6, y13);
      context7.closePath();
    }
    if (buffer) {
      context7 = null;
      return buffer + "" || null;
    }
  }
  rectangle6.x = function(_) {
    if (arguments.length) {
      x9 = number9(_);
      return rectangle6;
    } else {
      return x9;
    }
  };
  rectangle6.y = function(_) {
    if (arguments.length) {
      y9 = number9(_);
      return rectangle6;
    } else {
      return y9;
    }
  };
  rectangle6.width = function(_) {
    if (arguments.length) {
      width2 = number9(_);
      return rectangle6;
    } else {
      return width2;
    }
  };
  rectangle6.height = function(_) {
    if (arguments.length) {
      height2 = number9(_);
      return rectangle6;
    } else {
      return height2;
    }
  };
  rectangle6.cornerRadius = function(tl6, tr6, br6, bl6) {
    if (arguments.length) {
      crTL = number9(tl6);
      crTR = tr6 != null ? number9(tr6) : crTL;
      crBR = br6 != null ? number9(br6) : crTL;
      crBL = bl6 != null ? number9(bl6) : crTR;
      return rectangle6;
    } else {
      return crTL;
    }
  };
  rectangle6.context = function(_) {
    if (arguments.length) {
      context7 = _ == null ? null : _;
      return rectangle6;
    } else {
      return context7;
    }
  };
  return rectangle6;
}
function vg_trail5() {
  var x9, y9, size, defined2, context7 = null, ready, x13, y13, r1;
  function point21(x22, y22, w22) {
    const r2 = w22 / 2;
    if (ready) {
      var ux = y13 - y22, uy = x22 - x13;
      if (ux || uy) {
        var ud = Math.hypot(ux, uy), rx = (ux /= ud) * r1, ry = (uy /= ud) * r1, t = Math.atan2(uy, ux);
        context7.moveTo(x13 - rx, y13 - ry);
        context7.lineTo(x22 - ux * r2, y22 - uy * r2);
        context7.arc(x22, y22, r2, t - Math.PI, t);
        context7.lineTo(x13 + rx, y13 + ry);
        context7.arc(x13, y13, r1, t, t + Math.PI);
      } else {
        context7.arc(x22, y22, r2, 0, Tau5);
      }
      context7.closePath();
    } else {
      ready = 1;
    }
    x13 = x22;
    y13 = y22;
    r1 = r2;
  }
  function trail7(data3) {
    var i, n = data3.length, d, defined0 = false, buffer;
    if (context7 == null)
      context7 = buffer = path();
    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined2(d = data3[i], i, data3)) === defined0) {
        if (defined0 = !defined0)
          ready = 0;
      }
      if (defined0)
        point21(+x9(d, i, data3), +y9(d, i, data3), +size(d, i, data3));
    }
    if (buffer) {
      context7 = null;
      return buffer + "" || null;
    }
  }
  trail7.x = function(_) {
    if (arguments.length) {
      x9 = _;
      return trail7;
    } else {
      return x9;
    }
  };
  trail7.y = function(_) {
    if (arguments.length) {
      y9 = _;
      return trail7;
    } else {
      return y9;
    }
  };
  trail7.size = function(_) {
    if (arguments.length) {
      size = _;
      return trail7;
    } else {
      return size;
    }
  };
  trail7.defined = function(_) {
    if (arguments.length) {
      defined2 = _;
      return trail7;
    } else {
      return defined2;
    }
  };
  trail7.context = function(_) {
    if (arguments.length) {
      if (_ == null) {
        context7 = null;
      } else {
        context7 = _;
      }
      return trail7;
    } else {
      return context7;
    }
  };
  return trail7;
}
function value$15(a4, b6) {
  return a4 != null ? a4 : b6;
}
var x8 = (item) => item.x || 0;
var y8 = (item) => item.y || 0;
var w6 = (item) => item.width || 0;
var h5 = (item) => item.height || 0;
var xw5 = (item) => (item.x || 0) + (item.width || 0);
var yh5 = (item) => (item.y || 0) + (item.height || 0);
var sa5 = (item) => item.startAngle || 0;
var ea6 = (item) => item.endAngle || 0;
var pa5 = (item) => item.padAngle || 0;
var ir5 = (item) => item.innerRadius || 0;
var or5 = (item) => item.outerRadius || 0;
var cr5 = (item) => item.cornerRadius || 0;
var tl5 = (item) => value$15(item.cornerRadiusTopLeft, item.cornerRadius) || 0;
var tr5 = (item) => value$15(item.cornerRadiusTopRight, item.cornerRadius) || 0;
var br5 = (item) => value$15(item.cornerRadiusBottomRight, item.cornerRadius) || 0;
var bl5 = (item) => value$15(item.cornerRadiusBottomLeft, item.cornerRadius) || 0;
var sz5 = (item) => value$15(item.size, 64);
var ts5 = (item) => item.size || 1;
var def5 = (item) => !(item.defined === false);
var type5 = (item) => symbols13(item.shape || "circle");
var arcShape5 = arc_default().startAngle(sa5).endAngle(ea6).padAngle(pa5).innerRadius(ir5).outerRadius(or5).cornerRadius(cr5);
var areavShape5 = area_default().x(x8).y1(y8).y0(yh5).defined(def5);
var areahShape5 = area_default().y(y8).x1(x8).x0(xw5).defined(def5);
var lineShape5 = line_default().x(x8).y(y8).defined(def5);
var rectShape5 = vg_rect5().x(x8).y(y8).width(w6).height(h5).cornerRadius(tl5, tr5, br5, bl5);
var symbolShape5 = Symbol2().type(type5).size(sz5);
var trailShape5 = vg_trail5().x(x8).y(y8).defined(def5).size(ts5);
function hasCornerRadius5(item) {
  return item.cornerRadius || item.cornerRadiusTopLeft || item.cornerRadiusTopRight || item.cornerRadiusBottomRight || item.cornerRadiusBottomLeft;
}
function arc$15(context7, item) {
  return arcShape5.context(context7)(item);
}
function area$15(context7, items) {
  const item = items[0], interp = item.interpolate || "linear";
  return (item.orient === "horizontal" ? areahShape5 : areavShape5).curve(curves5(interp, item.orient, item.tension)).context(context7)(items);
}
function line$15(context7, items) {
  const item = items[0], interp = item.interpolate || "linear";
  return lineShape5.curve(curves5(interp, item.orient, item.tension)).context(context7)(items);
}
function rectangle5(context7, item, x9, y9) {
  return rectShape5.context(context7)(item, x9, y9);
}
function shape$15(context7, item) {
  return (item.mark.shape || item.shape).context(context7)(item);
}
function symbol$15(context7, item) {
  return symbolShape5.context(context7)(item);
}
function trail$15(context7, items) {
  return trailShape5.context(context7)(items);
}
var clip_id5 = 1;
function clip$15(renderer, item, size) {
  var clip7 = item.clip, defs = renderer._defs, id24 = item.clip_id || (item.clip_id = "clip" + clip_id5++), c5 = defs.clipping[id24] || (defs.clipping[id24] = {
    id: id24
  });
  if (isFunction11(clip7)) {
    c5.path = clip7(null);
  } else if (hasCornerRadius5(size)) {
    c5.path = rectangle5(null, size, 0, 0);
  } else {
    c5.width = size.width || 0;
    c5.height = size.height || 0;
  }
  return "url(#" + id24 + ")";
}
function Bounds5(b6) {
  this.clear();
  if (b6)
    this.union(b6);
}
Bounds5.prototype = {
  clone() {
    return new Bounds5(this);
  },
  clear() {
    this.x1 = +Number.MAX_VALUE;
    this.y1 = +Number.MAX_VALUE;
    this.x2 = -Number.MAX_VALUE;
    this.y2 = -Number.MAX_VALUE;
    return this;
  },
  empty() {
    return this.x1 === +Number.MAX_VALUE && this.y1 === +Number.MAX_VALUE && this.x2 === -Number.MAX_VALUE && this.y2 === -Number.MAX_VALUE;
  },
  equals(b6) {
    return this.x1 === b6.x1 && this.y1 === b6.y1 && this.x2 === b6.x2 && this.y2 === b6.y2;
  },
  set(x13, y13, x22, y22) {
    if (x22 < x13) {
      this.x2 = x13;
      this.x1 = x22;
    } else {
      this.x1 = x13;
      this.x2 = x22;
    }
    if (y22 < y13) {
      this.y2 = y13;
      this.y1 = y22;
    } else {
      this.y1 = y13;
      this.y2 = y22;
    }
    return this;
  },
  add(x9, y9) {
    if (x9 < this.x1)
      this.x1 = x9;
    if (y9 < this.y1)
      this.y1 = y9;
    if (x9 > this.x2)
      this.x2 = x9;
    if (y9 > this.y2)
      this.y2 = y9;
    return this;
  },
  expand(d) {
    this.x1 -= d;
    this.y1 -= d;
    this.x2 += d;
    this.y2 += d;
    return this;
  },
  round() {
    this.x1 = Math.floor(this.x1);
    this.y1 = Math.floor(this.y1);
    this.x2 = Math.ceil(this.x2);
    this.y2 = Math.ceil(this.y2);
    return this;
  },
  scale(s2) {
    this.x1 *= s2;
    this.y1 *= s2;
    this.x2 *= s2;
    this.y2 *= s2;
    return this;
  },
  translate(dx, dy) {
    this.x1 += dx;
    this.x2 += dx;
    this.y1 += dy;
    this.y2 += dy;
    return this;
  },
  rotate(angle2, x9, y9) {
    const p = this.rotatedPoints(angle2, x9, y9);
    return this.clear().add(p[0], p[1]).add(p[2], p[3]).add(p[4], p[5]).add(p[6], p[7]);
  },
  rotatedPoints(angle2, x9, y9) {
    var {
      x1: x13,
      y1: y13,
      x2: x22,
      y2: y22
    } = this, cos4 = Math.cos(angle2), sin4 = Math.sin(angle2), cx = x9 - x9 * cos4 + y9 * sin4, cy = y9 - x9 * sin4 - y9 * cos4;
    return [cos4 * x13 - sin4 * y13 + cx, sin4 * x13 + cos4 * y13 + cy, cos4 * x13 - sin4 * y22 + cx, sin4 * x13 + cos4 * y22 + cy, cos4 * x22 - sin4 * y13 + cx, sin4 * x22 + cos4 * y13 + cy, cos4 * x22 - sin4 * y22 + cx, sin4 * x22 + cos4 * y22 + cy];
  },
  union(b6) {
    if (b6.x1 < this.x1)
      this.x1 = b6.x1;
    if (b6.y1 < this.y1)
      this.y1 = b6.y1;
    if (b6.x2 > this.x2)
      this.x2 = b6.x2;
    if (b6.y2 > this.y2)
      this.y2 = b6.y2;
    return this;
  },
  intersect(b6) {
    if (b6.x1 > this.x1)
      this.x1 = b6.x1;
    if (b6.y1 > this.y1)
      this.y1 = b6.y1;
    if (b6.x2 < this.x2)
      this.x2 = b6.x2;
    if (b6.y2 < this.y2)
      this.y2 = b6.y2;
    return this;
  },
  encloses(b6) {
    return b6 && this.x1 <= b6.x1 && this.x2 >= b6.x2 && this.y1 <= b6.y1 && this.y2 >= b6.y2;
  },
  alignsWith(b6) {
    return b6 && (this.x1 == b6.x1 || this.x2 == b6.x2 || this.y1 == b6.y1 || this.y2 == b6.y2);
  },
  intersects(b6) {
    return b6 && !(this.x2 < b6.x1 || this.x1 > b6.x2 || this.y2 < b6.y1 || this.y1 > b6.y2);
  },
  contains(x9, y9) {
    return !(x9 < this.x1 || x9 > this.x2 || y9 < this.y1 || y9 > this.y2);
  },
  width() {
    return this.x2 - this.x1;
  },
  height() {
    return this.y2 - this.y1;
  }
};
function Item5(mark) {
  this.mark = mark;
  this.bounds = this.bounds || new Bounds5();
}
function GroupItem5(mark) {
  Item5.call(this, mark);
  this.items = this.items || [];
}
inherits15(GroupItem5, Item5);
var ResourceLoader5 = class {
  constructor(customLoader) {
    this._pending = 0;
    this._loader = customLoader || loader6();
  }
  pending() {
    return this._pending;
  }
  sanitizeURL(uri) {
    const loader7 = this;
    increment5(loader7);
    return loader7._loader.sanitize(uri, {
      context: "href"
    }).then((opt) => {
      decrement5(loader7);
      return opt;
    }).catch(() => {
      decrement5(loader7);
      return null;
    });
  }
  loadImage(uri) {
    const loader7 = this, Image2 = domImage5();
    increment5(loader7);
    return loader7._loader.sanitize(uri, {
      context: "image"
    }).then((opt) => {
      const url = opt.href;
      if (!url || !Image2)
        throw {
          url
        };
      const img = new Image2();
      const cors = has13(opt, "crossOrigin") ? opt.crossOrigin : "anonymous";
      if (cors != null)
        img.crossOrigin = cors;
      img.onload = () => decrement5(loader7);
      img.onerror = () => decrement5(loader7);
      img.src = url;
      return img;
    }).catch((e3) => {
      decrement5(loader7);
      return {
        complete: false,
        width: 0,
        height: 0,
        src: e3 && e3.url || ""
      };
    });
  }
  ready() {
    const loader7 = this;
    return new Promise((accept) => {
      function poll(value7) {
        if (!loader7.pending())
          accept(value7);
        else
          setTimeout(() => {
            poll(true);
          }, 10);
      }
      poll(false);
    });
  }
};
function increment5(loader7) {
  loader7._pending += 1;
}
function decrement5(loader7) {
  loader7._pending -= 1;
}
function boundStroke5(bounds6, item, miter) {
  if (item.stroke && item.opacity !== 0 && item.strokeOpacity !== 0) {
    const sw = item.strokeWidth != null ? +item.strokeWidth : 1;
    bounds6.expand(sw + (miter ? miterAdjustment5(item, sw) : 0));
  }
  return bounds6;
}
function miterAdjustment5(item, strokeWidth) {
  return item.strokeJoin && item.strokeJoin !== "miter" ? 0 : strokeWidth;
}
var circleThreshold5 = Tau5 - 1e-8;
var bounds5;
var lx5;
var ly5;
var rot5;
var ma5;
var mb5;
var mc5;
var md5;
var add8 = (x9, y9) => bounds5.add(x9, y9);
var addL5 = (x9, y9) => add8(lx5 = x9, ly5 = y9);
var addX5 = (x9) => add8(x9, bounds5.y1);
var addY5 = (y9) => add8(bounds5.x1, y9);
var px5 = (x9, y9) => ma5 * x9 + mc5 * y9;
var py5 = (x9, y9) => mb5 * x9 + md5 * y9;
var addp5 = (x9, y9) => add8(px5(x9, y9), py5(x9, y9));
var addpL5 = (x9, y9) => addL5(px5(x9, y9), py5(x9, y9));
function boundContext5(_, deg) {
  bounds5 = _;
  if (deg) {
    rot5 = deg * DegToRad5;
    ma5 = md5 = Math.cos(rot5);
    mb5 = Math.sin(rot5);
    mc5 = -mb5;
  } else {
    ma5 = md5 = 1;
    rot5 = mb5 = mc5 = 0;
  }
  return context$15;
}
var context$15 = {
  beginPath() {
  },
  closePath() {
  },
  moveTo: addpL5,
  lineTo: addpL5,
  rect(x9, y9, w8, h6) {
    if (rot5) {
      addp5(x9 + w8, y9);
      addp5(x9 + w8, y9 + h6);
      addp5(x9, y9 + h6);
      addpL5(x9, y9);
    } else {
      add8(x9 + w8, y9 + h6);
      addL5(x9, y9);
    }
  },
  quadraticCurveTo(x13, y13, x22, y22) {
    const px1 = px5(x13, y13), py1 = py5(x13, y13), px22 = px5(x22, y22), py22 = py5(x22, y22);
    quadExtrema5(lx5, px1, px22, addX5);
    quadExtrema5(ly5, py1, py22, addY5);
    addL5(px22, py22);
  },
  bezierCurveTo(x13, y13, x22, y22, x32, y32) {
    const px1 = px5(x13, y13), py1 = py5(x13, y13), px22 = px5(x22, y22), py22 = py5(x22, y22), px32 = px5(x32, y32), py32 = py5(x32, y32);
    cubicExtrema5(lx5, px1, px22, px32, addX5);
    cubicExtrema5(ly5, py1, py22, py32, addY5);
    addL5(px32, py32);
  },
  arc(cx, cy, r, sa6, ea7, ccw) {
    sa6 += rot5;
    ea7 += rot5;
    lx5 = r * Math.cos(ea7) + cx;
    ly5 = r * Math.sin(ea7) + cy;
    if (Math.abs(ea7 - sa6) > circleThreshold5) {
      add8(cx - r, cy - r);
      add8(cx + r, cy + r);
    } else {
      const update3 = (a4) => add8(r * Math.cos(a4) + cx, r * Math.sin(a4) + cy);
      let s2, i;
      update3(sa6);
      update3(ea7);
      if (ea7 !== sa6) {
        sa6 = sa6 % Tau5;
        if (sa6 < 0)
          sa6 += Tau5;
        ea7 = ea7 % Tau5;
        if (ea7 < 0)
          ea7 += Tau5;
        if (ea7 < sa6) {
          ccw = !ccw;
          s2 = sa6;
          sa6 = ea7;
          ea7 = s2;
        }
        if (ccw) {
          ea7 -= Tau5;
          s2 = sa6 - sa6 % HalfPi5;
          for (i = 0; i < 4 && s2 > ea7; ++i, s2 -= HalfPi5)
            update3(s2);
        } else {
          s2 = sa6 - sa6 % HalfPi5 + HalfPi5;
          for (i = 0; i < 4 && s2 < ea7; ++i, s2 = s2 + HalfPi5)
            update3(s2);
        }
      }
    }
  }
};
function quadExtrema5(x07, x13, x22, cb) {
  const t = (x07 - x13) / (x07 + x22 - 2 * x13);
  if (0 < t && t < 1)
    cb(x07 + (x13 - x07) * t);
}
function cubicExtrema5(x07, x13, x22, x32, cb) {
  const a4 = x32 - x07 + 3 * x13 - 3 * x22, b6 = x07 + x22 - 2 * x13, c5 = x07 - x13;
  let t014 = 0, t13 = 0, r;
  if (Math.abs(a4) > Epsilon5) {
    r = b6 * b6 + c5 * a4;
    if (r >= 0) {
      r = Math.sqrt(r);
      t014 = (-b6 + r) / a4;
      t13 = (-b6 - r) / a4;
    }
  } else {
    t014 = 0.5 * c5 / b6;
  }
  if (0 < t014 && t014 < 1)
    cb(cubic5(t014, x07, x13, x22, x32));
  if (0 < t13 && t13 < 1)
    cb(cubic5(t13, x07, x13, x22, x32));
}
function cubic5(t, x07, x13, x22, x32) {
  const s2 = 1 - t, s22 = s2 * s2, t22 = t * t;
  return s22 * s2 * x07 + 3 * s22 * t * x13 + 3 * s2 * t22 * x22 + t22 * t * x32;
}
var context5 = (context5 = domCanvas7(1, 1)) ? context5.getContext("2d") : null;
var b5 = new Bounds5();
function intersectPath5(draw7) {
  return function(item, brush) {
    if (!context5)
      return true;
    draw7(context5, item);
    b5.clear().union(item.bounds).intersect(brush).round();
    const {
      x1: x13,
      y1: y13,
      x2: x22,
      y2: y22
    } = b5;
    for (let y9 = y13; y9 <= y22; ++y9) {
      for (let x9 = x13; x9 <= x22; ++x9) {
        if (context5.isPointInPath(x9, y9)) {
          return true;
        }
      }
    }
    return false;
  };
}
function intersectPoint5(item, box) {
  return box.contains(item.x || 0, item.y || 0);
}
function intersectRect5(item, box) {
  const x9 = item.x || 0, y9 = item.y || 0, w8 = item.width || 0, h6 = item.height || 0;
  return box.intersects(b5.set(x9, y9, x9 + w8, y9 + h6));
}
function intersectRule5(item, box) {
  const x9 = item.x || 0, y9 = item.y || 0, x22 = item.x2 != null ? item.x2 : x9, y22 = item.y2 != null ? item.y2 : y9;
  return intersectBoxLine5(box, x9, y9, x22, y22);
}
function intersectBoxLine5(box, x9, y9, u4, v2) {
  const {
    x1: x13,
    y1: y13,
    x2: x22,
    y2: y22
  } = box, dx = u4 - x9, dy = v2 - y9;
  let t014 = 0, t13 = 1, p, q, r, e3;
  for (e3 = 0; e3 < 4; ++e3) {
    if (e3 === 0) {
      p = -dx;
      q = -(x13 - x9);
    }
    if (e3 === 1) {
      p = dx;
      q = x22 - x9;
    }
    if (e3 === 2) {
      p = -dy;
      q = -(y13 - y9);
    }
    if (e3 === 3) {
      p = dy;
      q = y22 - y9;
    }
    if (Math.abs(p) < 1e-10 && q < 0)
      return false;
    r = q / p;
    if (p < 0) {
      if (r > t13)
        return false;
      else if (r > t014)
        t014 = r;
    } else if (p > 0) {
      if (r < t014)
        return false;
      else if (r < t13)
        t13 = r;
    }
  }
  return true;
}
function blend5(context7, item) {
  context7.globalCompositeOperation = item.blend || "source-over";
}
function value5(value7, dflt) {
  return value7 == null ? dflt : value7;
}
function addStops5(gradient8, stops) {
  const n = stops.length;
  for (let i = 0; i < n; ++i) {
    gradient8.addColorStop(stops[i].offset, stops[i].color);
  }
  return gradient8;
}
function gradient5(context7, spec, bounds6) {
  const w8 = bounds6.width(), h6 = bounds6.height();
  let gradient8;
  if (spec.gradient === "radial") {
    gradient8 = context7.createRadialGradient(bounds6.x1 + value5(spec.x1, 0.5) * w8, bounds6.y1 + value5(spec.y1, 0.5) * h6, Math.max(w8, h6) * value5(spec.r1, 0), bounds6.x1 + value5(spec.x2, 0.5) * w8, bounds6.y1 + value5(spec.y2, 0.5) * h6, Math.max(w8, h6) * value5(spec.r2, 0.5));
  } else {
    const x13 = value5(spec.x1, 0), y13 = value5(spec.y1, 0), x22 = value5(spec.x2, 1), y22 = value5(spec.y2, 0);
    if (x13 === x22 || y13 === y22 || w8 === h6) {
      gradient8 = context7.createLinearGradient(bounds6.x1 + x13 * w8, bounds6.y1 + y13 * h6, bounds6.x1 + x22 * w8, bounds6.y1 + y22 * h6);
    } else {
      const image7 = domCanvas7(Math.ceil(w8), Math.ceil(h6)), ictx = image7.getContext("2d");
      ictx.scale(w8, h6);
      ictx.fillStyle = addStops5(ictx.createLinearGradient(x13, y13, x22, y22), spec.stops);
      ictx.fillRect(0, 0, w8, h6);
      return context7.createPattern(image7, "no-repeat");
    }
  }
  return addStops5(gradient8, spec.stops);
}
function color6(context7, item, value7) {
  return isGradient5(value7) ? gradient5(context7, value7, item.bounds) : value7;
}
function fill5(context7, item, opacity2) {
  opacity2 *= item.fillOpacity == null ? 1 : item.fillOpacity;
  if (opacity2 > 0) {
    context7.globalAlpha = opacity2;
    context7.fillStyle = color6(context7, item, item.fill);
    return true;
  } else {
    return false;
  }
}
var Empty6 = [];
function stroke5(context7, item, opacity2) {
  var lw = (lw = item.strokeWidth) != null ? lw : 1;
  if (lw <= 0)
    return false;
  opacity2 *= item.strokeOpacity == null ? 1 : item.strokeOpacity;
  if (opacity2 > 0) {
    context7.globalAlpha = opacity2;
    context7.strokeStyle = color6(context7, item, item.stroke);
    context7.lineWidth = lw;
    context7.lineCap = item.strokeCap || "butt";
    context7.lineJoin = item.strokeJoin || "miter";
    context7.miterLimit = item.strokeMiterLimit || 10;
    if (context7.setLineDash) {
      context7.setLineDash(item.strokeDash || Empty6);
      context7.lineDashOffset = item.strokeDashOffset || 0;
    }
    return true;
  } else {
    return false;
  }
}
function compare7(a4, b6) {
  return a4.zindex - b6.zindex || a4.index - b6.index;
}
function zorder5(scene) {
  if (!scene.zdirty)
    return scene.zitems;
  var items = scene.items, output3 = [], item, i, n;
  for (i = 0, n = items.length; i < n; ++i) {
    item = items[i];
    item.index = i;
    if (item.zindex)
      output3.push(item);
  }
  scene.zdirty = false;
  return scene.zitems = output3.sort(compare7);
}
function visit5(scene, visitor) {
  var items = scene.items, i, n;
  if (!items || !items.length)
    return;
  const zitems = zorder5(scene);
  if (zitems && zitems.length) {
    for (i = 0, n = items.length; i < n; ++i) {
      if (!items[i].zindex)
        visitor(items[i]);
    }
    items = zitems;
  }
  for (i = 0, n = items.length; i < n; ++i) {
    visitor(items[i]);
  }
}
function pickVisit5(scene, visitor) {
  var items = scene.items, hit6, i;
  if (!items || !items.length)
    return null;
  const zitems = zorder5(scene);
  if (zitems && zitems.length)
    items = zitems;
  for (i = items.length; --i >= 0; ) {
    if (hit6 = visitor(items[i]))
      return hit6;
  }
  if (items === zitems) {
    for (items = scene.items, i = items.length; --i >= 0; ) {
      if (!items[i].zindex) {
        if (hit6 = visitor(items[i]))
          return hit6;
      }
    }
  }
  return null;
}
function drawAll5(path7) {
  return function(context7, scene, bounds6) {
    visit5(scene, (item) => {
      if (!bounds6 || bounds6.intersects(item.bounds)) {
        drawPath5(path7, context7, item, item);
      }
    });
  };
}
function drawOne5(path7) {
  return function(context7, scene, bounds6) {
    if (scene.items.length && (!bounds6 || bounds6.intersects(scene.bounds))) {
      drawPath5(path7, context7, scene.items[0], scene.items);
    }
  };
}
function drawPath5(path7, context7, item, items) {
  var opacity2 = item.opacity == null ? 1 : item.opacity;
  if (opacity2 === 0)
    return;
  if (path7(context7, items))
    return;
  blend5(context7, item);
  if (item.fill && fill5(context7, item, opacity2)) {
    context7.fill();
  }
  if (item.stroke && stroke5(context7, item, opacity2)) {
    context7.stroke();
  }
}
function pick$15(test2) {
  test2 = test2 || truthy16;
  return function(context7, scene, x9, y9, gx, gy) {
    x9 *= context7.pixelRatio;
    y9 *= context7.pixelRatio;
    return pickVisit5(scene, (item) => {
      const b6 = item.bounds;
      if (b6 && !b6.contains(gx, gy) || !b6)
        return;
      if (test2(context7, item, x9, y9, gx, gy))
        return item;
    });
  };
}
function hitPath5(path7, filled) {
  return function(context7, o, x9, y9) {
    var item = Array.isArray(o) ? o[0] : o, fill6 = filled == null ? item.fill : filled, stroke6 = item.stroke && context7.isPointInStroke, lw, lc;
    if (stroke6) {
      lw = item.strokeWidth;
      lc = item.strokeCap;
      context7.lineWidth = lw != null ? lw : 1;
      context7.lineCap = lc != null ? lc : "butt";
    }
    return path7(context7, o) ? false : fill6 && context7.isPointInPath(x9, y9) || stroke6 && context7.isPointInStroke(x9, y9);
  };
}
function pickPath5(path7) {
  return pick$15(hitPath5(path7));
}
function translate6(x9, y9) {
  return "translate(" + x9 + "," + y9 + ")";
}
function rotate5(a4) {
  return "rotate(" + a4 + ")";
}
function scale14(scaleX, scaleY2) {
  return "scale(" + scaleX + "," + scaleY2 + ")";
}
function translateItem5(item) {
  return translate6(item.x || 0, item.y || 0);
}
function rotateItem5(item) {
  return translate6(item.x || 0, item.y || 0) + (item.angle ? " " + rotate5(item.angle) : "");
}
function transformItem5(item) {
  return translate6(item.x || 0, item.y || 0) + (item.angle ? " " + rotate5(item.angle) : "") + (item.scaleX || item.scaleY ? " " + scale14(item.scaleX || 1, item.scaleY || 1) : "");
}
function markItemPath5(type7, shape6, isect) {
  function attr6(emit6, item) {
    emit6("transform", rotateItem5(item));
    emit6("d", shape6(null, item));
  }
  function bound6(bounds6, item) {
    shape6(boundContext5(bounds6, item.angle), item);
    return boundStroke5(bounds6, item).translate(item.x || 0, item.y || 0);
  }
  function draw7(context7, item) {
    var x9 = item.x || 0, y9 = item.y || 0, a4 = item.angle || 0;
    context7.translate(x9, y9);
    if (a4)
      context7.rotate(a4 *= DegToRad5);
    context7.beginPath();
    shape6(context7, item);
    if (a4)
      context7.rotate(-a4);
    context7.translate(-x9, -y9);
  }
  return {
    type: type7,
    tag: "path",
    nested: false,
    attr: attr6,
    bound: bound6,
    draw: drawAll5(draw7),
    pick: pickPath5(draw7),
    isect: isect || intersectPath5(draw7)
  };
}
var arc6 = markItemPath5("arc", arc$15);
function pickArea5(a4, p) {
  var v2 = a4[0].orient === "horizontal" ? p[1] : p[0], z = a4[0].orient === "horizontal" ? "y" : "x", i = a4.length, min5 = Infinity, hit6, d;
  while (--i >= 0) {
    if (a4[i].defined === false)
      continue;
    d = Math.abs(a4[i][z] - v2);
    if (d < min5) {
      min5 = d;
      hit6 = a4[i];
    }
  }
  return hit6;
}
function pickLine5(a4, p) {
  var t = Math.pow(a4[0].strokeWidth || 1, 2), i = a4.length, dx, dy, dd;
  while (--i >= 0) {
    if (a4[i].defined === false)
      continue;
    dx = a4[i].x - p[0];
    dy = a4[i].y - p[1];
    dd = dx * dx + dy * dy;
    if (dd < t)
      return a4[i];
  }
  return null;
}
function pickTrail5(a4, p) {
  var i = a4.length, dx, dy, dd;
  while (--i >= 0) {
    if (a4[i].defined === false)
      continue;
    dx = a4[i].x - p[0];
    dy = a4[i].y - p[1];
    dd = dx * dx + dy * dy;
    dx = a4[i].size || 1;
    if (dd < dx * dx)
      return a4[i];
  }
  return null;
}
function markMultiItemPath5(type7, shape6, tip) {
  function attr6(emit6, item) {
    var items = item.mark.items;
    if (items.length)
      emit6("d", shape6(null, items));
  }
  function bound6(bounds6, mark) {
    var items = mark.items;
    if (items.length === 0) {
      return bounds6;
    } else {
      shape6(boundContext5(bounds6), items);
      return boundStroke5(bounds6, items[0]);
    }
  }
  function draw7(context7, items) {
    context7.beginPath();
    shape6(context7, items);
  }
  const hit6 = hitPath5(draw7);
  function pick7(context7, scene, x9, y9, gx, gy) {
    var items = scene.items, b6 = scene.bounds;
    if (!items || !items.length || b6 && !b6.contains(gx, gy)) {
      return null;
    }
    x9 *= context7.pixelRatio;
    y9 *= context7.pixelRatio;
    return hit6(context7, items, x9, y9) ? items[0] : null;
  }
  return {
    type: type7,
    tag: "path",
    nested: true,
    attr: attr6,
    bound: bound6,
    draw: drawOne5(draw7),
    pick: pick7,
    isect: intersectPoint5,
    tip
  };
}
var area6 = markMultiItemPath5("area", area$15, pickArea5);
function clip5(context7, scene) {
  var clip7 = scene.clip;
  context7.save();
  if (isFunction11(clip7)) {
    context7.beginPath();
    clip7(context7);
    context7.clip();
  } else {
    clipGroup5(context7, scene.group);
  }
}
function clipGroup5(context7, group7) {
  context7.beginPath();
  hasCornerRadius5(group7) ? rectangle5(context7, group7, 0, 0) : context7.rect(0, 0, group7.width || 0, group7.height || 0);
  context7.clip();
}
function offset$15(item) {
  const sw = value5(item.strokeWidth, 1);
  return item.strokeOffset != null ? item.strokeOffset : item.stroke && sw > 0.5 && sw < 1.5 ? 0.5 - Math.abs(sw - 1) : 0;
}
function attr$55(emit6, item) {
  emit6("transform", translateItem5(item));
}
function emitRectangle5(emit6, item) {
  const off = offset$15(item);
  emit6("d", rectangle5(null, item, off, off));
}
function background5(emit6, item) {
  emit6("class", "background");
  emit6("aria-hidden", true);
  emitRectangle5(emit6, item);
}
function foreground5(emit6, item) {
  emit6("class", "foreground");
  emit6("aria-hidden", true);
  if (item.strokeForeground) {
    emitRectangle5(emit6, item);
  } else {
    emit6("d", "");
  }
}
function content5(emit6, item, renderer) {
  const url = item.clip ? clip$15(renderer, item, item) : null;
  emit6("clip-path", url);
}
function bound$55(bounds6, group7) {
  if (!group7.clip && group7.items) {
    const items = group7.items, m3 = items.length;
    for (let j = 0; j < m3; ++j) {
      bounds6.union(items[j].bounds);
    }
  }
  if ((group7.clip || group7.width || group7.height) && !group7.noBound) {
    bounds6.add(0, 0).add(group7.width || 0, group7.height || 0);
  }
  boundStroke5(bounds6, group7);
  return bounds6.translate(group7.x || 0, group7.y || 0);
}
function rectanglePath5(context7, group7, x9, y9) {
  const off = offset$15(group7);
  context7.beginPath();
  rectangle5(context7, group7, (x9 || 0) + off, (y9 || 0) + off);
}
var hitBackground5 = hitPath5(rectanglePath5);
var hitForeground5 = hitPath5(rectanglePath5, false);
var hitCorner5 = hitPath5(rectanglePath5, true);
function draw$45(context7, scene, bounds6, markTypes) {
  visit5(scene, (group7) => {
    const gx = group7.x || 0, gy = group7.y || 0, fore = group7.strokeForeground, opacity2 = group7.opacity == null ? 1 : group7.opacity;
    if ((group7.stroke || group7.fill) && opacity2) {
      rectanglePath5(context7, group7, gx, gy);
      blend5(context7, group7);
      if (group7.fill && fill5(context7, group7, opacity2)) {
        context7.fill();
      }
      if (group7.stroke && !fore && stroke5(context7, group7, opacity2)) {
        context7.stroke();
      }
    }
    context7.save();
    context7.translate(gx, gy);
    if (group7.clip)
      clipGroup5(context7, group7);
    if (bounds6)
      bounds6.translate(-gx, -gy);
    visit5(group7, (item) => {
      if (item.marktype === "group" || markTypes == null || markTypes.includes(item.marktype)) {
        this.draw(context7, item, bounds6, markTypes);
      }
    });
    if (bounds6)
      bounds6.translate(gx, gy);
    context7.restore();
    if (fore && group7.stroke && opacity2) {
      rectanglePath5(context7, group7, gx, gy);
      blend5(context7, group7);
      if (stroke5(context7, group7, opacity2)) {
        context7.stroke();
      }
    }
  });
}
function pick5(context7, scene, x9, y9, gx, gy) {
  if (scene.bounds && !scene.bounds.contains(gx, gy) || !scene.items) {
    return null;
  }
  const cx = x9 * context7.pixelRatio, cy = y9 * context7.pixelRatio;
  return pickVisit5(scene, (group7) => {
    let hit6, dx, dy;
    const b6 = group7.bounds;
    if (b6 && !b6.contains(gx, gy))
      return;
    dx = group7.x || 0;
    dy = group7.y || 0;
    const dw = dx + (group7.width || 0), dh = dy + (group7.height || 0), c5 = group7.clip;
    if (c5 && (gx < dx || gx > dw || gy < dy || gy > dh))
      return;
    context7.save();
    context7.translate(dx, dy);
    dx = gx - dx;
    dy = gy - dy;
    if (c5 && hasCornerRadius5(group7) && !hitCorner5(context7, group7, cx, cy)) {
      context7.restore();
      return null;
    }
    const fore = group7.strokeForeground, ix = scene.interactive !== false;
    if (ix && fore && group7.stroke && hitForeground5(context7, group7, cx, cy)) {
      context7.restore();
      return group7;
    }
    hit6 = pickVisit5(group7, (mark) => pickMark5(mark, dx, dy) ? this.pick(mark, x9, y9, dx, dy) : null);
    if (!hit6 && ix && (group7.fill || !fore && group7.stroke) && hitBackground5(context7, group7, cx, cy)) {
      hit6 = group7;
    }
    context7.restore();
    return hit6 || null;
  });
}
function pickMark5(mark, x9, y9) {
  return (mark.interactive !== false || mark.marktype === "group") && mark.bounds && mark.bounds.contains(x9, y9);
}
var group6 = {
  type: "group",
  tag: "g",
  nested: false,
  attr: attr$55,
  bound: bound$55,
  draw: draw$45,
  pick: pick5,
  isect: intersectRect5,
  content: content5,
  background: background5,
  foreground: foreground5
};
var metadata5 = {
  "xmlns": "http://www.w3.org/2000/svg",
  "xmlns:xlink": "http://www.w3.org/1999/xlink",
  "version": "1.1"
};
function getImage5(item, renderer) {
  var image7 = item.image;
  if (!image7 || item.url && item.url !== image7.url) {
    image7 = {
      complete: false,
      width: 0,
      height: 0
    };
    renderer.loadImage(item.url).then((image8) => {
      item.image = image8;
      item.image.url = item.url;
    });
  }
  return image7;
}
function imageWidth5(item, image7) {
  return item.width != null ? item.width : !image7 || !image7.width ? 0 : item.aspect !== false && item.height ? item.height * image7.width / image7.height : image7.width;
}
function imageHeight5(item, image7) {
  return item.height != null ? item.height : !image7 || !image7.height ? 0 : item.aspect !== false && item.width ? item.width * image7.height / image7.width : image7.height;
}
function imageXOffset5(align2, w8) {
  return align2 === "center" ? w8 / 2 : align2 === "right" ? w8 : 0;
}
function imageYOffset5(baseline3, h6) {
  return baseline3 === "middle" ? h6 / 2 : baseline3 === "bottom" ? h6 : 0;
}
function attr$45(emit6, item, renderer) {
  const img = getImage5(item, renderer), w8 = imageWidth5(item, img), h6 = imageHeight5(item, img), x9 = (item.x || 0) - imageXOffset5(item.align, w8), y9 = (item.y || 0) - imageYOffset5(item.baseline, h6), i = !img.src && img.toDataURL ? img.toDataURL() : img.src || "";
  emit6("href", i, metadata5["xmlns:xlink"], "xlink:href");
  emit6("transform", translate6(x9, y9));
  emit6("width", w8);
  emit6("height", h6);
  emit6("preserveAspectRatio", item.aspect === false ? "none" : "xMidYMid");
}
function bound$45(bounds6, item) {
  const img = item.image, w8 = imageWidth5(item, img), h6 = imageHeight5(item, img), x9 = (item.x || 0) - imageXOffset5(item.align, w8), y9 = (item.y || 0) - imageYOffset5(item.baseline, h6);
  return bounds6.set(x9, y9, x9 + w8, y9 + h6);
}
function draw$35(context7, scene, bounds6) {
  visit5(scene, (item) => {
    if (bounds6 && !bounds6.intersects(item.bounds))
      return;
    const img = getImage5(item, this);
    let w8 = imageWidth5(item, img);
    let h6 = imageHeight5(item, img);
    if (w8 === 0 || h6 === 0)
      return;
    let x9 = (item.x || 0) - imageXOffset5(item.align, w8), y9 = (item.y || 0) - imageYOffset5(item.baseline, h6), opacity2, ar0, ar1, t;
    if (item.aspect !== false) {
      ar0 = img.width / img.height;
      ar1 = item.width / item.height;
      if (ar0 === ar0 && ar1 === ar1 && ar0 !== ar1) {
        if (ar1 < ar0) {
          t = w8 / ar0;
          y9 += (h6 - t) / 2;
          h6 = t;
        } else {
          t = h6 * ar0;
          x9 += (w8 - t) / 2;
          w8 = t;
        }
      }
    }
    if (img.complete || img.toDataURL) {
      blend5(context7, item);
      context7.globalAlpha = (opacity2 = item.opacity) != null ? opacity2 : 1;
      context7.imageSmoothingEnabled = item.smooth !== false;
      context7.drawImage(img, x9, y9, w8, h6);
    }
  });
}
var image5 = {
  type: "image",
  tag: "image",
  nested: false,
  attr: attr$45,
  bound: bound$45,
  draw: draw$35,
  pick: pick$15(),
  isect: truthy16,
  // bounds check is sufficient
  get: getImage5,
  xOffset: imageXOffset5,
  yOffset: imageYOffset5
};
var line6 = markMultiItemPath5("line", line$15, pickLine5);
function attr$35(emit6, item) {
  var sx = item.scaleX || 1, sy = item.scaleY || 1;
  if (sx !== 1 || sy !== 1) {
    emit6("vector-effect", "non-scaling-stroke");
  }
  emit6("transform", transformItem5(item));
  emit6("d", item.path);
}
function path$15(context7, item) {
  var path7 = item.path;
  if (path7 == null)
    return true;
  var x9 = item.x || 0, y9 = item.y || 0, sx = item.scaleX || 1, sy = item.scaleY || 1, a4 = (item.angle || 0) * DegToRad5, cache2 = item.pathCache;
  if (!cache2 || cache2.path !== path7) {
    (item.pathCache = cache2 = parse9(path7)).path = path7;
  }
  if (a4 && context7.rotate && context7.translate) {
    context7.translate(x9, y9);
    context7.rotate(a4);
    pathRender5(context7, cache2, 0, 0, sx, sy);
    context7.rotate(-a4);
    context7.translate(-x9, -y9);
  } else {
    pathRender5(context7, cache2, x9, y9, sx, sy);
  }
}
function bound$35(bounds6, item) {
  return path$15(boundContext5(bounds6, item.angle), item) ? bounds6.set(0, 0, 0, 0) : boundStroke5(bounds6, item, true);
}
var path$25 = {
  type: "path",
  tag: "path",
  nested: false,
  attr: attr$35,
  bound: bound$35,
  draw: drawAll5(path$15),
  pick: pickPath5(path$15),
  isect: intersectPath5(path$15)
};
function attr$25(emit6, item) {
  emit6("d", rectangle5(null, item));
}
function bound$25(bounds6, item) {
  var x9, y9;
  return boundStroke5(bounds6.set(x9 = item.x || 0, y9 = item.y || 0, x9 + item.width || 0, y9 + item.height || 0), item);
}
function draw$25(context7, item) {
  context7.beginPath();
  rectangle5(context7, item);
}
var rect5 = {
  type: "rect",
  tag: "path",
  nested: false,
  attr: attr$25,
  bound: bound$25,
  draw: drawAll5(draw$25),
  pick: pickPath5(draw$25),
  isect: intersectRect5
};
function attr$15(emit6, item) {
  emit6("transform", translateItem5(item));
  emit6("x2", item.x2 != null ? item.x2 - (item.x || 0) : 0);
  emit6("y2", item.y2 != null ? item.y2 - (item.y || 0) : 0);
}
function bound$15(bounds6, item) {
  var x13, y13;
  return boundStroke5(bounds6.set(x13 = item.x || 0, y13 = item.y || 0, item.x2 != null ? item.x2 : x13, item.y2 != null ? item.y2 : y13), item);
}
function path6(context7, item, opacity2) {
  var x13, y13, x22, y22;
  if (item.stroke && stroke5(context7, item, opacity2)) {
    x13 = item.x || 0;
    y13 = item.y || 0;
    x22 = item.x2 != null ? item.x2 : x13;
    y22 = item.y2 != null ? item.y2 : y13;
    context7.beginPath();
    context7.moveTo(x13, y13);
    context7.lineTo(x22, y22);
    return true;
  }
  return false;
}
function draw$15(context7, scene, bounds6) {
  visit5(scene, (item) => {
    if (bounds6 && !bounds6.intersects(item.bounds))
      return;
    var opacity2 = item.opacity == null ? 1 : item.opacity;
    if (opacity2 && path6(context7, item, opacity2)) {
      blend5(context7, item);
      context7.stroke();
    }
  });
}
function hit$15(context7, item, x9, y9) {
  if (!context7.isPointInStroke)
    return false;
  return path6(context7, item, 1) && context7.isPointInStroke(x9, y9);
}
var rule5 = {
  type: "rule",
  tag: "line",
  nested: false,
  attr: attr$15,
  bound: bound$15,
  draw: draw$15,
  pick: pick$15(hit$15),
  isect: intersectRule5
};
var shape5 = markItemPath5("shape", shape$15);
var symbol5 = markItemPath5("symbol", symbol$15, intersectPoint5);
var widthCache5 = lruCache5();
var textMetrics5 = {
  height: fontSize5,
  measureWidth: measureWidth5,
  estimateWidth: estimateWidth5,
  width: estimateWidth5,
  canvas: useCanvas5
};
useCanvas5(true);
function useCanvas5(use) {
  textMetrics5.width = use && context5 ? measureWidth5 : estimateWidth5;
}
function estimateWidth5(item, text7) {
  return _estimateWidth5(textValue5(item, text7), fontSize5(item));
}
function _estimateWidth5(text7, currentFontHeight) {
  return ~~(0.8 * text7.length * currentFontHeight);
}
function measureWidth5(item, text7) {
  return fontSize5(item) <= 0 || !(text7 = textValue5(item, text7)) ? 0 : _measureWidth5(text7, font5(item));
}
function _measureWidth5(text7, currentFont) {
  const key4 = `(${currentFont}) ${text7}`;
  let width2 = widthCache5.get(key4);
  if (width2 === void 0) {
    context5.font = currentFont;
    width2 = context5.measureText(text7).width;
    widthCache5.set(key4, width2);
  }
  return width2;
}
function fontSize5(item) {
  return item.fontSize != null ? +item.fontSize || 0 : 11;
}
function lineHeight5(item) {
  return item.lineHeight != null ? item.lineHeight : fontSize5(item) + 2;
}
function lineArray5(_) {
  return isArray16(_) ? _.length > 1 ? _ : _[0] : _;
}
function textLines5(item) {
  return lineArray5(item.lineBreak && item.text && !isArray16(item.text) ? item.text.split(item.lineBreak) : item.text);
}
function textValue5(item, line8) {
  const text7 = line8 == null ? "" : (line8 + "").trim();
  return item.limit > 0 && text7.length ? truncate7(item, text7) : text7;
}
function widthGetter5(item) {
  if (textMetrics5.width === measureWidth5) {
    const currentFont = font5(item);
    return (text7) => _measureWidth5(text7, currentFont);
  } else if (textMetrics5.width === estimateWidth5) {
    const currentFontHeight = fontSize5(item);
    return (text7) => _estimateWidth5(text7, currentFontHeight);
  } else {
    return (text7) => textMetrics5.width(item, text7);
  }
}
function truncate7(item, text7) {
  var limit = +item.limit, width2 = widthGetter5(item);
  if (width2(text7) < limit)
    return text7;
  var ellipsis = item.ellipsis || "…", rtl = item.dir === "rtl", lo = 0, hi = text7.length, mid;
  limit -= width2(ellipsis);
  if (rtl) {
    while (lo < hi) {
      mid = lo + hi >>> 1;
      if (width2(text7.slice(mid)) > limit)
        lo = mid + 1;
      else
        hi = mid;
    }
    return ellipsis + text7.slice(lo);
  } else {
    while (lo < hi) {
      mid = 1 + (lo + hi >>> 1);
      if (width2(text7.slice(0, mid)) < limit)
        lo = mid;
      else
        hi = mid - 1;
    }
    return text7.slice(0, lo) + ellipsis;
  }
}
function fontFamily5(item, quote) {
  var font7 = item.font;
  return (quote && font7 ? String(font7).replace(/"/g, "'") : font7) || "sans-serif";
}
function font5(item, quote) {
  return (item.fontStyle ? item.fontStyle + " " : "") + (item.fontVariant ? item.fontVariant + " " : "") + (item.fontWeight ? item.fontWeight + " " : "") + fontSize5(item) + "px " + fontFamily5(item, quote);
}
function offset7(item) {
  var baseline3 = item.baseline, h6 = fontSize5(item);
  return Math.round(baseline3 === "top" ? 0.79 * h6 : baseline3 === "middle" ? 0.3 * h6 : baseline3 === "bottom" ? -0.21 * h6 : baseline3 === "line-top" ? 0.29 * h6 + 0.5 * lineHeight5(item) : baseline3 === "line-bottom" ? 0.29 * h6 - 0.5 * lineHeight5(item) : 0);
}
var textAlign5 = {
  "left": "start",
  "center": "middle",
  "right": "end"
};
var tempBounds6 = new Bounds5();
function anchorPoint5(item) {
  var x9 = item.x || 0, y9 = item.y || 0, r = item.radius || 0, t;
  if (r) {
    t = (item.theta || 0) - HalfPi5;
    x9 += r * Math.cos(t);
    y9 += r * Math.sin(t);
  }
  tempBounds6.x1 = x9;
  tempBounds6.y1 = y9;
  return tempBounds6;
}
function attr5(emit6, item) {
  var dx = item.dx || 0, dy = (item.dy || 0) + offset7(item), p = anchorPoint5(item), x9 = p.x1, y9 = p.y1, a4 = item.angle || 0, t;
  emit6("text-anchor", textAlign5[item.align] || "start");
  if (a4) {
    t = translate6(x9, y9) + " " + rotate5(a4);
    if (dx || dy)
      t += " " + translate6(dx, dy);
  } else {
    t = translate6(x9 + dx, y9 + dy);
  }
  emit6("transform", t);
}
function bound5(bounds6, item, mode2) {
  var h6 = textMetrics5.height(item), a4 = item.align, p = anchorPoint5(item), x9 = p.x1, y9 = p.y1, dx = item.dx || 0, dy = (item.dy || 0) + offset7(item) - Math.round(0.8 * h6), tl6 = textLines5(item), w8;
  if (isArray16(tl6)) {
    h6 += lineHeight5(item) * (tl6.length - 1);
    w8 = tl6.reduce((w9, t) => Math.max(w9, textMetrics5.width(item, t)), 0);
  } else {
    w8 = textMetrics5.width(item, tl6);
  }
  if (a4 === "center") {
    dx -= w8 / 2;
  } else if (a4 === "right") {
    dx -= w8;
  } else
    ;
  bounds6.set(dx += x9, dy += y9, dx + w8, dy + h6);
  if (item.angle && !mode2) {
    bounds6.rotate(item.angle * DegToRad5, x9, y9);
  } else if (mode2 === 2) {
    return bounds6.rotatedPoints(item.angle * DegToRad5, x9, y9);
  }
  return bounds6;
}
function draw6(context7, scene, bounds6) {
  visit5(scene, (item) => {
    var opacity2 = item.opacity == null ? 1 : item.opacity, p, x9, y9, i, lh, tl6, str;
    if (bounds6 && !bounds6.intersects(item.bounds) || // bounds check
    opacity2 === 0 || item.fontSize <= 0 || item.text == null || item.text.length === 0)
      return;
    context7.font = font5(item);
    context7.textAlign = item.align || "left";
    p = anchorPoint5(item);
    x9 = p.x1, y9 = p.y1;
    if (item.angle) {
      context7.save();
      context7.translate(x9, y9);
      context7.rotate(item.angle * DegToRad5);
      x9 = y9 = 0;
    }
    x9 += item.dx || 0;
    y9 += (item.dy || 0) + offset7(item);
    tl6 = textLines5(item);
    blend5(context7, item);
    if (isArray16(tl6)) {
      lh = lineHeight5(item);
      for (i = 0; i < tl6.length; ++i) {
        str = textValue5(item, tl6[i]);
        if (item.fill && fill5(context7, item, opacity2)) {
          context7.fillText(str, x9, y9);
        }
        if (item.stroke && stroke5(context7, item, opacity2)) {
          context7.strokeText(str, x9, y9);
        }
        y9 += lh;
      }
    } else {
      str = textValue5(item, tl6);
      if (item.fill && fill5(context7, item, opacity2)) {
        context7.fillText(str, x9, y9);
      }
      if (item.stroke && stroke5(context7, item, opacity2)) {
        context7.strokeText(str, x9, y9);
      }
    }
    if (item.angle)
      context7.restore();
  });
}
function hit5(context7, item, x9, y9, gx, gy) {
  if (item.fontSize <= 0)
    return false;
  if (!item.angle)
    return true;
  var p = anchorPoint5(item), ax = p.x1, ay = p.y1, b6 = bound5(tempBounds6, item, 1), a4 = -item.angle * DegToRad5, cos4 = Math.cos(a4), sin4 = Math.sin(a4), px6 = cos4 * gx - sin4 * gy + (ax - cos4 * ax + sin4 * ay), py6 = sin4 * gx + cos4 * gy + (ay - sin4 * ax - cos4 * ay);
  return b6.contains(px6, py6);
}
function intersectText5(item, box) {
  const p = bound5(tempBounds6, item, 2);
  return intersectBoxLine5(box, p[0], p[1], p[2], p[3]) || intersectBoxLine5(box, p[0], p[1], p[4], p[5]) || intersectBoxLine5(box, p[4], p[5], p[6], p[7]) || intersectBoxLine5(box, p[2], p[3], p[6], p[7]);
}
var text5 = {
  type: "text",
  tag: "text",
  nested: false,
  attr: attr5,
  bound: bound5,
  draw: draw6,
  pick: pick$15(hit5),
  isect: intersectText5
};
var trail5 = markMultiItemPath5("trail", trail$15, pickTrail5);
var Marks5 = {
  arc: arc6,
  area: area6,
  group: group6,
  image: image5,
  line: line6,
  path: path$25,
  rect: rect5,
  rule: rule5,
  shape: shape5,
  symbol: symbol5,
  text: text5,
  trail: trail5
};
function domCreate5(doc, tag, ns) {
  if (!doc && typeof document !== "undefined" && document.createElement) {
    doc = document;
  }
  return doc ? ns ? doc.createElementNS(ns, tag) : doc.createElement(tag) : null;
}
function domFind5(el, tag) {
  tag = tag.toLowerCase();
  var nodes = el.childNodes, i = 0, n = nodes.length;
  for (; i < n; ++i)
    if (nodes[i].tagName.toLowerCase() === tag) {
      return nodes[i];
    }
}
function domChild5(el, index4, tag, ns) {
  var a4 = el.childNodes[index4], b6;
  if (!a4 || a4.tagName.toLowerCase() !== tag.toLowerCase()) {
    b6 = a4 || null;
    a4 = domCreate5(el.ownerDocument, tag, ns);
    el.insertBefore(a4, b6);
  }
  return a4;
}
function domClear5(el, index4) {
  var nodes = el.childNodes, curr = nodes.length;
  while (curr > index4)
    el.removeChild(nodes[--curr]);
  return el;
}
function cssClass5(mark) {
  return "mark-" + mark.marktype + (mark.role ? " role-" + mark.role : "") + (mark.name ? " " + mark.name : "");
}
function point18(event2, el) {
  const rect7 = el.getBoundingClientRect();
  return [event2.clientX - rect7.left - (el.clientLeft || 0), event2.clientY - rect7.top - (el.clientTop || 0)];
}
function resolveItem5(item, event2, el, origin) {
  var mark = item && item.mark, mdef, p;
  if (mark && (mdef = Marks5[mark.marktype]).tip) {
    p = point18(event2, el);
    p[0] -= origin[0];
    p[1] -= origin[1];
    while (item = item.mark.group) {
      p[0] -= item.x || 0;
      p[1] -= item.y || 0;
    }
    item = mdef.tip(mark.items, p);
  }
  return item;
}
var Handler5 = class {
  /**
   * Create a new Handler instance.
   * @param {object} [customLoader] - Optional loader instance for
   *   href URL sanitization. If not specified, a standard loader
   *   instance will be generated.
   * @param {function} [customTooltip] - Optional tooltip handler
   *   function for custom tooltip display.
   * @constructor
   */
  constructor(customLoader, customTooltip) {
    this._active = null;
    this._handlers = {};
    this._loader = customLoader || loader6();
    this._tooltip = customTooltip || defaultTooltip5;
  }
  /**
   * Initialize a new Handler instance.
   * @param {DOMElement} el - The containing DOM element for the display.
   * @param {Array<number>} origin - The origin of the display, in pixels.
   *   The coordinate system will be translated to this point.
   * @param {object} [obj] - Optional context object that should serve as
   *   the "this" context for event callbacks.
   * @return {Handler} - This handler instance.
   */
  initialize(el, origin, obj) {
    this._el = el;
    this._obj = obj || null;
    return this.origin(origin);
  }
  /**
   * Returns the parent container element for a visualization.
   * @return {DOMElement} - The containing DOM element.
   */
  element() {
    return this._el;
  }
  /**
   * Returns the scene element (e.g., canvas or SVG) of the visualization
   * Subclasses must override if the first child is not the scene element.
   * @return {DOMElement} - The scene (e.g., canvas or SVG) element.
   */
  canvas() {
    return this._el && this._el.firstChild;
  }
  /**
   * Get / set the origin coordinates of the visualization.
   */
  origin(origin) {
    if (arguments.length) {
      this._origin = origin || [0, 0];
      return this;
    } else {
      return this._origin.slice();
    }
  }
  /**
   * Get / set the scenegraph root.
   */
  scene(scene) {
    if (!arguments.length)
      return this._scene;
    this._scene = scene;
    return this;
  }
  /**
   * Add an event handler. Subclasses should override this method.
   */
  on() {
  }
  /**
   * Remove an event handler. Subclasses should override this method.
   */
  off() {
  }
  /**
   * Utility method for finding the array index of an event handler.
   * @param {Array} h - An array of registered event handlers.
   * @param {string} type - The event type.
   * @param {function} handler - The event handler instance to find.
   * @return {number} - The handler's array index or -1 if not registered.
   */
  _handlerIndex(h6, type7, handler) {
    for (let i = h6 ? h6.length : 0; --i >= 0; ) {
      if (h6[i].type === type7 && (!handler || h6[i].handler === handler)) {
        return i;
      }
    }
    return -1;
  }
  /**
   * Returns an array with registered event handlers.
   * @param {string} [type] - The event type to query. Any annotations
   *   are ignored; for example, for the argument "click.foo", ".foo" will
   *   be ignored and the method returns all "click" handlers. If type is
   *   null or unspecified, this method returns handlers for all types.
   * @return {Array} - A new array containing all registered event handlers.
   */
  handlers(type7) {
    const h6 = this._handlers, a4 = [];
    if (type7) {
      a4.push(...h6[this.eventName(type7)]);
    } else {
      for (const k3 in h6) {
        a4.push(...h6[k3]);
      }
    }
    return a4;
  }
  /**
   * Parses an event name string to return the specific event type.
   * For example, given "click.foo" returns "click"
   * @param {string} name - The input event type string.
   * @return {string} - A string with the event type only.
   */
  eventName(name) {
    const i = name.indexOf(".");
    return i < 0 ? name : name.slice(0, i);
  }
  /**
   * Handle hyperlink navigation in response to an item.href value.
   * @param {Event} event - The event triggering hyperlink navigation.
   * @param {Item} item - The scenegraph item.
   * @param {string} href - The URL to navigate to.
   */
  handleHref(event2, item, href6) {
    this._loader.sanitize(href6, {
      context: "href"
    }).then((opt) => {
      const e3 = new MouseEvent(event2.type, event2), a4 = domCreate5(null, "a");
      for (const name in opt)
        a4.setAttribute(name, opt[name]);
      a4.dispatchEvent(e3);
    }).catch(() => {
    });
  }
  /**
   * Handle tooltip display in response to an item.tooltip value.
   * @param {Event} event - The event triggering tooltip display.
   * @param {Item} item - The scenegraph item.
   * @param {boolean} show - A boolean flag indicating whether
   *   to show or hide a tooltip for the given item.
   */
  handleTooltip(event2, item, show) {
    if (item && item.tooltip != null) {
      item = resolveItem5(item, event2, this.canvas(), this._origin);
      const value7 = show && item && item.tooltip || null;
      this._tooltip.call(this._obj, this, event2, item, value7);
    }
  }
  /**
   * Returns the size of a scenegraph item and its position relative
   * to the viewport.
   * @param {Item} item - The scenegraph item.
   * @return {object} - A bounding box object (compatible with the
   *   DOMRect type) consisting of x, y, width, heigh, top, left,
   *   right, and bottom properties.
   */
  getItemBoundingClientRect(item) {
    const el = this.canvas();
    if (!el)
      return;
    const rect7 = el.getBoundingClientRect(), origin = this._origin, bounds6 = item.bounds, width2 = bounds6.width(), height2 = bounds6.height();
    let x9 = bounds6.x1 + origin[0] + rect7.left, y9 = bounds6.y1 + origin[1] + rect7.top;
    while (item.mark && (item = item.mark.group)) {
      x9 += item.x || 0;
      y9 += item.y || 0;
    }
    return {
      x: x9,
      y: y9,
      width: width2,
      height: height2,
      left: x9,
      top: y9,
      right: x9 + width2,
      bottom: y9 + height2
    };
  }
};
function defaultTooltip5(handler, event2, item, value7) {
  handler.element().setAttribute("title", value7 || "");
}
var Renderer5 = class {
  /**
   * Create a new Renderer instance.
   * @param {object} [loader] - Optional loader instance for
   *   image and href URL sanitization. If not specified, a
   *   standard loader instance will be generated.
   * @constructor
   */
  constructor(loader7) {
    this._el = null;
    this._bgcolor = null;
    this._loader = new ResourceLoader5(loader7);
  }
  /**
   * Initialize a new Renderer instance.
   * @param {DOMElement} el - The containing DOM element for the display.
   * @param {number} width - The coordinate width of the display, in pixels.
   * @param {number} height - The coordinate height of the display, in pixels.
   * @param {Array<number>} origin - The origin of the display, in pixels.
   *   The coordinate system will be translated to this point.
   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
   *   the width and height to determine the final pixel size.
   * @return {Renderer} - This renderer instance.
   */
  initialize(el, width2, height2, origin, scaleFactor) {
    this._el = el;
    return this.resize(width2, height2, origin, scaleFactor);
  }
  /**
   * Returns the parent container element for a visualization.
   * @return {DOMElement} - The containing DOM element.
   */
  element() {
    return this._el;
  }
  /**
   * Returns the scene element (e.g., canvas or SVG) of the visualization
   * Subclasses must override if the first child is not the scene element.
   * @return {DOMElement} - The scene (e.g., canvas or SVG) element.
   */
  canvas() {
    return this._el && this._el.firstChild;
  }
  /**
   * Get / set the background color.
   */
  background(bgcolor) {
    if (arguments.length === 0)
      return this._bgcolor;
    this._bgcolor = bgcolor;
    return this;
  }
  /**
   * Resize the display.
   * @param {number} width - The new coordinate width of the display, in pixels.
   * @param {number} height - The new coordinate height of the display, in pixels.
   * @param {Array<number>} origin - The new origin of the display, in pixels.
   *   The coordinate system will be translated to this point.
   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
   *   the width and height to determine the final pixel size.
   * @return {Renderer} - This renderer instance;
   */
  resize(width2, height2, origin, scaleFactor) {
    this._width = width2;
    this._height = height2;
    this._origin = origin || [0, 0];
    this._scale = scaleFactor || 1;
    return this;
  }
  /**
   * Report a dirty item whose bounds should be redrawn.
   * This base class method does nothing. Subclasses that perform
   * incremental should implement this method.
   * @param {Item} item - The dirty item whose bounds should be redrawn.
   */
  dirty() {
  }
  /**
   * Render an input scenegraph, potentially with a set of dirty items.
   * This method will perform an immediate rendering with available resources.
   * The renderer may also need to perform image loading to perform a complete
   * render. This process can lead to asynchronous re-rendering of the scene
   * after this method returns. To receive notification when rendering is
   * complete, use the renderAsync method instead.
   * @param {object} scene - The root mark of a scenegraph to render.
   * @param {Array} markTypes - Array of the mark types to render.
   *                            If undefined, render all mark types
   * @return {Renderer} - This renderer instance.
   */
  render(scene, markTypes) {
    const r = this;
    r._call = function() {
      r._render(scene, markTypes);
    };
    r._call();
    r._call = null;
    return r;
  }
  /**
   * Internal rendering method. Renderer subclasses should override this
   * method to actually perform rendering.
   * @param {object} scene - The root mark of a scenegraph to render.
   * @param {Array} markTypes - Array of the mark types to render.
   *                            If undefined, render all mark types
   */
  _render() {
  }
  /**
   * Asynchronous rendering method. Similar to render, but returns a Promise
   * that resolves when all rendering is completed. Sometimes a renderer must
   * perform image loading to get a complete rendering. The returned
   * Promise will not resolve until this process completes.
   * @param {object} scene - The root mark of a scenegraph to render.
   * @param {Array} markTypes - Array of the mark types to render.
   *                            If undefined, render all mark types
   * @return {Promise} - A Promise that resolves when rendering is complete.
   */
  renderAsync(scene, markTypes) {
    const r = this.render(scene, markTypes);
    return this._ready ? this._ready.then(() => r) : Promise.resolve(r);
  }
  /**
   * Internal method for asynchronous resource loading.
   * Proxies method calls to the ImageLoader, and tracks loading
   * progress to invoke a re-render once complete.
   * @param {string} method - The method name to invoke on the ImageLoader.
   * @param {string} uri - The URI for the requested resource.
   * @return {Promise} - A Promise that resolves to the requested resource.
   */
  _load(method10, uri) {
    var r = this, p = r._loader[method10](uri);
    if (!r._ready) {
      const call = r._call;
      r._ready = r._loader.ready().then((redraw) => {
        if (redraw)
          call();
        r._ready = null;
      });
    }
    return p;
  }
  /**
   * Sanitize a URL to include as a hyperlink in the rendered scene.
   * This method proxies a call to ImageLoader.sanitizeURL, but also tracks
   * image loading progress and invokes a re-render once complete.
   * @param {string} uri - The URI string to sanitize.
   * @return {Promise} - A Promise that resolves to the sanitized URL.
   */
  sanitizeURL(uri) {
    return this._load("sanitizeURL", uri);
  }
  /**
   * Requests an image to include in the rendered scene.
   * This method proxies a call to ImageLoader.loadImage, but also tracks
   * image loading progress and invokes a re-render once complete.
   * @param {string} uri - The URI string of the image.
   * @return {Promise} - A Promise that resolves to the loaded Image.
   */
  loadImage(uri) {
    return this._load("loadImage", uri);
  }
};
var KeyDownEvent5 = "keydown";
var KeyPressEvent5 = "keypress";
var KeyUpEvent5 = "keyup";
var DragEnterEvent5 = "dragenter";
var DragLeaveEvent5 = "dragleave";
var DragOverEvent5 = "dragover";
var PointerDownEvent5 = "pointerdown";
var PointerUpEvent5 = "pointerup";
var PointerMoveEvent5 = "pointermove";
var PointerOutEvent5 = "pointerout";
var PointerOverEvent5 = "pointerover";
var MouseDownEvent5 = "mousedown";
var MouseUpEvent5 = "mouseup";
var MouseMoveEvent5 = "mousemove";
var MouseOutEvent5 = "mouseout";
var MouseOverEvent5 = "mouseover";
var ClickEvent5 = "click";
var DoubleClickEvent5 = "dblclick";
var WheelEvent5 = "wheel";
var MouseWheelEvent5 = "mousewheel";
var TouchStartEvent5 = "touchstart";
var TouchMoveEvent5 = "touchmove";
var TouchEndEvent5 = "touchend";
var Events5 = [KeyDownEvent5, KeyPressEvent5, KeyUpEvent5, DragEnterEvent5, DragLeaveEvent5, DragOverEvent5, PointerDownEvent5, PointerUpEvent5, PointerMoveEvent5, PointerOutEvent5, PointerOverEvent5, MouseDownEvent5, MouseUpEvent5, MouseMoveEvent5, MouseOutEvent5, MouseOverEvent5, ClickEvent5, DoubleClickEvent5, WheelEvent5, MouseWheelEvent5, TouchStartEvent5, TouchMoveEvent5, TouchEndEvent5];
var TooltipShowEvent5 = PointerMoveEvent5;
var TooltipHideEvent5 = MouseOutEvent5;
var HrefEvent5 = ClickEvent5;
var CanvasHandler5 = class extends Handler5 {
  constructor(loader7, tooltip2) {
    super(loader7, tooltip2);
    this._down = null;
    this._touch = null;
    this._first = true;
    this._events = {};
    this.events = Events5;
    this.pointermove = move5([PointerMoveEvent5, MouseMoveEvent5], [PointerOverEvent5, MouseOverEvent5], [PointerOutEvent5, MouseOutEvent5]);
    this.dragover = move5([DragOverEvent5], [DragEnterEvent5], [DragLeaveEvent5]), this.pointerout = inactive5([PointerOutEvent5, MouseOutEvent5]);
    this.dragleave = inactive5([DragLeaveEvent5]);
  }
  initialize(el, origin, obj) {
    this._canvas = el && domFind5(el, "canvas");
    [ClickEvent5, MouseDownEvent5, PointerDownEvent5, PointerMoveEvent5, PointerOutEvent5, DragLeaveEvent5].forEach((type7) => eventListenerCheck5(this, type7));
    return super.initialize(el, origin, obj);
  }
  // return the backing canvas instance
  canvas() {
    return this._canvas;
  }
  // retrieve the current canvas context
  context() {
    return this._canvas.getContext("2d");
  }
  // to keep old versions of firefox happy
  DOMMouseScroll(evt) {
    this.fire(MouseWheelEvent5, evt);
  }
  pointerdown(evt) {
    this._down = this._active;
    this.fire(PointerDownEvent5, evt);
  }
  mousedown(evt) {
    this._down = this._active;
    this.fire(MouseDownEvent5, evt);
  }
  click(evt) {
    if (this._down === this._active) {
      this.fire(ClickEvent5, evt);
      this._down = null;
    }
  }
  touchstart(evt) {
    this._touch = this.pickEvent(evt.changedTouches[0]);
    if (this._first) {
      this._active = this._touch;
      this._first = false;
    }
    this.fire(TouchStartEvent5, evt, true);
  }
  touchmove(evt) {
    this.fire(TouchMoveEvent5, evt, true);
  }
  touchend(evt) {
    this.fire(TouchEndEvent5, evt, true);
    this._touch = null;
  }
  // fire an event
  fire(type7, evt, touch2) {
    const a4 = touch2 ? this._touch : this._active, h6 = this._handlers[type7];
    evt.vegaType = type7;
    if (type7 === HrefEvent5 && a4 && a4.href) {
      this.handleHref(evt, a4, a4.href);
    } else if (type7 === TooltipShowEvent5 || type7 === TooltipHideEvent5) {
      this.handleTooltip(evt, a4, type7 !== TooltipHideEvent5);
    }
    if (h6) {
      for (let i = 0, len = h6.length; i < len; ++i) {
        h6[i].handler.call(this._obj, evt, a4);
      }
    }
  }
  // add an event handler
  on(type7, handler) {
    const name = this.eventName(type7), h6 = this._handlers, i = this._handlerIndex(h6[name], type7, handler);
    if (i < 0) {
      eventListenerCheck5(this, type7);
      (h6[name] || (h6[name] = [])).push({
        type: type7,
        handler
      });
    }
    return this;
  }
  // remove an event handler
  off(type7, handler) {
    const name = this.eventName(type7), h6 = this._handlers[name], i = this._handlerIndex(h6, type7, handler);
    if (i >= 0) {
      h6.splice(i, 1);
    }
    return this;
  }
  pickEvent(evt) {
    const p = point18(evt, this._canvas), o = this._origin;
    return this.pick(this._scene, p[0], p[1], p[0] - o[0], p[1] - o[1]);
  }
  // find the scenegraph item at the current pointer position
  // x, y -- the absolute x, y pointer coordinates on the canvas element
  // gx, gy -- the relative coordinates within the current group
  pick(scene, x9, y9, gx, gy) {
    const g = this.context(), mark = Marks5[scene.marktype];
    return mark.pick.call(this, g, scene, x9, y9, gx, gy);
  }
};
var eventBundle5 = (type7) => type7 === TouchStartEvent5 || type7 === TouchMoveEvent5 || type7 === TouchEndEvent5 ? [TouchStartEvent5, TouchMoveEvent5, TouchEndEvent5] : [type7];
function eventListenerCheck5(handler, type7) {
  eventBundle5(type7).forEach((_) => addEventListener5(handler, _));
}
function addEventListener5(handler, type7) {
  const canvas = handler.canvas();
  if (canvas && !handler._events[type7]) {
    handler._events[type7] = 1;
    canvas.addEventListener(type7, handler[type7] ? (evt) => handler[type7](evt) : (evt) => handler.fire(type7, evt));
  }
}
function fireAll5(handler, types, event2) {
  types.forEach((type7) => handler.fire(type7, event2));
}
function move5(moveEvents, overEvents, outEvents) {
  return function(evt) {
    const a4 = this._active, p = this.pickEvent(evt);
    if (p === a4) {
      fireAll5(this, moveEvents, evt);
    } else {
      if (!a4 || !a4.exit) {
        fireAll5(this, outEvents, evt);
      }
      this._active = p;
      fireAll5(this, overEvents, evt);
      fireAll5(this, moveEvents, evt);
    }
  };
}
function inactive5(types) {
  return function(evt) {
    fireAll5(this, types, evt);
    this._active = null;
  };
}
function devicePixelRatio5() {
  return typeof window !== "undefined" ? window.devicePixelRatio || 1 : 1;
}
function resize5(canvas, width2, height2, origin, scaleFactor, opt) {
  const inDOM = typeof HTMLElement !== "undefined" && canvas instanceof HTMLElement && canvas.parentNode != null, context7 = canvas.getContext("2d"), ratio = inDOM ? devicePixelRatio5() : scaleFactor;
  canvas.width = width2 * ratio;
  canvas.height = height2 * ratio;
  for (const key4 in opt) {
    context7[key4] = opt[key4];
  }
  if (inDOM && ratio !== 1) {
    canvas.style.width = width2 + "px";
    canvas.style.height = height2 + "px";
  }
  context7.pixelRatio = ratio;
  context7.setTransform(ratio, 0, 0, ratio, ratio * origin[0], ratio * origin[1]);
  return canvas;
}
var CanvasRenderer5 = class extends Renderer5 {
  constructor(loader7) {
    super(loader7);
    this._options = {};
    this._redraw = false;
    this._dirty = new Bounds5();
    this._tempb = new Bounds5();
  }
  initialize(el, width2, height2, origin, scaleFactor, options) {
    this._options = options || {};
    this._canvas = this._options.externalContext ? null : domCanvas7(1, 1, this._options.type);
    if (el && this._canvas) {
      domClear5(el, 0).appendChild(this._canvas);
      this._canvas.setAttribute("class", "marks");
    }
    return super.initialize(el, width2, height2, origin, scaleFactor);
  }
  resize(width2, height2, origin, scaleFactor) {
    super.resize(width2, height2, origin, scaleFactor);
    if (this._canvas) {
      resize5(this._canvas, this._width, this._height, this._origin, this._scale, this._options.context);
    } else {
      const ctx = this._options.externalContext;
      if (!ctx)
        error16("CanvasRenderer is missing a valid canvas or context");
      ctx.scale(this._scale, this._scale);
      ctx.translate(this._origin[0], this._origin[1]);
    }
    this._redraw = true;
    return this;
  }
  canvas() {
    return this._canvas;
  }
  context() {
    return this._options.externalContext || (this._canvas ? this._canvas.getContext("2d") : null);
  }
  dirty(item) {
    const b6 = this._tempb.clear().union(item.bounds);
    let g = item.mark.group;
    while (g) {
      b6.translate(g.x || 0, g.y || 0);
      g = g.mark.group;
    }
    this._dirty.union(b6);
  }
  _render(scene, markTypes) {
    const g = this.context(), o = this._origin, w8 = this._width, h6 = this._height, db = this._dirty, vb = viewBounds5(o, w8, h6);
    g.save();
    const b6 = this._redraw || db.empty() ? (this._redraw = false, vb.expand(1)) : clipToBounds5(g, vb.intersect(db), o);
    this.clear(-o[0], -o[1], w8, h6);
    this.draw(g, scene, b6, markTypes);
    g.restore();
    db.clear();
    return this;
  }
  draw(ctx, scene, bounds6, markTypes) {
    if (scene.marktype !== "group" && markTypes != null && !markTypes.includes(scene.marktype)) {
      return;
    }
    const mark = Marks5[scene.marktype];
    if (scene.clip)
      clip5(ctx, scene);
    mark.draw.call(this, ctx, scene, bounds6, markTypes);
    if (scene.clip)
      ctx.restore();
  }
  clear(x9, y9, w8, h6) {
    const opt = this._options, g = this.context();
    if (opt.type !== "pdf" && !opt.externalContext) {
      g.clearRect(x9, y9, w8, h6);
    }
    if (this._bgcolor != null) {
      g.fillStyle = this._bgcolor;
      g.fillRect(x9, y9, w8, h6);
    }
  }
};
var viewBounds5 = (origin, width2, height2) => new Bounds5().set(0, 0, width2, height2).translate(-origin[0], -origin[1]);
function clipToBounds5(g, b6, origin) {
  b6.expand(1).round();
  if (g.pixelRatio % 1) {
    b6.scale(g.pixelRatio).round().scale(1 / g.pixelRatio);
  }
  b6.translate(-(origin[0] % 1), -(origin[1] % 1));
  g.beginPath();
  g.rect(b6.x1, b6.y1, b6.width(), b6.height());
  g.clip();
  return b6;
}
var SVGHandler5 = class extends Handler5 {
  constructor(loader7, tooltip2) {
    super(loader7, tooltip2);
    const h6 = this;
    h6._hrefHandler = listener5(h6, (evt, item) => {
      if (item && item.href)
        h6.handleHref(evt, item, item.href);
    });
    h6._tooltipHandler = listener5(h6, (evt, item) => {
      h6.handleTooltip(evt, item, evt.type !== TooltipHideEvent5);
    });
  }
  initialize(el, origin, obj) {
    let svg = this._svg;
    if (svg) {
      svg.removeEventListener(HrefEvent5, this._hrefHandler);
      svg.removeEventListener(TooltipShowEvent5, this._tooltipHandler);
      svg.removeEventListener(TooltipHideEvent5, this._tooltipHandler);
    }
    this._svg = svg = el && domFind5(el, "svg");
    if (svg) {
      svg.addEventListener(HrefEvent5, this._hrefHandler);
      svg.addEventListener(TooltipShowEvent5, this._tooltipHandler);
      svg.addEventListener(TooltipHideEvent5, this._tooltipHandler);
    }
    return super.initialize(el, origin, obj);
  }
  canvas() {
    return this._svg;
  }
  // add an event handler
  on(type7, handler) {
    const name = this.eventName(type7), h6 = this._handlers, i = this._handlerIndex(h6[name], type7, handler);
    if (i < 0) {
      const x9 = {
        type: type7,
        handler,
        listener: listener5(this, handler)
      };
      (h6[name] || (h6[name] = [])).push(x9);
      if (this._svg) {
        this._svg.addEventListener(name, x9.listener);
      }
    }
    return this;
  }
  // remove an event handler
  off(type7, handler) {
    const name = this.eventName(type7), h6 = this._handlers[name], i = this._handlerIndex(h6, type7, handler);
    if (i >= 0) {
      if (this._svg) {
        this._svg.removeEventListener(name, h6[i].listener);
      }
      h6.splice(i, 1);
    }
    return this;
  }
};
var listener5 = (context7, handler) => (evt) => {
  let item = evt.target.__data__;
  item = Array.isArray(item) ? item[0] : item;
  evt.vegaType = evt.type;
  handler.call(context7._obj, evt, item);
};
var ARIA_HIDDEN5 = "aria-hidden";
var ARIA_LABEL5 = "aria-label";
var ARIA_ROLE5 = "role";
var ARIA_ROLEDESCRIPTION5 = "aria-roledescription";
var GRAPHICS_OBJECT5 = "graphics-object";
var GRAPHICS_SYMBOL5 = "graphics-symbol";
var bundle5 = (role, roledesc, label) => ({
  [ARIA_ROLE5]: role,
  [ARIA_ROLEDESCRIPTION5]: roledesc,
  [ARIA_LABEL5]: label || void 0
});
var AriaIgnore5 = toSet11(["axis-domain", "axis-grid", "axis-label", "axis-tick", "axis-title", "legend-band", "legend-entry", "legend-gradient", "legend-label", "legend-title", "legend-symbol", "title"]);
var AriaGuides5 = {
  "axis": {
    desc: "axis",
    caption: axisCaption5
  },
  "legend": {
    desc: "legend",
    caption: legendCaption5
  },
  "title-text": {
    desc: "title",
    caption: (item) => `Title text '${titleCaption5(item)}'`
  },
  "title-subtitle": {
    desc: "subtitle",
    caption: (item) => `Subtitle text '${titleCaption5(item)}'`
  }
};
var AriaEncode5 = {
  ariaRole: ARIA_ROLE5,
  ariaRoleDescription: ARIA_ROLEDESCRIPTION5,
  description: ARIA_LABEL5
};
function ariaItemAttributes5(emit6, item) {
  const hide = item.aria === false;
  emit6(ARIA_HIDDEN5, hide || void 0);
  if (hide || item.description == null) {
    for (const prop in AriaEncode5) {
      emit6(AriaEncode5[prop], void 0);
    }
  } else {
    const type7 = item.mark.marktype;
    emit6(ARIA_LABEL5, item.description);
    emit6(ARIA_ROLE5, item.ariaRole || (type7 === "group" ? GRAPHICS_OBJECT5 : GRAPHICS_SYMBOL5));
    emit6(ARIA_ROLEDESCRIPTION5, item.ariaRoleDescription || `${type7} mark`);
  }
}
function ariaMarkAttributes5(mark) {
  return mark.aria === false ? {
    [ARIA_HIDDEN5]: true
  } : AriaIgnore5[mark.role] ? null : AriaGuides5[mark.role] ? ariaGuide5(mark, AriaGuides5[mark.role]) : ariaMark5(mark);
}
function ariaMark5(mark) {
  const type7 = mark.marktype;
  const recurse6 = type7 === "group" || type7 === "text" || mark.items.some((_) => _.description != null && _.aria !== false);
  return bundle5(recurse6 ? GRAPHICS_OBJECT5 : GRAPHICS_SYMBOL5, `${type7} mark container`, mark.description);
}
function ariaGuide5(mark, opt) {
  try {
    const item = mark.items[0], caption = opt.caption || (() => "");
    return bundle5(opt.role || GRAPHICS_SYMBOL5, opt.desc, item.description || caption(item));
  } catch (err) {
    return null;
  }
}
function titleCaption5(item) {
  return array15(item.text).join(" ");
}
function axisCaption5(item) {
  const datum2 = item.datum, orient2 = item.orient, title2 = datum2.title ? extractTitle5(item) : null, ctx = item.context, scale19 = ctx.scales[datum2.scale].value, locale5 = ctx.dataflow.locale(), type7 = scale19.type, xy = orient2 === "left" || orient2 === "right" ? "Y" : "X";
  return `${xy}-axis` + (title2 ? ` titled '${title2}'` : "") + ` for a ${isDiscrete5(type7) ? "discrete" : type7} scale with ${domainCaption5(locale5, scale19, item)}`;
}
function legendCaption5(item) {
  const datum2 = item.datum, title2 = datum2.title ? extractTitle5(item) : null, type7 = `${datum2.type || ""} legend`.trim(), scales10 = datum2.scales, props = Object.keys(scales10), ctx = item.context, scale19 = ctx.scales[scales10[props[0]]].value, locale5 = ctx.dataflow.locale();
  return capitalize5(type7) + (title2 ? ` titled '${title2}'` : "") + ` for ${channelCaption5(props)} with ${domainCaption5(locale5, scale19, item)}`;
}
function extractTitle5(item) {
  try {
    return array15(peek10(item.items).items[0].text).join(" ");
  } catch (err) {
    return null;
  }
}
function channelCaption5(props) {
  props = props.map((p) => p + (p === "fill" || p === "stroke" ? " color" : ""));
  return props.length < 2 ? props[0] : props.slice(0, -1).join(", ") + " and " + peek10(props);
}
function capitalize5(s2) {
  return s2.length ? s2[0].toUpperCase() + s2.slice(1) : s2;
}
var innerText5 = (val) => (val + "").replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
var attrText5 = (val) => innerText5(val).replace(/"/g, "&quot;").replace(/\t/g, "&#x9;").replace(/\n/g, "&#xA;").replace(/\r/g, "&#xD;");
function markup5() {
  let buf = "", outer = "", inner = "";
  const stack2 = [], clear2 = () => outer = inner = "", push = (tag) => {
    if (outer) {
      buf += `${outer}>${inner}`;
      clear2();
    }
    stack2.push(tag);
  }, attr6 = (name, value7) => {
    if (value7 != null)
      outer += ` ${name}="${attrText5(value7)}"`;
    return m3;
  }, m3 = {
    open(tag, ...attrs) {
      push(tag);
      outer = "<" + tag;
      for (const set7 of attrs) {
        for (const key4 in set7)
          attr6(key4, set7[key4]);
      }
      return m3;
    },
    close() {
      const tag = stack2.pop();
      if (outer) {
        buf += outer + (inner ? `>${inner}</${tag}>` : "/>");
      } else {
        buf += `</${tag}>`;
      }
      clear2();
      return m3;
    },
    attr: attr6,
    text: (t) => (inner += innerText5(t), m3),
    toString: () => buf
  };
  return m3;
}
var serializeXML5 = (node) => _serialize5(markup5(), node) + "";
function _serialize5(m3, node) {
  m3.open(node.tagName);
  if (node.hasAttributes()) {
    const attrs = node.attributes, n = attrs.length;
    for (let i = 0; i < n; ++i) {
      m3.attr(attrs[i].name, attrs[i].value);
    }
  }
  if (node.hasChildNodes()) {
    const children3 = node.childNodes;
    for (const child of children3) {
      child.nodeType === 3 ? m3.text(child.nodeValue) : _serialize5(m3, child);
    }
  }
  return m3.close();
}
var stylesAttr5 = {
  fill: "fill",
  fillOpacity: "fill-opacity",
  stroke: "stroke",
  strokeOpacity: "stroke-opacity",
  strokeWidth: "stroke-width",
  strokeCap: "stroke-linecap",
  strokeJoin: "stroke-linejoin",
  strokeDash: "stroke-dasharray",
  strokeDashOffset: "stroke-dashoffset",
  strokeMiterLimit: "stroke-miterlimit",
  opacity: "opacity"
};
var stylesCss5 = {
  blend: "mix-blend-mode"
};
var rootAttributes5 = {
  "fill": "none",
  "stroke-miterlimit": 10
};
var RootIndex5 = 0;
var xmlns5 = "http://www.w3.org/2000/xmlns/";
var svgns5 = metadata5.xmlns;
var SVGRenderer5 = class extends Renderer5 {
  constructor(loader7) {
    super(loader7);
    this._dirtyID = 0;
    this._dirty = [];
    this._svg = null;
    this._root = null;
    this._defs = null;
  }
  /**
   * Initialize a new SVGRenderer instance.
   * @param {DOMElement} el - The containing DOM element for the display.
   * @param {number} width - The coordinate width of the display, in pixels.
   * @param {number} height - The coordinate height of the display, in pixels.
   * @param {Array<number>} origin - The origin of the display, in pixels.
   *   The coordinate system will be translated to this point.
   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
   *   the width and height to determine the final pixel size.
   * @return {SVGRenderer} - This renderer instance.
   */
  initialize(el, width2, height2, origin, scaleFactor) {
    this._defs = {};
    this._clearDefs();
    if (el) {
      this._svg = domChild5(el, 0, "svg", svgns5);
      this._svg.setAttributeNS(xmlns5, "xmlns", svgns5);
      this._svg.setAttributeNS(xmlns5, "xmlns:xlink", metadata5["xmlns:xlink"]);
      this._svg.setAttribute("version", metadata5["version"]);
      this._svg.setAttribute("class", "marks");
      domClear5(el, 1);
      this._root = domChild5(this._svg, RootIndex5, "g", svgns5);
      setAttributes5(this._root, rootAttributes5);
      domClear5(this._svg, RootIndex5 + 1);
    }
    this.background(this._bgcolor);
    return super.initialize(el, width2, height2, origin, scaleFactor);
  }
  /**
   * Get / set the background color.
   */
  background(bgcolor) {
    if (arguments.length && this._svg) {
      this._svg.style.setProperty("background-color", bgcolor);
    }
    return super.background(...arguments);
  }
  /**
   * Resize the display.
   * @param {number} width - The new coordinate width of the display, in pixels.
   * @param {number} height - The new coordinate height of the display, in pixels.
   * @param {Array<number>} origin - The new origin of the display, in pixels.
   *   The coordinate system will be translated to this point.
   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
   *   the width and height to determine the final pixel size.
   * @return {SVGRenderer} - This renderer instance;
   */
  resize(width2, height2, origin, scaleFactor) {
    super.resize(width2, height2, origin, scaleFactor);
    if (this._svg) {
      setAttributes5(this._svg, {
        width: this._width * this._scale,
        height: this._height * this._scale,
        viewBox: `0 0 ${this._width} ${this._height}`
      });
      this._root.setAttribute("transform", `translate(${this._origin})`);
    }
    this._dirty = [];
    return this;
  }
  /**
   * Returns the SVG element of the visualization.
   * @return {DOMElement} - The SVG element.
   */
  canvas() {
    return this._svg;
  }
  /**
   * Returns an SVG text string for the rendered content,
   * or null if this renderer is currently headless.
   */
  svg() {
    const svg = this._svg, bg = this._bgcolor;
    if (!svg)
      return null;
    let node;
    if (bg) {
      svg.removeAttribute("style");
      node = domChild5(svg, RootIndex5, "rect", svgns5);
      setAttributes5(node, {
        width: this._width,
        height: this._height,
        fill: bg
      });
    }
    const text7 = serializeXML5(svg);
    if (bg) {
      svg.removeChild(node);
      this._svg.style.setProperty("background-color", bg);
    }
    return text7;
  }
  /**
   * Internal rendering method.
   * @param {object} scene - The root mark of a scenegraph to render.
   * @param {Array} markTypes - Array of the mark types to render.
   *                            If undefined, render all mark types
   */
  _render(scene, markTypes) {
    if (this._dirtyCheck()) {
      if (this._dirtyAll)
        this._clearDefs();
      this.mark(this._root, scene, void 0, markTypes);
      domClear5(this._root, 1);
    }
    this.defs();
    this._dirty = [];
    ++this._dirtyID;
    return this;
  }
  // -- Manage rendering of items marked as dirty --
  /**
   * Flag a mark item as dirty.
   * @param {Item} item - The mark item.
   */
  dirty(item) {
    if (item.dirty !== this._dirtyID) {
      item.dirty = this._dirtyID;
      this._dirty.push(item);
    }
  }
  /**
   * Check if a mark item is considered dirty.
   * @param {Item} item - The mark item.
   */
  isDirty(item) {
    return this._dirtyAll || !item._svg || !item._svg.ownerSVGElement || item.dirty === this._dirtyID;
  }
  /**
   * Internal method to check dirty status and, if possible,
   * make targetted updates without a full rendering pass.
   */
  _dirtyCheck() {
    this._dirtyAll = true;
    const items = this._dirty;
    if (!items.length || !this._dirtyID)
      return true;
    const id24 = ++this._dirtyID;
    let item, mark, type7, mdef, i, n, o;
    for (i = 0, n = items.length; i < n; ++i) {
      item = items[i];
      mark = item.mark;
      if (mark.marktype !== type7) {
        type7 = mark.marktype;
        mdef = Marks5[type7];
      }
      if (mark.zdirty && mark.dirty !== id24) {
        this._dirtyAll = false;
        dirtyParents5(item, id24);
        mark.items.forEach((i2) => {
          i2.dirty = id24;
        });
      }
      if (mark.zdirty)
        continue;
      if (item.exit) {
        if (mdef.nested && mark.items.length) {
          o = mark.items[0];
          if (o._svg)
            this._update(mdef, o._svg, o);
        } else if (item._svg) {
          o = item._svg.parentNode;
          if (o)
            o.removeChild(item._svg);
        }
        item._svg = null;
        continue;
      }
      item = mdef.nested ? mark.items[0] : item;
      if (item._update === id24)
        continue;
      if (!item._svg || !item._svg.ownerSVGElement) {
        this._dirtyAll = false;
        dirtyParents5(item, id24);
      } else {
        this._update(mdef, item._svg, item);
      }
      item._update = id24;
    }
    return !this._dirtyAll;
  }
  // -- Construct & maintain scenegraph to SVG mapping ---
  /**
   * Render a set of mark items.
   * @param {SVGElement} el - The parent element in the SVG tree.
   * @param {object} scene - The mark parent to render.
   * @param {SVGElement} prev - The previous sibling in the SVG tree.
   * @param {Array} markTypes - Array of the mark types to render.
   *                            If undefined, render all mark types
   */
  mark(el, scene, prev, markTypes) {
    if (!this.isDirty(scene)) {
      return scene._svg;
    }
    const svg = this._svg, markType2 = scene.marktype, mdef = Marks5[markType2], events3 = scene.interactive === false ? "none" : null, isGroup = mdef.tag === "g";
    const parent = bind5(scene, el, prev, "g", svg);
    if (markType2 !== "group" && markTypes != null && !markTypes.includes(markType2)) {
      domClear5(parent, 0);
      return scene._svg;
    }
    parent.setAttribute("class", cssClass5(scene));
    const aria2 = ariaMarkAttributes5(scene);
    for (const key4 in aria2)
      setAttribute5(parent, key4, aria2[key4]);
    if (!isGroup) {
      setAttribute5(parent, "pointer-events", events3);
    }
    setAttribute5(parent, "clip-path", scene.clip ? clip$15(this, scene, scene.group) : null);
    let sibling = null, i = 0;
    const process2 = (item) => {
      const dirty = this.isDirty(item), node = bind5(item, parent, sibling, mdef.tag, svg);
      if (dirty) {
        this._update(mdef, node, item);
        if (isGroup)
          recurse5(this, node, item, markTypes);
      }
      sibling = node;
      ++i;
    };
    if (mdef.nested) {
      if (scene.items.length)
        process2(scene.items[0]);
    } else {
      visit5(scene, process2);
    }
    domClear5(parent, i);
    return parent;
  }
  /**
   * Update the attributes of an SVG element for a mark item.
   * @param {object} mdef - The mark definition object
   * @param {SVGElement} el - The SVG element.
   * @param {Item} item - The mark item.
   */
  _update(mdef, el, item) {
    element5 = el;
    values5 = el.__values__;
    ariaItemAttributes5(emit5, item);
    mdef.attr(emit5, item, this);
    const extra = mark_extras5[mdef.type];
    if (extra)
      extra.call(this, mdef, el, item);
    if (element5)
      this.style(element5, item);
  }
  /**
   * Update the presentation attributes of an SVG element for a mark item.
   * @param {SVGElement} el - The SVG element.
   * @param {Item} item - The mark item.
   */
  style(el, item) {
    if (item == null)
      return;
    for (const prop in stylesAttr5) {
      let value7 = prop === "font" ? fontFamily5(item) : item[prop];
      if (value7 === values5[prop])
        continue;
      const name = stylesAttr5[prop];
      if (value7 == null) {
        el.removeAttribute(name);
      } else {
        if (isGradient5(value7)) {
          value7 = gradientRef5(value7, this._defs.gradient, href5());
        }
        el.setAttribute(name, value7 + "");
      }
      values5[prop] = value7;
    }
    for (const prop in stylesCss5) {
      setStyle5(el, stylesCss5[prop], item[prop]);
    }
  }
  /**
   * Render SVG defs, as needed.
   * Must be called *after* marks have been processed to ensure the
   * collected state is current and accurate.
   */
  defs() {
    const svg = this._svg, defs = this._defs;
    let el = defs.el, index4 = 0;
    for (const id24 in defs.gradient) {
      if (!el)
        defs.el = el = domChild5(svg, RootIndex5 + 1, "defs", svgns5);
      index4 = updateGradient5(el, defs.gradient[id24], index4);
    }
    for (const id24 in defs.clipping) {
      if (!el)
        defs.el = el = domChild5(svg, RootIndex5 + 1, "defs", svgns5);
      index4 = updateClipping5(el, defs.clipping[id24], index4);
    }
    if (el) {
      index4 === 0 ? (svg.removeChild(el), defs.el = null) : domClear5(el, index4);
    }
  }
  /**
   * Clear defs caches.
   */
  _clearDefs() {
    const def6 = this._defs;
    def6.gradient = {};
    def6.clipping = {};
  }
};
function dirtyParents5(item, id24) {
  for (; item && item.dirty !== id24; item = item.mark.group) {
    item.dirty = id24;
    if (item.mark && item.mark.dirty !== id24) {
      item.mark.dirty = id24;
    } else
      return;
  }
}
function updateGradient5(el, grad, index4) {
  let i, n, stop2;
  if (grad.gradient === "radial") {
    let pt = domChild5(el, index4++, "pattern", svgns5);
    setAttributes5(pt, {
      id: patternPrefix5 + grad.id,
      viewBox: "0,0,1,1",
      width: "100%",
      height: "100%",
      preserveAspectRatio: "xMidYMid slice"
    });
    pt = domChild5(pt, 0, "rect", svgns5);
    setAttributes5(pt, {
      width: 1,
      height: 1,
      fill: `url(${href5()}#${grad.id})`
    });
    el = domChild5(el, index4++, "radialGradient", svgns5);
    setAttributes5(el, {
      id: grad.id,
      fx: grad.x1,
      fy: grad.y1,
      fr: grad.r1,
      cx: grad.x2,
      cy: grad.y2,
      r: grad.r2
    });
  } else {
    el = domChild5(el, index4++, "linearGradient", svgns5);
    setAttributes5(el, {
      id: grad.id,
      x1: grad.x1,
      x2: grad.x2,
      y1: grad.y1,
      y2: grad.y2
    });
  }
  for (i = 0, n = grad.stops.length; i < n; ++i) {
    stop2 = domChild5(el, i, "stop", svgns5);
    stop2.setAttribute("offset", grad.stops[i].offset);
    stop2.setAttribute("stop-color", grad.stops[i].color);
  }
  domClear5(el, i);
  return index4;
}
function updateClipping5(el, clip7, index4) {
  let mask;
  el = domChild5(el, index4, "clipPath", svgns5);
  el.setAttribute("id", clip7.id);
  if (clip7.path) {
    mask = domChild5(el, 0, "path", svgns5);
    mask.setAttribute("d", clip7.path);
  } else {
    mask = domChild5(el, 0, "rect", svgns5);
    setAttributes5(mask, {
      x: 0,
      y: 0,
      width: clip7.width,
      height: clip7.height
    });
  }
  domClear5(el, 1);
  return index4 + 1;
}
function recurse5(renderer, el, group7, markTypes) {
  el = el.lastChild.previousSibling;
  let prev, idx = 0;
  visit5(group7, (item) => {
    prev = renderer.mark(el, item, prev, markTypes);
    ++idx;
  });
  domClear5(el, 1 + idx);
}
function bind5(item, el, sibling, tag, svg) {
  let node = item._svg, doc;
  if (!node) {
    doc = el.ownerDocument;
    node = domCreate5(doc, tag, svgns5);
    item._svg = node;
    if (item.mark) {
      node.__data__ = item;
      node.__values__ = {
        fill: "default"
      };
      if (tag === "g") {
        const bg = domCreate5(doc, "path", svgns5);
        node.appendChild(bg);
        bg.__data__ = item;
        const cg = domCreate5(doc, "g", svgns5);
        node.appendChild(cg);
        cg.__data__ = item;
        const fg = domCreate5(doc, "path", svgns5);
        node.appendChild(fg);
        fg.__data__ = item;
        fg.__values__ = {
          fill: "default"
        };
      }
    }
  }
  if (node.ownerSVGElement !== svg || siblingCheck5(node, sibling)) {
    el.insertBefore(node, sibling ? sibling.nextSibling : el.firstChild);
  }
  return node;
}
function siblingCheck5(node, sibling) {
  return node.parentNode && node.parentNode.childNodes.length > 1 && node.previousSibling != sibling;
}
var element5 = null;
var values5 = null;
var mark_extras5 = {
  group(mdef, el, item) {
    const fg = element5 = el.childNodes[2];
    values5 = fg.__values__;
    mdef.foreground(emit5, item, this);
    values5 = el.__values__;
    element5 = el.childNodes[1];
    mdef.content(emit5, item, this);
    const bg = element5 = el.childNodes[0];
    mdef.background(emit5, item, this);
    const value7 = item.mark.interactive === false ? "none" : null;
    if (value7 !== values5.events) {
      setAttribute5(fg, "pointer-events", value7);
      setAttribute5(bg, "pointer-events", value7);
      values5.events = value7;
    }
    if (item.strokeForeground && item.stroke) {
      const fill6 = item.fill;
      setAttribute5(fg, "display", null);
      this.style(bg, item);
      setAttribute5(bg, "stroke", null);
      if (fill6)
        item.fill = null;
      values5 = fg.__values__;
      this.style(fg, item);
      if (fill6)
        item.fill = fill6;
      element5 = null;
    } else {
      setAttribute5(fg, "display", "none");
    }
  },
  image(mdef, el, item) {
    if (item.smooth === false) {
      setStyle5(el, "image-rendering", "optimizeSpeed");
      setStyle5(el, "image-rendering", "pixelated");
    } else {
      setStyle5(el, "image-rendering", null);
    }
  },
  text(mdef, el, item) {
    const tl6 = textLines5(item);
    let key4, value7, doc, lh;
    if (isArray16(tl6)) {
      value7 = tl6.map((_) => textValue5(item, _));
      key4 = value7.join("\n");
      if (key4 !== values5.text) {
        domClear5(el, 0);
        doc = el.ownerDocument;
        lh = lineHeight5(item);
        value7.forEach((t, i) => {
          const ts6 = domCreate5(doc, "tspan", svgns5);
          ts6.__data__ = item;
          ts6.textContent = t;
          if (i) {
            ts6.setAttribute("x", 0);
            ts6.setAttribute("dy", lh);
          }
          el.appendChild(ts6);
        });
        values5.text = key4;
      }
    } else {
      value7 = textValue5(item, tl6);
      if (value7 !== values5.text) {
        el.textContent = value7;
        values5.text = value7;
      }
    }
    setAttribute5(el, "font-family", fontFamily5(item));
    setAttribute5(el, "font-size", fontSize5(item) + "px");
    setAttribute5(el, "font-style", item.fontStyle);
    setAttribute5(el, "font-variant", item.fontVariant);
    setAttribute5(el, "font-weight", item.fontWeight);
  }
};
function emit5(name, value7, ns) {
  if (value7 === values5[name])
    return;
  if (ns) {
    setAttributeNS5(element5, name, value7, ns);
  } else {
    setAttribute5(element5, name, value7);
  }
  values5[name] = value7;
}
function setStyle5(el, name, value7) {
  if (value7 !== values5[name]) {
    if (value7 == null) {
      el.style.removeProperty(name);
    } else {
      el.style.setProperty(name, value7 + "");
    }
    values5[name] = value7;
  }
}
function setAttributes5(el, attrs) {
  for (const key4 in attrs) {
    setAttribute5(el, key4, attrs[key4]);
  }
}
function setAttribute5(el, name, value7) {
  if (value7 != null) {
    el.setAttribute(name, value7);
  } else {
    el.removeAttribute(name);
  }
}
function setAttributeNS5(el, name, value7, ns) {
  if (value7 != null) {
    el.setAttributeNS(ns, name, value7);
  } else {
    el.removeAttributeNS(ns, name);
  }
}
function href5() {
  let loc;
  return typeof window === "undefined" ? "" : (loc = window.location).hash ? loc.href.slice(0, -loc.hash.length) : loc.href;
}
var SVGStringRenderer5 = class extends Renderer5 {
  constructor(loader7) {
    super(loader7);
    this._text = null;
    this._defs = {
      gradient: {},
      clipping: {}
    };
  }
  /**
   * Returns the rendered SVG text string,
   * or null if rendering has not yet occurred.
   */
  svg() {
    return this._text;
  }
  /**
   * Internal rendering method.
   * @param {object} scene - The root mark of a scenegraph to render.
   */
  _render(scene) {
    const m3 = markup5();
    m3.open("svg", extend17({}, metadata5, {
      class: "marks",
      width: this._width * this._scale,
      height: this._height * this._scale,
      viewBox: `0 0 ${this._width} ${this._height}`
    }));
    const bg = this._bgcolor;
    if (bg && bg !== "transparent" && bg !== "none") {
      m3.open("rect", {
        width: this._width,
        height: this._height,
        fill: bg
      }).close();
    }
    m3.open("g", rootAttributes5, {
      transform: "translate(" + this._origin + ")"
    });
    this.mark(m3, scene);
    m3.close();
    this.defs(m3);
    this._text = m3.close() + "";
    return this;
  }
  /**
   * Render a set of mark items.
   * @param {object} m - The markup context.
   * @param {object} scene - The mark parent to render.
   */
  mark(m3, scene) {
    const mdef = Marks5[scene.marktype], tag = mdef.tag, attrList = [ariaItemAttributes5, mdef.attr];
    m3.open("g", {
      "class": cssClass5(scene),
      "clip-path": scene.clip ? clip$15(this, scene, scene.group) : null
    }, ariaMarkAttributes5(scene), {
      "pointer-events": tag !== "g" && scene.interactive === false ? "none" : null
    });
    const process2 = (item) => {
      const href6 = this.href(item);
      if (href6)
        m3.open("a", href6);
      m3.open(tag, this.attr(scene, item, attrList, tag !== "g" ? tag : null));
      if (tag === "text") {
        const tl6 = textLines5(item);
        if (isArray16(tl6)) {
          const attrs = {
            x: 0,
            dy: lineHeight5(item)
          };
          for (let i = 0; i < tl6.length; ++i) {
            m3.open("tspan", i ? attrs : null).text(textValue5(item, tl6[i])).close();
          }
        } else {
          m3.text(textValue5(item, tl6));
        }
      } else if (tag === "g") {
        const fore = item.strokeForeground, fill6 = item.fill, stroke6 = item.stroke;
        if (fore && stroke6) {
          item.stroke = null;
        }
        m3.open("path", this.attr(scene, item, mdef.background, "bgrect")).close();
        m3.open("g", this.attr(scene, item, mdef.content));
        visit5(item, (scene2) => this.mark(m3, scene2));
        m3.close();
        if (fore && stroke6) {
          if (fill6)
            item.fill = null;
          item.stroke = stroke6;
          m3.open("path", this.attr(scene, item, mdef.foreground, "bgrect")).close();
          if (fill6)
            item.fill = fill6;
        } else {
          m3.open("path", this.attr(scene, item, mdef.foreground, "bgfore")).close();
        }
      }
      m3.close();
      if (href6)
        m3.close();
    };
    if (mdef.nested) {
      if (scene.items && scene.items.length)
        process2(scene.items[0]);
    } else {
      visit5(scene, process2);
    }
    return m3.close();
  }
  /**
   * Get href attributes for a hyperlinked mark item.
   * @param {Item} item - The mark item.
   */
  href(item) {
    const href6 = item.href;
    let attr6;
    if (href6) {
      if (attr6 = this._hrefs && this._hrefs[href6]) {
        return attr6;
      } else {
        this.sanitizeURL(href6).then((attr7) => {
          attr7["xlink:href"] = attr7.href;
          attr7.href = null;
          (this._hrefs || (this._hrefs = {}))[href6] = attr7;
        });
      }
    }
    return null;
  }
  /**
   * Get an object of SVG attributes for a mark item.
   * @param {object} scene - The mark parent.
   * @param {Item} item - The mark item.
   * @param {array|function} attrs - One or more attribute emitters.
   * @param {string} tag - The tag being rendered.
   */
  attr(scene, item, attrs, tag) {
    const object2 = {}, emit6 = (name, value7, ns, prefixed) => {
      object2[prefixed || name] = value7;
    };
    if (Array.isArray(attrs)) {
      attrs.forEach((fn) => fn(emit6, item, this));
    } else {
      attrs(emit6, item, this);
    }
    if (tag) {
      style5(object2, item, scene, tag, this._defs);
    }
    return object2;
  }
  /**
   * Render SVG defs, as needed.
   * Must be called *after* marks have been processed to ensure the
   * collected state is current and accurate.
   * @param {object} m - The markup context.
   */
  defs(m3) {
    const gradient8 = this._defs.gradient, clipping = this._defs.clipping, count3 = Object.keys(gradient8).length + Object.keys(clipping).length;
    if (count3 === 0)
      return;
    m3.open("defs");
    for (const id24 in gradient8) {
      const def6 = gradient8[id24], stops = def6.stops;
      if (def6.gradient === "radial") {
        m3.open("pattern", {
          id: patternPrefix5 + id24,
          viewBox: "0,0,1,1",
          width: "100%",
          height: "100%",
          preserveAspectRatio: "xMidYMid slice"
        });
        m3.open("rect", {
          width: "1",
          height: "1",
          fill: "url(#" + id24 + ")"
        }).close();
        m3.close();
        m3.open("radialGradient", {
          id: id24,
          fx: def6.x1,
          fy: def6.y1,
          fr: def6.r1,
          cx: def6.x2,
          cy: def6.y2,
          r: def6.r2
        });
      } else {
        m3.open("linearGradient", {
          id: id24,
          x1: def6.x1,
          x2: def6.x2,
          y1: def6.y1,
          y2: def6.y2
        });
      }
      for (let i = 0; i < stops.length; ++i) {
        m3.open("stop", {
          offset: stops[i].offset,
          "stop-color": stops[i].color
        }).close();
      }
      m3.close();
    }
    for (const id24 in clipping) {
      const def6 = clipping[id24];
      m3.open("clipPath", {
        id: id24
      });
      if (def6.path) {
        m3.open("path", {
          d: def6.path
        }).close();
      } else {
        m3.open("rect", {
          x: 0,
          y: 0,
          width: def6.width,
          height: def6.height
        }).close();
      }
      m3.close();
    }
    m3.close();
  }
};
function style5(s2, item, scene, tag, defs) {
  let styleList;
  if (item == null)
    return s2;
  if (tag === "bgrect" && scene.interactive === false) {
    s2["pointer-events"] = "none";
  }
  if (tag === "bgfore") {
    if (scene.interactive === false) {
      s2["pointer-events"] = "none";
    }
    s2.display = "none";
    if (item.fill !== null)
      return s2;
  }
  if (tag === "image" && item.smooth === false) {
    styleList = ["image-rendering: optimizeSpeed;", "image-rendering: pixelated;"];
  }
  if (tag === "text") {
    s2["font-family"] = fontFamily5(item);
    s2["font-size"] = fontSize5(item) + "px";
    s2["font-style"] = item.fontStyle;
    s2["font-variant"] = item.fontVariant;
    s2["font-weight"] = item.fontWeight;
  }
  for (const prop in stylesAttr5) {
    let value7 = item[prop];
    const name = stylesAttr5[prop];
    if (value7 === "transparent" && (name === "fill" || name === "stroke"))
      ;
    else if (value7 != null) {
      if (isGradient5(value7)) {
        value7 = gradientRef5(value7, defs.gradient, "");
      }
      s2[name] = value7;
    }
  }
  for (const prop in stylesCss5) {
    const value7 = item[prop];
    if (value7 != null) {
      styleList = styleList || [];
      styleList.push(`${stylesCss5[prop]}: ${value7};`);
    }
  }
  if (styleList) {
    s2.style = styleList.join(" ");
  }
  return s2;
}
var OPTS5 = {
  svgMarkTypes: ["text"],
  svgOnTop: true,
  debug: false
};
var HybridRenderer5 = class extends Renderer5 {
  constructor(loader7) {
    super(loader7);
    this._svgRenderer = new SVGRenderer5(loader7);
    this._canvasRenderer = new CanvasRenderer5(loader7);
  }
  /**
   * Initialize a new HybridRenderer instance.
   * @param {DOMElement} el - The containing DOM element for the display.
   * @param {number} width - The coordinate width of the display, in pixels.
   * @param {number} height - The coordinate height of the display, in pixels.
   * @param {Array<number>} origin - The origin of the display, in pixels.
   *   The coordinate system will be translated to this point.
   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
   *   the width and height to determine the final pixel size.
   * @return {HybridRenderer} - This renderer instance.
   */
  initialize(el, width2, height2, origin, scaleFactor) {
    this._root_el = domChild5(el, 0, "div");
    const bottomEl = domChild5(this._root_el, 0, "div");
    const topEl = domChild5(this._root_el, 1, "div");
    this._root_el.style.position = "relative";
    if (!OPTS5.debug) {
      bottomEl.style.height = "100%";
      topEl.style.position = "absolute";
      topEl.style.top = "0";
      topEl.style.left = "0";
      topEl.style.height = "100%";
      topEl.style.width = "100%";
    }
    this._svgEl = OPTS5.svgOnTop ? topEl : bottomEl;
    this._canvasEl = OPTS5.svgOnTop ? bottomEl : topEl;
    this._svgEl.style.pointerEvents = "none";
    this._canvasRenderer.initialize(this._canvasEl, width2, height2, origin, scaleFactor);
    this._svgRenderer.initialize(this._svgEl, width2, height2, origin, scaleFactor);
    return super.initialize(el, width2, height2, origin, scaleFactor);
  }
  /**
   * Flag a mark item as dirty.
   * @param {Item} item - The mark item.
   */
  dirty(item) {
    if (OPTS5.svgMarkTypes.includes(item.mark.marktype)) {
      this._svgRenderer.dirty(item);
    } else {
      this._canvasRenderer.dirty(item);
    }
    return this;
  }
  /**
   * Internal rendering method.
   * @param {object} scene - The root mark of a scenegraph to render.
   * @param {Array} markTypes - Array of the mark types to render.
   *                            If undefined, render all mark types
   */
  _render(scene, markTypes) {
    const allMarkTypes = markTypes ?? ["arc", "area", "image", "line", "path", "rect", "rule", "shape", "symbol", "text", "trail"];
    const canvasMarkTypes = allMarkTypes.filter((m3) => !OPTS5.svgMarkTypes.includes(m3));
    this._svgRenderer.render(scene, OPTS5.svgMarkTypes);
    this._canvasRenderer.render(scene, canvasMarkTypes);
  }
  /**
   * Resize the display.
   * @param {number} width - The new coordinate width of the display, in pixels.
   * @param {number} height - The new coordinate height of the display, in pixels.
   * @param {Array<number>} origin - The new origin of the display, in pixels.
   *   The coordinate system will be translated to this point.
   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
   *   the width and height to determine the final pixel size.
   * @return {SVGRenderer} - This renderer instance;
   */
  resize(width2, height2, origin, scaleFactor) {
    super.resize(width2, height2, origin, scaleFactor);
    this._svgRenderer.resize(width2, height2, origin, scaleFactor);
    this._canvasRenderer.resize(width2, height2, origin, scaleFactor);
    return this;
  }
  background(bgcolor) {
    if (OPTS5.svgOnTop) {
      this._canvasRenderer.background(bgcolor);
    } else {
      this._svgRenderer.background(bgcolor);
    }
    return this;
  }
};
var HybridHandler5 = class extends CanvasHandler5 {
  constructor(loader7, tooltip2) {
    super(loader7, tooltip2);
  }
  initialize(el, origin, obj) {
    const canvas = domChild5(domChild5(el, 0, "div"), OPTS5.svgOnTop ? 0 : 1, "div");
    return super.initialize(canvas, origin, obj);
  }
};
var Canvas5 = "canvas";
var Hybrid5 = "hybrid";
var PNG5 = "png";
var SVG5 = "svg";
var None8 = "none";
var modules5 = {};
modules5[Canvas5] = modules5[PNG5] = {
  renderer: CanvasRenderer5,
  headless: CanvasRenderer5,
  handler: CanvasHandler5
};
modules5[SVG5] = {
  renderer: SVGRenderer5,
  headless: SVGStringRenderer5,
  handler: SVGHandler5
};
modules5[Hybrid5] = {
  renderer: HybridRenderer5,
  headless: HybridRenderer5,
  handler: HybridHandler5
};
modules5[None8] = {};
function intersect4(scene, bounds6, filter4) {
  const hits = [], box = new Bounds5().union(bounds6), type7 = scene.marktype;
  return type7 ? intersectMark2(scene, box, filter4, hits) : type7 === "group" ? intersectGroup2(scene, box, filter4, hits) : error16("Intersect scene must be mark node or group item.");
}
function intersectMark2(mark, box, filter4, hits) {
  if (visitMark2(mark, box, filter4)) {
    const items = mark.items, type7 = mark.marktype, n = items.length;
    let i = 0;
    if (type7 === "group") {
      for (; i < n; ++i) {
        intersectGroup2(items[i], box, filter4, hits);
      }
    } else {
      for (const test2 = Marks5[type7].isect; i < n; ++i) {
        const item = items[i];
        if (intersectItem2(item, box, test2))
          hits.push(item);
      }
    }
  }
  return hits;
}
function visitMark2(mark, box, filter4) {
  return mark.bounds && box.intersects(mark.bounds) && (mark.marktype === "group" || mark.interactive !== false && (!filter4 || filter4(mark)));
}
function intersectGroup2(group7, box, filter4, hits) {
  if (filter4 && filter4(group7.mark) && intersectItem2(group7, box, Marks5.group.isect)) {
    hits.push(group7);
  }
  const marks = group7.items, n = marks && marks.length;
  if (n) {
    const x9 = group7.x || 0, y9 = group7.y || 0;
    box.translate(-x9, -y9);
    for (let i = 0; i < n; ++i) {
      intersectMark2(marks[i], box, filter4, hits);
    }
    box.translate(x9, y9);
  }
  return hits;
}
function intersectItem2(item, box, test2) {
  const bounds6 = item.bounds;
  return box.encloses(bounds6) || box.intersects(bounds6) && test2(item, box);
}
var clipBounds5 = new Bounds5();

// node_modules/vega-selections/node_modules/vega-util/build/vega-util.js
function accessor18(fn, fields, name) {
  fn.fields = fields || [];
  fn.fname = name;
  return fn;
}
function getter18(path7) {
  return path7.length === 1 ? get118(path7[0]) : getN18(path7);
}
var get118 = (field25) => function(obj) {
  return obj[field25];
};
var getN18 = (path7) => {
  const len = path7.length;
  return function(obj) {
    for (let i = 0; i < len; ++i) {
      obj = obj[path7[i]];
    }
    return obj;
  };
};
function error18(message) {
  throw Error(message);
}
function splitAccessPath18(p) {
  const path7 = [], n = p.length;
  let q = null, b6 = 0, s2 = "", i, j, c5;
  p = p + "";
  function push() {
    path7.push(s2 + p.substring(i, j));
    s2 = "";
    i = j + 1;
  }
  for (i = j = 0; j < n; ++j) {
    c5 = p[j];
    if (c5 === "\\") {
      s2 += p.substring(i, j++);
      i = j;
    } else if (c5 === q) {
      push();
      q = null;
      b6 = -1;
    } else if (q) {
      continue;
    } else if (i === b6 && c5 === '"') {
      i = j + 1;
      q = c5;
    } else if (i === b6 && c5 === "'") {
      i = j + 1;
      q = c5;
    } else if (c5 === "." && !b6) {
      if (j > i) {
        push();
      } else {
        i = j + 1;
      }
    } else if (c5 === "[") {
      if (j > i)
        push();
      b6 = i = j + 1;
    } else if (c5 === "]") {
      if (!b6)
        error18("Access path missing open bracket: " + p);
      if (b6 > 0)
        push();
      b6 = 0;
      i = j + 1;
    }
  }
  if (b6)
    error18("Access path missing closing bracket: " + p);
  if (q)
    error18("Access path missing closing quote: " + p);
  if (j > i) {
    j++;
    push();
  }
  return path7;
}
function field18(field25, name, opt) {
  const path7 = splitAccessPath18(field25);
  field25 = path7.length === 1 ? path7[0] : field25;
  return accessor18((opt && opt.get || getter18)(path7), [field25], name || field25);
}
var id18 = field18("id");
var identity22 = accessor18((_) => _, [], "identity");
var zero20 = accessor18(() => 0, [], "zero");
var one19 = accessor18(() => 1, [], "one");
var truthy18 = accessor18(() => true, [], "true");
var falsy18 = accessor18(() => false, [], "false");
var DisallowedObjectProperties18 = /* @__PURE__ */ new Set([...Object.getOwnPropertyNames(Object.prototype).filter((name) => typeof Object.prototype[name] === "function"), "__proto__"]);
var isArray18 = Array.isArray;
function peek12(array22) {
  return array22[array22.length - 1];
}
function toNumber11(_) {
  return _ == null || _ === "" ? null : +_;
}
function array17(_) {
  return _ != null ? isArray18(_) ? _ : [_] : [];
}
function extend18(_) {
  for (let x9, k3, i = 1, len = arguments.length; i < len; ++i) {
    x9 = arguments[i];
    for (k3 in x9) {
      _[k3] = x9[k3];
    }
  }
  return _;
}
function has15(object2, property2) {
  return Object.hasOwn(object2, property2);
}
function inrange3(value7, range7, left, right) {
  let r0 = range7[0], r1 = range7[range7.length - 1], t;
  if (r0 > r1) {
    t = r0;
    r0 = r1;
    r1 = t;
  }
  left = left === void 0 || left;
  right = right === void 0 || right;
  return (left ? r0 <= value7 : r0 < value7) && (right ? value7 <= r1 : value7 < r1);
}
function isDate7(_) {
  return Object.prototype.toString.call(_) === "[object Date]";
}

// node_modules/vega-selections/build/vega-selection.js
var SELECTION_GETTER = Symbol("vega_selection_getter");
function getter19(f) {
  if (!f.getter || !f.getter[SELECTION_GETTER]) {
    f.getter = field18(f.field);
    f.getter[SELECTION_GETTER] = true;
  }
  return f.getter;
}
var Intersect = "intersect";
var Union = "union";
var VlMulti = "vlMulti";
var VlPoint = "vlPoint";
var Or = "or";
var And = "and";
var SelectionId = "_vgsid_";
var $selectionId = field18(SelectionId);
var TYPE_ENUM = "E";
var TYPE_RANGE_INC = "R";
var TYPE_RANGE_EXC = "R-E";
var TYPE_RANGE_LE = "R-LE";
var TYPE_RANGE_RE = "R-RE";
var TYPE_PRED_LT = "E-LT";
var TYPE_PRED_LTE = "E-LTE";
var TYPE_PRED_GT = "E-GT";
var TYPE_PRED_GTE = "E-GTE";
var TYPE_PRED_VALID = "E-VALID";
var TYPE_PRED_ONE_OF = "E-ONE";
var UNIT_INDEX = "index:unit";
function testPoint(datum2, entry2) {
  var fields = entry2.fields, values7 = entry2.values, n = fields.length, i = 0, dval, f;
  for (; i < n; ++i) {
    f = fields[i];
    dval = getter19(f)(datum2);
    if (isDate7(dval))
      dval = toNumber11(dval);
    if (isDate7(values7[i]))
      values7[i] = toNumber11(values7[i]);
    if (isArray18(values7[i]) && isDate7(values7[i][0]))
      values7[i] = values7[i].map(toNumber11);
    if (f.type === TYPE_ENUM) {
      if (isArray18(values7[i]) ? !values7[i].includes(dval) : dval !== values7[i]) {
        return false;
      }
    } else {
      if (f.type === TYPE_RANGE_INC) {
        if (!inrange3(dval, values7[i]))
          return false;
      } else if (f.type === TYPE_RANGE_RE) {
        if (!inrange3(dval, values7[i], true, false))
          return false;
      } else if (f.type === TYPE_RANGE_EXC) {
        if (!inrange3(dval, values7[i], false, false))
          return false;
      } else if (f.type === TYPE_RANGE_LE) {
        if (!inrange3(dval, values7[i], false, true))
          return false;
      } else if (f.type === TYPE_PRED_LT) {
        if (dval >= values7[i])
          return false;
      } else if (f.type === TYPE_PRED_LTE) {
        if (dval > values7[i])
          return false;
      } else if (f.type === TYPE_PRED_GT) {
        if (dval <= values7[i])
          return false;
      } else if (f.type === TYPE_PRED_GTE) {
        if (dval < values7[i])
          return false;
      } else if (f.type === TYPE_PRED_VALID) {
        if (dval === null || isNaN(dval))
          return false;
      } else if (f.type === TYPE_PRED_ONE_OF) {
        if (values7[i].indexOf(dval) === -1)
          return false;
      }
    }
  }
  return true;
}
function selectionTest(name, datum2, op) {
  var data3 = this.context.data[name], entries2 = data3 ? data3.values.value : [], unitIdx = data3 ? data3[UNIT_INDEX] && data3[UNIT_INDEX].value : void 0, intersect6 = op === Intersect, n = entries2.length, i = 0, entry2, miss, count3, unit2, b6;
  for (; i < n; ++i) {
    entry2 = entries2[i];
    if (unitIdx && intersect6) {
      miss = miss || {};
      count3 = miss[unit2 = entry2.unit] || 0;
      if (count3 === -1)
        continue;
      b6 = testPoint(datum2, entry2);
      miss[unit2] = b6 ? -1 : ++count3;
      if (b6 && unitIdx.size === 1)
        return true;
      if (!b6 && count3 === unitIdx.get(unit2).count)
        return false;
    } else {
      b6 = testPoint(datum2, entry2);
      if (intersect6 ^ b6)
        return b6;
    }
  }
  return n && intersect6;
}
var bisect = bisector($selectionId);
var bisectLeft2 = bisect.left;
var bisectRight2 = bisect.right;
function selectionIdTest(name, datum2, op) {
  const data3 = this.context.data[name], entries2 = data3 ? data3.values.value : [], unitIdx = data3 ? data3[UNIT_INDEX] && data3[UNIT_INDEX].value : void 0, intersect6 = op === Intersect, value7 = $selectionId(datum2), index4 = bisectLeft2(entries2, value7);
  if (index4 === entries2.length)
    return false;
  if ($selectionId(entries2[index4]) !== value7)
    return false;
  if (unitIdx && intersect6) {
    if (unitIdx.size === 1)
      return true;
    if (bisectRight2(entries2, value7) - index4 < unitIdx.size)
      return false;
  }
  return true;
}
function selectionTuples(array22, base) {
  return array22.map((x9) => extend18(base.fields ? {
    values: base.fields.map((f) => getter19(f)(x9.datum))
  } : {
    [SelectionId]: $selectionId(x9.datum)
  }, base));
}
function selectionResolve(name, op, isMulti, vl5) {
  var data3 = this.context.data[name], entries2 = data3 ? data3.values.value : [], resolved = {}, multiRes = {}, types = {}, entry2, fields, values7, unit2, field25, value7, res, resUnit, type7, union2, n = entries2.length, i = 0, j, m3;
  for (; i < n; ++i) {
    entry2 = entries2[i];
    unit2 = entry2.unit;
    fields = entry2.fields;
    values7 = entry2.values;
    if (fields && values7) {
      for (j = 0, m3 = fields.length; j < m3; ++j) {
        field25 = fields[j];
        res = resolved[field25.field] || (resolved[field25.field] = {});
        resUnit = res[unit2] || (res[unit2] = []);
        types[field25.field] = type7 = field25.type.charAt(0);
        union2 = ops[`${type7}_union`];
        res[unit2] = union2(resUnit, array17(values7[j]));
      }
      if (isMulti) {
        resUnit = multiRes[unit2] || (multiRes[unit2] = []);
        resUnit.push(array17(values7).reduce((obj, curr, j2) => (obj[fields[j2].field] = curr, obj), {}));
      }
    } else {
      field25 = SelectionId;
      value7 = $selectionId(entry2);
      res = resolved[field25] || (resolved[field25] = {});
      resUnit = res[unit2] || (res[unit2] = []);
      resUnit.push(value7);
      if (isMulti) {
        resUnit = multiRes[unit2] || (multiRes[unit2] = []);
        resUnit.push({
          [SelectionId]: value7
        });
      }
    }
  }
  op = op || Union;
  if (resolved[SelectionId]) {
    resolved[SelectionId] = ops[`${SelectionId}_${op}`](...Object.values(resolved[SelectionId]));
  } else {
    Object.keys(resolved).forEach((field26) => {
      resolved[field26] = Object.keys(resolved[field26]).map((unit3) => resolved[field26][unit3]).reduce((acc, curr) => acc === void 0 ? curr : ops[`${types[field26]}_${op}`](acc, curr));
    });
  }
  entries2 = Object.keys(multiRes);
  if (isMulti && entries2.length) {
    const key4 = vl5 ? VlPoint : VlMulti;
    resolved[key4] = op === Union ? {
      [Or]: entries2.reduce((acc, k3) => (acc.push(...multiRes[k3]), acc), [])
    } : {
      [And]: entries2.map((k3) => ({
        [Or]: multiRes[k3]
      }))
    };
  }
  return resolved;
}
var ops = {
  [`${SelectionId}_union`]: union,
  [`${SelectionId}_intersect`]: intersection,
  E_union: function(base, value7) {
    if (!base.length)
      return value7;
    var i = 0, n = value7.length;
    for (; i < n; ++i)
      if (!base.includes(value7[i]))
        base.push(value7[i]);
    return base;
  },
  E_intersect: function(base, value7) {
    return !base.length ? value7 : base.filter((v2) => value7.includes(v2));
  },
  R_union: function(base, value7) {
    var lo = toNumber11(value7[0]), hi = toNumber11(value7[1]);
    if (lo > hi) {
      lo = value7[1];
      hi = value7[0];
    }
    if (!base.length)
      return [lo, hi];
    if (base[0] > lo)
      base[0] = lo;
    if (base[1] < hi)
      base[1] = hi;
    return base;
  },
  R_intersect: function(base, value7) {
    var lo = toNumber11(value7[0]), hi = toNumber11(value7[1]);
    if (lo > hi) {
      lo = value7[1];
      hi = value7[0];
    }
    if (!base.length)
      return [lo, hi];
    if (hi < base[0] || base[1] < lo) {
      return [];
    } else {
      if (base[0] < lo)
        base[0] = lo;
      if (base[1] > hi)
        base[1] = hi;
    }
    return base;
  }
};
var DataPrefix = ":";
var IndexPrefix = "@";
function selectionVisitor(name, args, scope, params2) {
  if (args[0].type !== Literal)
    error18("First argument to selection functions must be a string literal.");
  const data3 = args[0].value, op = args.length >= 2 && peek12(args).value, field25 = "unit", indexName = IndexPrefix + field25, dataName = DataPrefix + data3;
  if (op === Intersect && !has15(params2, indexName)) {
    params2[indexName] = scope.getData(data3).indataRef(scope, field25);
  }
  if (!has15(params2, dataName)) {
    params2[dataName] = scope.getData(data3).tuplesRef();
  }
}

// node_modules/vega-functions/build/vega-functions.js
function data(name) {
  const data3 = this.context.data[name];
  return data3 ? data3.values.value : [];
}
function indata(name, field25, value7) {
  const index4 = this.context.data[name]["index:" + field25], entry2 = index4 ? index4.value.get(value7) : void 0;
  return entry2 ? entry2.count : entry2;
}
function setdata(name, tuples) {
  const df = this.context.dataflow, data3 = this.context.data[name], input = data3.input;
  df.pulse(input, df.changeset().remove(truthy16).insert(tuples));
  return 1;
}
function encode(item, name, retval) {
  if (item) {
    const df = this.context.dataflow, target2 = item.mark.source;
    df.pulse(target2, df.changeset().encode(item, name));
  }
  return retval !== void 0 ? retval : item;
}
var wrap = (method10) => function(value7, spec) {
  const locale5 = this.context.dataflow.locale();
  return value7 === null ? "null" : locale5[method10](spec)(value7);
};
var format13 = wrap("format");
var timeFormat2 = wrap("timeFormat");
var utcFormat2 = wrap("utcFormat");
var timeParse2 = wrap("timeParse");
var utcParse2 = wrap("utcParse");
var dateObj = new Date(2e3, 0, 1);
function time2(month, day, specifier) {
  if (!Number.isInteger(month) || !Number.isInteger(day))
    return "";
  dateObj.setYear(2e3);
  dateObj.setMonth(month);
  dateObj.setDate(day);
  return timeFormat2.call(this, dateObj, specifier);
}
function monthFormat(month) {
  return time2.call(this, month, 1, "%B");
}
function monthAbbrevFormat(month) {
  return time2.call(this, month, 1, "%b");
}
function dayFormat(day) {
  return time2.call(this, 0, 2 + day, "%A");
}
function dayAbbrevFormat(day) {
  return time2.call(this, 0, 2 + day, "%a");
}
var DataPrefix2 = ":";
var IndexPrefix2 = "@";
var ScalePrefix = "%";
var SignalPrefix = "$";
function dataVisitor(name, args, scope, params2) {
  if (args[0].type !== Literal) {
    error16("First argument to data functions must be a string literal.");
  }
  const data3 = args[0].value, dataName = DataPrefix2 + data3;
  if (!has13(dataName, params2)) {
    try {
      params2[dataName] = scope.getData(data3).tuplesRef();
    } catch (err) {
    }
  }
}
function indataVisitor(name, args, scope, params2) {
  if (args[0].type !== Literal)
    error16("First argument to indata must be a string literal.");
  if (args[1].type !== Literal)
    error16("Second argument to indata must be a string literal.");
  const data3 = args[0].value, field25 = args[1].value, indexName = IndexPrefix2 + field25;
  if (!has13(indexName, params2)) {
    params2[indexName] = scope.getData(data3).indataRef(scope, field25);
  }
}
function scaleVisitor(name, args, scope, params2) {
  if (args[0].type === Literal) {
    addScaleDependency(scope, params2, args[0].value);
  } else {
    for (name in scope.scales) {
      addScaleDependency(scope, params2, name);
    }
  }
}
function addScaleDependency(scope, params2, name) {
  const scaleName = ScalePrefix + name;
  if (!has13(params2, scaleName)) {
    try {
      params2[scaleName] = scope.scaleRef(name);
    } catch (err) {
    }
  }
}
function getScale(nameOrFunction, ctx) {
  if (isString9(nameOrFunction)) {
    const maybeScale = ctx.scales[nameOrFunction];
    return maybeScale && isRegisteredScale(maybeScale.value) ? maybeScale.value : void 0;
  } else if (isFunction11(nameOrFunction)) {
    return isRegisteredScale(nameOrFunction) ? nameOrFunction : void 0;
  }
  return void 0;
}
function internalScaleFunctions(codegen2, fnctx, visitors) {
  fnctx.__bandwidth = (s2) => s2 && s2.bandwidth ? s2.bandwidth() : 0;
  visitors._bandwidth = scaleVisitor;
  visitors._range = scaleVisitor;
  visitors._scale = scaleVisitor;
  const ref2 = (arg) => "_[" + (arg.type === Literal ? $7(ScalePrefix + arg.value) : $7(ScalePrefix) + "+" + codegen2(arg)) + "]";
  return {
    _bandwidth: (args) => `this.__bandwidth(${ref2(args[0])})`,
    _range: (args) => `${ref2(args[0])}.range()`,
    _scale: (args) => `${ref2(args[0])}(${codegen2(args[1])})`
  };
}
function geoMethod(methodName, globalMethod) {
  return function(projection3, geojson, group7) {
    if (projection3) {
      const p = getScale(projection3, (group7 || this).context);
      return p && p.path[methodName](geojson);
    } else {
      return globalMethod(geojson);
    }
  };
}
var geoArea = geoMethod("area", area_default2);
var geoBounds = geoMethod("bounds", bounds_default);
var geoCentroid = geoMethod("centroid", centroid_default);
function geoScale(projection3, group7) {
  const p = getScale(projection3, (group7 || this).context);
  return p && p.scale();
}
function inScope(item) {
  const group7 = this.context.group;
  let value7 = false;
  if (group7)
    while (item) {
      if (item === group7) {
        value7 = true;
        break;
      }
      item = item.mark.group;
    }
  return value7;
}
function log8(df, method10, args) {
  try {
    df[method10].apply(df, ["EXPRESSION"].concat([].slice.call(args)));
  } catch (err) {
    df.warn(err);
  }
  return args[args.length - 1];
}
function warn() {
  return log8(this.context.dataflow, "warn", arguments);
}
function info() {
  return log8(this.context.dataflow, "info", arguments);
}
function debug() {
  return log8(this.context.dataflow, "debug", arguments);
}
function channel_luminance_value(channelValue) {
  const val = channelValue / 255;
  if (val <= 0.03928) {
    return val / 12.92;
  }
  return Math.pow((val + 0.055) / 1.055, 2.4);
}
function luminance(color9) {
  const c5 = rgb(color9), r = channel_luminance_value(c5.r), g = channel_luminance_value(c5.g), b6 = channel_luminance_value(c5.b);
  return 0.2126 * r + 0.7152 * g + 0.0722 * b6;
}
function contrast(color1, color22) {
  const lum1 = luminance(color1), lum2 = luminance(color22), lumL = Math.max(lum1, lum2), lumD = Math.min(lum1, lum2);
  return (lumL + 0.05) / (lumD + 0.05);
}
function merge5() {
  const args = [].slice.call(arguments);
  args.unshift({});
  return extend17(...args);
}
function equal(a4, b6) {
  return a4 === b6 || a4 !== a4 && b6 !== b6 ? true : isArray16(a4) ? isArray16(b6) && a4.length === b6.length ? equalArray(a4, b6) : false : isObject9(a4) && isObject9(b6) ? equalObject(a4, b6) : false;
}
function equalArray(a4, b6) {
  for (let i = 0, n = a4.length; i < n; ++i) {
    if (!equal(a4[i], b6[i]))
      return false;
  }
  return true;
}
function equalObject(a4, b6) {
  for (const key4 in a4) {
    if (!equal(a4[key4], b6[key4]))
      return false;
  }
  return true;
}
function removePredicate(props) {
  return (_) => equalObject(props, _);
}
function modify(name, insert2, remove2, toggle2, modify2, values7) {
  const df = this.context.dataflow, data3 = this.context.data[name], input = data3.input, stamp = df.stamp();
  let changes = data3.changes, predicate, key4;
  if (df._trigger === false || !(input.value.length || insert2 || toggle2)) {
    return 0;
  }
  if (!changes || changes.stamp < stamp) {
    data3.changes = changes = df.changeset();
    changes.stamp = stamp;
    df.runAfter(() => {
      data3.modified = true;
      df.pulse(input, changes).run();
    }, true, 1);
  }
  if (remove2) {
    predicate = remove2 === true ? truthy16 : isArray16(remove2) || isTuple(remove2) ? remove2 : removePredicate(remove2);
    changes.remove(predicate);
  }
  if (insert2) {
    changes.insert(insert2);
  }
  if (toggle2) {
    predicate = removePredicate(toggle2);
    if (input.value.some(predicate)) {
      changes.remove(predicate);
    } else {
      changes.insert(toggle2);
    }
  }
  if (modify2) {
    for (key4 in values7) {
      changes.modify(modify2, key4, values7[key4]);
    }
  }
  return 1;
}
function pinchDistance(event2) {
  const t = event2.touches, dx = t[0].clientX - t[1].clientX, dy = t[0].clientY - t[1].clientY;
  return Math.hypot(dx, dy);
}
function pinchAngle(event2) {
  const t = event2.touches;
  return Math.atan2(t[0].clientY - t[1].clientY, t[0].clientX - t[1].clientX);
}
var accessors = {};
function pluck(data3, name) {
  const accessor24 = accessors[name] || (accessors[name] = field16(name));
  return isArray16(data3) ? data3.map(accessor24) : accessor24(data3);
}
function array18(seq) {
  return isArray16(seq) || ArrayBuffer.isView(seq) ? seq : null;
}
function sequence3(seq) {
  return array18(seq) || (isString9(seq) ? seq : null);
}
function join6(seq, ...args) {
  return array18(seq).join(...args);
}
function indexof(seq, ...args) {
  return sequence3(seq).indexOf(...args);
}
function lastindexof(seq, ...args) {
  return sequence3(seq).lastIndexOf(...args);
}
function slice11(seq, ...args) {
  return sequence3(seq).slice(...args);
}
function replace2(str, pattern, repl) {
  if (isFunction11(repl))
    error16("Function argument passed to replace.");
  if (!isString9(pattern) && !isRegExp2(pattern))
    error16("Please pass a string or RegExp argument to replace.");
  return String(str).replace(pattern, repl);
}
function reverse2(seq) {
  return array18(seq).slice().reverse();
}
function sort3(seq) {
  return array18(seq).slice().sort(ascending9);
}
function bandspace(count3, paddingInner2, paddingOuter2) {
  return bandSpace8(count3 || 0, paddingInner2 || 0, paddingOuter2 || 0);
}
function bandwidth(name, group7) {
  const s2 = getScale(name, (group7 || this).context);
  return s2 && s2.bandwidth ? s2.bandwidth() : 0;
}
function copy3(name, group7) {
  const s2 = getScale(name, (group7 || this).context);
  return s2 ? s2.copy() : void 0;
}
function domain(name, group7) {
  const s2 = getScale(name, (group7 || this).context);
  return s2 ? s2.domain() : [];
}
function invert(name, range7, group7) {
  const s2 = getScale(name, (group7 || this).context);
  return !s2 ? void 0 : isArray16(range7) ? (s2.invertRange || s2.invert)(range7) : (s2.invert || s2.invertExtent)(range7);
}
function range3(name, group7) {
  const s2 = getScale(name, (group7 || this).context);
  return s2 && s2.range ? s2.range() : [];
}
function scale15(name, value7, group7) {
  const s2 = getScale(name, (group7 || this).context);
  return s2 ? s2(value7) : void 0;
}
function scaleGradient(scale19, p02, p1, count3, group7) {
  scale19 = getScale(scale19, (group7 || this).context);
  const gradient8 = Gradient2(p02, p1);
  let stops = scale19.domain(), min5 = stops[0], max5 = peek10(stops), fraction = identity20;
  if (!(max5 - min5)) {
    scale19 = (scale19.interpolator ? scale13("sequential")().interpolator(scale19.interpolator()) : scale13("linear")().interpolate(scale19.interpolate()).range(scale19.range())).domain([min5 = 0, max5 = 1]);
  } else {
    fraction = scaleFraction2(scale19, min5, max5);
  }
  if (scale19.ticks) {
    stops = scale19.ticks(+count3 || 15);
    if (min5 !== stops[0])
      stops.unshift(min5);
    if (max5 !== peek10(stops))
      stops.push(max5);
  }
  stops.forEach((_) => gradient8.stop(fraction(_), scale19(_)));
  return gradient8;
}
function geoShape(projection3, geojson, group7) {
  const p = getScale(projection3, (group7 || this).context);
  return function(context7) {
    return p ? p.path.context(context7)(geojson) : "";
  };
}
function pathShape(path7) {
  let p = null;
  return function(context7) {
    return context7 ? pathRender5(context7, p = p || parse9(path7)) : path7;
  };
}
var datum = (d) => d.data;
function treeNodes(name, context7) {
  const tree = data.call(context7, name);
  return tree.root && tree.root.lookup || {};
}
function treePath(name, source3, target2) {
  const nodes = treeNodes(name, this), s2 = nodes[source3], t = nodes[target2];
  return s2 && t ? s2.path(t).map(datum) : void 0;
}
function treeAncestors(name, node) {
  const n = treeNodes(name, this)[node];
  return n ? n.ancestors().map(datum) : void 0;
}
var _window = () => typeof window !== "undefined" && window || null;
function screen() {
  const w8 = _window();
  return w8 ? w8.screen : {};
}
function windowSize() {
  const w8 = _window();
  return w8 ? [w8.innerWidth, w8.innerHeight] : [void 0, void 0];
}
function containerSize() {
  const view = this.context.dataflow, el = view.container && view.container();
  return el ? [el.clientWidth, el.clientHeight] : [void 0, void 0];
}
function intersect5(b6, opt, group7) {
  if (!b6)
    return [];
  const [u4, v2] = b6, box = new Bounds5().set(u4[0], u4[1], v2[0], v2[1]), scene = group7 || this.context.dataflow.scenegraph().root;
  return intersect4(scene, box, filter3(opt));
}
function filter3(opt) {
  let p = null;
  if (opt) {
    const types = array15(opt.marktype), names = array15(opt.markname);
    p = (_) => (!types.length || types.some((t) => _.marktype === t)) && (!names.length || names.some((s2) => _.name === s2));
  }
  return p;
}
function lassoAppend(lasso, x9, y9, minDist = 5) {
  lasso = array15(lasso);
  const last = lasso[lasso.length - 1];
  return last === void 0 || Math.hypot(last[0] - x9, last[1] - y9) > minDist ? [...lasso, [x9, y9]] : lasso;
}
function lassoPath(lasso) {
  return array15(lasso).reduce((svg, [x9, y9], i) => {
    return svg += i == 0 ? `M ${x9},${y9} ` : i === lasso.length - 1 ? " Z" : `L ${x9},${y9} `;
  }, "");
}
function intersectLasso(markname, pixelLasso, unit2) {
  const {
    x: x9,
    y: y9,
    mark
  } = unit2;
  const bb2 = new Bounds5().set(Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER, Number.MIN_SAFE_INTEGER, Number.MIN_SAFE_INTEGER);
  for (const [px6, py6] of pixelLasso) {
    if (px6 < bb2.x1)
      bb2.x1 = px6;
    if (px6 > bb2.x2)
      bb2.x2 = px6;
    if (py6 < bb2.y1)
      bb2.y1 = py6;
    if (py6 > bb2.y2)
      bb2.y2 = py6;
  }
  bb2.translate(x9, y9);
  const intersection2 = intersect5([[bb2.x1, bb2.y1], [bb2.x2, bb2.y2]], markname, mark);
  return intersection2.filter((tuple) => pointInPolygon(tuple.x, tuple.y, pixelLasso));
}
function pointInPolygon(testx, testy, polygon) {
  let intersections = 0;
  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
    const [prevX, prevY] = polygon[j];
    const [x9, y9] = polygon[i];
    if (y9 > testy != prevY > testy && testx < (prevX - x9) * (testy - y9) / (prevY - y9) + x9) {
      intersections++;
    }
  }
  return intersections & 1;
}
var functionContext = {
  random() {
    return random();
  },
  // override default
  cumulativeNormal,
  cumulativeLogNormal,
  cumulativeUniform,
  densityNormal,
  densityLogNormal,
  densityUniform,
  quantileNormal,
  quantileLogNormal,
  quantileUniform,
  sampleNormal,
  sampleLogNormal,
  sampleUniform,
  isArray: isArray16,
  isBoolean: isBoolean4,
  isDate: isDate6,
  isDefined(_) {
    return _ !== void 0;
  },
  isNumber: isNumber12,
  isObject: isObject9,
  isRegExp: isRegExp2,
  isString: isString9,
  isTuple,
  isValid(_) {
    return _ != null && _ === _;
  },
  toBoolean: toBoolean6,
  toDate(_) {
    return toDate6(_);
  },
  // suppress extra arguments
  toNumber: toNumber10,
  toString: toString6,
  indexof,
  join: join6,
  lastindexof,
  replace: replace2,
  reverse: reverse2,
  sort: sort3,
  slice: slice11,
  flush: flush2,
  lerp: lerp2,
  merge: merge5,
  pad: pad4,
  peek: peek10,
  pluck,
  span: span10,
  inrange: inrange2,
  truncate: truncate6,
  rgb,
  lab,
  hcl,
  hsl,
  luminance,
  contrast,
  sequence: range,
  format: format13,
  utcFormat: utcFormat2,
  utcParse: utcParse2,
  utcOffset: utcOffset2,
  utcSequence: utcSequence2,
  timeFormat: timeFormat2,
  timeParse: timeParse2,
  timeOffset: timeOffset2,
  timeSequence: timeSequence2,
  timeUnitSpecifier: timeUnitSpecifier2,
  monthFormat,
  monthAbbrevFormat,
  dayFormat,
  dayAbbrevFormat,
  quarter: quarter2,
  utcquarter: utcquarter2,
  week: week2,
  utcweek: utcweek2,
  dayofyear: dayofyear2,
  utcdayofyear: utcdayofyear2,
  warn,
  info,
  debug,
  extent(_) {
    return extent7(_);
  },
  // suppress extra arguments
  inScope,
  intersect: intersect5,
  clampRange: clampRange2,
  pinchDistance,
  pinchAngle,
  screen,
  containerSize,
  windowSize,
  bandspace,
  setdata,
  pathShape,
  panLinear: panLinear2,
  panLog: panLog2,
  panPow: panPow2,
  panSymlog: panSymlog2,
  zoomLinear: zoomLinear3,
  zoomLog: zoomLog3,
  zoomPow: zoomPow3,
  zoomSymlog: zoomSymlog3,
  encode,
  modify,
  lassoAppend,
  lassoPath,
  intersectLasso
};
var eventFunctions = ["view", "item", "group", "xy", "x", "y"];
var eventPrefix = "event.vega.";
var thisPrefix = "this.";
var astVisitors = {};
var codegenParams = {
  forbidden: ["_"],
  allowed: ["datum", "event", "item"],
  fieldvar: "datum",
  globalvar: (id24) => `_[${$7(SignalPrefix + id24)}]`,
  functions: buildFunctions,
  constants: Constants,
  visitors: astVisitors
};
var codeGenerator = codegen(codegenParams);
function buildFunctions(codegen2) {
  const fn = Functions(codegen2);
  eventFunctions.forEach((name) => fn[name] = eventPrefix + name);
  for (const name in functionContext) {
    fn[name] = thisPrefix + name;
  }
  extend17(fn, internalScaleFunctions(codegen2, functionContext, astVisitors));
  return fn;
}
function expressionFunction(name, fn, visitor) {
  if (arguments.length === 1) {
    return functionContext[name];
  }
  functionContext[name] = fn;
  if (visitor)
    astVisitors[name] = visitor;
  if (codeGenerator)
    codeGenerator.functions[name] = thisPrefix + name;
  return this;
}
expressionFunction("bandwidth", bandwidth, scaleVisitor);
expressionFunction("copy", copy3, scaleVisitor);
expressionFunction("domain", domain, scaleVisitor);
expressionFunction("range", range3, scaleVisitor);
expressionFunction("invert", invert, scaleVisitor);
expressionFunction("scale", scale15, scaleVisitor);
expressionFunction("gradient", scaleGradient, scaleVisitor);
expressionFunction("geoArea", geoArea, scaleVisitor);
expressionFunction("geoBounds", geoBounds, scaleVisitor);
expressionFunction("geoCentroid", geoCentroid, scaleVisitor);
expressionFunction("geoShape", geoShape, scaleVisitor);
expressionFunction("geoScale", geoScale, scaleVisitor);
expressionFunction("indata", indata, indataVisitor);
expressionFunction("data", data, dataVisitor);
expressionFunction("treePath", treePath, dataVisitor);
expressionFunction("treeAncestors", treeAncestors, dataVisitor);
expressionFunction("vlSelectionTest", selectionTest, selectionVisitor);
expressionFunction("vlSelectionIdTest", selectionIdTest, selectionVisitor);
expressionFunction("vlSelectionResolve", selectionResolve, selectionVisitor);
expressionFunction("vlSelectionTuples", selectionTuples);
function parser2(expr2, scope) {
  const params2 = {};
  let ast;
  try {
    expr2 = isString9(expr2) ? expr2 : $7(expr2) + "";
    ast = parser(expr2);
  } catch (err) {
    error16("Expression parse error: " + expr2);
  }
  ast.visit((node) => {
    if (node.type !== CallExpression)
      return;
    const name = node.callee.name, visit6 = codegenParams.visitors[name];
    if (visit6)
      visit6(name, node.arguments, scope, params2);
  });
  const gen = codeGenerator(ast);
  gen.globals.forEach((name) => {
    const signalName = SignalPrefix + name;
    if (!has13(params2, signalName) && scope.getSignal(name)) {
      params2[signalName] = scope.signalRef(name);
    }
  });
  return {
    $expr: extend17({
      code: gen.code
    }, scope.options.ast ? {
      ast
    } : null),
    $fields: gen.fields,
    $params: params2
  };
}

// node_modules/vega-runtime/node_modules/vega-util/build/vega-util.js
function accessor19(fn, fields, name) {
  fn.fields = fields || [];
  fn.fname = name;
  return fn;
}
function accessorFields5(fn) {
  return fn == null ? null : fn.fields;
}
function getter20(path7) {
  return path7.length === 1 ? get119(path7[0]) : getN19(path7);
}
var get119 = (field25) => function(obj) {
  return obj[field25];
};
var getN19 = (path7) => {
  const len = path7.length;
  return function(obj) {
    for (let i = 0; i < len; ++i) {
      obj = obj[path7[i]];
    }
    return obj;
  };
};
function error19(message) {
  throw Error(message);
}
function splitAccessPath19(p) {
  const path7 = [], n = p.length;
  let q = null, b6 = 0, s2 = "", i, j, c5;
  p = p + "";
  function push() {
    path7.push(s2 + p.substring(i, j));
    s2 = "";
    i = j + 1;
  }
  for (i = j = 0; j < n; ++j) {
    c5 = p[j];
    if (c5 === "\\") {
      s2 += p.substring(i, j++);
      i = j;
    } else if (c5 === q) {
      push();
      q = null;
      b6 = -1;
    } else if (q) {
      continue;
    } else if (i === b6 && c5 === '"') {
      i = j + 1;
      q = c5;
    } else if (i === b6 && c5 === "'") {
      i = j + 1;
      q = c5;
    } else if (c5 === "." && !b6) {
      if (j > i) {
        push();
      } else {
        i = j + 1;
      }
    } else if (c5 === "[") {
      if (j > i)
        push();
      b6 = i = j + 1;
    } else if (c5 === "]") {
      if (!b6)
        error19("Access path missing open bracket: " + p);
      if (b6 > 0)
        push();
      b6 = 0;
      i = j + 1;
    }
  }
  if (b6)
    error19("Access path missing closing bracket: " + p);
  if (q)
    error19("Access path missing closing quote: " + p);
  if (j > i) {
    j++;
    push();
  }
  return path7;
}
function field19(field25, name, opt) {
  const path7 = splitAccessPath19(field25);
  field25 = path7.length === 1 ? path7[0] : field25;
  return accessor19((opt && opt.get || getter20)(path7), [field25], name || field25);
}
var id19 = field19("id");
var identity23 = accessor19((_) => _, [], "identity");
var zero21 = accessor19(() => 0, [], "zero");
var one20 = accessor19(() => 1, [], "one");
var truthy19 = accessor19(() => true, [], "true");
var falsy19 = accessor19(() => false, [], "false");
var DisallowedObjectProperties19 = /* @__PURE__ */ new Set([...Object.getOwnPropertyNames(Object.prototype).filter((name) => typeof Object.prototype[name] === "function"), "__proto__"]);
var isArray19 = Array.isArray;
function isObject10(_) {
  return _ === Object(_);
}
function array19(_) {
  return _ != null ? isArray19(_) ? _ : [_] : [];
}
function isFunction13(_) {
  return typeof _ === "function";
}
var DESCENDING3 = "descending";
function compare8(fields, orders, opt) {
  opt = opt || {};
  orders = array19(orders) || [];
  const ord = [], get23 = [], fmap = {}, gen = opt.comparator || comparator3;
  array19(fields).forEach((f, i) => {
    if (f == null)
      return;
    ord.push(orders[i] === DESCENDING3 ? -1 : 1);
    get23.push(f = isFunction13(f) ? f : field19(f, null, opt));
    (accessorFields5(f) || []).forEach((_) => fmap[_] = 1);
  });
  return get23.length === 0 ? null : accessor19(gen(get23, ord), Object.keys(fmap));
}
var ascending11 = (u4, v2) => (u4 < v2 || u4 == null) && v2 != null ? -1 : (u4 > v2 || v2 == null) && u4 != null ? 1 : (v2 = v2 instanceof Date ? +v2 : v2, u4 = u4 instanceof Date ? +u4 : u4) !== u4 && v2 === v2 ? -1 : v2 !== v2 && u4 === u4 ? 1 : 0;
var comparator3 = (fields, orders) => fields.length === 1 ? compare13(fields[0], orders[0]) : compareN3(fields, orders, fields.length);
var compare13 = (field25, order) => function(a4, b6) {
  return ascending11(field25(a4), field25(b6)) * order;
};
var compareN3 = (fields, orders, n) => {
  orders.push(0);
  return function(a4, b6) {
    let f, c5 = 0, i = -1;
    while (c5 === 0 && ++i < n) {
      f = fields[i];
      c5 = ascending11(f(a4), f(b6));
    }
    return c5 * orders[i];
  };
};
function has16(object2, property2) {
  return Object.hasOwn(object2, property2);
}
function isString11(_) {
  return typeof _ === "string";
}
function key3(fields, flat, opt) {
  if (fields) {
    fields = flat ? array19(fields).map((f) => f.replace(/\\(.)/g, "$1")) : array19(fields);
  }
  const len = fields && fields.length, gen = opt && opt.get || getter20, map13 = (f) => gen(flat ? [f] : splitAccessPath19(f));
  let fn;
  if (!len) {
    fn = function() {
      return "";
    };
  } else if (len === 1) {
    const get23 = map13(fields[0]);
    fn = function(_) {
      return "" + get23(_);
    };
  } else {
    const get23 = fields.map(map13);
    fn = function(_) {
      let s2 = "" + get23[0](_), i = 0;
      while (++i < len)
        s2 += "|" + get23[i](_);
      return s2;
    };
  }
  return accessor19(fn, fields, "key");
}
function $8(x9) {
  return isArray19(x9) ? `[${x9.map((v2) => v2 === null ? "null" : $8(v2))}]` : isObject10(x9) || isString11(x9) ? (
    // Output valid JSON and JS source strings.
    // See https://github.com/judofyr/timeless/blob/master/posts/json-isnt-a-javascript-subset.md
    JSON.stringify(x9).replaceAll("\u2028", "\\u2028").replaceAll("\u2029", "\\u2029")
  ) : x9;
}
function toSet13(_) {
  const s2 = {}, n = _.length;
  for (let i = 0; i < n; ++i)
    s2[_[i]] = true;
  return s2;
}

// node_modules/vega-runtime/build/vega-runtime.js
function parse10(spec) {
  const ctx = this, operators = spec.operators || [];
  if (spec.background) {
    ctx.background = spec.background;
  }
  if (spec.eventConfig) {
    ctx.eventConfig = spec.eventConfig;
  }
  if (spec.locale) {
    ctx.locale = spec.locale;
  }
  operators.forEach((entry2) => ctx.parseOperator(entry2));
  operators.forEach((entry2) => ctx.parseOperatorParameters(entry2));
  (spec.streams || []).forEach((entry2) => ctx.parseStream(entry2));
  (spec.updates || []).forEach((entry2) => ctx.parseUpdate(entry2));
  return ctx.resolve();
}
var Skip = toSet13(["rule"]);
var Swap = toSet13(["group", "image", "rect"]);
function adjustSpatial(encode2, marktype) {
  let code = "";
  if (Skip[marktype])
    return code;
  if (encode2.x2) {
    if (encode2.x) {
      if (Swap[marktype]) {
        code += "if(o.x>o.x2)$=o.x,o.x=o.x2,o.x2=$;";
      }
      code += "o.width=o.x2-o.x;";
    } else {
      code += "o.x=o.x2-(o.width||0);";
    }
  }
  if (encode2.xc) {
    code += "o.x=o.xc-(o.width||0)/2;";
  }
  if (encode2.y2) {
    if (encode2.y) {
      if (Swap[marktype]) {
        code += "if(o.y>o.y2)$=o.y,o.y=o.y2,o.y2=$;";
      }
      code += "o.height=o.y2-o.y;";
    } else {
      code += "o.y=o.y2-(o.height||0);";
    }
  }
  if (encode2.yc) {
    code += "o.y=o.yc-(o.height||0)/2;";
  }
  return code;
}
function canonicalType(type7) {
  return (type7 + "").toLowerCase();
}
function isOperator(type7) {
  return canonicalType(type7) === "operator";
}
function isCollect(type7) {
  return canonicalType(type7) === "collect";
}
function expression(ctx, args, code) {
  if (!code.endsWith(";")) {
    code = "return(" + code + ");";
  }
  const fn = Function(...args.concat(code));
  return ctx && ctx.functions ? fn.bind(ctx.functions) : fn;
}
function _compare(u4, v2, lt, gt) {
  return `((u = ${u4}) < (v = ${v2}) || u == null) && v != null ? ${lt}
  : (u > v || v == null) && u != null ? ${gt}
  : ((v = v instanceof Date ? +v : v), (u = u instanceof Date ? +u : u)) !== u && v === v ? ${lt}
  : v !== v && u === u ? ${gt} : `;
}
var expressionCodegen = {
  /**
   * Parse an expression used to update an operator value.
   */
  operator: (ctx, expr2) => expression(ctx, ["_"], expr2.code),
  /**
   * Parse an expression provided as an operator parameter value.
   */
  parameter: (ctx, expr2) => expression(ctx, ["datum", "_"], expr2.code),
  /**
   * Parse an expression applied to an event stream.
   */
  event: (ctx, expr2) => expression(ctx, ["event"], expr2.code),
  /**
   * Parse an expression used to handle an event-driven operator update.
   */
  handler: (ctx, expr2) => {
    const code = `var datum=event.item&&event.item.datum;return ${expr2.code};`;
    return expression(ctx, ["_", "event"], code);
  },
  /**
   * Parse an expression that performs visual encoding.
   */
  encode: (ctx, encode2) => {
    const {
      marktype,
      channels
    } = encode2;
    let code = "var o=item,datum=o.datum,m=0,$;";
    for (const name in channels) {
      const o = "o[" + $8(name) + "]";
      code += `$=${channels[name].code};if(${o}!==$)${o}=$,m=1;`;
    }
    code += adjustSpatial(channels, marktype);
    code += "return m;";
    return expression(ctx, ["item", "_"], code);
  },
  /**
   * Optimized code generators for access and comparison.
   */
  codegen: {
    get(path7) {
      const ref2 = `[${path7.map($8).join("][")}]`;
      const get23 = Function("_", `return _${ref2};`);
      get23.path = ref2;
      return get23;
    },
    comparator(fields, orders) {
      let t;
      const map13 = (f, i) => {
        const o = orders[i];
        let u4, v2;
        if (f.path) {
          u4 = `a${f.path}`;
          v2 = `b${f.path}`;
        } else {
          (t = t || {})["f" + i] = f;
          u4 = `this.f${i}(a)`;
          v2 = `this.f${i}(b)`;
        }
        return _compare(u4, v2, -o, o);
      };
      const fn = Function("a", "b", "var u, v; return " + fields.map(map13).join("") + "0;");
      return t ? fn.bind(t) : fn;
    }
  }
};
function parseOperator(spec) {
  const ctx = this;
  if (isOperator(spec.type) || !spec.type) {
    ctx.operator(spec, spec.update ? ctx.operatorExpression(spec.update) : null);
  } else {
    ctx.transform(spec, spec.type);
  }
}
function parseOperatorParameters(spec) {
  const ctx = this;
  if (spec.params) {
    const op = ctx.get(spec.id);
    if (!op)
      error19("Invalid operator id: " + spec.id);
    ctx.dataflow.connect(op, op.parameters(ctx.parseParameters(spec.params), spec.react, spec.initonly));
  }
}
function parseParameters(spec, params2) {
  params2 = params2 || {};
  const ctx = this;
  for (const key4 in spec) {
    const value7 = spec[key4];
    params2[key4] = isArray19(value7) ? value7.map((v2) => parseParameter(v2, ctx, params2)) : parseParameter(value7, ctx, params2);
  }
  return params2;
}
function parseParameter(spec, ctx, params2) {
  if (!spec || !isObject10(spec))
    return spec;
  for (let i = 0, n = PARSERS.length, p; i < n; ++i) {
    p = PARSERS[i];
    if (has16(spec, p.key)) {
      return p.parse(spec, ctx, params2);
    }
  }
  return spec;
}
var PARSERS = [{
  key: "$ref",
  parse: getOperator
}, {
  key: "$key",
  parse: getKey
}, {
  key: "$expr",
  parse: getExpression
}, {
  key: "$field",
  parse: getField2
}, {
  key: "$encode",
  parse: getEncode
}, {
  key: "$compare",
  parse: getCompare
}, {
  key: "$context",
  parse: getContext
}, {
  key: "$subflow",
  parse: getSubflow
}, {
  key: "$tupleid",
  parse: getTupleId
}];
function getOperator(_, ctx) {
  return ctx.get(_.$ref) || error19("Operator not defined: " + _.$ref);
}
function getExpression(_, ctx, params2) {
  if (_.$params) {
    ctx.parseParameters(_.$params, params2);
  }
  const k3 = "e:" + _.$expr.code;
  return ctx.fn[k3] || (ctx.fn[k3] = accessor19(ctx.parameterExpression(_.$expr), _.$fields));
}
function getKey(_, ctx) {
  const k3 = "k:" + _.$key + "_" + !!_.$flat;
  return ctx.fn[k3] || (ctx.fn[k3] = key3(_.$key, _.$flat, ctx.expr.codegen));
}
function getField2(_, ctx) {
  if (!_.$field)
    return null;
  const k3 = "f:" + _.$field + "_" + _.$name;
  return ctx.fn[k3] || (ctx.fn[k3] = field19(_.$field, _.$name, ctx.expr.codegen));
}
function getCompare(_, ctx) {
  const k3 = "c:" + _.$compare + "_" + _.$order, c5 = array19(_.$compare).map((_2) => _2 && _2.$tupleid ? tupleid : _2);
  return ctx.fn[k3] || (ctx.fn[k3] = compare8(c5, _.$order, ctx.expr.codegen));
}
function getEncode(_, ctx) {
  const spec = _.$encode, encode2 = {};
  for (const name in spec) {
    const enc = spec[name];
    encode2[name] = accessor19(ctx.encodeExpression(enc.$expr), enc.$fields);
    encode2[name].output = enc.$output;
  }
  return encode2;
}
function getContext(_, ctx) {
  return ctx;
}
function getSubflow(_, ctx) {
  const spec = _.$subflow;
  return function(dataflow, key4, parent) {
    const subctx = ctx.fork().parse(spec), op = subctx.get(spec.operators[0].id), p = subctx.signals.parent;
    if (p)
      p.set(parent);
    op.detachSubflow = () => ctx.detach(subctx);
    return op;
  };
}
function getTupleId() {
  return tupleid;
}
function parseStream(spec) {
  var ctx = this, filter4 = spec.filter != null ? ctx.eventExpression(spec.filter) : void 0, stream2 = spec.stream != null ? ctx.get(spec.stream) : void 0, args;
  if (spec.source) {
    stream2 = ctx.events(spec.source, spec.type, filter4);
  } else if (spec.merge) {
    args = spec.merge.map((_) => ctx.get(_));
    stream2 = args[0].merge.apply(args[0], args.slice(1));
  }
  if (spec.between) {
    args = spec.between.map((_) => ctx.get(_));
    stream2 = stream2.between(args[0], args[1]);
  }
  if (spec.filter) {
    stream2 = stream2.filter(filter4);
  }
  if (spec.throttle != null) {
    stream2 = stream2.throttle(+spec.throttle);
  }
  if (spec.debounce != null) {
    stream2 = stream2.debounce(+spec.debounce);
  }
  if (stream2 == null) {
    error19("Invalid stream definition: " + JSON.stringify(spec));
  }
  if (spec.consume)
    stream2.consume(true);
  ctx.stream(spec, stream2);
}
function parseUpdate(spec) {
  var ctx = this, srcid = isObject10(srcid = spec.source) ? srcid.$ref : srcid, source3 = ctx.get(srcid), target2 = null, update3 = spec.update, params2 = void 0;
  if (!source3)
    error19("Source not defined: " + spec.source);
  target2 = spec.target && spec.target.$expr ? ctx.eventExpression(spec.target.$expr) : ctx.get(spec.target);
  if (update3 && update3.$expr) {
    if (update3.$params) {
      params2 = ctx.parseParameters(update3.$params);
    }
    update3 = ctx.handlerExpression(update3.$expr);
  }
  ctx.update(spec, source3, target2, update3, params2);
}
var SKIP3 = {
  skip: true
};
function getState(options) {
  var ctx = this, state = {};
  if (options.signals) {
    var signals = state.signals = {};
    Object.keys(ctx.signals).forEach((key4) => {
      const op = ctx.signals[key4];
      if (options.signals(key4, op)) {
        signals[key4] = op.value;
      }
    });
  }
  if (options.data) {
    var data3 = state.data = {};
    Object.keys(ctx.data).forEach((key4) => {
      const dataset = ctx.data[key4];
      if (options.data(key4, dataset)) {
        data3[key4] = dataset.input.value;
      }
    });
  }
  if (ctx.subcontext && options.recurse !== false) {
    state.subcontext = ctx.subcontext.map((ctx2) => ctx2.getState(options));
  }
  return state;
}
function setState(state) {
  var ctx = this, df = ctx.dataflow, data3 = state.data, signals = state.signals;
  Object.keys(signals || {}).forEach((key4) => {
    df.update(ctx.signals[key4], signals[key4], SKIP3);
  });
  Object.keys(data3 || {}).forEach((key4) => {
    df.pulse(ctx.data[key4].input, df.changeset().remove(truthy19).insert(data3[key4]));
  });
  (state.subcontext || []).forEach((substate, i) => {
    const subctx = ctx.subcontext[i];
    if (subctx)
      subctx.setState(substate);
  });
}
function context6(df, transforms2, functions, expr2) {
  return new Context(df, transforms2, functions, expr2);
}
function Context(df, transforms2, functions, expr2) {
  this.dataflow = df;
  this.transforms = transforms2;
  this.events = df.events.bind(df);
  this.expr = expr2 || expressionCodegen, this.signals = {};
  this.scales = {};
  this.nodes = {};
  this.data = {};
  this.fn = {};
  if (functions) {
    this.functions = Object.create(functions);
    this.functions.context = this;
  }
}
function Subcontext(ctx) {
  this.dataflow = ctx.dataflow;
  this.transforms = ctx.transforms;
  this.events = ctx.events;
  this.expr = ctx.expr;
  this.signals = Object.create(ctx.signals);
  this.scales = Object.create(ctx.scales);
  this.nodes = Object.create(ctx.nodes);
  this.data = Object.create(ctx.data);
  this.fn = Object.create(ctx.fn);
  if (ctx.functions) {
    this.functions = Object.create(ctx.functions);
    this.functions.context = this;
  }
}
Context.prototype = Subcontext.prototype = {
  fork() {
    const ctx = new Subcontext(this);
    (this.subcontext || (this.subcontext = [])).push(ctx);
    return ctx;
  },
  detach(ctx) {
    this.subcontext = this.subcontext.filter((c5) => c5 !== ctx);
    const keys5 = Object.keys(ctx.nodes);
    for (const key4 of keys5)
      ctx.nodes[key4]._targets = null;
    for (const key4 of keys5)
      ctx.nodes[key4].detach();
    ctx.nodes = null;
  },
  get(id24) {
    return this.nodes[id24];
  },
  set(id24, node) {
    return this.nodes[id24] = node;
  },
  add(spec, op) {
    const ctx = this, df = ctx.dataflow, data3 = spec.value;
    ctx.set(spec.id, op);
    if (isCollect(spec.type) && data3) {
      if (data3.$ingest) {
        df.ingest(op, data3.$ingest, data3.$format);
      } else if (data3.$request) {
        df.preload(op, data3.$request, data3.$format);
      } else {
        df.pulse(op, df.changeset().insert(data3));
      }
    }
    if (spec.root) {
      ctx.root = op;
    }
    if (spec.parent) {
      let p = ctx.get(spec.parent.$ref);
      if (p) {
        df.connect(p, [op]);
        op.targets().add(p);
      } else {
        (ctx.unresolved = ctx.unresolved || []).push(() => {
          p = ctx.get(spec.parent.$ref);
          df.connect(p, [op]);
          op.targets().add(p);
        });
      }
    }
    if (spec.signal) {
      ctx.signals[spec.signal] = op;
    }
    if (spec.scale) {
      ctx.scales[spec.scale] = op;
    }
    if (spec.data) {
      for (const name in spec.data) {
        const data4 = ctx.data[name] || (ctx.data[name] = {});
        spec.data[name].forEach((role) => data4[role] = op);
      }
    }
  },
  resolve() {
    (this.unresolved || []).forEach((fn) => fn());
    delete this.unresolved;
    return this;
  },
  operator(spec, update3) {
    this.add(spec, this.dataflow.add(spec.value, update3));
  },
  transform(spec, type7) {
    this.add(spec, this.dataflow.add(this.transforms[canonicalType(type7)]));
  },
  stream(spec, stream2) {
    this.set(spec.id, stream2);
  },
  update(spec, stream2, target2, update3, params2) {
    this.dataflow.on(stream2, target2, update3, params2, spec.options);
  },
  // expression parsing
  operatorExpression(expr2) {
    return this.expr.operator(this, expr2);
  },
  parameterExpression(expr2) {
    return this.expr.parameter(this, expr2);
  },
  eventExpression(expr2) {
    return this.expr.event(this, expr2);
  },
  handlerExpression(expr2) {
    return this.expr.handler(this, expr2);
  },
  encodeExpression(encode2) {
    return this.expr.encode(this, encode2);
  },
  // parse methods
  parse: parse10,
  parseOperator,
  parseOperatorParameters,
  parseParameters,
  parseStream,
  parseUpdate,
  // state methods
  getState,
  setState
};

// node_modules/vega-view/build/vega-view.js
function initializeAria(view) {
  const el = view.container();
  if (el) {
    el.setAttribute("role", "graphics-document");
    el.setAttribute("aria-roleDescription", "visualization");
    ariaLabel(el, view.description());
  }
}
function ariaLabel(el, desc) {
  if (el)
    desc == null ? el.removeAttribute("aria-label") : el.setAttribute("aria-label", desc);
}
function background6(view) {
  view.add(null, (_) => {
    view._background = _.bg;
    view._resize = 1;
    return _.bg;
  }, {
    bg: view._signals.background
  });
}
var Default = "default";
function cursor(view) {
  const cursor3 = view._signals.cursor || (view._signals.cursor = view.add({
    user: Default,
    item: null
  }));
  view.on(view.events("view", "pointermove"), cursor3, (_, event2) => {
    const value7 = cursor3.value, user = value7 ? isString8(value7) ? value7 : value7.user : Default, item = event2.item && event2.item.cursor || null;
    return value7 && user === value7.user && item == value7.item ? value7 : {
      user,
      item
    };
  });
  view.add(null, function(_) {
    let user = _.cursor, item = this.value;
    if (!isString8(user)) {
      item = user.item;
      user = user.user;
    }
    setCursor(view, user && user !== Default ? user : item || user);
    return item;
  }, {
    cursor: cursor3
  });
}
function setCursor(view, cursor3) {
  const el = view.globalCursor() ? typeof document !== "undefined" && document.body : view.container();
  if (el) {
    return cursor3 == null ? el.style.removeProperty("cursor") : el.style.cursor = cursor3;
  }
}
function dataref(view, name) {
  var data3 = view._runtime.data;
  if (!has12(data3, name)) {
    error15("Unrecognized data set: " + name);
  }
  return data3[name];
}
function data2(name, values7) {
  return arguments.length < 2 ? dataref(this, name).values.value : change.call(this, name, changeset().remove(truthy15).insert(values7));
}
function change(name, changes) {
  if (!isChangeSet(changes)) {
    error15("Second argument to changes must be a changeset.");
  }
  const dataset = dataref(this, name);
  dataset.modified = true;
  return this.pulse(dataset.input, changes);
}
function insert(name, _) {
  return change.call(this, name, changeset().insert(_));
}
function remove(name, _) {
  return change.call(this, name, changeset().remove(_));
}
function width(view) {
  var padding3 = view.padding();
  return Math.max(0, view._viewWidth + padding3.left + padding3.right);
}
function height(view) {
  var padding3 = view.padding();
  return Math.max(0, view._viewHeight + padding3.top + padding3.bottom);
}
function offset8(view) {
  var padding3 = view.padding(), origin = view._origin;
  return [padding3.left + origin[0], padding3.top + origin[1]];
}
function resizeRenderer(view) {
  var origin = offset8(view), w8 = width(view), h6 = height(view);
  view._renderer.background(view.background());
  view._renderer.resize(w8, h6, origin);
  view._handler.origin(origin);
  view._resizeListeners.forEach((handler) => {
    try {
      handler(w8, h6);
    } catch (error25) {
      view.error(error25);
    }
  });
}
function eventExtend(view, event2, item) {
  var r = view._renderer, el = r && r.canvas(), p, e3, translate8;
  if (el) {
    translate8 = offset8(view);
    e3 = event2.changedTouches ? event2.changedTouches[0] : event2;
    p = point16(e3, el);
    p[0] -= translate8[0];
    p[1] -= translate8[1];
  }
  event2.dataflow = view;
  event2.item = item;
  event2.vega = extension(view, item, p);
  return event2;
}
function extension(view, item, point21) {
  const itemGroup = item ? item.mark.marktype === "group" ? item : item.mark.group : null;
  function group7(name) {
    var g = itemGroup, i;
    if (name)
      for (i = item; i; i = i.mark.group) {
        if (i.mark.name === name) {
          g = i;
          break;
        }
      }
    return g && g.mark && g.mark.interactive ? g : {};
  }
  function xy(item2) {
    if (!item2)
      return point21;
    if (isString8(item2))
      item2 = group7(item2);
    const p = point21.slice();
    while (item2) {
      p[0] -= item2.x || 0;
      p[1] -= item2.y || 0;
      item2 = item2.mark && item2.mark.group;
    }
    return p;
  }
  return {
    view: constant12(view),
    item: constant12(item || {}),
    group: group7,
    xy,
    x: (item2) => xy(item2)[0],
    y: (item2) => xy(item2)[1]
  };
}
var VIEW = "view";
var TIMER = "timer";
var WINDOW = "window";
var NO_TRAP = {
  trap: false
};
function initializeEventConfig(config) {
  const events3 = extend16({
    defaults: {}
  }, config);
  const unpack = (obj, keys5) => {
    keys5.forEach((k3) => {
      if (isArray15(obj[k3]))
        obj[k3] = toSet10(obj[k3]);
    });
  };
  unpack(events3.defaults, ["prevent", "allow"]);
  unpack(events3, ["view", "window", "selector"]);
  return events3;
}
function trackEventListener(view, sources, type7, handler) {
  view._eventListeners.push({
    type: type7,
    sources: array14(sources),
    handler
  });
}
function prevent(view, type7) {
  var def6 = view._eventConfig.defaults, prevent2 = def6.prevent, allow = def6.allow;
  return prevent2 === false || allow === true ? false : prevent2 === true || allow === false ? true : prevent2 ? prevent2[type7] : allow ? !allow[type7] : view.preventDefault();
}
function permit(view, key4, type7) {
  const rule8 = view._eventConfig && view._eventConfig[key4];
  if (rule8 === false || isObject8(rule8) && !rule8[type7]) {
    view.warn(`Blocked ${key4} ${type7} event listener.`);
    return false;
  }
  return true;
}
function events2(source3, type7, filter4) {
  var view = this, s2 = new EventStream(filter4), send = function(e3, item) {
    view.runAsync(null, () => {
      if (source3 === VIEW && prevent(view, type7)) {
        e3.preventDefault();
      }
      s2.receive(eventExtend(view, e3, item));
    });
  }, sources;
  if (source3 === TIMER) {
    if (permit(view, "timer", type7)) {
      view.timer(send, type7);
    }
  } else if (source3 === VIEW) {
    if (permit(view, "view", type7)) {
      view.addEventListener(type7, send, NO_TRAP);
    }
  } else {
    if (source3 === WINDOW) {
      if (permit(view, "window", type7) && typeof window !== "undefined") {
        sources = [window];
      }
    } else if (typeof document !== "undefined") {
      if (permit(view, "selector", type7)) {
        sources = Array.from(document.querySelectorAll(source3));
      }
    }
    if (!sources) {
      view.warn("Can not resolve event source: " + source3);
    } else {
      for (var i = 0, n = sources.length; i < n; ++i) {
        sources[i].addEventListener(type7, send);
      }
      trackEventListener(view, sources, type7, send);
    }
  }
  return s2;
}
function itemFilter(event2) {
  return event2.item;
}
function markTarget(event2) {
  return event2.item.mark.source;
}
function invoke(name) {
  return function(_, event2) {
    return event2.vega.view().changeset().encode(event2.item, name);
  };
}
function hover(hoverSet, leaveSet) {
  hoverSet = [hoverSet || "hover"];
  leaveSet = [leaveSet || "update", hoverSet[0]];
  this.on(this.events("view", "pointerover", itemFilter), markTarget, invoke(hoverSet));
  this.on(this.events("view", "pointerout", itemFilter), markTarget, invoke(leaveSet));
  return this;
}
function finalize() {
  var tooltip2 = this._tooltip, timers = this._timers, handlers = this._handler.handlers(), listeners = this._eventListeners, n, m3, e3, h6, t;
  n = timers.length;
  while (--n >= 0) {
    timers[n].stop();
  }
  n = listeners.length;
  while (--n >= 0) {
    e3 = listeners[n];
    m3 = e3.sources.length;
    while (--m3 >= 0) {
      e3.sources[m3].removeEventListener(e3.type, e3.handler);
    }
  }
  if (tooltip2) {
    tooltip2.call(this, this._handler, null, null, null);
  }
  n = handlers.length;
  while (--n >= 0) {
    t = handlers[n].type;
    h6 = handlers[n].handler;
    this._handler.off(t, h6);
  }
  return this;
}
function element6(tag, attr6, text7) {
  const el = document.createElement(tag);
  for (const key4 in attr6)
    el.setAttribute(key4, attr6[key4]);
  if (text7 != null)
    el.textContent = text7;
  return el;
}
var BindClass = "vega-bind";
var NameClass = "vega-bind-name";
var RadioClass = "vega-bind-radio";
function bind6(view, el, binding) {
  if (!el)
    return;
  const param2 = binding.param;
  let bind7 = binding.state;
  if (!bind7) {
    bind7 = binding.state = {
      elements: null,
      active: false,
      set: null,
      update: (value7) => {
        if (value7 != view.signal(param2.signal)) {
          view.runAsync(null, () => {
            bind7.source = true;
            view.signal(param2.signal, value7);
          });
        }
      }
    };
    if (param2.debounce) {
      bind7.update = debounce3(param2.debounce, bind7.update);
    }
  }
  const create12 = param2.input == null && param2.element ? target : generate;
  create12(bind7, el, param2, view);
  if (!bind7.active) {
    view.on(view._signals[param2.signal], null, () => {
      bind7.source ? bind7.source = false : bind7.set(view.signal(param2.signal));
    });
    bind7.active = true;
  }
  return bind7;
}
function target(bind7, node, param2, view) {
  const type7 = param2.event || "input";
  const handler = () => bind7.update(node.value);
  view.signal(param2.signal, node.value);
  node.addEventListener(type7, handler);
  trackEventListener(view, node, type7, handler);
  bind7.set = (value7) => {
    node.value = value7;
    node.dispatchEvent(event(type7));
  };
}
function event(type7) {
  return typeof Event !== "undefined" ? new Event(type7) : {
    type: type7
  };
}
function generate(bind7, el, param2, view) {
  const value7 = view.signal(param2.signal);
  const div = element6("div", {
    "class": BindClass
  });
  const wrapper = param2.input === "radio" ? div : div.appendChild(element6("label"));
  wrapper.appendChild(element6("span", {
    "class": NameClass
  }, param2.name || param2.signal));
  el.appendChild(div);
  let input = form;
  switch (param2.input) {
    case "checkbox":
      input = checkbox;
      break;
    case "select":
      input = select;
      break;
    case "radio":
      input = radio;
      break;
    case "range":
      input = range4;
      break;
  }
  input(bind7, wrapper, param2, value7);
}
function form(bind7, el, param2, value7) {
  const node = element6("input");
  for (const key4 in param2) {
    if (key4 !== "signal" && key4 !== "element") {
      node.setAttribute(key4 === "input" ? "type" : key4, param2[key4]);
    }
  }
  node.setAttribute("name", param2.signal);
  node.value = value7;
  el.appendChild(node);
  node.addEventListener("input", () => bind7.update(node.value));
  bind7.elements = [node];
  bind7.set = (value8) => node.value = value8;
}
function checkbox(bind7, el, param2, value7) {
  const attr6 = {
    type: "checkbox",
    name: param2.signal
  };
  if (value7)
    attr6.checked = true;
  const node = element6("input", attr6);
  el.appendChild(node);
  node.addEventListener("change", () => bind7.update(node.checked));
  bind7.elements = [node];
  bind7.set = (value8) => node.checked = !!value8 || null;
}
function select(bind7, el, param2, value7) {
  const node = element6("select", {
    name: param2.signal
  }), labels2 = param2.labels || [];
  param2.options.forEach((option, i) => {
    const attr6 = {
      value: option
    };
    if (valuesEqual(option, value7))
      attr6.selected = true;
    node.appendChild(element6("option", attr6, (labels2[i] || option) + ""));
  });
  el.appendChild(node);
  node.addEventListener("change", () => {
    bind7.update(param2.options[node.selectedIndex]);
  });
  bind7.elements = [node];
  bind7.set = (value8) => {
    for (let i = 0, n = param2.options.length; i < n; ++i) {
      if (valuesEqual(param2.options[i], value8)) {
        node.selectedIndex = i;
        return;
      }
    }
  };
}
function radio(bind7, el, param2, value7) {
  const group7 = element6("span", {
    "class": RadioClass
  }), labels2 = param2.labels || [];
  el.appendChild(group7);
  bind7.elements = param2.options.map((option, i) => {
    const attr6 = {
      type: "radio",
      name: param2.signal,
      value: option
    };
    if (valuesEqual(option, value7))
      attr6.checked = true;
    const input = element6("input", attr6);
    input.addEventListener("change", () => bind7.update(option));
    const label = element6("label", {}, (labels2[i] || option) + "");
    label.prepend(input);
    group7.appendChild(label);
    return input;
  });
  bind7.set = (value8) => {
    const nodes = bind7.elements, n = nodes.length;
    for (let i = 0; i < n; ++i) {
      if (valuesEqual(nodes[i].value, value8))
        nodes[i].checked = true;
    }
  };
}
function range4(bind7, el, param2, value7) {
  value7 = value7 !== void 0 ? value7 : (+param2.max + +param2.min) / 2;
  const max5 = param2.max != null ? param2.max : Math.max(100, +value7) || 100, min5 = param2.min || Math.min(0, max5, +value7) || 0, step = param2.step || tickStep(min5, max5, 100);
  const node = element6("input", {
    type: "range",
    name: param2.signal,
    min: min5,
    max: max5,
    step
  });
  node.value = value7;
  const span12 = element6("span", {}, +value7);
  el.appendChild(node);
  el.appendChild(span12);
  const update3 = () => {
    span12.textContent = node.value;
    bind7.update(+node.value);
  };
  node.addEventListener("input", update3);
  node.addEventListener("change", update3);
  bind7.elements = [node];
  bind7.set = (value8) => {
    node.value = value8;
    span12.textContent = value8;
  };
}
function valuesEqual(a4, b6) {
  return a4 === b6 || a4 + "" === b6 + "";
}
function initializeRenderer(view, r, el, constructor, scaleFactor, opt) {
  r = r || new constructor(view.loader());
  return r.initialize(el, width(view), height(view), offset8(view), scaleFactor, opt).background(view.background());
}
function trap(view, fn) {
  return !fn ? null : function() {
    try {
      fn.apply(this, arguments);
    } catch (error25) {
      view.error(error25);
    }
  };
}
function initializeHandler(view, prevHandler, el, constructor) {
  const handler = new constructor(view.loader(), trap(view, view.tooltip())).scene(view.scenegraph().root).initialize(el, offset8(view), view);
  if (prevHandler) {
    prevHandler.handlers().forEach((h6) => {
      handler.on(h6.type, h6.handler);
    });
  }
  return handler;
}
function initialize3(el, elBind) {
  const view = this, type7 = view._renderType, config = view._eventConfig.bind, module = renderModule2(type7);
  el = view._el = el ? lookup8(view, el, true) : null;
  initializeAria(view);
  if (!module)
    view.error("Unrecognized renderer type: " + type7);
  const Handler7 = module.handler || CanvasHandler4, Renderer6 = el ? module.renderer : module.headless;
  view._renderer = !Renderer6 ? null : initializeRenderer(view, view._renderer, el, Renderer6);
  view._handler = initializeHandler(view, view._handler, el, Handler7);
  view._redraw = true;
  if (el && config !== "none") {
    elBind = elBind ? view._elBind = lookup8(view, elBind, true) : el.appendChild(element6("form", {
      "class": "vega-bindings"
    }));
    view._bind.forEach((_) => {
      if (_.param.element && config !== "container") {
        _.element = lookup8(view, _.param.element, !!_.param.input);
      }
    });
    view._bind.forEach((_) => {
      bind6(view, _.element || elBind, _);
    });
  }
  return view;
}
function lookup8(view, el, clear2) {
  if (typeof el === "string") {
    if (typeof document !== "undefined") {
      el = document.querySelector(el);
      if (!el) {
        view.error("Signal bind element not found: " + el);
        return null;
      }
    } else {
      view.error("DOM document instance not found.");
      return null;
    }
  }
  if (el && clear2) {
    try {
      el.textContent = "";
    } catch (e3) {
      el = null;
      view.error(e3);
    }
  }
  return el;
}
var number10 = (_) => +_ || 0;
var paddingObject = (_) => ({
  top: _,
  bottom: _,
  left: _,
  right: _
});
function padding(_) {
  return isObject8(_) ? {
    top: number10(_.top),
    bottom: number10(_.bottom),
    left: number10(_.left),
    right: number10(_.right)
  } : paddingObject(number10(_));
}
async function renderHeadless(view, type7, scaleFactor, opt) {
  const module = renderModule2(type7), ctr = module && module.headless;
  if (!ctr)
    error15("Unrecognized renderer type: " + type7);
  await view.runAsync();
  return initializeRenderer(view, null, null, ctr, scaleFactor, opt).renderAsync(view._scenegraph.root);
}
async function renderToImageURL(type7, scaleFactor) {
  if (type7 !== RenderType2.Canvas && type7 !== RenderType2.SVG && type7 !== RenderType2.PNG) {
    error15("Unrecognized image type: " + type7);
  }
  const r = await renderHeadless(this, type7, scaleFactor);
  return type7 === RenderType2.SVG ? toBlobURL(r.svg(), "image/svg+xml") : r.canvas().toDataURL("image/png");
}
function toBlobURL(data3, mime) {
  const blob = new Blob([data3], {
    type: mime
  });
  return window.URL.createObjectURL(blob);
}
async function renderToCanvas(scaleFactor, opt) {
  const r = await renderHeadless(this, RenderType2.Canvas, scaleFactor, opt);
  return r.canvas();
}
async function renderToSVG(scaleFactor) {
  const r = await renderHeadless(this, RenderType2.SVG, scaleFactor);
  return r.svg();
}
function runtime(view, spec, expr2) {
  return context6(view, transforms, functionContext, expr2).parse(spec);
}
function scale16(name) {
  var scales10 = this._runtime.scales;
  if (!has12(scales10, name)) {
    error15("Unrecognized scale or projection: " + name);
  }
  return scales10[name].value;
}
var Width = "width";
var Height = "height";
var Padding2 = "padding";
var Skip2 = {
  skip: true
};
function viewWidth(view, width2) {
  var a4 = view.autosize(), p = view.padding();
  return width2 - (a4 && a4.contains === Padding2 ? p.left + p.right : 0);
}
function viewHeight(view, height2) {
  var a4 = view.autosize(), p = view.padding();
  return height2 - (a4 && a4.contains === Padding2 ? p.top + p.bottom : 0);
}
function initializeResize(view) {
  var s2 = view._signals, w8 = s2[Width], h6 = s2[Height], p = s2[Padding2];
  function resetSize() {
    view._autosize = view._resize = 1;
  }
  view._resizeWidth = view.add(null, (_) => {
    view._width = _.size;
    view._viewWidth = viewWidth(view, _.size);
    resetSize();
  }, {
    size: w8
  });
  view._resizeHeight = view.add(null, (_) => {
    view._height = _.size;
    view._viewHeight = viewHeight(view, _.size);
    resetSize();
  }, {
    size: h6
  });
  const resizePadding = view.add(null, resetSize, {
    pad: p
  });
  view._resizeWidth.rank = w8.rank + 1;
  view._resizeHeight.rank = h6.rank + 1;
  resizePadding.rank = p.rank + 1;
}
function resizeView(viewWidth2, viewHeight2, width2, height2, origin, auto) {
  this.runAfter((view) => {
    let rerun2 = 0;
    view._autosize = 0;
    if (view.width() !== width2) {
      rerun2 = 1;
      view.signal(Width, width2, Skip2);
      view._resizeWidth.skip(true);
    }
    if (view.height() !== height2) {
      rerun2 = 1;
      view.signal(Height, height2, Skip2);
      view._resizeHeight.skip(true);
    }
    if (view._viewWidth !== viewWidth2) {
      view._resize = 1;
      view._viewWidth = viewWidth2;
    }
    if (view._viewHeight !== viewHeight2) {
      view._resize = 1;
      view._viewHeight = viewHeight2;
    }
    if (view._origin[0] !== origin[0] || view._origin[1] !== origin[1]) {
      view._resize = 1;
      view._origin = origin;
    }
    if (rerun2)
      view.run("enter");
    if (auto)
      view.runAfter((v2) => v2.resize());
  }, false, 1);
}
function getState2(options) {
  return this._runtime.getState(options || {
    data: dataTest,
    signals: signalTest,
    recurse: true
  });
}
function dataTest(name, data3) {
  return data3.modified && isArray15(data3.input.value) && !name.startsWith("_:vega:_");
}
function signalTest(name, op) {
  return !(name === "parent" || op instanceof transforms.proxy);
}
function setState2(state) {
  this.runAsync(null, (v2) => {
    v2._trigger = false;
    v2._runtime.setState(state);
  }, (v2) => {
    v2._trigger = true;
  });
  return this;
}
function timer2(callback, delay) {
  function tick2(elapsed) {
    callback({
      timestamp: Date.now(),
      elapsed
    });
  }
  this._timers.push(interval_default(tick2, delay));
}
function defaultTooltip6(handler, event2, item, value7) {
  const el = handler.element();
  if (el)
    el.setAttribute("title", formatTooltip(value7));
}
function formatTooltip(value7) {
  return value7 == null ? "" : isArray15(value7) ? formatArray(value7) : isObject8(value7) && !isDate5(value7) ? formatObject(value7) : value7 + "";
}
function formatObject(obj) {
  return Object.keys(obj).map((key4) => {
    const v2 = obj[key4];
    return key4 + ": " + (isArray15(v2) ? formatArray(v2) : formatValue7(v2));
  }).join("\n");
}
function formatArray(value7) {
  return "[" + value7.map(formatValue7).join(", ") + "]";
}
function formatValue7(value7) {
  return isArray15(value7) ? "[…]" : isObject8(value7) && !isDate5(value7) ? "{…}" : value7;
}
function watchPixelRatio() {
  if (this.renderer() === "canvas" && this._renderer._canvas) {
    let remove2 = null;
    const updatePixelRatio = () => {
      if (remove2 != null) {
        remove2();
      }
      const media = matchMedia(`(resolution: ${window.devicePixelRatio}dppx)`);
      media.addEventListener("change", updatePixelRatio);
      remove2 = () => {
        media.removeEventListener("change", updatePixelRatio);
      };
      this._renderer._canvas.getContext("2d").pixelRatio = window.devicePixelRatio || 1;
      this._redraw = true;
      this._resize = 1;
      this.resize().runAsync();
    };
    updatePixelRatio();
  }
}
function View(spec, options) {
  const view = this;
  options = options || {};
  Dataflow.call(view);
  if (options.loader)
    view.loader(options.loader);
  if (options.logger)
    view.logger(options.logger);
  if (options.logLevel != null)
    view.logLevel(options.logLevel);
  if (options.locale || spec.locale) {
    const loc = extend16({}, spec.locale, options.locale);
    view.locale(locale4(loc.number, loc.time));
  }
  view._el = null;
  view._elBind = null;
  view._renderType = options.renderer || RenderType2.Canvas;
  view._scenegraph = new Scenegraph2();
  const root = view._scenegraph.root;
  view._renderer = null;
  view._tooltip = options.tooltip || defaultTooltip6, view._redraw = true;
  view._handler = new CanvasHandler4().scene(root);
  view._globalCursor = false;
  view._preventDefault = false;
  view._timers = [];
  view._eventListeners = [];
  view._resizeListeners = [];
  view._eventConfig = initializeEventConfig(spec.eventConfig);
  view.globalCursor(view._eventConfig.globalCursor);
  const ctx = runtime(view, spec, options.expr);
  view._runtime = ctx;
  view._signals = ctx.signals;
  view._bind = (spec.bindings || []).map((_) => ({
    state: null,
    param: extend16({}, _)
  }));
  if (ctx.root)
    ctx.root.set(root);
  root.source = ctx.data.root.input;
  view.pulse(ctx.data.root.input, view.changeset().insert(root.items));
  view._width = view.width();
  view._height = view.height();
  view._viewWidth = viewWidth(view, view._width);
  view._viewHeight = viewHeight(view, view._height);
  view._origin = [0, 0];
  view._resize = 0;
  view._autosize = 1;
  initializeResize(view);
  background6(view);
  cursor(view);
  view.description(spec.description);
  if (options.hover)
    view.hover();
  if (options.container)
    view.initialize(options.container, options.bind);
  if (options.watchPixelRatio)
    view._watchPixelRatio();
}
function lookupSignal(view, name) {
  return has12(view._signals, name) ? view._signals[name] : error15("Unrecognized signal name: " + $6(name));
}
function findOperatorHandler(op, handler) {
  const h6 = (op._targets || []).filter((op2) => op2._update && op2._update.handler === handler);
  return h6.length ? h6[0] : null;
}
function addOperatorListener(view, name, op, handler) {
  let h6 = findOperatorHandler(op, handler);
  if (!h6) {
    h6 = trap(view, () => handler(name, op.value));
    h6.handler = handler;
    view.on(op, null, h6);
  }
  return view;
}
function removeOperatorListener(view, op, handler) {
  const h6 = findOperatorHandler(op, handler);
  if (h6)
    op._targets.remove(h6);
  return view;
}
inherits14(View, Dataflow, {
  // -- DATAFLOW / RENDERING ----
  async evaluate(encode2, prerun, postrun) {
    await Dataflow.prototype.evaluate.call(this, encode2, prerun);
    if (this._redraw || this._resize) {
      try {
        if (this._renderer) {
          if (this._resize) {
            this._resize = 0;
            resizeRenderer(this);
          }
          await this._renderer.renderAsync(this._scenegraph.root);
        }
        this._redraw = false;
      } catch (e3) {
        this.error(e3);
      }
    }
    if (postrun)
      asyncCallback(this, postrun);
    return this;
  },
  dirty(item) {
    this._redraw = true;
    this._renderer && this._renderer.dirty(item);
  },
  // -- GET / SET ----
  description(text7) {
    if (arguments.length) {
      const desc = text7 != null ? text7 + "" : null;
      if (desc !== this._desc)
        ariaLabel(this._el, this._desc = desc);
      return this;
    }
    return this._desc;
  },
  container() {
    return this._el;
  },
  scenegraph() {
    return this._scenegraph;
  },
  origin() {
    return this._origin.slice();
  },
  signal(name, value7, options) {
    const op = lookupSignal(this, name);
    return arguments.length === 1 ? op.value : this.update(op, value7, options);
  },
  width(_) {
    return arguments.length ? this.signal("width", _) : this.signal("width");
  },
  height(_) {
    return arguments.length ? this.signal("height", _) : this.signal("height");
  },
  padding(_) {
    return arguments.length ? this.signal("padding", padding(_)) : padding(this.signal("padding"));
  },
  autosize(_) {
    return arguments.length ? this.signal("autosize", _) : this.signal("autosize");
  },
  background(_) {
    return arguments.length ? this.signal("background", _) : this.signal("background");
  },
  renderer(type7) {
    if (!arguments.length)
      return this._renderType;
    if (!renderModule2(type7))
      error15("Unrecognized renderer type: " + type7);
    if (type7 !== this._renderType) {
      this._renderType = type7;
      this._resetRenderer();
    }
    return this;
  },
  tooltip(handler) {
    if (!arguments.length)
      return this._tooltip;
    if (handler !== this._tooltip) {
      this._tooltip = handler;
      this._resetRenderer();
    }
    return this;
  },
  loader(loader7) {
    if (!arguments.length)
      return this._loader;
    if (loader7 !== this._loader) {
      Dataflow.prototype.loader.call(this, loader7);
      this._resetRenderer();
    }
    return this;
  },
  resize() {
    this._autosize = 1;
    return this.touch(lookupSignal(this, "autosize"));
  },
  _resetRenderer() {
    if (this._renderer) {
      this._renderer = null;
      this.initialize(this._el, this._elBind);
    }
  },
  // -- SIZING ----
  _resizeView: resizeView,
  // -- EVENT HANDLING ----
  addEventListener(type7, handler, options) {
    let callback = handler;
    if (!(options && options.trap === false)) {
      callback = trap(this, handler);
      callback.raw = handler;
    }
    this._handler.on(type7, callback);
    return this;
  },
  removeEventListener(type7, handler) {
    var handlers = this._handler.handlers(type7), i = handlers.length, h6, t;
    while (--i >= 0) {
      t = handlers[i].type;
      h6 = handlers[i].handler;
      if (type7 === t && (handler === h6 || handler === h6.raw)) {
        this._handler.off(t, h6);
        break;
      }
    }
    return this;
  },
  addResizeListener(handler) {
    const l = this._resizeListeners;
    if (!l.includes(handler)) {
      l.push(handler);
    }
    return this;
  },
  removeResizeListener(handler) {
    var l = this._resizeListeners, i = l.indexOf(handler);
    if (i >= 0) {
      l.splice(i, 1);
    }
    return this;
  },
  addSignalListener(name, handler) {
    return addOperatorListener(this, name, lookupSignal(this, name), handler);
  },
  removeSignalListener(name, handler) {
    return removeOperatorListener(this, lookupSignal(this, name), handler);
  },
  addDataListener(name, handler) {
    return addOperatorListener(this, name, dataref(this, name).values, handler);
  },
  removeDataListener(name, handler) {
    return removeOperatorListener(this, dataref(this, name).values, handler);
  },
  globalCursor(_) {
    if (arguments.length) {
      if (this._globalCursor !== !!_) {
        const prev = setCursor(this, null);
        this._globalCursor = !!_;
        if (prev)
          setCursor(this, prev);
      }
      return this;
    } else {
      return this._globalCursor;
    }
  },
  preventDefault(_) {
    if (arguments.length) {
      this._preventDefault = _;
      return this;
    } else {
      return this._preventDefault;
    }
  },
  timer: timer2,
  events: events2,
  finalize,
  hover,
  // -- DATA ----
  data: data2,
  change,
  insert,
  remove,
  // -- SCALES --
  scale: scale16,
  // -- INITIALIZATION ----
  initialize: initialize3,
  // -- HEADLESS RENDERING ----
  toImageURL: renderToImageURL,
  toCanvas: renderToCanvas,
  toSVG: renderToSVG,
  // -- SAVE / RESTORE STATE ----
  getState: getState2,
  setState: setState2,
  // RE-RENDER ON ZOOM
  _watchPixelRatio: watchPixelRatio
});

// node_modules/vega-parser/node_modules/vega-util/build/vega-util.js
function accessor20(fn, fields, name) {
  fn.fields = fields || [];
  fn.fname = name;
  return fn;
}
function getter21(path7) {
  return path7.length === 1 ? get120(path7[0]) : getN20(path7);
}
var get120 = (field25) => function(obj) {
  return obj[field25];
};
var getN20 = (path7) => {
  const len = path7.length;
  return function(obj) {
    for (let i = 0; i < len; ++i) {
      obj = obj[path7[i]];
    }
    return obj;
  };
};
function error20(message) {
  throw Error(message);
}
function splitAccessPath20(p) {
  const path7 = [], n = p.length;
  let q = null, b6 = 0, s2 = "", i, j, c5;
  p = p + "";
  function push() {
    path7.push(s2 + p.substring(i, j));
    s2 = "";
    i = j + 1;
  }
  for (i = j = 0; j < n; ++j) {
    c5 = p[j];
    if (c5 === "\\") {
      s2 += p.substring(i, j++);
      i = j;
    } else if (c5 === q) {
      push();
      q = null;
      b6 = -1;
    } else if (q) {
      continue;
    } else if (i === b6 && c5 === '"') {
      i = j + 1;
      q = c5;
    } else if (i === b6 && c5 === "'") {
      i = j + 1;
      q = c5;
    } else if (c5 === "." && !b6) {
      if (j > i) {
        push();
      } else {
        i = j + 1;
      }
    } else if (c5 === "[") {
      if (j > i)
        push();
      b6 = i = j + 1;
    } else if (c5 === "]") {
      if (!b6)
        error20("Access path missing open bracket: " + p);
      if (b6 > 0)
        push();
      b6 = 0;
      i = j + 1;
    }
  }
  if (b6)
    error20("Access path missing closing bracket: " + p);
  if (q)
    error20("Access path missing closing quote: " + p);
  if (j > i) {
    j++;
    push();
  }
  return path7;
}
function field20(field25, name, opt) {
  const path7 = splitAccessPath20(field25);
  field25 = path7.length === 1 ? path7[0] : field25;
  return accessor20((opt && opt.get || getter21)(path7), [field25], name || field25);
}
var id20 = field20("id");
var identity24 = accessor20((_) => _, [], "identity");
var zero22 = accessor20(() => 0, [], "zero");
var one21 = accessor20(() => 1, [], "one");
var truthy20 = accessor20(() => true, [], "true");
var falsy20 = accessor20(() => false, [], "false");
var DisallowedObjectProperties20 = /* @__PURE__ */ new Set([...Object.getOwnPropertyNames(Object.prototype).filter((name) => typeof Object.prototype[name] === "function"), "__proto__"]);
var isArray20 = Array.isArray;
function isObject11(_) {
  return _ === Object(_);
}
var isLegalKey2 = (key4) => key4 !== "__proto__";
function mergeConfig2(...configs) {
  return configs.reduce((out, source3) => {
    for (const key4 in source3) {
      if (key4 === "signals") {
        out.signals = mergeNamed2(out.signals, source3.signals);
      } else {
        const r = key4 === "legend" ? {
          layout: 1
        } : key4 === "style" ? true : null;
        writeConfig2(out, key4, source3[key4], r);
      }
    }
    return out;
  }, {});
}
function writeConfig2(output3, key4, value7, recurse6) {
  if (!isLegalKey2(key4))
    return;
  let k3, o;
  if (isObject11(value7) && !isArray20(value7)) {
    o = isObject11(output3[key4]) ? output3[key4] : output3[key4] = {};
    for (k3 in value7) {
      if (recurse6 && (recurse6 === true || recurse6[k3])) {
        writeConfig2(o, k3, value7[k3]);
      } else if (isLegalKey2(k3)) {
        o[k3] = value7[k3];
      }
    }
  } else {
    output3[key4] = value7;
  }
}
function mergeNamed2(a4, b6) {
  if (a4 == null)
    return b6;
  const map13 = {}, out = [];
  function add10(_) {
    if (!map13[_.name]) {
      map13[_.name] = 1;
      out.push(_);
    }
  }
  b6.forEach(add10);
  a4.forEach(add10);
  return out;
}
function peek13(array22) {
  return array22[array22.length - 1];
}
function toNumber12(_) {
  return _ == null || _ === "" ? null : +_;
}
function array20(_) {
  return _ != null ? isArray20(_) ? _ : [_] : [];
}
function extend19(_) {
  for (let x9, k3, i = 1, len = arguments.length; i < len; ++i) {
    x9 = arguments[i];
    for (k3 in x9) {
      _[k3] = x9[k3];
    }
  }
  return _;
}
function has17(object2, property2) {
  return Object.hasOwn(object2, property2);
}
function isString12(_) {
  return typeof _ === "string";
}
function $9(x9) {
  return isArray20(x9) ? `[${x9.map((v2) => v2 === null ? "null" : $9(v2))}]` : isObject11(x9) || isString12(x9) ? (
    // Output valid JSON and JS source strings.
    // See https://github.com/judofyr/timeless/blob/master/posts/json-isnt-a-javascript-subset.md
    JSON.stringify(x9).replaceAll("\u2028", "\\u2028").replaceAll("\u2029", "\\u2029")
  ) : x9;
}
function toSet14(_) {
  const s2 = {}, n = _.length;
  for (let i = 0; i < n; ++i)
    s2[_[i]] = true;
  return s2;
}

// node_modules/vega-event-selector/build/vega-event-selector.js
var VIEW2 = "view";
var LBRACK = "[";
var RBRACK = "]";
var LBRACE = "{";
var RBRACE = "}";
var COLON = ":";
var COMMA = ",";
var NAME = "@";
var GT = ">";
var ILLEGAL2 = /[[\]{}]/;
var DEFAULT_MARKS = {
  "*": 1,
  arc: 1,
  area: 1,
  group: 1,
  image: 1,
  line: 1,
  path: 1,
  rect: 1,
  rule: 1,
  shape: 1,
  symbol: 1,
  text: 1,
  trail: 1
};
var DEFAULT_SOURCE;
var MARKS;
function eventSelector(selector, source3, marks) {
  DEFAULT_SOURCE = source3 || VIEW2;
  MARKS = marks || DEFAULT_MARKS;
  return parseMerge(selector.trim()).map(parseSelector);
}
function isMarkType(type7) {
  return MARKS[type7];
}
function find3(s2, i, endChar, pushChar, popChar) {
  const n = s2.length;
  let count3 = 0, c5;
  for (; i < n; ++i) {
    c5 = s2[i];
    if (!count3 && c5 === endChar)
      return i;
    else if (popChar && popChar.includes(c5))
      --count3;
    else if (pushChar && pushChar.includes(c5))
      ++count3;
  }
  return i;
}
function parseMerge(s2) {
  const output3 = [], n = s2.length;
  let start = 0, i = 0;
  while (i < n) {
    i = find3(s2, i, COMMA, LBRACK + LBRACE, RBRACK + RBRACE);
    output3.push(s2.substring(start, i).trim());
    start = ++i;
  }
  if (output3.length === 0) {
    throw "Empty event selector: " + s2;
  }
  return output3;
}
function parseSelector(s2) {
  return s2[0] === "[" ? parseBetween(s2) : parseStream2(s2);
}
function parseBetween(s2) {
  const n = s2.length;
  let i = 1, b6;
  i = find3(s2, i, RBRACK, LBRACK, RBRACK);
  if (i === n) {
    throw "Empty between selector: " + s2;
  }
  b6 = parseMerge(s2.substring(1, i));
  if (b6.length !== 2) {
    throw "Between selector must have two elements: " + s2;
  }
  s2 = s2.slice(i + 1).trim();
  if (s2[0] !== GT) {
    throw "Expected '>' after between selector: " + s2;
  }
  b6 = b6.map(parseSelector);
  const stream2 = parseSelector(s2.slice(1).trim());
  if (stream2.between) {
    return {
      between: b6,
      stream: stream2
    };
  } else {
    stream2.between = b6;
  }
  return stream2;
}
function parseStream2(s2) {
  const stream2 = {
    source: DEFAULT_SOURCE
  }, source3 = [];
  let throttle = [0, 0], markname = 0, start = 0, n = s2.length, i = 0, j, filter4;
  if (s2[n - 1] === RBRACE) {
    i = s2.lastIndexOf(LBRACE);
    if (i >= 0) {
      try {
        throttle = parseThrottle(s2.substring(i + 1, n - 1));
      } catch (e3) {
        throw "Invalid throttle specification: " + s2;
      }
      s2 = s2.slice(0, i).trim();
      n = s2.length;
    } else
      throw "Unmatched right brace: " + s2;
    i = 0;
  }
  if (!n)
    throw s2;
  if (s2[0] === NAME)
    markname = ++i;
  j = find3(s2, i, COLON);
  if (j < n) {
    source3.push(s2.substring(start, j).trim());
    start = i = ++j;
  }
  i = find3(s2, i, LBRACK);
  if (i === n) {
    source3.push(s2.substring(start, n).trim());
  } else {
    source3.push(s2.substring(start, i).trim());
    filter4 = [];
    start = ++i;
    if (start === n)
      throw "Unmatched left bracket: " + s2;
  }
  while (i < n) {
    i = find3(s2, i, RBRACK);
    if (i === n)
      throw "Unmatched left bracket: " + s2;
    filter4.push(s2.substring(start, i).trim());
    if (i < n - 1 && s2[++i] !== LBRACK)
      throw "Expected left bracket: " + s2;
    start = ++i;
  }
  if (!(n = source3.length) || ILLEGAL2.test(source3[n - 1])) {
    throw "Invalid event selector: " + s2;
  }
  if (n > 1) {
    stream2.type = source3[1];
    if (markname) {
      stream2.markname = source3[0].slice(1);
    } else if (isMarkType(source3[0])) {
      stream2.marktype = source3[0];
    } else {
      stream2.source = source3[0];
    }
  } else {
    stream2.type = source3[0];
  }
  if (stream2.type.slice(-1) === "!") {
    stream2.consume = true;
    stream2.type = stream2.type.slice(0, -1);
  }
  if (filter4 != null)
    stream2.filter = filter4;
  if (throttle[0])
    stream2.throttle = throttle[0];
  if (throttle[1])
    stream2.debounce = throttle[1];
  return stream2;
}
function parseThrottle(s2) {
  const a4 = s2.split(COMMA);
  if (!s2.length || a4.length > 2)
    throw s2;
  return a4.map((_) => {
    const x9 = +_;
    if (x9 !== x9)
      throw s2;
    return x9;
  });
}

// node_modules/vega-parser/node_modules/vega-time/build/vega-time.js
var YEAR11 = "year";
var QUARTER11 = "quarter";
var MONTH11 = "month";
var WEEK11 = "week";
var DATE11 = "date";
var DAY11 = "day";
var DAYOFYEAR11 = "dayofyear";
var HOURS11 = "hours";
var MINUTES11 = "minutes";
var SECONDS11 = "seconds";
var MILLISECONDS11 = "milliseconds";
var TIME_UNITS11 = [YEAR11, QUARTER11, MONTH11, WEEK11, DATE11, DAY11, DAYOFYEAR11, HOURS11, MINUTES11, SECONDS11, MILLISECONDS11];
var UNITS11 = TIME_UNITS11.reduce((o, u4, i) => (o[u4] = 1 + i, o), {});
var defaultSpecifiers11 = {
  [YEAR11]: "%Y ",
  [QUARTER11]: "Q%q ",
  [MONTH11]: "%b ",
  [DATE11]: "%d ",
  [WEEK11]: "W%U ",
  [DAY11]: "%a ",
  [DAYOFYEAR11]: "%j ",
  [HOURS11]: "%H:00",
  [MINUTES11]: "00:%M",
  [SECONDS11]: ":%S",
  [MILLISECONDS11]: ".%L",
  [`${YEAR11}-${MONTH11}`]: "%Y-%m ",
  [`${YEAR11}-${MONTH11}-${DATE11}`]: "%Y-%m-%d ",
  [`${HOURS11}-${MINUTES11}`]: "%H:%M"
};
var t013 = /* @__PURE__ */ new Date();
function localYear11(y9) {
  t013.setFullYear(y9);
  t013.setMonth(0);
  t013.setDate(1);
  t013.setHours(0, 0, 0, 0);
  return t013;
}
function localDayOfYear11(d) {
  return timeDay.count(localYear11(d.getFullYear()) - 1, d);
}
function localWeekNum11(d) {
  return timeSunday.count(localYear11(d.getFullYear()) - 1, d);
}
function localFirst11(y9) {
  return localYear11(y9).getDay();
}
function utcDayOfYear11(d) {
  const y9 = Date.UTC(d.getUTCFullYear(), 0, 1);
  return utcDay.count(y9 - 1, d);
}
function utcWeekNum11(d) {
  const y9 = Date.UTC(d.getUTCFullYear(), 0, 1);
  return utcSunday.count(y9 - 1, d);
}
function utcFirst11(y9) {
  t013.setTime(Date.UTC(y9, 0, 1));
  return t013.getUTCDay();
}
function weekday11(week3, day, firstDay) {
  return day + week3 * 7 - (firstDay + 6) % 7;
}
var localGet11 = {
  [YEAR11]: (d) => d.getFullYear(),
  [QUARTER11]: (d) => Math.floor(d.getMonth() / 3),
  [MONTH11]: (d) => d.getMonth(),
  [DATE11]: (d) => d.getDate(),
  [HOURS11]: (d) => d.getHours(),
  [MINUTES11]: (d) => d.getMinutes(),
  [SECONDS11]: (d) => d.getSeconds(),
  [MILLISECONDS11]: (d) => d.getMilliseconds(),
  [DAYOFYEAR11]: (d) => localDayOfYear11(d),
  [WEEK11]: (d) => localWeekNum11(d),
  [WEEK11 + DAY11]: (d, y9) => weekday11(localWeekNum11(d), d.getDay(), localFirst11(y9)),
  [DAY11]: (d, y9) => weekday11(1, d.getDay(), localFirst11(y9))
};
var localInv11 = {
  [QUARTER11]: (q) => 3 * q,
  [WEEK11]: (w8, y9) => weekday11(w8, 0, localFirst11(y9))
};
var utcGet11 = {
  [YEAR11]: (d) => d.getUTCFullYear(),
  [QUARTER11]: (d) => Math.floor(d.getUTCMonth() / 3),
  [MONTH11]: (d) => d.getUTCMonth(),
  [DATE11]: (d) => d.getUTCDate(),
  [HOURS11]: (d) => d.getUTCHours(),
  [MINUTES11]: (d) => d.getUTCMinutes(),
  [SECONDS11]: (d) => d.getUTCSeconds(),
  [MILLISECONDS11]: (d) => d.getUTCMilliseconds(),
  [DAYOFYEAR11]: (d) => utcDayOfYear11(d),
  [WEEK11]: (d) => utcWeekNum11(d),
  [DAY11]: (d, y9) => weekday11(1, d.getUTCDay(), utcFirst11(y9)),
  [WEEK11 + DAY11]: (d, y9) => weekday11(utcWeekNum11(d), d.getUTCDay(), utcFirst11(y9))
};
var utcInv11 = {
  [QUARTER11]: (q) => 3 * q,
  [WEEK11]: (w8, y9) => weekday11(w8, 0, utcFirst11(y9))
};
var timeIntervals11 = {
  [YEAR11]: timeYear,
  [QUARTER11]: timeMonth.every(3),
  [MONTH11]: timeMonth,
  [WEEK11]: timeSunday,
  [DATE11]: timeDay,
  [DAY11]: timeDay,
  [DAYOFYEAR11]: timeDay,
  [HOURS11]: timeHour,
  [MINUTES11]: timeMinute,
  [SECONDS11]: second,
  [MILLISECONDS11]: millisecond
};
var utcIntervals11 = {
  [YEAR11]: utcYear,
  [QUARTER11]: utcMonth.every(3),
  [MONTH11]: utcMonth,
  [WEEK11]: utcSunday,
  [DATE11]: utcDay,
  [DAY11]: utcDay,
  [DAYOFYEAR11]: utcDay,
  [HOURS11]: utcHour,
  [MINUTES11]: utcMinute,
  [SECONDS11]: second,
  [MILLISECONDS11]: millisecond
};
var durationSecond12 = 1e3;
var durationMinute12 = durationSecond12 * 60;
var durationHour12 = durationMinute12 * 60;
var durationDay12 = durationHour12 * 24;
var durationWeek12 = durationDay12 * 7;
var durationMonth12 = durationDay12 * 30;
var durationYear12 = durationDay12 * 365;
var Milli11 = [YEAR11, MONTH11, DATE11, HOURS11, MINUTES11, SECONDS11, MILLISECONDS11];
var Seconds11 = Milli11.slice(0, -1);
var Minutes11 = Seconds11.slice(0, -1);
var Hours11 = Minutes11.slice(0, -1);
var Day11 = Hours11.slice(0, -1);
var Week11 = [YEAR11, WEEK11];
var Month11 = [YEAR11, MONTH11];
var Year11 = [YEAR11];
var intervals11 = [[Seconds11, 1, durationSecond12], [Seconds11, 5, 5 * durationSecond12], [Seconds11, 15, 15 * durationSecond12], [Seconds11, 30, 30 * durationSecond12], [Minutes11, 1, durationMinute12], [Minutes11, 5, 5 * durationMinute12], [Minutes11, 15, 15 * durationMinute12], [Minutes11, 30, 30 * durationMinute12], [Hours11, 1, durationHour12], [Hours11, 3, 3 * durationHour12], [Hours11, 6, 6 * durationHour12], [Hours11, 12, 12 * durationHour12], [Day11, 1, durationDay12], [Week11, 1, durationWeek12], [Month11, 1, durationMonth12], [Month11, 3, 3 * durationMonth12], [Year11, 1, durationYear12]];

// node_modules/vega-parser/node_modules/vega-scale/build/vega-scale.js
function bandSpace9(count3, paddingInner2, paddingOuter2) {
  const space = count3 - paddingInner2 + paddingOuter2 * 2;
  return count3 ? space > 0 ? space : 1 : 0;
}
var Identity9 = "identity";
var Linear10 = "linear";
var Log9 = "log";
var Pow9 = "pow";
var Sqrt9 = "sqrt";
var Symlog9 = "symlog";
var Time9 = "time";
var UTC9 = "utc";
var Sequential9 = "sequential";
var Diverging9 = "diverging";
var Quantile10 = "quantile";
var Quantize9 = "quantize";
var Threshold9 = "threshold";
var Ordinal9 = "ordinal";
var Point9 = "point";
var Band9 = "band";
var BinOrdinal9 = "bin-ordinal";
var Continuous9 = "continuous";
var Discrete9 = "discrete";
var Discretizing9 = "discretizing";
var Interpolating9 = "interpolating";
var Temporal9 = "temporal";
function invertRange9(scale19) {
  return function(_) {
    let lo = _[0], hi = _[1], t;
    if (hi < lo) {
      t = lo;
      lo = hi;
      hi = t;
    }
    return [scale19.invert(lo), scale19.invert(hi)];
  };
}
function invertRangeExtent9(scale19) {
  return function(_) {
    const range7 = scale19.range();
    let lo = _[0], hi = _[1], min5 = -1, max5, t, i, n;
    if (hi < lo) {
      t = lo;
      lo = hi;
      hi = t;
    }
    for (i = 0, n = range7.length; i < n; ++i) {
      if (range7[i] >= lo && range7[i] <= hi) {
        if (min5 < 0)
          min5 = i;
        max5 = i;
      }
    }
    if (min5 < 0)
      return void 0;
    lo = scale19.invertExtent(range7[min5]);
    hi = scale19.invertExtent(range7[max5]);
    return [lo[0] === void 0 ? lo[1] : lo[0], hi[1] === void 0 ? hi[0] : hi[1]];
  };
}
function band10() {
  const scale19 = ordinal().unknown(void 0), domain3 = scale19.domain, ordinalRange = scale19.range;
  let range$1 = [0, 1], step, bandwidth2, round2 = false, paddingInner2 = 0, paddingOuter2 = 0, align2 = 0.5;
  delete scale19.unknown;
  function rescale() {
    const n = domain3().length, reverse4 = range$1[1] < range$1[0], stop2 = range$1[1 - reverse4], space = bandSpace9(n, paddingInner2, paddingOuter2);
    let start = range$1[reverse4 - 0];
    step = (stop2 - start) / (space || 1);
    if (round2) {
      step = Math.floor(step);
    }
    start += (stop2 - start - step * (n - paddingInner2)) * align2;
    bandwidth2 = step * (1 - paddingInner2);
    if (round2) {
      start = Math.round(start);
      bandwidth2 = Math.round(bandwidth2);
    }
    const values7 = range(n).map((i) => start + step * i);
    return ordinalRange(reverse4 ? values7.reverse() : values7);
  }
  scale19.domain = function(_) {
    if (arguments.length) {
      domain3(_);
      return rescale();
    } else {
      return domain3();
    }
  };
  scale19.range = function(_) {
    if (arguments.length) {
      range$1 = [+_[0], +_[1]];
      return rescale();
    } else {
      return range$1.slice();
    }
  };
  scale19.rangeRound = function(_) {
    range$1 = [+_[0], +_[1]];
    round2 = true;
    return rescale();
  };
  scale19.bandwidth = function() {
    return bandwidth2;
  };
  scale19.step = function() {
    return step;
  };
  scale19.round = function(_) {
    if (arguments.length) {
      round2 = !!_;
      return rescale();
    } else {
      return round2;
    }
  };
  scale19.padding = function(_) {
    if (arguments.length) {
      paddingOuter2 = Math.max(0, Math.min(1, _));
      paddingInner2 = paddingOuter2;
      return rescale();
    } else {
      return paddingInner2;
    }
  };
  scale19.paddingInner = function(_) {
    if (arguments.length) {
      paddingInner2 = Math.max(0, Math.min(1, _));
      return rescale();
    } else {
      return paddingInner2;
    }
  };
  scale19.paddingOuter = function(_) {
    if (arguments.length) {
      paddingOuter2 = Math.max(0, Math.min(1, _));
      return rescale();
    } else {
      return paddingOuter2;
    }
  };
  scale19.align = function(_) {
    if (arguments.length) {
      align2 = Math.max(0, Math.min(1, _));
      return rescale();
    } else {
      return align2;
    }
  };
  scale19.invertRange = function(_) {
    if (_[0] == null || _[1] == null)
      return;
    const reverse4 = range$1[1] < range$1[0], values7 = reverse4 ? ordinalRange().reverse() : ordinalRange(), n = values7.length - 1;
    let lo = +_[0], hi = +_[1], a4, b6, t;
    if (lo !== lo || hi !== hi)
      return;
    if (hi < lo) {
      t = lo;
      lo = hi;
      hi = t;
    }
    if (hi < values7[0] || lo > range$1[1 - reverse4])
      return;
    a4 = Math.max(0, bisectRight(values7, lo) - 1);
    b6 = lo === hi ? a4 : bisectRight(values7, hi) - 1;
    if (lo - values7[a4] > bandwidth2 + 1e-10)
      ++a4;
    if (reverse4) {
      t = a4;
      a4 = n - b6;
      b6 = n - t;
    }
    return a4 > b6 ? void 0 : domain3().slice(a4, b6 + 1);
  };
  scale19.invert = function(_) {
    const value7 = scale19.invertRange([_, _]);
    return value7 ? value7[0] : value7;
  };
  scale19.copy = function() {
    return band10().domain(domain3()).range(range$1).round(round2).paddingInner(paddingInner2).paddingOuter(paddingOuter2).align(align2);
  };
  return rescale();
}
function pointish9(scale19) {
  const copy4 = scale19.copy;
  scale19.padding = scale19.paddingOuter;
  delete scale19.paddingInner;
  scale19.copy = function() {
    return pointish9(copy4());
  };
  return scale19;
}
function point19() {
  return pointish9(band10().paddingInner(1));
}
var map12 = Array.prototype.map;
function numbers11(_) {
  return map12.call(_, toNumber12);
}
var slice12 = Array.prototype.slice;
function scaleBinOrdinal9() {
  let domain3 = [], range7 = [];
  function scale19(x9) {
    return x9 == null || x9 !== x9 ? void 0 : range7[(bisect_default2(domain3, x9) - 1) % range7.length];
  }
  scale19.domain = function(_) {
    if (arguments.length) {
      domain3 = numbers11(_);
      return scale19;
    } else {
      return domain3.slice();
    }
  };
  scale19.range = function(_) {
    if (arguments.length) {
      range7 = slice12.call(_);
      return scale19;
    } else {
      return range7.slice();
    }
  };
  scale19.tickFormat = function(count3, specifier) {
    return tickFormat(domain3[0], peek13(domain3), count3 == null ? 10 : count3, specifier);
  };
  scale19.copy = function() {
    return scaleBinOrdinal9().domain(scale19.domain()).range(scale19.range());
  };
  return scale19;
}
var scales9 = /* @__PURE__ */ new Map();
var VEGA_SCALE9 = Symbol("vega_scale");
function registerScale9(scale19) {
  scale19[VEGA_SCALE9] = true;
  return scale19;
}
function create11(type7, constructor, metadata6) {
  const ctr = function scale19() {
    const s2 = constructor();
    if (!s2.invertRange) {
      s2.invertRange = s2.invert ? invertRange9(s2) : s2.invertExtent ? invertRangeExtent9(s2) : void 0;
    }
    s2.type = type7;
    return registerScale9(s2);
  };
  ctr.metadata = toSet14(array20(metadata6));
  return ctr;
}
function scale17(type7, scale19, metadata6) {
  if (arguments.length > 1) {
    scales9.set(type7, create11(type7, scale19, metadata6));
    return this;
  } else {
    return isValidScaleType9(type7) ? scales9.get(type7) : void 0;
  }
}
scale17(Identity9, identity8);
scale17(Linear10, linear3, Continuous9);
scale17(Log9, log3, [Continuous9, Log9]);
scale17(Pow9, pow3, Continuous9);
scale17(Sqrt9, sqrt2, Continuous9);
scale17(Symlog9, symlog2, Continuous9);
scale17(Time9, time, [Continuous9, Temporal9]);
scale17(UTC9, utcTime, [Continuous9, Temporal9]);
scale17(Sequential9, sequential, [Continuous9, Interpolating9]);
scale17(`${Sequential9}-${Linear10}`, sequential, [Continuous9, Interpolating9]);
scale17(`${Sequential9}-${Log9}`, sequentialLog, [Continuous9, Interpolating9, Log9]);
scale17(`${Sequential9}-${Pow9}`, sequentialPow, [Continuous9, Interpolating9]);
scale17(`${Sequential9}-${Sqrt9}`, sequentialSqrt, [Continuous9, Interpolating9]);
scale17(`${Sequential9}-${Symlog9}`, sequentialSymlog, [Continuous9, Interpolating9]);
scale17(`${Diverging9}-${Linear10}`, diverging, [Continuous9, Interpolating9]);
scale17(`${Diverging9}-${Log9}`, divergingLog, [Continuous9, Interpolating9, Log9]);
scale17(`${Diverging9}-${Pow9}`, divergingPow, [Continuous9, Interpolating9]);
scale17(`${Diverging9}-${Sqrt9}`, divergingSqrt, [Continuous9, Interpolating9]);
scale17(`${Diverging9}-${Symlog9}`, divergingSymlog, [Continuous9, Interpolating9]);
scale17(Quantile10, quantile2, [Discretizing9, Quantile10]);
scale17(Quantize9, quantize, Discretizing9);
scale17(Threshold9, threshold, Discretizing9);
scale17(BinOrdinal9, scaleBinOrdinal9, [Discrete9, Discretizing9]);
scale17(Ordinal9, ordinal, Discrete9);
scale17(Band9, band10, Discrete9);
scale17(Point9, point19, Discrete9);
function isValidScaleType9(type7) {
  return scales9.has(type7);
}
function hasType7(key4, type7) {
  const s2 = scales9.get(key4);
  return s2 && s2.metadata[type7];
}
function isContinuous2(key4) {
  return hasType7(key4, Continuous9);
}
function isDiscrete6(key4) {
  return hasType7(key4, Discrete9);
}
function isDiscretizing6(key4) {
  return hasType7(key4, Discretizing9);
}
function isQuantile(key4) {
  return hasType7(key4, Quantile10);
}
function interpolateColors9(colors10, type7, gamma2) {
  return piecewise(interpolate9(type7 || "rgb", gamma2), colors10);
}
function interpolate9(type7, gamma2) {
  const interp = src_exports[method9(type7)];
  return gamma2 != null && interp && interp.gamma ? interp.gamma(gamma2) : interp;
}
function method9(type7) {
  return "interpolate" + type7.toLowerCase().split("-").map((s2) => s2[0].toUpperCase() + s2.slice(1)).join("");
}
var continuous10 = {
  blues: "cfe1f2bed8eca8cee58fc1de74b2d75ba3cf4592c63181bd206fb2125ca40a4a90",
  greens: "d3eecdc0e6baabdda594d3917bc77d60ba6c46ab5e329a512089430e7735036429",
  greys: "e2e2e2d4d4d4c4c4c4b1b1b19d9d9d8888887575756262624d4d4d3535351e1e1e",
  oranges: "fdd8b3fdc998fdb87bfda55efc9244f87f2cf06b18e4580bd14904b93d029f3303",
  purples: "e2e1efd4d4e8c4c5e0b4b3d6a3a0cc928ec3827cb97566ae684ea25c3696501f8c",
  reds: "fdc9b4fcb49afc9e80fc8767fa7051f6573fec3f2fdc2a25c81b1db21218970b13",
  blueGreen: "d5efedc1e8e0a7ddd18bd2be70c6a958ba9144ad77319c5d2089460e7736036429",
  bluePurple: "ccddecbad0e4a8c2dd9ab0d4919cc98d85be8b6db28a55a6873c99822287730f71",
  greenBlue: "d3eecec5e8c3b1e1bb9bd8bb82cec269c2ca51b2cd3c9fc7288abd1675b10b60a1",
  orangeRed: "fddcaffdcf9bfdc18afdad77fb9562f67d53ee6545e24932d32d1ebf130da70403",
  purpleBlue: "dbdaebc8cee4b1c3de97b7d87bacd15b9fc93a90c01e7fb70b70ab056199045281",
  purpleBlueGreen: "dbd8eac8cee4b0c3de93b7d872acd1549fc83892bb1c88a3097f8702736b016353",
  purpleRed: "dcc9e2d3b3d7ce9eccd186c0da6bb2e14da0e23189d91e6fc61159ab07498f023a",
  redPurple: "fccfccfcbec0faa9b8f98faff571a5ec539ddb3695c41b8aa908808d0179700174",
  yellowGreen: "e4f4acd1eca0b9e2949ed68880c97c62bb6e47aa5e3297502083440e723b036034",
  yellowOrangeBrown: "feeaa1fedd84fecc63feb746fca031f68921eb7215db5e0bc54c05ab3d038f3204",
  yellowOrangeRed: "fee087fed16ffebd59fea849fd903efc7335f9522bee3423de1b20ca0b22af0225",
  blueOrange: "134b852f78b35da2cb9dcae1d2e5eff2f0ebfce0bafbbf74e8932fc5690d994a07",
  brownBlueGreen: "704108a0651ac79548e3c78af3e6c6eef1eac9e9e48ed1c74da79e187a72025147",
  purpleGreen: "5b1667834792a67fb6c9aed3e6d6e8eff0efd9efd5aedda971bb75368e490e5e29",
  purpleOrange: "4114696647968f83b7b9b4d6dadbebf3eeeafce0bafbbf74e8932fc5690d994a07",
  redBlue: "8c0d25bf363adf745ef4ae91fbdbc9f2efeed2e5ef9dcae15da2cb2f78b3134b85",
  redGrey: "8c0d25bf363adf745ef4ae91fcdccbfaf4f1e2e2e2c0c0c0969696646464343434",
  yellowGreenBlue: "eff9bddbf1b4bde5b594d5b969c5be45b4c22c9ec02182b82163aa23479c1c3185",
  redYellowBlue: "a50026d4322cf16e43fcac64fedd90faf8c1dcf1ecabd6e875abd04a74b4313695",
  redYellowGreen: "a50026d4322cf16e43fcac63fedd8df9f7aed7ee8ea4d86e64bc6122964f006837",
  pinkYellowGreen: "8e0152c0267edd72adf0b3d6faddedf5f3efe1f2cab6de8780bb474f9125276419",
  spectral: "9e0142d13c4bf0704afcac63fedd8dfbf8b0e0f3a1a9dda269bda94288b55e4fa2",
  viridis: "440154470e61481a6c482575472f7d443a834144873d4e8a39568c35608d31688e2d708e2a788e27818e23888e21918d1f988b1fa08822a8842ab07f35b77943bf7154c56866cc5d7ad1518fd744a5db36bcdf27d2e21be9e51afde725",
  magma: "0000040404130b0924150e3720114b2c11603b0f704a107957157e651a80721f817f24828c29819a2e80a8327db6377ac43c75d1426fde4968e95462f1605df76f5cfa7f5efc8f65fe9f6dfeaf78febf84fece91fddea0fcedaffcfdbf",
  inferno: "0000040403130c0826170c3b240c4f330a5f420a68500d6c5d126e6b176e781c6d86216b932667a12b62ae305cbb3755c73e4cd24644dd513ae65c30ed6925f3771af8850ffb9506fca50afcb519fac62df6d645f2e661f3f484fcffa4",
  plasma: "0d088723069033059742039d5002a25d01a66a00a87801a88405a7900da49c179ea72198b12a90ba3488c33d80cb4779d35171da5a69e16462e76e5bed7953f2834cf68f44fa9a3dfca636fdb32ffec029fcce25f9dc24f5ea27f0f921",
  cividis: "00205100235800265d002961012b65042e670831690d346b11366c16396d1c3c6e213f6e26426e2c456e31476e374a6e3c4d6e42506e47536d4c566d51586e555b6e5a5e6e5e616e62646f66676f6a6a706e6d717270717573727976737c79747f7c75827f758682768985778c8877908b78938e789691789a94789e9778a19b78a59e77a9a177aea575b2a874b6ab73bbaf71c0b26fc5b66dc9b96acebd68d3c065d8c462ddc85fe2cb5ce7cf58ebd355f0d652f3da4ff7de4cfae249fce647",
  rainbow: "6e40aa883eb1a43db3bf3cafd83fa4ee4395fe4b83ff576eff6659ff7847ff8c38f3a130e2b72fcfcc36bee044aff05b8ff4576ff65b52f6673af27828ea8d1ddfa319d0b81cbecb23abd82f96e03d82e14c6edb5a5dd0664dbf6e40aa",
  sinebow: "ff4040fc582af47218e78d0bd5a703bfbf00a7d5038de70b72f41858fc2a40ff402afc5818f4720be78d03d5a700bfbf03a7d50b8de71872f42a58fc4040ff582afc7218f48d0be7a703d5bf00bfd503a7e70b8df41872fc2a58ff4040",
  turbo: "23171b32204a3e2a71453493493eae4b49c54a53d7485ee44569ee4074f53c7ff8378af93295f72e9ff42ba9ef28b3e926bce125c5d925cdcf27d5c629dcbc2de3b232e9a738ee9d3ff39347f68950f9805afc7765fd6e70fe667cfd5e88fc5795fb51a1f84badf545b9f140c5ec3cd0e637dae034e4d931ecd12ef4c92bfac029ffb626ffad24ffa223ff9821ff8d1fff821dff771cfd6c1af76118f05616e84b14df4111d5380fcb2f0dc0260ab61f07ac1805a313029b0f00950c00910b00",
  browns: "eedbbdecca96e9b97ae4a865dc9856d18954c7784cc0673fb85536ad44339f3632",
  tealBlues: "bce4d89dd3d181c3cb65b3c245a2b9368fae347da0306a932c5985",
  teals: "bbdfdfa2d4d58ac9c975bcbb61b0af4da5a43799982b8b8c1e7f7f127273006667",
  warmGreys: "dcd4d0cec5c1c0b8b4b3aaa7a59c9998908c8b827f7e7673726866665c5a59504e",
  goldGreen: "f4d166d5ca60b6c35c98bb597cb25760a6564b9c533f8f4f33834a257740146c36",
  goldOrange: "f4d166f8be5cf8aa4cf5983bf3852aef701be2621fd65322c54923b142239e3a26",
  goldRed: "f4d166f6be59f9aa51fc964ef6834bee734ae56249db5247cf4244c43141b71d3e",
  lightGreyRed: "efe9e6e1dad7d5cbc8c8bdb9bbaea9cd967ddc7b43e15f19df4011dc000b",
  lightGreyTeal: "e4eaead6dcddc8ced2b7c2c7a6b4bc64b0bf22a6c32295c11f85be1876bc",
  lightMulti: "e0f1f2c4e9d0b0de9fd0e181f6e072f6c053f3993ef77440ef4a3c",
  lightOrange: "f2e7daf7d5baf9c499fab184fa9c73f68967ef7860e8645bde515bd43d5b",
  lightTealBlue: "e3e9e0c0dccf9aceca7abfc859afc0389fb9328dad2f7ca0276b95255988",
  darkBlue: "3232322d46681a5c930074af008cbf05a7ce25c0dd38daed50f3faffffff",
  darkGold: "3c3c3c584b37725e348c7631ae8b2bcfa424ecc31ef9de30fff184ffffff",
  darkGreen: "3a3a3a215748006f4d048942489e4276b340a6c63dd2d836ffeb2cffffaa",
  darkMulti: "3737371f5287197d8c29a86995ce3fffe800ffffff",
  darkRed: "3434347036339e3c38cc4037e75d1eec8620eeab29f0ce32ffeb2c"
};
var discrete9 = {
  accent: Accent_default,
  category10: category10_default,
  category20: "1f77b4aec7e8ff7f0effbb782ca02c98df8ad62728ff98969467bdc5b0d58c564bc49c94e377c2f7b6d27f7f7fc7c7c7bcbd22dbdb8d17becf9edae5",
  category20b: "393b795254a36b6ecf9c9ede6379398ca252b5cf6bcedb9c8c6d31bd9e39e7ba52e7cb94843c39ad494ad6616be7969c7b4173a55194ce6dbdde9ed6",
  category20c: "3182bd6baed69ecae1c6dbefe6550dfd8d3cfdae6bfdd0a231a35474c476a1d99bc7e9c0756bb19e9ac8bcbddcdadaeb636363969696bdbdbdd9d9d9",
  dark2: Dark2_default,
  observable10: observable10_default,
  paired: Paired_default,
  pastel1: Pastel1_default,
  pastel2: Pastel2_default,
  set1: Set1_default,
  set2: Set2_default,
  set3: Set3_default,
  tableau10: "4c78a8f58518e4575672b7b254a24beeca3bb279a2ff9da69d755dbab0ac",
  tableau20: "4c78a89ecae9f58518ffbf7954a24b88d27ab79a20f2cf5b43989483bcb6e45756ff9d9879706ebab0acd67195fcbfd2b279a2d6a5c99e765fd8b5a5"
};
function colors9(palette) {
  if (isArray20(palette))
    return palette;
  const n = palette.length / 6 | 0, c5 = new Array(n);
  for (let i = 0; i < n; ) {
    c5[i] = "#" + palette.slice(i * 6, ++i * 6);
  }
  return c5;
}
function apply9(_, f) {
  for (const k3 in _)
    scheme36(k3, f(_[k3]));
}
var schemes9 = {};
apply9(discrete9, colors9);
apply9(continuous10, (_) => interpolateColors9(colors9(_)));
function scheme36(name, scheme38) {
  name = name && name.toLowerCase();
  if (arguments.length > 1) {
    schemes9[name] = scheme38;
    return this;
  } else {
    return schemes9[name];
  }
}
var symbols14 = {
  [Quantile10]: "quantiles",
  [Quantize9]: "thresholds",
  [Threshold9]: "domain"
};
var formats11 = {
  [Quantile10]: "quantiles",
  [Quantize9]: "domain"
};

// node_modules/vega-parser/build/vega-parser.js
function parseAutosize(spec) {
  return isObject11(spec) ? spec : {
    type: spec || "pad"
  };
}
var number11 = (_) => +_ || 0;
var paddingObject2 = (_) => ({
  top: _,
  bottom: _,
  left: _,
  right: _
});
function parsePadding(spec) {
  return !isObject11(spec) ? paddingObject2(number11(spec)) : spec.signal ? spec : {
    top: number11(spec.top),
    bottom: number11(spec.bottom),
    left: number11(spec.left),
    right: number11(spec.right)
  };
}
var encoder = (_) => isObject11(_) && !isArray20(_) ? extend19({}, _) : {
  value: _
};
function addEncode(object2, name, value7, set7) {
  if (value7 != null) {
    const isEncoder = isObject11(value7) && !isArray20(value7) || isArray20(value7) && value7.length && isObject11(value7[0]);
    if (isEncoder) {
      object2.update[name] = value7;
    } else {
      object2[set7 || "enter"][name] = {
        value: value7
      };
    }
    return 1;
  } else {
    return 0;
  }
}
function addEncoders(object2, enter, update3) {
  for (const name in enter) {
    addEncode(object2, name, enter[name]);
  }
  for (const name in update3) {
    addEncode(object2, name, update3[name], "update");
  }
}
function extendEncode(encode2, extra, skip) {
  for (const name in extra) {
    if (skip && has17(skip, name))
      continue;
    encode2[name] = extend19(encode2[name] || {}, extra[name]);
  }
  return encode2;
}
function has18(key4, encode2) {
  return encode2 && (encode2.enter && encode2.enter[key4] || encode2.update && encode2.update[key4]);
}
var MarkRole = "mark";
var FrameRole2 = "frame";
var ScopeRole2 = "scope";
var AxisRole2 = "axis";
var AxisDomainRole = "axis-domain";
var AxisGridRole = "axis-grid";
var AxisLabelRole = "axis-label";
var AxisTickRole = "axis-tick";
var AxisTitleRole = "axis-title";
var LegendRole2 = "legend";
var LegendBandRole = "legend-band";
var LegendEntryRole = "legend-entry";
var LegendGradientRole = "legend-gradient";
var LegendLabelRole = "legend-label";
var LegendSymbolRole = "legend-symbol";
var LegendTitleRole = "legend-title";
var TitleRole2 = "title";
var TitleTextRole = "title-text";
var TitleSubtitleRole = "title-subtitle";
function applyDefaults(encode2, type7, role, style6, config) {
  const defaults2 = {}, enter = {};
  let update3, key4, skip, props;
  key4 = "lineBreak";
  if (type7 === "text" && config[key4] != null && !has18(key4, encode2)) {
    applyDefault(defaults2, key4, config[key4]);
  }
  if (role == "legend" || String(role).startsWith("axis")) {
    role = null;
  }
  props = role === FrameRole2 ? config.group : role === MarkRole ? extend19({}, config.mark, config[type7]) : null;
  for (key4 in props) {
    skip = has18(key4, encode2) || (key4 === "fill" || key4 === "stroke") && (has18("fill", encode2) || has18("stroke", encode2));
    if (!skip)
      applyDefault(defaults2, key4, props[key4]);
  }
  array20(style6).forEach((name) => {
    const props2 = config.style && config.style[name];
    for (const key5 in props2) {
      if (!has18(key5, encode2)) {
        applyDefault(defaults2, key5, props2[key5]);
      }
    }
  });
  encode2 = extend19({}, encode2);
  for (key4 in defaults2) {
    props = defaults2[key4];
    if (props.signal) {
      (update3 = update3 || {})[key4] = props;
    } else {
      enter[key4] = props;
    }
  }
  encode2.enter = extend19(enter, encode2.enter);
  if (update3)
    encode2.update = extend19(update3, encode2.update);
  return encode2;
}
function applyDefault(defaults2, key4, value7) {
  defaults2[key4] = value7 && value7.signal ? {
    signal: value7.signal
  } : {
    value: value7
  };
}
var scaleRef = (scale19) => isString12(scale19) ? $9(scale19) : scale19.signal ? `(${scale19.signal})` : field21(scale19);
function entry$1(enc) {
  if (enc.gradient != null) {
    return gradient6(enc);
  }
  let value7 = enc.signal ? `(${enc.signal})` : enc.color ? color7(enc.color) : enc.field != null ? field21(enc.field) : enc.value !== void 0 ? $9(enc.value) : void 0;
  if (enc.scale != null) {
    value7 = scale18(enc, value7);
  }
  if (value7 === void 0) {
    value7 = null;
  }
  if (enc.exponent != null) {
    value7 = `pow(${value7},${property(enc.exponent)})`;
  }
  if (enc.mult != null) {
    value7 += `*${property(enc.mult)}`;
  }
  if (enc.offset != null) {
    value7 += `+${property(enc.offset)}`;
  }
  if (enc.round) {
    value7 = `round(${value7})`;
  }
  return value7;
}
var _color = (type7, x9, y9, z) => `(${type7}(${[x9, y9, z].map(entry$1).join(",")})+'')`;
function color7(enc) {
  return enc.c ? _color("hcl", enc.h, enc.c, enc.l) : enc.h || enc.s ? _color("hsl", enc.h, enc.s, enc.l) : enc.l || enc.a ? _color("lab", enc.l, enc.a, enc.b) : enc.r || enc.g || enc.b ? _color("rgb", enc.r, enc.g, enc.b) : null;
}
function gradient6(enc) {
  const args = [enc.start, enc.stop, enc.count].map((_) => _ == null ? null : $9(_));
  while (args.length && peek13(args) == null)
    args.pop();
  args.unshift(scaleRef(enc.gradient));
  return `gradient(${args.join(",")})`;
}
function property(property2) {
  return isObject11(property2) ? "(" + entry$1(property2) + ")" : property2;
}
function field21(ref2) {
  return resolveField(isObject11(ref2) ? ref2 : {
    datum: ref2
  });
}
function resolveField(ref2) {
  let object2, level, field25;
  if (ref2.signal) {
    object2 = "datum";
    field25 = ref2.signal;
  } else if (ref2.group || ref2.parent) {
    level = Math.max(1, ref2.level || 1);
    object2 = "item";
    while (level-- > 0) {
      object2 += ".mark.group";
    }
    if (ref2.parent) {
      field25 = ref2.parent;
      object2 += ".datum";
    } else {
      field25 = ref2.group;
    }
  } else if (ref2.datum) {
    object2 = "datum";
    field25 = ref2.datum;
  } else {
    error20("Invalid field reference: " + $9(ref2));
  }
  if (!ref2.signal) {
    field25 = isString12(field25) ? splitAccessPath20(field25).map($9).join("][") : resolveField(field25);
  }
  return object2 + "[" + field25 + "]";
}
function scale18(enc, value7) {
  const scale19 = scaleRef(enc.scale);
  if (enc.range != null) {
    value7 = `lerp(_range(${scale19}), ${+enc.range})`;
  } else {
    if (value7 !== void 0)
      value7 = `_scale(${scale19}, ${value7})`;
    if (enc.band) {
      value7 = (value7 ? value7 + "+" : "") + `_bandwidth(${scale19})` + (+enc.band === 1 ? "" : "*" + property(enc.band));
      if (enc.extra) {
        value7 = `(datum.extra ? _scale(${scale19}, datum.extra.value) : ${value7})`;
      }
    }
    if (value7 == null)
      value7 = "0";
  }
  return value7;
}
function rule6(enc) {
  let code = "";
  enc.forEach((rule8) => {
    const value7 = entry$1(rule8);
    code += rule8.test ? `(${rule8.test})?${value7}:` : value7;
  });
  if (peek13(code) === ":") {
    code += "null";
  }
  return code;
}
function parseEncode(encode2, type7, role, style6, scope, params2) {
  const enc = {};
  params2 = params2 || {};
  params2.encoders = {
    $encode: enc
  };
  encode2 = applyDefaults(encode2, type7, role, style6, scope.config);
  for (const key4 in encode2) {
    enc[key4] = parseBlock(encode2[key4], type7, params2, scope);
  }
  return params2;
}
function parseBlock(block, marktype, params2, scope) {
  const channels = {}, fields = {};
  for (const name in block) {
    if (block[name] != null) {
      channels[name] = parse$1(expr(block[name]), scope, params2, fields);
    }
  }
  return {
    $expr: {
      marktype,
      channels
    },
    $fields: Object.keys(fields),
    $output: Object.keys(block)
  };
}
function expr(enc) {
  return isArray20(enc) ? rule6(enc) : entry$1(enc);
}
function parse$1(code, scope, params2, fields) {
  const expr2 = parser2(code, scope);
  expr2.$fields.forEach((name) => fields[name] = 1);
  extend19(params2, expr2.$params);
  return expr2.$expr;
}
var OUTER = "outer";
var OUTER_INVALID = ["value", "update", "init", "react", "bind"];
function outerError(prefix, name) {
  error20(prefix + ' for "outer" push: ' + $9(name));
}
function parseSignal(signal, scope) {
  const name = signal.name;
  if (signal.push === OUTER) {
    if (!scope.signals[name])
      outerError("No prior signal definition", name);
    OUTER_INVALID.forEach((prop) => {
      if (signal[prop] !== void 0)
        outerError("Invalid property ", prop);
    });
  } else {
    const op = scope.addSignal(name, signal.value);
    if (signal.react === false)
      op.react = false;
    if (signal.bind)
      scope.addBinding(name, signal.bind);
  }
}
function Entry(type7, value7, params2, parent) {
  this.id = -1;
  this.type = type7;
  this.value = value7;
  this.params = params2;
  if (parent)
    this.parent = parent;
}
function entry(type7, value7, params2, parent) {
  return new Entry(type7, value7, params2, parent);
}
function operator(value7, params2) {
  return entry("operator", value7, params2);
}
function ref(op) {
  const ref2 = {
    $ref: op.id
  };
  if (op.id < 0)
    (op.refs = op.refs || []).push(ref2);
  return ref2;
}
function fieldRef$1(field25, name) {
  return name ? {
    $field: field25,
    $name: name
  } : {
    $field: field25
  };
}
var keyFieldRef = fieldRef$1("key");
function compareRef(fields, orders) {
  return {
    $compare: fields,
    $order: orders
  };
}
function keyRef(fields, flat) {
  const ref2 = {
    $key: fields
  };
  if (flat)
    ref2.$flat = true;
  return ref2;
}
var Ascending = "ascending";
var Descending = "descending";
function sortKey(sort4) {
  return !isObject11(sort4) ? "" : (sort4.order === Descending ? "-" : "+") + aggrField(sort4.op, sort4.field);
}
function aggrField(op, field25) {
  return (op && op.signal ? "$" + op.signal : op || "") + (op && field25 ? "_" : "") + (field25 && field25.signal ? "$" + field25.signal : field25 || "");
}
var Scope$1 = "scope";
var View2 = "view";
function isSignal(_) {
  return _ && _.signal;
}
function isExpr$1(_) {
  return _ && _.expr;
}
function hasSignal(_) {
  if (isSignal(_))
    return true;
  if (isObject11(_))
    for (const key4 in _) {
      if (hasSignal(_[key4]))
        return true;
    }
  return false;
}
function value6(specValue, defaultValue) {
  return specValue != null ? specValue : defaultValue;
}
function deref(v2) {
  return v2 && v2.signal || v2;
}
var Timer2 = "timer";
function parseStream3(stream2, scope) {
  const method10 = stream2.merge ? mergeStream : stream2.stream ? nestedStream : stream2.type ? eventStream : error20("Invalid stream specification: " + $9(stream2));
  return method10(stream2, scope);
}
function eventSource(source3) {
  return source3 === Scope$1 ? View2 : source3 || View2;
}
function mergeStream(stream2, scope) {
  const list = stream2.merge.map((s2) => parseStream3(s2, scope)), entry2 = streamParameters({
    merge: list
  }, stream2, scope);
  return scope.addStream(entry2).id;
}
function nestedStream(stream2, scope) {
  const id24 = parseStream3(stream2.stream, scope), entry2 = streamParameters({
    stream: id24
  }, stream2, scope);
  return scope.addStream(entry2).id;
}
function eventStream(stream2, scope) {
  let id24;
  if (stream2.type === Timer2) {
    id24 = scope.event(Timer2, stream2.throttle);
    stream2 = {
      between: stream2.between,
      filter: stream2.filter
    };
  } else {
    id24 = scope.event(eventSource(stream2.source), stream2.type);
  }
  const entry2 = streamParameters({
    stream: id24
  }, stream2, scope);
  return Object.keys(entry2).length === 1 ? id24 : scope.addStream(entry2).id;
}
function streamParameters(entry2, stream2, scope) {
  let param2 = stream2.between;
  if (param2) {
    if (param2.length !== 2) {
      error20('Stream "between" parameter must have 2 entries: ' + $9(stream2));
    }
    entry2.between = [parseStream3(param2[0], scope), parseStream3(param2[1], scope)];
  }
  param2 = stream2.filter ? [].concat(stream2.filter) : [];
  if (stream2.marktype || stream2.markname || stream2.markrole) {
    param2.push(filterMark(stream2.marktype, stream2.markname, stream2.markrole));
  }
  if (stream2.source === Scope$1) {
    param2.push("inScope(event.item)");
  }
  if (param2.length) {
    entry2.filter = parser2("(" + param2.join(")&&(") + ")", scope).$expr;
  }
  if ((param2 = stream2.throttle) != null) {
    entry2.throttle = +param2;
  }
  if ((param2 = stream2.debounce) != null) {
    entry2.debounce = +param2;
  }
  if (stream2.consume) {
    entry2.consume = true;
  }
  return entry2;
}
function filterMark(type7, name, role) {
  const item = "event.item";
  return item + (type7 && type7 !== "*" ? "&&" + item + ".mark.marktype==='" + type7 + "'" : "") + (role ? "&&" + item + ".mark.role==='" + role + "'" : "") + (name ? "&&" + item + ".mark.name==='" + name + "'" : "");
}
var OP_VALUE_EXPR = {
  code: "_.$value",
  ast: {
    type: "Identifier",
    value: "value"
  }
};
function parseUpdate2(spec, scope, target2) {
  const encode2 = spec.encode, entry2 = {
    target: target2
  };
  let events3 = spec.events, update3 = spec.update, sources = [];
  if (!events3) {
    error20("Signal update missing events specification.");
  }
  if (isString12(events3)) {
    events3 = eventSelector(events3, scope.isSubscope() ? Scope$1 : View2);
  }
  events3 = array20(events3).filter((s2) => s2.signal || s2.scale ? (sources.push(s2), 0) : 1);
  if (sources.length > 1) {
    sources = [mergeSources(sources)];
  }
  if (events3.length) {
    sources.push(events3.length > 1 ? {
      merge: events3
    } : events3[0]);
  }
  if (encode2 != null) {
    if (update3)
      error20("Signal encode and update are mutually exclusive.");
    update3 = "encode(item()," + $9(encode2) + ")";
  }
  entry2.update = isString12(update3) ? parser2(update3, scope) : update3.expr != null ? parser2(update3.expr, scope) : update3.value != null ? update3.value : update3.signal != null ? {
    $expr: OP_VALUE_EXPR,
    $params: {
      $value: scope.signalRef(update3.signal)
    }
  } : error20("Invalid signal update specification.");
  if (spec.force) {
    entry2.options = {
      force: true
    };
  }
  sources.forEach((source3) => scope.addUpdate(extend19(streamSource(source3, scope), entry2)));
}
function streamSource(stream2, scope) {
  return {
    source: stream2.signal ? scope.signalRef(stream2.signal) : stream2.scale ? scope.scaleRef(stream2.scale) : parseStream3(stream2, scope)
  };
}
function mergeSources(sources) {
  return {
    signal: "[" + sources.map((s2) => s2.scale ? 'scale("' + s2.scale + '")' : s2.signal) + "]"
  };
}
function parseSignalUpdates(signal, scope) {
  const op = scope.getSignal(signal.name);
  let expr2 = signal.update;
  if (signal.init) {
    if (expr2) {
      error20("Signals can not include both init and update expressions.");
    } else {
      expr2 = signal.init;
      op.initonly = true;
    }
  }
  if (expr2) {
    expr2 = parser2(expr2, scope);
    op.update = expr2.$expr;
    op.params = expr2.$params;
  }
  if (signal.on) {
    signal.on.forEach((_) => parseUpdate2(_, scope, op.id));
  }
}
var transform3 = (name) => (params2, value7, parent) => entry(name, value7, params2 || void 0, parent);
var Aggregate2 = transform3("aggregate");
var AxisTicks2 = transform3("axisticks");
var Bound2 = transform3("bound");
var Collect2 = transform3("collect");
var Compare2 = transform3("compare");
var DataJoin2 = transform3("datajoin");
var Encode2 = transform3("encode");
var Expression2 = transform3("expression");
var Facet2 = transform3("facet");
var Field2 = transform3("field");
var Key2 = transform3("key");
var LegendEntries2 = transform3("legendentries");
var Load2 = transform3("load");
var Mark2 = transform3("mark");
var MultiExtent2 = transform3("multiextent");
var MultiValues2 = transform3("multivalues");
var Overlap2 = transform3("overlap");
var Params3 = transform3("params");
var PreFacet2 = transform3("prefacet");
var Projection2 = transform3("projection");
var Proxy2 = transform3("proxy");
var Relay2 = transform3("relay");
var Render2 = transform3("render");
var Scale2 = transform3("scale");
var Sieve2 = transform3("sieve");
var SortItems2 = transform3("sortitems");
var ViewLayout2 = transform3("viewlayout");
var Values2 = transform3("values");
var FIELD_REF_ID = 0;
var MULTIDOMAIN_SORT_OPS = {
  min: "min",
  max: "max",
  count: "sum"
};
function initScale(spec, scope) {
  const type7 = spec.type || "linear";
  if (!isValidScaleType9(type7)) {
    error20("Unrecognized scale type: " + $9(type7));
  }
  scope.addScale(spec.name, {
    type: type7,
    domain: void 0
  });
}
function parseScale(spec, scope) {
  const params2 = scope.getScale(spec.name).params;
  let key4;
  params2.domain = parseScaleDomain(spec.domain, spec, scope);
  if (spec.range != null) {
    params2.range = parseScaleRange(spec, scope, params2);
  }
  if (spec.interpolate != null) {
    parseScaleInterpolate(spec.interpolate, params2);
  }
  if (spec.nice != null) {
    params2.nice = parseScaleNice(spec.nice, scope);
  }
  if (spec.bins != null) {
    params2.bins = parseScaleBins(spec.bins, scope);
  }
  for (key4 in spec) {
    if (has17(params2, key4) || key4 === "name")
      continue;
    params2[key4] = parseLiteral(spec[key4], scope);
  }
}
function parseLiteral(v2, scope) {
  return !isObject11(v2) ? v2 : v2.signal ? scope.signalRef(v2.signal) : error20("Unsupported object: " + $9(v2));
}
function parseArray(v2, scope) {
  return v2.signal ? scope.signalRef(v2.signal) : v2.map((v3) => parseLiteral(v3, scope));
}
function dataLookupError(name) {
  error20("Can not find data set: " + $9(name));
}
function parseScaleDomain(domain3, spec, scope) {
  if (!domain3) {
    if (spec.domainMin != null || spec.domainMax != null) {
      error20("No scale domain defined for domainMin/domainMax to override.");
    }
    return;
  }
  return domain3.signal ? scope.signalRef(domain3.signal) : (isArray20(domain3) ? explicitDomain : domain3.fields ? multipleDomain : singularDomain)(domain3, spec, scope);
}
function explicitDomain(domain3, spec, scope) {
  return domain3.map((v2) => parseLiteral(v2, scope));
}
function singularDomain(domain3, spec, scope) {
  const data3 = scope.getData(domain3.data);
  if (!data3)
    dataLookupError(domain3.data);
  return isDiscrete6(spec.type) ? data3.valuesRef(scope, domain3.field, parseSort(domain3.sort, false)) : isQuantile(spec.type) ? data3.domainRef(scope, domain3.field) : data3.extentRef(scope, domain3.field);
}
function multipleDomain(domain3, spec, scope) {
  const data3 = domain3.data, fields = domain3.fields.reduce((dom, d) => {
    d = isString12(d) ? {
      data: data3,
      field: d
    } : isArray20(d) || d.signal ? fieldRef(d, scope) : d;
    dom.push(d);
    return dom;
  }, []);
  return (isDiscrete6(spec.type) ? ordinalMultipleDomain : isQuantile(spec.type) ? quantileMultipleDomain : numericMultipleDomain)(domain3, scope, fields);
}
function fieldRef(data3, scope) {
  const name = "_:vega:_" + FIELD_REF_ID++, coll = Collect2({});
  if (isArray20(data3)) {
    coll.value = {
      $ingest: data3
    };
  } else if (data3.signal) {
    const code = "setdata(" + $9(name) + "," + data3.signal + ")";
    coll.params.input = scope.signalRef(code);
  }
  scope.addDataPipeline(name, [coll, Sieve2({})]);
  return {
    data: name,
    field: "data"
  };
}
function ordinalMultipleDomain(domain3, scope, fields) {
  const sort4 = parseSort(domain3.sort, true);
  let a4, v2;
  const counts = fields.map((f) => {
    const data3 = scope.getData(f.data);
    if (!data3)
      dataLookupError(f.data);
    return data3.countsRef(scope, f.field, sort4);
  });
  const p = {
    groupby: keyFieldRef,
    pulse: counts
  };
  if (sort4) {
    a4 = sort4.op || "count";
    v2 = sort4.field ? aggrField(a4, sort4.field) : "count";
    p.ops = [MULTIDOMAIN_SORT_OPS[a4]];
    p.fields = [scope.fieldRef(v2)];
    p.as = [v2];
  }
  a4 = scope.add(Aggregate2(p));
  const c5 = scope.add(Collect2({
    pulse: ref(a4)
  }));
  v2 = scope.add(Values2({
    field: keyFieldRef,
    sort: scope.sortRef(sort4),
    pulse: ref(c5)
  }));
  return ref(v2);
}
function parseSort(sort4, multidomain) {
  if (sort4) {
    if (!sort4.field && !sort4.op) {
      if (isObject11(sort4))
        sort4.field = "key";
      else
        sort4 = {
          field: "key"
        };
    } else if (!sort4.field && sort4.op !== "count") {
      error20("No field provided for sort aggregate op: " + sort4.op);
    } else if (multidomain && sort4.field) {
      if (sort4.op && !MULTIDOMAIN_SORT_OPS[sort4.op]) {
        error20("Multiple domain scales can not be sorted using " + sort4.op);
      }
    }
  }
  return sort4;
}
function quantileMultipleDomain(domain3, scope, fields) {
  const values7 = fields.map((f) => {
    const data3 = scope.getData(f.data);
    if (!data3)
      dataLookupError(f.data);
    return data3.domainRef(scope, f.field);
  });
  return ref(scope.add(MultiValues2({
    values: values7
  })));
}
function numericMultipleDomain(domain3, scope, fields) {
  const extents = fields.map((f) => {
    const data3 = scope.getData(f.data);
    if (!data3)
      dataLookupError(f.data);
    return data3.extentRef(scope, f.field);
  });
  return ref(scope.add(MultiExtent2({
    extents
  })));
}
function parseScaleBins(v2, scope) {
  return v2.signal || isArray20(v2) ? parseArray(v2, scope) : scope.objectProperty(v2);
}
function parseScaleNice(nice4, scope) {
  return nice4.signal ? scope.signalRef(nice4.signal) : isObject11(nice4) ? {
    interval: parseLiteral(nice4.interval),
    step: parseLiteral(nice4.step)
  } : parseLiteral(nice4);
}
function parseScaleInterpolate(interpolate11, params2) {
  params2.interpolate = parseLiteral(interpolate11.type || interpolate11);
  if (interpolate11.gamma != null) {
    params2.interpolateGamma = parseLiteral(interpolate11.gamma);
  }
}
function parseScaleRange(spec, scope, params2) {
  const config = scope.config.range;
  let range7 = spec.range;
  if (range7.signal) {
    return scope.signalRef(range7.signal);
  } else if (isString12(range7)) {
    if (config && has17(config, range7)) {
      spec = extend19({}, spec, {
        range: config[range7]
      });
      return parseScaleRange(spec, scope, params2);
    } else if (range7 === "width") {
      range7 = [0, {
        signal: "width"
      }];
    } else if (range7 === "height") {
      range7 = isDiscrete6(spec.type) ? [0, {
        signal: "height"
      }] : [{
        signal: "height"
      }, 0];
    } else {
      error20("Unrecognized scale range value: " + $9(range7));
    }
  } else if (range7.scheme) {
    params2.scheme = isArray20(range7.scheme) ? parseArray(range7.scheme, scope) : parseLiteral(range7.scheme, scope);
    if (range7.extent)
      params2.schemeExtent = parseArray(range7.extent, scope);
    if (range7.count)
      params2.schemeCount = parseLiteral(range7.count, scope);
    return;
  } else if (range7.step) {
    params2.rangeStep = parseLiteral(range7.step, scope);
    return;
  } else if (isDiscrete6(spec.type) && !isArray20(range7)) {
    return parseScaleDomain(range7, spec, scope);
  } else if (!isArray20(range7)) {
    error20("Unsupported range type: " + $9(range7));
  }
  return range7.map((v2) => (isArray20(v2) ? parseArray : parseLiteral)(v2, scope));
}
function parseProjection(proj, scope) {
  const config = scope.config.projection || {}, params2 = {};
  for (const name in proj) {
    if (name === "name")
      continue;
    params2[name] = parseParameter$1(proj[name], name, scope);
  }
  for (const name in config) {
    if (params2[name] == null) {
      params2[name] = parseParameter$1(config[name], name, scope);
    }
  }
  scope.addProjection(proj.name, params2);
}
function parseParameter$1(_, name, scope) {
  return isArray20(_) ? _.map((_2) => parseParameter$1(_2, name, scope)) : !isObject11(_) ? _ : _.signal ? scope.signalRef(_.signal) : name === "fit" ? _ : error20("Unsupported parameter object: " + $9(_));
}
var Top2 = "top";
var Left2 = "left";
var Right2 = "right";
var Bottom2 = "bottom";
var Center2 = "center";
var Vertical = "vertical";
var Start2 = "start";
var Middle2 = "middle";
var End2 = "end";
var Index = "index";
var Label2 = "label";
var Offset = "offset";
var Perc = "perc";
var Perc2 = "perc2";
var Value = "value";
var GuideLabelStyle = "guide-label";
var GuideTitleStyle = "guide-title";
var GroupTitleStyle = "group-title";
var GroupSubtitleStyle = "group-subtitle";
var Symbols2 = "symbol";
var Gradient3 = "gradient";
var Discrete10 = "discrete";
var Size = "size";
var Shape = "shape";
var Fill = "fill";
var Stroke = "stroke";
var StrokeWidth = "strokeWidth";
var StrokeDash = "strokeDash";
var Opacity = "opacity";
var LegendScales = [Size, Shape, Fill, Stroke, StrokeWidth, StrokeDash, Opacity];
var Skip3 = {
  name: 1,
  style: 1,
  interactive: 1
};
var zero23 = {
  value: 0
};
var one22 = {
  value: 1
};
var GroupMark = "group";
var RectMark = "rect";
var RuleMark = "rule";
var SymbolMark = "symbol";
var TextMark = "text";
function guideGroup(mark) {
  mark.type = GroupMark;
  mark.interactive = mark.interactive || false;
  return mark;
}
function lookup9(spec, config) {
  const _ = (name, dflt) => value6(spec[name], value6(config[name], dflt));
  _.isVertical = (s2) => Vertical === value6(spec.direction, config.direction || (s2 ? config.symbolDirection : config.gradientDirection));
  _.gradientLength = () => value6(spec.gradientLength, config.gradientLength || config.gradientWidth);
  _.gradientThickness = () => value6(spec.gradientThickness, config.gradientThickness || config.gradientHeight);
  _.entryColumns = () => value6(spec.columns, value6(config.columns, +_.isVertical(true)));
  return _;
}
function getEncoding(name, encode2) {
  const v2 = encode2 && (encode2.update && encode2.update[name] || encode2.enter && encode2.enter[name]);
  return v2 && v2.signal ? v2 : v2 ? v2.value : null;
}
function getStyle(name, scope, style6) {
  const s2 = scope.config.style[style6];
  return s2 && s2[name];
}
function anchorExpr(s2, e3, m3) {
  return `item.anchor === '${Start2}' ? ${s2} : item.anchor === '${End2}' ? ${e3} : ${m3}`;
}
var alignExpr$1 = anchorExpr($9(Left2), $9(Right2), $9(Center2));
function tickBand(_) {
  const v2 = _("tickBand");
  let offset9 = _("tickOffset"), band11, extra;
  if (!v2) {
    band11 = _("bandPosition");
    extra = _("tickExtra");
  } else if (v2.signal) {
    band11 = {
      signal: `(${v2.signal}) === 'extent' ? 1 : 0.5`
    };
    extra = {
      signal: `(${v2.signal}) === 'extent'`
    };
    if (!isObject11(offset9)) {
      offset9 = {
        signal: `(${v2.signal}) === 'extent' ? 0 : ${offset9}`
      };
    }
  } else if (v2 === "extent") {
    band11 = 1;
    extra = true;
    offset9 = 0;
  } else {
    band11 = 0.5;
    extra = false;
  }
  return {
    extra,
    band: band11,
    offset: offset9
  };
}
function extendOffset(value7, offset9) {
  return !offset9 ? value7 : !value7 ? offset9 : !isObject11(value7) ? {
    value: value7,
    offset: offset9
  } : Object.assign({}, value7, {
    offset: extendOffset(value7.offset, offset9)
  });
}
function guideMark(mark, extras) {
  if (extras) {
    mark.name = extras.name;
    mark.style = extras.style || mark.style;
    mark.interactive = !!extras.interactive;
    mark.encode = extendEncode(mark.encode, extras, Skip3);
  } else {
    mark.interactive = false;
  }
  return mark;
}
function legendGradient(spec, scale19, config, userEncode) {
  const _ = lookup9(spec, config), vertical = _.isVertical(), thickness = _.gradientThickness(), length2 = _.gradientLength();
  let enter, start, stop2, width2, height2;
  if (vertical) {
    start = [0, 1];
    stop2 = [0, 0];
    width2 = thickness;
    height2 = length2;
  } else {
    start = [0, 0];
    stop2 = [1, 0];
    width2 = length2;
    height2 = thickness;
  }
  const encode2 = {
    enter: enter = {
      opacity: zero23,
      x: zero23,
      y: zero23,
      width: encoder(width2),
      height: encoder(height2)
    },
    update: extend19({}, enter, {
      opacity: one22,
      fill: {
        gradient: scale19,
        start,
        stop: stop2
      }
    }),
    exit: {
      opacity: zero23
    }
  };
  addEncoders(encode2, {
    stroke: _("gradientStrokeColor"),
    strokeWidth: _("gradientStrokeWidth")
  }, {
    // update
    opacity: _("gradientOpacity")
  });
  return guideMark({
    type: RectMark,
    role: LegendGradientRole,
    encode: encode2
  }, userEncode);
}
function legendGradientDiscrete(spec, scale19, config, userEncode, dataRef) {
  const _ = lookup9(spec, config), vertical = _.isVertical(), thickness = _.gradientThickness(), length2 = _.gradientLength();
  let u4, v2, uu, vv, adjust = "";
  vertical ? (u4 = "y", uu = "y2", v2 = "x", vv = "width", adjust = "1-") : (u4 = "x", uu = "x2", v2 = "y", vv = "height");
  const enter = {
    opacity: zero23,
    fill: {
      scale: scale19,
      field: Value
    }
  };
  enter[u4] = {
    signal: adjust + "datum." + Perc,
    mult: length2
  };
  enter[v2] = zero23;
  enter[uu] = {
    signal: adjust + "datum." + Perc2,
    mult: length2
  };
  enter[vv] = encoder(thickness);
  const encode2 = {
    enter,
    update: extend19({}, enter, {
      opacity: one22
    }),
    exit: {
      opacity: zero23
    }
  };
  addEncoders(encode2, {
    stroke: _("gradientStrokeColor"),
    strokeWidth: _("gradientStrokeWidth")
  }, {
    // update
    opacity: _("gradientOpacity")
  });
  return guideMark({
    type: RectMark,
    role: LegendBandRole,
    key: Value,
    from: dataRef,
    encode: encode2
  }, userEncode);
}
var alignExpr = `datum.${Perc}<=0?"${Left2}":datum.${Perc}>=1?"${Right2}":"${Center2}"`;
var baselineExpr = `datum.${Perc}<=0?"${Bottom2}":datum.${Perc}>=1?"${Top2}":"${Middle2}"`;
function legendGradientLabels(spec, config, userEncode, dataRef) {
  const _ = lookup9(spec, config), vertical = _.isVertical(), thickness = encoder(_.gradientThickness()), length2 = _.gradientLength();
  let overlap = _("labelOverlap"), enter, update3, u4, v2, adjust = "";
  const encode2 = {
    enter: enter = {
      opacity: zero23
    },
    update: update3 = {
      opacity: one22,
      text: {
        field: Label2
      }
    },
    exit: {
      opacity: zero23
    }
  };
  addEncoders(encode2, {
    fill: _("labelColor"),
    fillOpacity: _("labelOpacity"),
    font: _("labelFont"),
    fontSize: _("labelFontSize"),
    fontStyle: _("labelFontStyle"),
    fontWeight: _("labelFontWeight"),
    limit: value6(spec.labelLimit, config.gradientLabelLimit)
  });
  if (vertical) {
    enter.align = {
      value: "left"
    };
    enter.baseline = update3.baseline = {
      signal: baselineExpr
    };
    u4 = "y";
    v2 = "x";
    adjust = "1-";
  } else {
    enter.align = update3.align = {
      signal: alignExpr
    };
    enter.baseline = {
      value: "top"
    };
    u4 = "x";
    v2 = "y";
  }
  enter[u4] = update3[u4] = {
    signal: adjust + "datum." + Perc,
    mult: length2
  };
  enter[v2] = update3[v2] = thickness;
  thickness.offset = value6(spec.labelOffset, config.gradientLabelOffset) || 0;
  overlap = overlap ? {
    separation: _("labelSeparation"),
    method: overlap,
    order: "datum." + Index
  } : void 0;
  return guideMark({
    type: TextMark,
    role: LegendLabelRole,
    style: GuideLabelStyle,
    key: Value,
    from: dataRef,
    encode: encode2,
    overlap
  }, userEncode);
}
function legendSymbolGroups(spec, config, userEncode, dataRef, columns) {
  const _ = lookup9(spec, config), entries2 = userEncode.entries, interactive2 = !!(entries2 && entries2.interactive), name = entries2 ? entries2.name : void 0, height2 = _("clipHeight"), symbolOffset = _("symbolOffset"), valueRef = {
    data: "value"
  }, xSignal = `(${columns}) ? datum.${Offset} : datum.${Size}`, yEncode = height2 ? encoder(height2) : {
    field: Size
  }, index4 = `datum.${Index}`, ncols = `max(1, ${columns})`;
  let encode2, enter, update3, nrows, sort4;
  yEncode.mult = 0.5;
  encode2 = {
    enter: enter = {
      opacity: zero23,
      x: {
        signal: xSignal,
        mult: 0.5,
        offset: symbolOffset
      },
      y: yEncode
    },
    update: update3 = {
      opacity: one22,
      x: enter.x,
      y: enter.y
    },
    exit: {
      opacity: zero23
    }
  };
  let baseFill = null, baseStroke = null;
  if (!spec.fill) {
    baseFill = config.symbolBaseFillColor;
    baseStroke = config.symbolBaseStrokeColor;
  }
  addEncoders(encode2, {
    fill: _("symbolFillColor", baseFill),
    shape: _("symbolType"),
    size: _("symbolSize"),
    stroke: _("symbolStrokeColor", baseStroke),
    strokeDash: _("symbolDash"),
    strokeDashOffset: _("symbolDashOffset"),
    strokeWidth: _("symbolStrokeWidth")
  }, {
    // update
    opacity: _("symbolOpacity")
  });
  LegendScales.forEach((scale19) => {
    if (spec[scale19]) {
      update3[scale19] = enter[scale19] = {
        scale: spec[scale19],
        field: Value
      };
    }
  });
  const symbols16 = guideMark({
    type: SymbolMark,
    role: LegendSymbolRole,
    key: Value,
    from: valueRef,
    clip: height2 ? true : void 0,
    encode: encode2
  }, userEncode.symbols);
  const labelOffset = encoder(symbolOffset);
  labelOffset.offset = _("labelOffset");
  encode2 = {
    enter: enter = {
      opacity: zero23,
      x: {
        signal: xSignal,
        offset: labelOffset
      },
      y: yEncode
    },
    update: update3 = {
      opacity: one22,
      text: {
        field: Label2
      },
      x: enter.x,
      y: enter.y
    },
    exit: {
      opacity: zero23
    }
  };
  addEncoders(encode2, {
    align: _("labelAlign"),
    baseline: _("labelBaseline"),
    fill: _("labelColor"),
    fillOpacity: _("labelOpacity"),
    font: _("labelFont"),
    fontSize: _("labelFontSize"),
    fontStyle: _("labelFontStyle"),
    fontWeight: _("labelFontWeight"),
    limit: _("labelLimit")
  });
  const labels2 = guideMark({
    type: TextMark,
    role: LegendLabelRole,
    style: GuideLabelStyle,
    key: Value,
    from: valueRef,
    encode: encode2
  }, userEncode.labels);
  encode2 = {
    enter: {
      noBound: {
        value: !height2
      },
      // ignore width/height in bounds calc
      width: zero23,
      height: height2 ? encoder(height2) : zero23,
      opacity: zero23
    },
    exit: {
      opacity: zero23
    },
    update: update3 = {
      opacity: one22,
      row: {
        signal: null
      },
      column: {
        signal: null
      }
    }
  };
  if (_.isVertical(true)) {
    nrows = `ceil(item.mark.items.length / ${ncols})`;
    update3.row.signal = `${index4}%${nrows}`;
    update3.column.signal = `floor(${index4} / ${nrows})`;
    sort4 = {
      field: ["row", index4]
    };
  } else {
    update3.row.signal = `floor(${index4} / ${ncols})`;
    update3.column.signal = `${index4} % ${ncols}`;
    sort4 = {
      field: index4
    };
  }
  update3.column.signal = `(${columns})?${update3.column.signal}:${index4}`;
  dataRef = {
    facet: {
      data: dataRef,
      name: "value",
      groupby: Index
    }
  };
  return guideGroup({
    role: ScopeRole2,
    from: dataRef,
    encode: extendEncode(encode2, entries2, Skip3),
    marks: [symbols16, labels2],
    name,
    interactive: interactive2,
    sort: sort4
  });
}
function legendSymbolLayout(spec, config) {
  const _ = lookup9(spec, config);
  return {
    align: _("gridAlign"),
    columns: _.entryColumns(),
    center: {
      row: true,
      column: false
    },
    padding: {
      row: _("rowPadding"),
      column: _("columnPadding")
    }
  };
}
var isL = 'item.orient === "left"';
var isR = 'item.orient === "right"';
var isLR = `(${isL} || ${isR})`;
var isVG = `datum.vgrad && ${isLR}`;
var baseline = anchorExpr('"top"', '"bottom"', '"middle"');
var alignFlip = anchorExpr('"right"', '"left"', '"center"');
var exprAlign = `datum.vgrad && ${isR} ? (${alignFlip}) : (${isLR} && !(datum.vgrad && ${isL})) ? "left" : ${alignExpr$1}`;
var exprAnchor = `item._anchor || (${isLR} ? "middle" : "start")`;
var exprAngle = `${isVG} ? (${isL} ? -90 : 90) : 0`;
var exprBaseline = `${isLR} ? (datum.vgrad ? (${isR} ? "bottom" : "top") : ${baseline}) : "top"`;
function legendTitle(spec, config, userEncode, dataRef) {
  const _ = lookup9(spec, config);
  const encode2 = {
    enter: {
      opacity: zero23
    },
    update: {
      opacity: one22,
      x: {
        field: {
          group: "padding"
        }
      },
      y: {
        field: {
          group: "padding"
        }
      }
    },
    exit: {
      opacity: zero23
    }
  };
  addEncoders(encode2, {
    orient: _("titleOrient"),
    _anchor: _("titleAnchor"),
    anchor: {
      signal: exprAnchor
    },
    angle: {
      signal: exprAngle
    },
    align: {
      signal: exprAlign
    },
    baseline: {
      signal: exprBaseline
    },
    text: spec.title,
    fill: _("titleColor"),
    fillOpacity: _("titleOpacity"),
    font: _("titleFont"),
    fontSize: _("titleFontSize"),
    fontStyle: _("titleFontStyle"),
    fontWeight: _("titleFontWeight"),
    limit: _("titleLimit"),
    lineHeight: _("titleLineHeight")
  }, {
    // require update
    align: _("titleAlign"),
    baseline: _("titleBaseline")
  });
  return guideMark({
    type: TextMark,
    role: LegendTitleRole,
    style: GuideTitleStyle,
    from: dataRef,
    encode: encode2
  }, userEncode);
}
function clip6(clip7, scope) {
  let expr2;
  if (isObject11(clip7)) {
    if (clip7.signal) {
      expr2 = clip7.signal;
    } else if (clip7.path) {
      expr2 = "pathShape(" + param(clip7.path) + ")";
    } else if (clip7.sphere) {
      expr2 = "geoShape(" + param(clip7.sphere) + ', {type: "Sphere"})';
    }
  }
  return expr2 ? scope.signalRef(expr2) : !!clip7;
}
function param(value7) {
  return isObject11(value7) && value7.signal ? value7.signal : $9(value7);
}
function getRole(spec) {
  const role = spec.role || "";
  return role.startsWith("axis") || role.startsWith("legend") || role.startsWith("title") ? role : spec.type === GroupMark ? ScopeRole2 : role || MarkRole;
}
function definition2(spec) {
  return {
    marktype: spec.type,
    name: spec.name || void 0,
    role: spec.role || getRole(spec),
    zindex: +spec.zindex || void 0,
    aria: spec.aria,
    description: spec.description
  };
}
function interactive(spec, scope) {
  return spec && spec.signal ? scope.signalRef(spec.signal) : spec === false ? false : true;
}
function parseTransform(spec, scope) {
  const def6 = definition(spec.type);
  if (!def6)
    error20("Unrecognized transform type: " + $9(spec.type));
  const t = entry(def6.type.toLowerCase(), null, parseParameters2(def6, spec, scope));
  if (spec.signal)
    scope.addSignal(spec.signal, scope.proxy(t));
  t.metadata = def6.metadata || {};
  return t;
}
function parseParameters2(def6, spec, scope) {
  const params2 = {}, n = def6.params.length;
  for (let i = 0; i < n; ++i) {
    const pdef = def6.params[i];
    params2[pdef.name] = parseParameter2(pdef, spec, scope);
  }
  return params2;
}
function parseParameter2(def6, spec, scope) {
  const type7 = def6.type, value7 = spec[def6.name];
  if (type7 === "index") {
    return parseIndexParameter(def6, spec, scope);
  } else if (value7 === void 0) {
    if (def6.required) {
      error20("Missing required " + $9(spec.type) + " parameter: " + $9(def6.name));
    }
    return;
  } else if (type7 === "param") {
    return parseSubParameters(def6, spec, scope);
  } else if (type7 === "projection") {
    return scope.projectionRef(spec[def6.name]);
  }
  return def6.array && !isSignal(value7) ? value7.map((v2) => parameterValue(def6, v2, scope)) : parameterValue(def6, value7, scope);
}
function parameterValue(def6, value7, scope) {
  const type7 = def6.type;
  if (isSignal(value7)) {
    return isExpr(type7) ? error20("Expression references can not be signals.") : isField(type7) ? scope.fieldRef(value7) : isCompare(type7) ? scope.compareRef(value7) : scope.signalRef(value7.signal);
  } else {
    const expr2 = def6.expr || isField(type7);
    return expr2 && outerExpr(value7) ? scope.exprRef(value7.expr, value7.as) : expr2 && outerField(value7) ? fieldRef$1(value7.field, value7.as) : isExpr(type7) ? parser2(value7, scope) : isData(type7) ? ref(scope.getData(value7).values) : isField(type7) ? fieldRef$1(value7) : isCompare(type7) ? scope.compareRef(value7) : value7;
  }
}
function parseIndexParameter(def6, spec, scope) {
  if (!isString12(spec.from)) {
    error20('Lookup "from" parameter must be a string literal.');
  }
  return scope.getData(spec.from).lookupRef(scope, spec.key);
}
function parseSubParameters(def6, spec, scope) {
  const value7 = spec[def6.name];
  if (def6.array) {
    if (!isArray20(value7)) {
      error20("Expected an array of sub-parameters. Instead: " + $9(value7));
    }
    return value7.map((v2) => parseSubParameter(def6, v2, scope));
  } else {
    return parseSubParameter(def6, value7, scope);
  }
}
function parseSubParameter(def6, value7, scope) {
  const n = def6.params.length;
  let pdef;
  for (let i = 0; i < n; ++i) {
    pdef = def6.params[i];
    for (const k3 in pdef.key) {
      if (pdef.key[k3] !== value7[k3]) {
        pdef = null;
        break;
      }
    }
    if (pdef)
      break;
  }
  if (!pdef)
    error20("Unsupported parameter: " + $9(value7));
  const params2 = extend19(parseParameters2(pdef, value7, scope), pdef.key);
  return ref(scope.add(Params3(params2)));
}
var outerExpr = (_) => _ && _.expr;
var outerField = (_) => _ && _.field;
var isData = (_) => _ === "data";
var isExpr = (_) => _ === "expr";
var isField = (_) => _ === "field";
var isCompare = (_) => _ === "compare";
function parseData$1(from, group7, scope) {
  let facet, key4, op, dataRef, parent;
  if (!from) {
    dataRef = ref(scope.add(Collect2(null, [{}])));
  } else if (facet = from.facet) {
    if (!group7)
      error20("Only group marks can be faceted.");
    if (facet.field != null) {
      dataRef = parent = getDataRef(facet, scope);
    } else {
      if (!from.data) {
        op = parseTransform(extend19({
          type: "aggregate",
          groupby: array20(facet.groupby)
        }, facet.aggregate), scope);
        op.params.key = scope.keyRef(facet.groupby);
        op.params.pulse = getDataRef(facet, scope);
        dataRef = parent = ref(scope.add(op));
      } else {
        parent = ref(scope.getData(from.data).aggregate);
      }
      key4 = scope.keyRef(facet.groupby, true);
    }
  }
  if (!dataRef) {
    dataRef = getDataRef(from, scope);
  }
  return {
    key: key4,
    pulse: dataRef,
    parent
  };
}
function getDataRef(from, scope) {
  return from.$ref ? from : from.data && from.data.$ref ? from.data : ref(scope.getData(from.data).output);
}
function DataScope(scope, input, output3, values7, aggr) {
  this.scope = scope;
  this.input = input;
  this.output = output3;
  this.values = values7;
  this.aggregate = aggr;
  this.index = {};
}
DataScope.fromEntries = function(scope, entries2) {
  const n = entries2.length, values7 = entries2[n - 1], output3 = entries2[n - 2];
  let input = entries2[0], aggr = null, i = 1;
  if (input && input.type === "load") {
    input = entries2[1];
  }
  scope.add(entries2[0]);
  for (; i < n; ++i) {
    entries2[i].params.pulse = ref(entries2[i - 1]);
    scope.add(entries2[i]);
    if (entries2[i].type === "aggregate")
      aggr = entries2[i];
  }
  return new DataScope(scope, input, output3, values7, aggr);
};
function fieldKey(field25) {
  return isString12(field25) ? field25 : null;
}
function addSortField(scope, p, sort4) {
  const as = aggrField(sort4.op, sort4.field);
  let s2;
  if (p.ops) {
    for (let i = 0, n = p.as.length; i < n; ++i) {
      if (p.as[i] === as)
        return;
    }
  } else {
    p.ops = ["count"];
    p.fields = [null];
    p.as = ["count"];
  }
  if (sort4.op) {
    p.ops.push((s2 = sort4.op.signal) ? scope.signalRef(s2) : sort4.op);
    p.fields.push(scope.fieldRef(sort4.field));
    p.as.push(as);
  }
}
function cache(scope, ds, name, optype, field25, counts, index4) {
  const cache2 = ds[name] || (ds[name] = {}), sort4 = sortKey(counts);
  let k3 = fieldKey(field25), v2, op;
  if (k3 != null) {
    scope = ds.scope;
    k3 = k3 + (sort4 ? "|" + sort4 : "");
    v2 = cache2[k3];
  }
  if (!v2) {
    const params2 = counts ? {
      field: keyFieldRef,
      pulse: ds.countsRef(scope, field25, counts)
    } : {
      field: scope.fieldRef(field25),
      pulse: ref(ds.output)
    };
    if (sort4)
      params2.sort = scope.sortRef(counts);
    op = scope.add(entry(optype, void 0, params2));
    if (index4)
      ds.index[field25] = op;
    v2 = ref(op);
    if (k3 != null)
      cache2[k3] = v2;
  }
  return v2;
}
DataScope.prototype = {
  countsRef(scope, field25, sort4) {
    const ds = this, cache2 = ds.counts || (ds.counts = {}), k3 = fieldKey(field25);
    let v2, a4, p;
    if (k3 != null) {
      scope = ds.scope;
      v2 = cache2[k3];
    }
    if (!v2) {
      p = {
        groupby: scope.fieldRef(field25, "key"),
        pulse: ref(ds.output)
      };
      if (sort4 && sort4.field)
        addSortField(scope, p, sort4);
      a4 = scope.add(Aggregate2(p));
      v2 = scope.add(Collect2({
        pulse: ref(a4)
      }));
      v2 = {
        agg: a4,
        ref: ref(v2)
      };
      if (k3 != null)
        cache2[k3] = v2;
    } else if (sort4 && sort4.field) {
      addSortField(scope, v2.agg.params, sort4);
    }
    return v2.ref;
  },
  tuplesRef() {
    return ref(this.values);
  },
  extentRef(scope, field25) {
    return cache(scope, this, "extent", "extent", field25, false);
  },
  domainRef(scope, field25) {
    return cache(scope, this, "domain", "values", field25, false);
  },
  valuesRef(scope, field25, sort4) {
    return cache(scope, this, "vals", "values", field25, sort4 || true);
  },
  lookupRef(scope, field25) {
    return cache(scope, this, "lookup", "tupleindex", field25, false);
  },
  indataRef(scope, field25) {
    return cache(scope, this, "indata", "tupleindex", field25, true, true);
  }
};
function parseFacet(spec, scope, group7) {
  const facet = spec.from.facet, name = facet.name, data3 = getDataRef(facet, scope);
  let op;
  if (!facet.name) {
    error20("Facet must have a name: " + $9(facet));
  }
  if (!facet.data) {
    error20("Facet must reference a data set: " + $9(facet));
  }
  if (facet.field) {
    op = scope.add(PreFacet2({
      field: scope.fieldRef(facet.field),
      pulse: data3
    }));
  } else if (facet.groupby) {
    op = scope.add(Facet2({
      key: scope.keyRef(facet.groupby),
      group: ref(scope.proxy(group7.parent)),
      pulse: data3
    }));
  } else {
    error20("Facet must specify groupby or field: " + $9(facet));
  }
  const subscope = scope.fork(), source3 = subscope.add(Collect2()), values7 = subscope.add(Sieve2({
    pulse: ref(source3)
  }));
  subscope.addData(name, new DataScope(subscope, source3, source3, values7));
  subscope.addSignal("parent", null);
  op.params.subflow = {
    $subflow: subscope.parse(spec).toRuntime()
  };
}
function parseSubflow(spec, scope, input) {
  const op = scope.add(PreFacet2({
    pulse: input.pulse
  })), subscope = scope.fork();
  subscope.add(Sieve2());
  subscope.addSignal("parent", null);
  op.params.subflow = {
    $subflow: subscope.parse(spec).toRuntime()
  };
}
function parseTrigger(spec, scope, name) {
  const remove2 = spec.remove, insert2 = spec.insert, toggle2 = spec.toggle, modify2 = spec.modify, values7 = spec.values, op = scope.add(operator());
  const update3 = "if(" + spec.trigger + ',modify("' + name + '",' + [insert2, remove2, toggle2, modify2, values7].map((_) => _ == null ? "null" : _).join(",") + "),0)";
  const expr2 = parser2(update3, scope);
  op.update = expr2.$expr;
  op.params = expr2.$params;
}
function parseMark(spec, scope) {
  const role = getRole(spec), group7 = spec.type === GroupMark, facet = spec.from && spec.from.facet, overlap = spec.overlap;
  let layout = spec.layout || role === ScopeRole2 || role === FrameRole2, ops2, op, store, enc, name, layoutRef, boundRef;
  const nested = role === MarkRole || layout || facet;
  const input = parseData$1(spec.from, group7, scope);
  op = scope.add(DataJoin2({
    key: input.key || (spec.key ? fieldRef$1(spec.key) : void 0),
    pulse: input.pulse,
    clean: !group7
  }));
  const joinRef = ref(op);
  op = store = scope.add(Collect2({
    pulse: joinRef
  }));
  op = scope.add(Mark2({
    markdef: definition2(spec),
    interactive: interactive(spec.interactive, scope),
    clip: clip6(spec.clip, scope),
    context: {
      $context: true
    },
    groups: scope.lookup(),
    parent: scope.signals.parent ? scope.signalRef("parent") : null,
    index: scope.markpath(),
    pulse: ref(op)
  }));
  const markRef = ref(op);
  op = enc = scope.add(Encode2(parseEncode(spec.encode, spec.type, role, spec.style, scope, {
    mod: false,
    pulse: markRef
  })));
  op.params.parent = scope.encode();
  if (spec.transform) {
    spec.transform.forEach((_) => {
      const tx = parseTransform(_, scope), md6 = tx.metadata;
      if (md6.generates || md6.changes) {
        error20("Mark transforms should not generate new data.");
      }
      if (!md6.nomod)
        enc.params.mod = true;
      tx.params.pulse = ref(op);
      scope.add(op = tx);
    });
  }
  if (spec.sort) {
    op = scope.add(SortItems2({
      sort: scope.compareRef(spec.sort),
      pulse: ref(op)
    }));
  }
  const encodeRef = ref(op);
  if (facet || layout) {
    layout = scope.add(ViewLayout2({
      layout: scope.objectProperty(spec.layout),
      legends: scope.legends,
      mark: markRef,
      pulse: encodeRef
    }));
    layoutRef = ref(layout);
  }
  const bound6 = scope.add(Bound2({
    mark: markRef,
    pulse: layoutRef || encodeRef
  }));
  boundRef = ref(bound6);
  if (group7) {
    if (nested) {
      ops2 = scope.operators;
      ops2.pop();
      if (layout)
        ops2.pop();
    }
    scope.pushState(encodeRef, layoutRef || boundRef, joinRef);
    facet ? parseFacet(spec, scope, input) : nested ? parseSubflow(spec, scope, input) : scope.parse(spec);
    scope.popState();
    if (nested) {
      if (layout)
        ops2.push(layout);
      ops2.push(bound6);
    }
  }
  if (overlap) {
    boundRef = parseOverlap(overlap, boundRef, scope);
  }
  const render = scope.add(Render2({
    pulse: boundRef
  })), sieve = scope.add(Sieve2({
    pulse: ref(render)
  }, void 0, scope.parent()));
  if (spec.name != null) {
    name = spec.name;
    scope.addData(name, new DataScope(scope, store, render, sieve));
    if (spec.on)
      spec.on.forEach((on2) => {
        if (on2.insert || on2.remove || on2.toggle) {
          error20("Marks only support modify triggers.");
        }
        parseTrigger(on2, scope, name);
      });
  }
}
function parseOverlap(overlap, source3, scope) {
  const method10 = overlap.method, bound6 = overlap.bound, sep = overlap.separation;
  const params2 = {
    separation: isSignal(sep) ? scope.signalRef(sep.signal) : sep,
    method: isSignal(method10) ? scope.signalRef(method10.signal) : method10,
    pulse: source3
  };
  if (overlap.order) {
    params2.sort = scope.compareRef({
      field: overlap.order
    });
  }
  if (bound6) {
    const tol = bound6.tolerance;
    params2.boundTolerance = isSignal(tol) ? scope.signalRef(tol.signal) : +tol;
    params2.boundScale = scope.scaleRef(bound6.scale);
    params2.boundOrient = bound6.orient;
  }
  return ref(scope.add(Overlap2(params2)));
}
function parseLegend(spec, scope) {
  const config = scope.config.legend, encode2 = spec.encode || {}, _ = lookup9(spec, config), legendEncode = encode2.legend || {}, name = legendEncode.name || void 0, interactive2 = legendEncode.interactive, style6 = legendEncode.style, scales10 = {};
  let scale19 = 0, entryLayout, params2, children3;
  LegendScales.forEach((s2) => spec[s2] ? (scales10[s2] = spec[s2], scale19 = scale19 || spec[s2]) : 0);
  if (!scale19)
    error20("Missing valid scale for legend.");
  const type7 = legendType(spec, scope.scaleType(scale19));
  const datum2 = {
    title: spec.title != null,
    scales: scales10,
    type: type7,
    vgrad: type7 !== "symbol" && _.isVertical()
  };
  const dataRef = ref(scope.add(Collect2(null, [datum2])));
  const entryEncode = {
    enter: {
      x: {
        value: 0
      },
      y: {
        value: 0
      }
    }
  };
  const entryRef = ref(scope.add(LegendEntries2(params2 = {
    type: type7,
    scale: scope.scaleRef(scale19),
    count: scope.objectProperty(_("tickCount")),
    limit: scope.property(_("symbolLimit")),
    values: scope.objectProperty(spec.values),
    minstep: scope.property(spec.tickMinStep),
    formatType: scope.property(spec.formatType),
    formatSpecifier: scope.property(spec.format)
  })));
  if (type7 === Gradient3) {
    children3 = [legendGradient(spec, scale19, config, encode2.gradient), legendGradientLabels(spec, config, encode2.labels, entryRef)];
    params2.count = params2.count || scope.signalRef(`max(2,2*floor((${deref(_.gradientLength())})/100))`);
  } else if (type7 === Discrete10) {
    children3 = [legendGradientDiscrete(spec, scale19, config, encode2.gradient, entryRef), legendGradientLabels(spec, config, encode2.labels, entryRef)];
  } else {
    entryLayout = legendSymbolLayout(spec, config);
    children3 = [legendSymbolGroups(spec, config, encode2, entryRef, deref(entryLayout.columns))];
    params2.size = sizeExpression(spec, scope, children3[0].marks);
  }
  children3 = [guideGroup({
    role: LegendEntryRole,
    from: dataRef,
    encode: entryEncode,
    marks: children3,
    layout: entryLayout,
    interactive: interactive2
  })];
  if (datum2.title) {
    children3.push(legendTitle(spec, config, encode2.title, dataRef));
  }
  return parseMark(guideGroup({
    role: LegendRole2,
    from: dataRef,
    encode: extendEncode(buildLegendEncode(_, spec, config), legendEncode, Skip3),
    marks: children3,
    aria: _("aria"),
    description: _("description"),
    zindex: _("zindex"),
    name,
    interactive: interactive2,
    style: style6
  }), scope);
}
function legendType(spec, scaleType2) {
  let type7 = spec.type || Symbols2;
  if (!spec.type && scaleCount(spec) === 1 && (spec.fill || spec.stroke)) {
    type7 = isContinuous2(scaleType2) ? Gradient3 : isDiscretizing6(scaleType2) ? Discrete10 : Symbols2;
  }
  return type7 !== Gradient3 ? type7 : isDiscretizing6(scaleType2) ? Discrete10 : Gradient3;
}
function scaleCount(spec) {
  return LegendScales.reduce((count3, type7) => count3 + (spec[type7] ? 1 : 0), 0);
}
function buildLegendEncode(_, spec, config) {
  const encode2 = {
    enter: {},
    update: {}
  };
  addEncoders(encode2, {
    orient: _("orient"),
    offset: _("offset"),
    padding: _("padding"),
    titlePadding: _("titlePadding"),
    cornerRadius: _("cornerRadius"),
    fill: _("fillColor"),
    stroke: _("strokeColor"),
    strokeWidth: config.strokeWidth,
    strokeDash: config.strokeDash,
    x: _("legendX"),
    y: _("legendY"),
    // accessibility support
    format: spec.format,
    formatType: spec.formatType
  });
  return encode2;
}
function sizeExpression(spec, scope, marks) {
  const size = deref(getChannel("size", spec, marks)), strokeWidth = deref(getChannel("strokeWidth", spec, marks)), fontSize6 = deref(getFontSize(marks[1].encode, scope, GuideLabelStyle));
  return parser2(`max(ceil(sqrt(${size})+${strokeWidth}),${fontSize6})`, scope);
}
function getChannel(name, spec, marks) {
  return spec[name] ? `scale("${spec[name]}",datum)` : getEncoding(name, marks[0].encode);
}
function getFontSize(encode2, scope, style6) {
  return getEncoding("fontSize", encode2) || getStyle("fontSize", scope, style6);
}
var angleExpr = `item.orient==="${Left2}"?-90:item.orient==="${Right2}"?90:0`;
function parseTitle(spec, scope) {
  spec = isString12(spec) ? {
    text: spec
  } : spec;
  const _ = lookup9(spec, scope.config.title), encode2 = spec.encode || {}, userEncode = encode2.group || {}, name = userEncode.name || void 0, interactive2 = userEncode.interactive, style6 = userEncode.style, children3 = [];
  const datum2 = {}, dataRef = ref(scope.add(Collect2(null, [datum2])));
  children3.push(buildTitle(spec, _, titleEncode(spec), dataRef));
  if (spec.subtitle) {
    children3.push(buildSubTitle(spec, _, encode2.subtitle, dataRef));
  }
  return parseMark(guideGroup({
    role: TitleRole2,
    from: dataRef,
    encode: groupEncode(_, userEncode),
    marks: children3,
    aria: _("aria"),
    description: _("description"),
    zindex: _("zindex"),
    name,
    interactive: interactive2,
    style: style6
  }), scope);
}
function titleEncode(spec) {
  const encode2 = spec.encode;
  return encode2 && encode2.title || extend19({
    name: spec.name,
    interactive: spec.interactive,
    style: spec.style
  }, encode2);
}
function groupEncode(_, userEncode) {
  const encode2 = {
    enter: {},
    update: {}
  };
  addEncoders(encode2, {
    orient: _("orient"),
    anchor: _("anchor"),
    align: {
      signal: alignExpr$1
    },
    angle: {
      signal: angleExpr
    },
    limit: _("limit"),
    frame: _("frame"),
    offset: _("offset") || 0,
    padding: _("subtitlePadding")
  });
  return extendEncode(encode2, userEncode, Skip3);
}
function buildTitle(spec, _, userEncode, dataRef) {
  const zero28 = {
    value: 0
  }, text7 = spec.text, encode2 = {
    enter: {
      opacity: zero28
    },
    update: {
      opacity: {
        value: 1
      }
    },
    exit: {
      opacity: zero28
    }
  };
  addEncoders(encode2, {
    text: text7,
    align: {
      signal: "item.mark.group.align"
    },
    angle: {
      signal: "item.mark.group.angle"
    },
    limit: {
      signal: "item.mark.group.limit"
    },
    baseline: "top",
    dx: _("dx"),
    dy: _("dy"),
    fill: _("color"),
    font: _("font"),
    fontSize: _("fontSize"),
    fontStyle: _("fontStyle"),
    fontWeight: _("fontWeight"),
    lineHeight: _("lineHeight")
  }, {
    // update
    align: _("align"),
    angle: _("angle"),
    baseline: _("baseline")
  });
  return guideMark({
    type: TextMark,
    role: TitleTextRole,
    style: GroupTitleStyle,
    from: dataRef,
    encode: encode2
  }, userEncode);
}
function buildSubTitle(spec, _, userEncode, dataRef) {
  const zero28 = {
    value: 0
  }, text7 = spec.subtitle, encode2 = {
    enter: {
      opacity: zero28
    },
    update: {
      opacity: {
        value: 1
      }
    },
    exit: {
      opacity: zero28
    }
  };
  addEncoders(encode2, {
    text: text7,
    align: {
      signal: "item.mark.group.align"
    },
    angle: {
      signal: "item.mark.group.angle"
    },
    limit: {
      signal: "item.mark.group.limit"
    },
    baseline: "top",
    dx: _("dx"),
    dy: _("dy"),
    fill: _("subtitleColor"),
    font: _("subtitleFont"),
    fontSize: _("subtitleFontSize"),
    fontStyle: _("subtitleFontStyle"),
    fontWeight: _("subtitleFontWeight"),
    lineHeight: _("subtitleLineHeight")
  }, {
    // update
    align: _("align"),
    angle: _("angle"),
    baseline: _("baseline")
  });
  return guideMark({
    type: TextMark,
    role: TitleSubtitleRole,
    style: GroupSubtitleStyle,
    from: dataRef,
    encode: encode2
  }, userEncode);
}
function parseData(data3, scope) {
  const transforms2 = [];
  if (data3.transform) {
    data3.transform.forEach((tx) => {
      transforms2.push(parseTransform(tx, scope));
    });
  }
  if (data3.on) {
    data3.on.forEach((on2) => {
      parseTrigger(on2, scope, data3.name);
    });
  }
  scope.addDataPipeline(data3.name, analyze(data3, scope, transforms2));
}
function analyze(data3, scope, ops2) {
  const output3 = [];
  let source3 = null, modify2 = false, generate3 = false, upstream, i, n, t, m3;
  if (data3.values) {
    if (isSignal(data3.values) || hasSignal(data3.format)) {
      output3.push(load7(scope, data3));
      output3.push(source3 = collect());
    } else {
      output3.push(source3 = collect({
        $ingest: data3.values,
        $format: data3.format
      }));
    }
  } else if (data3.url) {
    if (hasSignal(data3.url) || hasSignal(data3.format)) {
      output3.push(load7(scope, data3));
      output3.push(source3 = collect());
    } else {
      output3.push(source3 = collect({
        $request: data3.url,
        $format: data3.format
      }));
    }
  } else if (data3.source) {
    source3 = upstream = array20(data3.source).map((d) => ref(scope.getData(d).output));
    output3.push(null);
  }
  for (i = 0, n = ops2.length; i < n; ++i) {
    t = ops2[i];
    m3 = t.metadata;
    if (!source3 && !m3.source) {
      output3.push(source3 = collect());
    }
    output3.push(t);
    if (m3.generates)
      generate3 = true;
    if (m3.modifies && !generate3)
      modify2 = true;
    if (m3.source)
      source3 = t;
    else if (m3.changes)
      source3 = null;
  }
  if (upstream) {
    n = upstream.length - 1;
    output3[0] = Relay2({
      derive: modify2,
      pulse: n ? upstream : upstream[0]
    });
    if (modify2 || n) {
      output3.splice(1, 0, collect());
    }
  }
  if (!source3)
    output3.push(collect());
  output3.push(Sieve2({}));
  return output3;
}
function collect(values7) {
  const s2 = Collect2({}, values7);
  s2.metadata = {
    source: true
  };
  return s2;
}
function load7(scope, data3) {
  return Load2({
    url: data3.url ? scope.property(data3.url) : void 0,
    async: data3.async ? scope.property(data3.async) : void 0,
    values: data3.values ? scope.property(data3.values) : void 0,
    format: scope.objectProperty(data3.format)
  });
}
var isX = (orient2) => orient2 === Bottom2 || orient2 === Top2;
var getSign = (orient2, a4, b6) => isSignal(orient2) ? ifLeftTopExpr(orient2.signal, a4, b6) : orient2 === Left2 || orient2 === Top2 ? a4 : b6;
var ifX = (orient2, a4, b6) => isSignal(orient2) ? ifXEnc(orient2.signal, a4, b6) : isX(orient2) ? a4 : b6;
var ifY = (orient2, a4, b6) => isSignal(orient2) ? ifYEnc(orient2.signal, a4, b6) : isX(orient2) ? b6 : a4;
var ifTop = (orient2, a4, b6) => isSignal(orient2) ? ifTopExpr(orient2.signal, a4, b6) : orient2 === Top2 ? {
  value: a4
} : {
  value: b6
};
var ifRight = (orient2, a4, b6) => isSignal(orient2) ? ifRightExpr(orient2.signal, a4, b6) : orient2 === Right2 ? {
  value: a4
} : {
  value: b6
};
var ifXEnc = ($orient, a4, b6) => ifEnc(`${$orient} === '${Top2}' || ${$orient} === '${Bottom2}'`, a4, b6);
var ifYEnc = ($orient, a4, b6) => ifEnc(`${$orient} !== '${Top2}' && ${$orient} !== '${Bottom2}'`, a4, b6);
var ifLeftTopExpr = ($orient, a4, b6) => ifExpr(`${$orient} === '${Left2}' || ${$orient} === '${Top2}'`, a4, b6);
var ifTopExpr = ($orient, a4, b6) => ifExpr(`${$orient} === '${Top2}'`, a4, b6);
var ifRightExpr = ($orient, a4, b6) => ifExpr(`${$orient} === '${Right2}'`, a4, b6);
var ifEnc = (test2, a4, b6) => {
  a4 = a4 != null ? encoder(a4) : a4;
  b6 = b6 != null ? encoder(b6) : b6;
  if (isSimple(a4) && isSimple(b6)) {
    a4 = a4 ? a4.signal || $9(a4.value) : null;
    b6 = b6 ? b6.signal || $9(b6.value) : null;
    return {
      signal: `${test2} ? (${a4}) : (${b6})`
    };
  } else {
    return [extend19({
      test: test2
    }, a4)].concat(b6 || []);
  }
};
var isSimple = (enc) => enc == null || Object.keys(enc).length === 1;
var ifExpr = (test2, a4, b6) => ({
  signal: `${test2} ? (${toExpr(a4)}) : (${toExpr(b6)})`
});
var ifOrient = ($orient, t, b6, l, r) => ({
  signal: (l != null ? `${$orient} === '${Left2}' ? (${toExpr(l)}) : ` : "") + (b6 != null ? `${$orient} === '${Bottom2}' ? (${toExpr(b6)}) : ` : "") + (r != null ? `${$orient} === '${Right2}' ? (${toExpr(r)}) : ` : "") + (t != null ? `${$orient} === '${Top2}' ? (${toExpr(t)}) : ` : "") + "(null)"
});
var toExpr = (v2) => isSignal(v2) ? v2.signal : v2 == null ? null : $9(v2);
var mult = (sign4, value7) => value7 === 0 ? 0 : isSignal(sign4) ? {
  signal: `(${sign4.signal}) * ${value7}`
} : {
  value: sign4 * value7
};
var patch = (value7, base) => {
  const s2 = value7.signal;
  return s2 && s2.endsWith("(null)") ? {
    signal: s2.slice(0, -6) + base.signal
  } : value7;
};
function fallback(prop, config, axisConfig2, style6) {
  let styleProp;
  if (config && has17(config, prop)) {
    return config[prop];
  } else if (has17(axisConfig2, prop)) {
    return axisConfig2[prop];
  } else if (prop.startsWith("title")) {
    switch (prop) {
      case "titleColor":
        styleProp = "fill";
        break;
      case "titleFont":
      case "titleFontSize":
      case "titleFontWeight":
        styleProp = prop[5].toLowerCase() + prop.slice(6);
    }
    return style6[GuideTitleStyle][styleProp];
  } else if (prop.startsWith("label")) {
    switch (prop) {
      case "labelColor":
        styleProp = "fill";
        break;
      case "labelFont":
      case "labelFontSize":
        styleProp = prop[5].toLowerCase() + prop.slice(6);
    }
    return style6[GuideLabelStyle][styleProp];
  }
  return null;
}
function keys3(objects) {
  const map13 = {};
  for (const obj of objects) {
    if (!obj)
      continue;
    for (const key4 in obj)
      map13[key4] = 1;
  }
  return Object.keys(map13);
}
function axisConfig(spec, scope) {
  var config = scope.config, style6 = config.style, axis = config.axis, band11 = scope.scaleType(spec.scale) === "band" && config.axisBand, orient2 = spec.orient, xy, or6, key4;
  if (isSignal(orient2)) {
    const xyKeys = keys3([config.axisX, config.axisY]), orientKeys = keys3([config.axisTop, config.axisBottom, config.axisLeft, config.axisRight]);
    xy = {};
    for (key4 of xyKeys) {
      xy[key4] = ifX(orient2, fallback(key4, config.axisX, axis, style6), fallback(key4, config.axisY, axis, style6));
    }
    or6 = {};
    for (key4 of orientKeys) {
      or6[key4] = ifOrient(orient2.signal, fallback(key4, config.axisTop, axis, style6), fallback(key4, config.axisBottom, axis, style6), fallback(key4, config.axisLeft, axis, style6), fallback(key4, config.axisRight, axis, style6));
    }
  } else {
    xy = orient2 === Top2 || orient2 === Bottom2 ? config.axisX : config.axisY;
    or6 = config["axis" + orient2[0].toUpperCase() + orient2.slice(1)];
  }
  const result = xy || or6 || band11 ? extend19({}, axis, xy, or6, band11) : axis;
  return result;
}
function axisDomain(spec, config, userEncode, dataRef) {
  const _ = lookup9(spec, config), orient2 = spec.orient;
  let enter, update3;
  const encode2 = {
    enter: enter = {
      opacity: zero23
    },
    update: update3 = {
      opacity: one22
    },
    exit: {
      opacity: zero23
    }
  };
  addEncoders(encode2, {
    stroke: _("domainColor"),
    strokeCap: _("domainCap"),
    strokeDash: _("domainDash"),
    strokeDashOffset: _("domainDashOffset"),
    strokeWidth: _("domainWidth"),
    strokeOpacity: _("domainOpacity")
  });
  const pos0 = position(spec, 0);
  const pos1 = position(spec, 1);
  enter.x = update3.x = ifX(orient2, pos0, zero23);
  enter.x2 = update3.x2 = ifX(orient2, pos1);
  enter.y = update3.y = ifY(orient2, pos0, zero23);
  enter.y2 = update3.y2 = ifY(orient2, pos1);
  return guideMark({
    type: RuleMark,
    role: AxisDomainRole,
    from: dataRef,
    encode: encode2
  }, userEncode);
}
function position(spec, pos) {
  return {
    scale: spec.scale,
    range: pos
  };
}
function axisGrid(spec, config, userEncode, dataRef, band11) {
  const _ = lookup9(spec, config), orient2 = spec.orient, vscale = spec.gridScale, sign4 = getSign(orient2, 1, -1), offset9 = offsetValue2(spec.offset, sign4);
  let enter, exit, update3;
  const encode2 = {
    enter: enter = {
      opacity: zero23
    },
    update: update3 = {
      opacity: one22
    },
    exit: exit = {
      opacity: zero23
    }
  };
  addEncoders(encode2, {
    stroke: _("gridColor"),
    strokeCap: _("gridCap"),
    strokeDash: _("gridDash"),
    strokeDashOffset: _("gridDashOffset"),
    strokeOpacity: _("gridOpacity"),
    strokeWidth: _("gridWidth")
  });
  const tickPos = {
    scale: spec.scale,
    field: Value,
    band: band11.band,
    extra: band11.extra,
    offset: band11.offset,
    round: _("tickRound")
  };
  const sz6 = ifX(orient2, {
    signal: "height"
  }, {
    signal: "width"
  });
  const gridStart = vscale ? {
    scale: vscale,
    range: 0,
    mult: sign4,
    offset: offset9
  } : {
    value: 0,
    offset: offset9
  };
  const gridEnd = vscale ? {
    scale: vscale,
    range: 1,
    mult: sign4,
    offset: offset9
  } : extend19(sz6, {
    mult: sign4,
    offset: offset9
  });
  enter.x = update3.x = ifX(orient2, tickPos, gridStart);
  enter.y = update3.y = ifY(orient2, tickPos, gridStart);
  enter.x2 = update3.x2 = ifY(orient2, gridEnd);
  enter.y2 = update3.y2 = ifX(orient2, gridEnd);
  exit.x = ifX(orient2, tickPos);
  exit.y = ifY(orient2, tickPos);
  return guideMark({
    type: RuleMark,
    role: AxisGridRole,
    key: Value,
    from: dataRef,
    encode: encode2
  }, userEncode);
}
function offsetValue2(offset9, sign4) {
  if (sign4 === 1)
    ;
  else if (!isObject11(offset9)) {
    offset9 = isSignal(sign4) ? {
      signal: `(${sign4.signal}) * (${offset9 || 0})`
    } : sign4 * (offset9 || 0);
  } else {
    let entry2 = offset9 = extend19({}, offset9);
    while (entry2.mult != null) {
      if (!isObject11(entry2.mult)) {
        entry2.mult = isSignal(sign4) ? {
          signal: `(${entry2.mult}) * (${sign4.signal})`
        } : entry2.mult * sign4;
        return offset9;
      } else {
        entry2 = entry2.mult = extend19({}, entry2.mult);
      }
    }
    entry2.mult = sign4;
  }
  return offset9;
}
function axisTicks(spec, config, userEncode, dataRef, size, band11) {
  const _ = lookup9(spec, config), orient2 = spec.orient, sign4 = getSign(orient2, -1, 1);
  let enter, exit, update3;
  const encode2 = {
    enter: enter = {
      opacity: zero23
    },
    update: update3 = {
      opacity: one22
    },
    exit: exit = {
      opacity: zero23
    }
  };
  addEncoders(encode2, {
    stroke: _("tickColor"),
    strokeCap: _("tickCap"),
    strokeDash: _("tickDash"),
    strokeDashOffset: _("tickDashOffset"),
    strokeOpacity: _("tickOpacity"),
    strokeWidth: _("tickWidth")
  });
  const tickSize = encoder(size);
  tickSize.mult = sign4;
  const tickPos = {
    scale: spec.scale,
    field: Value,
    band: band11.band,
    extra: band11.extra,
    offset: band11.offset,
    round: _("tickRound")
  };
  update3.y = enter.y = ifX(orient2, zero23, tickPos);
  update3.y2 = enter.y2 = ifX(orient2, tickSize);
  exit.x = ifX(orient2, tickPos);
  update3.x = enter.x = ifY(orient2, zero23, tickPos);
  update3.x2 = enter.x2 = ifY(orient2, tickSize);
  exit.y = ifY(orient2, tickPos);
  return guideMark({
    type: RuleMark,
    role: AxisTickRole,
    key: Value,
    from: dataRef,
    encode: encode2
  }, userEncode);
}
function flushExpr(scale19, threshold2, a4, b6, c5) {
  return {
    signal: 'flush(range("' + scale19 + '"), scale("' + scale19 + '", datum.value), ' + threshold2 + "," + a4 + "," + b6 + "," + c5 + ")"
  };
}
function axisLabels(spec, config, userEncode, dataRef, size, band11) {
  const _ = lookup9(spec, config), orient2 = spec.orient, scale19 = spec.scale, sign4 = getSign(orient2, -1, 1), flush3 = deref(_("labelFlush")), flushOffset = deref(_("labelFlushOffset")), labelAlign = _("labelAlign"), labelBaseline = _("labelBaseline");
  let flushOn = flush3 === 0 || !!flush3, update3;
  const tickSize = encoder(size);
  tickSize.mult = sign4;
  tickSize.offset = encoder(_("labelPadding") || 0);
  tickSize.offset.mult = sign4;
  const tickPos = {
    scale: scale19,
    field: Value,
    band: 0.5,
    offset: extendOffset(band11.offset, _("labelOffset"))
  };
  const align2 = ifX(orient2, flushOn ? flushExpr(scale19, flush3, '"left"', '"right"', '"center"') : {
    value: "center"
  }, ifRight(orient2, "left", "right"));
  const baseline3 = ifX(orient2, ifTop(orient2, "bottom", "top"), flushOn ? flushExpr(scale19, flush3, '"top"', '"bottom"', '"middle"') : {
    value: "middle"
  });
  const offsetExpr2 = flushExpr(scale19, flush3, `-(${flushOffset})`, flushOffset, 0);
  flushOn = flushOn && flushOffset;
  const enter = {
    opacity: zero23,
    x: ifX(orient2, tickPos, tickSize),
    y: ifY(orient2, tickPos, tickSize)
  };
  const encode2 = {
    enter,
    update: update3 = {
      opacity: one22,
      text: {
        field: Label2
      },
      x: enter.x,
      y: enter.y,
      align: align2,
      baseline: baseline3
    },
    exit: {
      opacity: zero23,
      x: enter.x,
      y: enter.y
    }
  };
  addEncoders(encode2, {
    dx: !labelAlign && flushOn ? ifX(orient2, offsetExpr2) : null,
    dy: !labelBaseline && flushOn ? ifY(orient2, offsetExpr2) : null
  });
  addEncoders(encode2, {
    angle: _("labelAngle"),
    fill: _("labelColor"),
    fillOpacity: _("labelOpacity"),
    font: _("labelFont"),
    fontSize: _("labelFontSize"),
    fontWeight: _("labelFontWeight"),
    fontStyle: _("labelFontStyle"),
    limit: _("labelLimit"),
    lineHeight: _("labelLineHeight")
  }, {
    align: labelAlign,
    baseline: labelBaseline
  });
  const bound6 = _("labelBound");
  let overlap = _("labelOverlap");
  overlap = overlap || bound6 ? {
    separation: _("labelSeparation"),
    method: overlap,
    order: "datum.index",
    bound: bound6 ? {
      scale: scale19,
      orient: orient2,
      tolerance: bound6
    } : null
  } : void 0;
  if (update3.align !== align2) {
    update3.align = patch(update3.align, align2);
  }
  if (update3.baseline !== baseline3) {
    update3.baseline = patch(update3.baseline, baseline3);
  }
  return guideMark({
    type: TextMark,
    role: AxisLabelRole,
    style: GuideLabelStyle,
    key: Value,
    from: dataRef,
    encode: encode2,
    overlap
  }, userEncode);
}
function axisTitle(spec, config, userEncode, dataRef) {
  const _ = lookup9(spec, config), orient2 = spec.orient, sign4 = getSign(orient2, -1, 1);
  let enter, update3;
  const encode2 = {
    enter: enter = {
      opacity: zero23,
      anchor: encoder(_("titleAnchor", null)),
      align: {
        signal: alignExpr$1
      }
    },
    update: update3 = extend19({}, enter, {
      opacity: one22,
      text: encoder(spec.title)
    }),
    exit: {
      opacity: zero23
    }
  };
  const titlePos = {
    signal: `lerp(range("${spec.scale}"), ${anchorExpr(0, 1, 0.5)})`
  };
  update3.x = ifX(orient2, titlePos);
  update3.y = ifY(orient2, titlePos);
  enter.angle = ifX(orient2, zero23, mult(sign4, 90));
  enter.baseline = ifX(orient2, ifTop(orient2, Bottom2, Top2), {
    value: Bottom2
  });
  update3.angle = enter.angle;
  update3.baseline = enter.baseline;
  addEncoders(encode2, {
    fill: _("titleColor"),
    fillOpacity: _("titleOpacity"),
    font: _("titleFont"),
    fontSize: _("titleFontSize"),
    fontStyle: _("titleFontStyle"),
    fontWeight: _("titleFontWeight"),
    limit: _("titleLimit"),
    lineHeight: _("titleLineHeight")
  }, {
    // require update
    align: _("titleAlign"),
    angle: _("titleAngle"),
    baseline: _("titleBaseline")
  });
  autoLayout(_, orient2, encode2, userEncode);
  encode2.update.align = patch(encode2.update.align, enter.align);
  encode2.update.angle = patch(encode2.update.angle, enter.angle);
  encode2.update.baseline = patch(encode2.update.baseline, enter.baseline);
  return guideMark({
    type: TextMark,
    role: AxisTitleRole,
    style: GuideTitleStyle,
    from: dataRef,
    encode: encode2
  }, userEncode);
}
function autoLayout(_, orient2, encode2, userEncode) {
  const auto = (value7, dim) => value7 != null ? (encode2.update[dim] = patch(encoder(value7), encode2.update[dim]), false) : !has18(dim, userEncode) ? true : false;
  const autoY = auto(_("titleX"), "x"), autoX = auto(_("titleY"), "y");
  encode2.enter.auto = autoX === autoY ? encoder(autoX) : ifX(orient2, encoder(autoX), encoder(autoY));
}
function parseAxis(spec, scope) {
  const config = axisConfig(spec, scope), encode2 = spec.encode || {}, axisEncode = encode2.axis || {}, name = axisEncode.name || void 0, interactive2 = axisEncode.interactive, style6 = axisEncode.style, _ = lookup9(spec, config), band11 = tickBand(_);
  const datum2 = {
    scale: spec.scale,
    ticks: !!_("ticks"),
    labels: !!_("labels"),
    grid: !!_("grid"),
    domain: !!_("domain"),
    title: spec.title != null
  };
  const dataRef = ref(scope.add(Collect2({}, [datum2])));
  const ticksRef = ref(scope.add(AxisTicks2({
    scale: scope.scaleRef(spec.scale),
    extra: scope.property(band11.extra),
    count: scope.objectProperty(spec.tickCount),
    values: scope.objectProperty(spec.values),
    minstep: scope.property(spec.tickMinStep),
    formatType: scope.property(spec.formatType),
    formatSpecifier: scope.property(spec.format)
  })));
  const children3 = [];
  let size;
  if (datum2.grid) {
    children3.push(axisGrid(spec, config, encode2.grid, ticksRef, band11));
  }
  if (datum2.ticks) {
    size = _("tickSize");
    children3.push(axisTicks(spec, config, encode2.ticks, ticksRef, size, band11));
  }
  if (datum2.labels) {
    size = datum2.ticks ? size : 0;
    children3.push(axisLabels(spec, config, encode2.labels, ticksRef, size, band11));
  }
  if (datum2.domain) {
    children3.push(axisDomain(spec, config, encode2.domain, dataRef));
  }
  if (datum2.title) {
    children3.push(axisTitle(spec, config, encode2.title, dataRef));
  }
  return parseMark(guideGroup({
    role: AxisRole2,
    from: dataRef,
    encode: extendEncode(buildAxisEncode(_, spec), axisEncode, Skip3),
    marks: children3,
    aria: _("aria"),
    description: _("description"),
    zindex: _("zindex"),
    name,
    interactive: interactive2,
    style: style6
  }), scope);
}
function buildAxisEncode(_, spec) {
  const encode2 = {
    enter: {},
    update: {}
  };
  addEncoders(encode2, {
    orient: _("orient"),
    offset: _("offset") || 0,
    position: value6(spec.position, 0),
    titlePadding: _("titlePadding"),
    minExtent: _("minExtent"),
    maxExtent: _("maxExtent"),
    range: {
      signal: `abs(span(range("${spec.scale}")))`
    },
    translate: _("translate"),
    // accessibility support
    format: spec.format,
    formatType: spec.formatType
  });
  return encode2;
}
function parseScope(spec, scope, preprocessed) {
  const signals = array20(spec.signals), scales10 = array20(spec.scales);
  if (!preprocessed)
    signals.forEach((_) => parseSignal(_, scope));
  array20(spec.projections).forEach((_) => parseProjection(_, scope));
  scales10.forEach((_) => initScale(_, scope));
  array20(spec.data).forEach((_) => parseData(_, scope));
  scales10.forEach((_) => parseScale(_, scope));
  (preprocessed || signals).forEach((_) => parseSignalUpdates(_, scope));
  array20(spec.axes).forEach((_) => parseAxis(_, scope));
  array20(spec.marks).forEach((_) => parseMark(_, scope));
  array20(spec.legends).forEach((_) => parseLegend(_, scope));
  if (spec.title)
    parseTitle(spec.title, scope);
  scope.parseLambdas();
  return scope;
}
var rootEncode = (spec) => extendEncode({
  enter: {
    x: {
      value: 0
    },
    y: {
      value: 0
    }
  },
  update: {
    width: {
      signal: "width"
    },
    height: {
      signal: "height"
    }
  }
}, spec);
function parseView(spec, scope) {
  const config = scope.config;
  const root = ref(scope.root = scope.add(operator()));
  const signals = collectSignals(spec, config);
  signals.forEach((_) => parseSignal(_, scope));
  scope.description = spec.description || config.description;
  scope.eventConfig = config.events;
  scope.legends = scope.objectProperty(config.legend && config.legend.layout);
  scope.locale = config.locale;
  const input = scope.add(Collect2());
  const encode2 = scope.add(Encode2(parseEncode(rootEncode(spec.encode), GroupMark, FrameRole2, spec.style, scope, {
    pulse: ref(input)
  })));
  const parent = scope.add(ViewLayout2({
    layout: scope.objectProperty(spec.layout),
    legends: scope.legends,
    autosize: scope.signalRef("autosize"),
    mark: root,
    pulse: ref(encode2)
  }));
  scope.operators.pop();
  scope.pushState(ref(encode2), ref(parent), null);
  parseScope(spec, scope, signals);
  scope.operators.push(parent);
  let op = scope.add(Bound2({
    mark: root,
    pulse: ref(parent)
  }));
  op = scope.add(Render2({
    pulse: ref(op)
  }));
  op = scope.add(Sieve2({
    pulse: ref(op)
  }));
  scope.addData("root", new DataScope(scope, input, input, op));
  return scope;
}
function signalObject(name, value7) {
  return value7 && value7.signal ? {
    name,
    update: value7.signal
  } : {
    name,
    value: value7
  };
}
function collectSignals(spec, config) {
  const _ = (name) => value6(spec[name], config[name]), signals = [signalObject("background", _("background")), signalObject("autosize", parseAutosize(_("autosize"))), signalObject("padding", parsePadding(_("padding"))), signalObject("width", _("width") || 0), signalObject("height", _("height") || 0)], pre = signals.reduce((p, s2) => (p[s2.name] = s2, p), {}), map13 = {};
  array20(spec.signals).forEach((s2) => {
    if (has17(pre, s2.name)) {
      s2 = extend19(pre[s2.name], s2);
    } else {
      signals.push(s2);
    }
    map13[s2.name] = s2;
  });
  array20(config.signals).forEach((s2) => {
    if (!has17(map13, s2.name) && !has17(pre, s2.name)) {
      signals.push(s2);
    }
  });
  return signals;
}
function Scope(config, options) {
  this.config = config || {};
  this.options = options || {};
  this.bindings = [];
  this.field = {};
  this.signals = {};
  this.lambdas = {};
  this.scales = {};
  this.events = {};
  this.data = {};
  this.streams = [];
  this.updates = [];
  this.operators = [];
  this.eventConfig = null;
  this.locale = null;
  this._id = 0;
  this._subid = 0;
  this._nextsub = [0];
  this._parent = [];
  this._encode = [];
  this._lookup = [];
  this._markpath = [];
}
function Subscope(scope) {
  this.config = scope.config;
  this.options = scope.options;
  this.legends = scope.legends;
  this.field = Object.create(scope.field);
  this.signals = Object.create(scope.signals);
  this.lambdas = Object.create(scope.lambdas);
  this.scales = Object.create(scope.scales);
  this.events = Object.create(scope.events);
  this.data = Object.create(scope.data);
  this.streams = [];
  this.updates = [];
  this.operators = [];
  this._id = 0;
  this._subid = ++scope._nextsub[0];
  this._nextsub = scope._nextsub;
  this._parent = scope._parent.slice();
  this._encode = scope._encode.slice();
  this._lookup = scope._lookup.slice();
  this._markpath = scope._markpath;
}
Scope.prototype = Subscope.prototype = {
  parse(spec) {
    return parseScope(spec, this);
  },
  fork() {
    return new Subscope(this);
  },
  isSubscope() {
    return this._subid > 0;
  },
  toRuntime() {
    this.finish();
    return {
      description: this.description,
      operators: this.operators,
      streams: this.streams,
      updates: this.updates,
      bindings: this.bindings,
      eventConfig: this.eventConfig,
      locale: this.locale
    };
  },
  id() {
    return (this._subid ? this._subid + ":" : 0) + this._id++;
  },
  add(op) {
    this.operators.push(op);
    op.id = this.id();
    if (op.refs) {
      op.refs.forEach((ref2) => {
        ref2.$ref = op.id;
      });
      op.refs = null;
    }
    return op;
  },
  proxy(op) {
    const vref = op instanceof Entry ? ref(op) : op;
    return this.add(Proxy2({
      value: vref
    }));
  },
  addStream(stream2) {
    this.streams.push(stream2);
    stream2.id = this.id();
    return stream2;
  },
  addUpdate(update3) {
    this.updates.push(update3);
    return update3;
  },
  // Apply metadata
  finish() {
    let name, ds;
    if (this.root)
      this.root.root = true;
    for (name in this.signals) {
      this.signals[name].signal = name;
    }
    for (name in this.scales) {
      this.scales[name].scale = name;
    }
    function annotate(op, name2, type7) {
      let data3, list;
      if (op) {
        data3 = op.data || (op.data = {});
        list = data3[name2] || (data3[name2] = []);
        list.push(type7);
      }
    }
    for (name in this.data) {
      ds = this.data[name];
      annotate(ds.input, name, "input");
      annotate(ds.output, name, "output");
      annotate(ds.values, name, "values");
      for (const field25 in ds.index) {
        annotate(ds.index[field25], name, "index:" + field25);
      }
    }
    return this;
  },
  // ----
  pushState(encode2, parent, lookup10) {
    this._encode.push(ref(this.add(Sieve2({
      pulse: encode2
    }))));
    this._parent.push(parent);
    this._lookup.push(lookup10 ? ref(this.proxy(lookup10)) : null);
    this._markpath.push(-1);
  },
  popState() {
    this._encode.pop();
    this._parent.pop();
    this._lookup.pop();
    this._markpath.pop();
  },
  parent() {
    return peek13(this._parent);
  },
  encode() {
    return peek13(this._encode);
  },
  lookup() {
    return peek13(this._lookup);
  },
  markpath() {
    const p = this._markpath;
    return ++p[p.length - 1];
  },
  // ----
  fieldRef(field25, name) {
    if (isString12(field25))
      return fieldRef$1(field25, name);
    if (!field25.signal) {
      error20("Unsupported field reference: " + $9(field25));
    }
    const s2 = field25.signal;
    let f = this.field[s2];
    if (!f) {
      const params2 = {
        name: this.signalRef(s2)
      };
      if (name)
        params2.as = name;
      this.field[s2] = f = ref(this.add(Field2(params2)));
    }
    return f;
  },
  compareRef(cmp) {
    let signal = false;
    const check = (_) => isSignal(_) ? (signal = true, this.signalRef(_.signal)) : isExpr$1(_) ? (signal = true, this.exprRef(_.expr)) : _;
    const fields = array20(cmp.field).map(check), orders = array20(cmp.order).map(check);
    return signal ? ref(this.add(Compare2({
      fields,
      orders
    }))) : compareRef(fields, orders);
  },
  keyRef(fields, flat) {
    let signal = false;
    const check = (_) => isSignal(_) ? (signal = true, ref(sig[_.signal])) : _;
    const sig = this.signals;
    fields = array20(fields).map(check);
    return signal ? ref(this.add(Key2({
      fields,
      flat
    }))) : keyRef(fields, flat);
  },
  sortRef(sort4) {
    if (!sort4)
      return sort4;
    const a4 = aggrField(sort4.op, sort4.field), o = sort4.order || Ascending;
    return o.signal ? ref(this.add(Compare2({
      fields: a4,
      orders: this.signalRef(o.signal)
    }))) : compareRef(a4, o);
  },
  // ----
  event(source3, type7) {
    const key4 = source3 + ":" + type7;
    if (!this.events[key4]) {
      const id24 = this.id();
      this.streams.push({
        id: id24,
        source: source3,
        type: type7
      });
      this.events[key4] = id24;
    }
    return this.events[key4];
  },
  // ----
  hasOwnSignal(name) {
    return has17(this.signals, name);
  },
  addSignal(name, value7) {
    if (this.hasOwnSignal(name)) {
      error20("Duplicate signal name: " + $9(name));
    }
    const op = value7 instanceof Entry ? value7 : this.add(operator(value7));
    return this.signals[name] = op;
  },
  getSignal(name) {
    if (!this.signals[name]) {
      error20("Unrecognized signal name: " + $9(name));
    }
    return this.signals[name];
  },
  signalRef(s2) {
    if (this.signals[s2]) {
      return ref(this.signals[s2]);
    } else if (!has17(this.lambdas, s2)) {
      this.lambdas[s2] = this.add(operator(null));
    }
    return ref(this.lambdas[s2]);
  },
  parseLambdas() {
    const code = Object.keys(this.lambdas);
    for (let i = 0, n = code.length; i < n; ++i) {
      const s2 = code[i], e3 = parser2(s2, this), op = this.lambdas[s2];
      op.params = e3.$params;
      op.update = e3.$expr;
    }
  },
  property(spec) {
    return spec && spec.signal ? this.signalRef(spec.signal) : spec;
  },
  objectProperty(spec) {
    return !spec || !isObject11(spec) ? spec : this.signalRef(spec.signal || propertyLambda(spec));
  },
  exprRef(code, name) {
    const params2 = {
      expr: parser2(code, this)
    };
    if (name)
      params2.expr.$name = name;
    return ref(this.add(Expression2(params2)));
  },
  addBinding(name, bind7) {
    if (!this.bindings) {
      error20("Nested signals do not support binding: " + $9(name));
    }
    this.bindings.push(extend19({
      signal: name
    }, bind7));
  },
  // ----
  addScaleProj(name, transform4) {
    if (has17(this.scales, name)) {
      error20("Duplicate scale or projection name: " + $9(name));
    }
    this.scales[name] = this.add(transform4);
  },
  addScale(name, params2) {
    this.addScaleProj(name, Scale2(params2));
  },
  addProjection(name, params2) {
    this.addScaleProj(name, Projection2(params2));
  },
  getScale(name) {
    if (!this.scales[name]) {
      error20("Unrecognized scale name: " + $9(name));
    }
    return this.scales[name];
  },
  scaleRef(name) {
    return ref(this.getScale(name));
  },
  scaleType(name) {
    return this.getScale(name).params.type;
  },
  projectionRef(name) {
    return this.scaleRef(name);
  },
  projectionType(name) {
    return this.scaleType(name);
  },
  // ----
  addData(name, dataScope) {
    if (has17(this.data, name)) {
      error20("Duplicate data set name: " + $9(name));
    }
    return this.data[name] = dataScope;
  },
  getData(name) {
    if (!this.data[name]) {
      error20("Undefined data set name: " + $9(name));
    }
    return this.data[name];
  },
  addDataPipeline(name, entries2) {
    if (has17(this.data, name)) {
      error20("Duplicate data set name: " + $9(name));
    }
    return this.addData(name, DataScope.fromEntries(this, entries2));
  }
};
function propertyLambda(spec) {
  return (isArray20(spec) ? arrayLambda : objectLambda)(spec);
}
function arrayLambda(array22) {
  const n = array22.length;
  let code = "[";
  for (let i = 0; i < n; ++i) {
    const value7 = array22[i];
    code += (i > 0 ? "," : "") + (isObject11(value7) ? value7.signal || propertyLambda(value7) : $9(value7));
  }
  return code + "]";
}
function objectLambda(obj) {
  let code = "{", i = 0, key4, value7;
  for (key4 in obj) {
    value7 = obj[key4];
    code += (++i > 1 ? "," : "") + $9(key4) + ":" + (isObject11(value7) ? value7.signal || propertyLambda(value7) : $9(value7));
  }
  return code + "}";
}
function defaults() {
  const defaultFont2 = "sans-serif", defaultSymbolSize = 30, defaultStrokeWidth = 2, defaultColor = "#4c78a8", black = "#000", gray2 = "#888", lightGray = "#ddd";
  return {
    // default visualization description
    description: "Vega visualization",
    // default padding around visualization
    padding: 0,
    // default for automatic sizing; options: 'none', 'pad', 'fit'
    // or provide an object (e.g., {'type': 'pad', 'resize': true})
    autosize: "pad",
    // default view background color
    // covers the entire view component
    background: null,
    // default event handling configuration
    // preventDefault for view-sourced event types except 'wheel'
    events: {
      defaults: {
        allow: ["wheel"]
      }
    },
    // defaults for top-level group marks
    // accepts mark properties (fill, stroke, etc)
    // covers the data rectangle within group width/height
    group: null,
    // defaults for basic mark types
    // each subset accepts mark properties (fill, stroke, etc)
    mark: null,
    arc: {
      fill: defaultColor
    },
    area: {
      fill: defaultColor
    },
    image: null,
    line: {
      stroke: defaultColor,
      strokeWidth: defaultStrokeWidth
    },
    path: {
      stroke: defaultColor
    },
    rect: {
      fill: defaultColor
    },
    rule: {
      stroke: black
    },
    shape: {
      stroke: defaultColor
    },
    symbol: {
      fill: defaultColor,
      size: 64
    },
    text: {
      fill: black,
      font: defaultFont2,
      fontSize: 11
    },
    trail: {
      fill: defaultColor,
      size: defaultStrokeWidth
    },
    // style definitions
    style: {
      // axis & legend labels
      "guide-label": {
        fill: black,
        font: defaultFont2,
        fontSize: 10
      },
      // axis & legend titles
      "guide-title": {
        fill: black,
        font: defaultFont2,
        fontSize: 11,
        fontWeight: "bold"
      },
      // headers, including chart title
      "group-title": {
        fill: black,
        font: defaultFont2,
        fontSize: 13,
        fontWeight: "bold"
      },
      // chart subtitle
      "group-subtitle": {
        fill: black,
        font: defaultFont2,
        fontSize: 12
      },
      // defaults for styled point marks in Vega-Lite
      point: {
        size: defaultSymbolSize,
        strokeWidth: defaultStrokeWidth,
        shape: "circle"
      },
      circle: {
        size: defaultSymbolSize,
        strokeWidth: defaultStrokeWidth
      },
      square: {
        size: defaultSymbolSize,
        strokeWidth: defaultStrokeWidth,
        shape: "square"
      },
      // defaults for styled group marks in Vega-Lite
      cell: {
        fill: "transparent",
        stroke: lightGray
      },
      view: {
        fill: "transparent"
      }
    },
    // defaults for title
    title: {
      orient: "top",
      anchor: "middle",
      offset: 4,
      subtitlePadding: 3
    },
    // defaults for axes
    axis: {
      minExtent: 0,
      maxExtent: 200,
      bandPosition: 0.5,
      domain: true,
      domainWidth: 1,
      domainColor: gray2,
      grid: false,
      gridWidth: 1,
      gridColor: lightGray,
      labels: true,
      labelAngle: 0,
      labelLimit: 180,
      labelOffset: 0,
      labelPadding: 2,
      ticks: true,
      tickColor: gray2,
      tickOffset: 0,
      tickRound: true,
      tickSize: 5,
      tickWidth: 1,
      titlePadding: 4
    },
    // correction for centering bias
    axisBand: {
      tickOffset: -0.5
    },
    // defaults for cartographic projection
    projection: {
      type: "mercator"
    },
    // defaults for legends
    legend: {
      orient: "right",
      padding: 0,
      gridAlign: "each",
      columnPadding: 10,
      rowPadding: 2,
      symbolDirection: "vertical",
      gradientDirection: "vertical",
      gradientLength: 200,
      gradientThickness: 16,
      gradientStrokeColor: lightGray,
      gradientStrokeWidth: 0,
      gradientLabelOffset: 2,
      labelAlign: "left",
      labelBaseline: "middle",
      labelLimit: 160,
      labelOffset: 4,
      labelOverlap: true,
      symbolLimit: 30,
      symbolType: "circle",
      symbolSize: 100,
      symbolOffset: 0,
      symbolStrokeWidth: 1.5,
      symbolBaseFillColor: "transparent",
      symbolBaseStrokeColor: gray2,
      titleLimit: 180,
      titleOrient: "top",
      titlePadding: 5,
      layout: {
        offset: 18,
        direction: "horizontal",
        left: {
          direction: "vertical"
        },
        right: {
          direction: "vertical"
        }
      }
    },
    // defaults for scale ranges
    range: {
      category: {
        scheme: "tableau10"
      },
      ordinal: {
        scheme: "blues"
      },
      heatmap: {
        scheme: "yellowgreenblue"
      },
      ramp: {
        scheme: "blues"
      },
      diverging: {
        scheme: "blueorange",
        extent: [1, 0]
      },
      symbol: ["circle", "square", "triangle-up", "cross", "diamond", "triangle-right", "triangle-down", "triangle-left"]
    }
  };
}
function parse11(spec, config, options) {
  if (!isObject11(spec)) {
    error20("Input Vega specification must be an object.");
  }
  config = mergeConfig2(defaults(), config, spec.config);
  return parseView(spec, new Scope(config, options)).toRuntime();
}

// node_modules/vega/build/vega.module.js
var version$1 = "6.2.0";
extend(transforms, vega_transforms_exports, vega_view_transforms_exports, vega_encode_exports, vega_geo_exports, vega_force_exports, vega_label_exports, vega_hierarchy_exports, vega_regression_exports, vega_voronoi_exports, vega_wordcloud_exports, vega_crossfilter_exports);
var version = version$1;

// node_modules/vega-interpreter/node_modules/vega-util/build/vega-util.js
function accessor21(fn, fields, name) {
  fn.fields = fields || [];
  fn.fname = name;
  return fn;
}
function getter22(path7) {
  return path7.length === 1 ? get121(path7[0]) : getN21(path7);
}
var get121 = (field25) => function(obj) {
  return obj[field25];
};
var getN21 = (path7) => {
  const len = path7.length;
  return function(obj) {
    for (let i = 0; i < len; ++i) {
      obj = obj[path7[i]];
    }
    return obj;
  };
};
function error21(message) {
  throw Error(message);
}
function splitAccessPath21(p) {
  const path7 = [], n = p.length;
  let q = null, b6 = 0, s2 = "", i, j, c5;
  p = p + "";
  function push() {
    path7.push(s2 + p.substring(i, j));
    s2 = "";
    i = j + 1;
  }
  for (i = j = 0; j < n; ++j) {
    c5 = p[j];
    if (c5 === "\\") {
      s2 += p.substring(i, j++);
      i = j;
    } else if (c5 === q) {
      push();
      q = null;
      b6 = -1;
    } else if (q) {
      continue;
    } else if (i === b6 && c5 === '"') {
      i = j + 1;
      q = c5;
    } else if (i === b6 && c5 === "'") {
      i = j + 1;
      q = c5;
    } else if (c5 === "." && !b6) {
      if (j > i) {
        push();
      } else {
        i = j + 1;
      }
    } else if (c5 === "[") {
      if (j > i)
        push();
      b6 = i = j + 1;
    } else if (c5 === "]") {
      if (!b6)
        error21("Access path missing open bracket: " + p);
      if (b6 > 0)
        push();
      b6 = 0;
      i = j + 1;
    }
  }
  if (b6)
    error21("Access path missing closing bracket: " + p);
  if (q)
    error21("Access path missing closing quote: " + p);
  if (j > i) {
    j++;
    push();
  }
  return path7;
}
function field22(field25, name, opt) {
  const path7 = splitAccessPath21(field25);
  field25 = path7.length === 1 ? path7[0] : field25;
  return accessor21((opt && opt.get || getter22)(path7), [field25], name || field25);
}
var id21 = field22("id");
var identity25 = accessor21((_) => _, [], "identity");
var zero24 = accessor21(() => 0, [], "zero");
var one23 = accessor21(() => 1, [], "one");
var truthy21 = accessor21(() => true, [], "true");
var falsy21 = accessor21(() => false, [], "false");
var DisallowedObjectProperties21 = /* @__PURE__ */ new Set([...Object.getOwnPropertyNames(Object.prototype).filter((name) => typeof Object.prototype[name] === "function"), "__proto__"]);
var isArray21 = Array.isArray;
var ascending12 = (u4, v2) => (u4 < v2 || u4 == null) && v2 != null ? -1 : (u4 > v2 || v2 == null) && u4 != null ? 1 : (v2 = v2 instanceof Date ? +v2 : v2, u4 = u4 instanceof Date ? +u4 : u4) !== u4 && v2 === v2 ? -1 : v2 !== v2 && u4 === u4 ? 1 : 0;
function isString13(_) {
  return typeof _ === "string";
}

// node_modules/vega-interpreter/build/vega-interpreter.js
function adjustSpatial2(item, encode2, swap3) {
  let t;
  if (encode2.x2) {
    if (encode2.x) {
      if (swap3 && item.x > item.x2) {
        t = item.x;
        item.x = item.x2;
        item.x2 = t;
      }
      item.width = item.x2 - item.x;
    } else {
      item.x = item.x2 - (item.width || 0);
    }
  }
  if (encode2.xc) {
    item.x = item.xc - (item.width || 0) / 2;
  }
  if (encode2.y2) {
    if (encode2.y) {
      if (swap3 && item.y > item.y2) {
        t = item.y;
        item.y = item.y2;
        item.y2 = t;
      }
      item.height = item.y2 - item.y;
    } else {
      item.y = item.y2 - (item.height || 0);
    }
  }
  if (encode2.yc) {
    item.y = item.yc - (item.height || 0) / 2;
  }
}
var Constants2 = {
  NaN: NaN,
  E: Math.E,
  LN2: Math.LN2,
  LN10: Math.LN10,
  LOG2E: Math.LOG2E,
  LOG10E: Math.LOG10E,
  PI: Math.PI,
  SQRT1_2: Math.SQRT1_2,
  SQRT2: Math.SQRT2,
  MIN_VALUE: Number.MIN_VALUE,
  MAX_VALUE: Number.MAX_VALUE
};
var Ops = {
  "*": (a4, b6) => a4 * b6,
  "+": (a4, b6) => a4 + b6,
  "-": (a4, b6) => a4 - b6,
  "/": (a4, b6) => a4 / b6,
  "%": (a4, b6) => a4 % b6,
  ">": (a4, b6) => a4 > b6,
  "<": (a4, b6) => a4 < b6,
  "<=": (a4, b6) => a4 <= b6,
  ">=": (a4, b6) => a4 >= b6,
  "==": (a4, b6) => a4 == b6,
  "!=": (a4, b6) => a4 != b6,
  "===": (a4, b6) => a4 === b6,
  "!==": (a4, b6) => a4 !== b6,
  "&": (a4, b6) => a4 & b6,
  "|": (a4, b6) => a4 | b6,
  "^": (a4, b6) => a4 ^ b6,
  "<<": (a4, b6) => a4 << b6,
  ">>": (a4, b6) => a4 >> b6,
  ">>>": (a4, b6) => a4 >>> b6
};
var Unary = {
  "+": (a4) => +a4,
  "-": (a4) => -a4,
  "~": (a4) => ~a4,
  "!": (a4) => !a4
};
var slice13 = Array.prototype.slice;
var apply10 = (m3, args, cast) => {
  const obj = cast ? cast(args[0]) : args[0];
  return obj[m3].apply(obj, slice13.call(args, 1));
};
var datetime = (yearOrTimestring, m3 = 0, d = 1, H = 0, M2 = 0, S = 0, ms = 0) => isString13(yearOrTimestring) ? new Date(yearOrTimestring) : new Date(yearOrTimestring, m3, d, H, M2, S, ms);
var Functions2 = {
  // math functions
  isNaN: Number.isNaN,
  isFinite: Number.isFinite,
  abs: Math.abs,
  acos: Math.acos,
  asin: Math.asin,
  atan: Math.atan,
  atan2: Math.atan2,
  ceil: Math.ceil,
  cos: Math.cos,
  exp: Math.exp,
  floor: Math.floor,
  log: Math.log,
  max: Math.max,
  min: Math.min,
  pow: Math.pow,
  random: Math.random,
  round: Math.round,
  sin: Math.sin,
  sqrt: Math.sqrt,
  tan: Math.tan,
  clamp: (a4, b6, c5) => Math.max(b6, Math.min(c5, a4)),
  // date functions
  now: Date.now,
  utc: Date.UTC,
  datetime,
  date: (d) => new Date(d).getDate(),
  day: (d) => new Date(d).getDay(),
  year: (d) => new Date(d).getFullYear(),
  month: (d) => new Date(d).getMonth(),
  hours: (d) => new Date(d).getHours(),
  minutes: (d) => new Date(d).getMinutes(),
  seconds: (d) => new Date(d).getSeconds(),
  milliseconds: (d) => new Date(d).getMilliseconds(),
  time: (d) => new Date(d).getTime(),
  timezoneoffset: (d) => new Date(d).getTimezoneOffset(),
  utcdate: (d) => new Date(d).getUTCDate(),
  utcday: (d) => new Date(d).getUTCDay(),
  utcyear: (d) => new Date(d).getUTCFullYear(),
  utcmonth: (d) => new Date(d).getUTCMonth(),
  utchours: (d) => new Date(d).getUTCHours(),
  utcminutes: (d) => new Date(d).getUTCMinutes(),
  utcseconds: (d) => new Date(d).getUTCSeconds(),
  utcmilliseconds: (d) => new Date(d).getUTCMilliseconds(),
  // sequence functions
  length: (x9) => x9.length,
  join: function() {
    return apply10("join", arguments);
  },
  indexof: function() {
    return apply10("indexOf", arguments);
  },
  lastindexof: function() {
    return apply10("lastIndexOf", arguments);
  },
  slice: function() {
    return apply10("slice", arguments);
  },
  reverse: (x9) => x9.slice().reverse(),
  sort: (x9) => x9.slice().sort(ascending12),
  // string functions
  parseFloat,
  parseInt,
  upper: (x9) => String(x9).toUpperCase(),
  lower: (x9) => String(x9).toLowerCase(),
  substring: function() {
    return apply10("substring", arguments, String);
  },
  split: function() {
    return apply10("split", arguments, String);
  },
  replace: function() {
    return apply10("replace", arguments, String);
  },
  trim: (x9) => String(x9).trim(),
  // Base64 encode/decode
  // Convert binary string to base64-encoded ascii
  btoa: (x9) => btoa(x9),
  // Convert base64-encoded ascii to binary string
  atob: (x9) => atob(x9),
  // regexp functions
  regexp: RegExp,
  test: (r, t) => RegExp(r).test(t)
};
var EventFunctions = ["view", "item", "group", "xy", "x", "y"];
var DisallowedMethods = /* @__PURE__ */ new Set([Function, eval, setTimeout, setInterval]);
if (typeof setImmediate === "function")
  DisallowedMethods.add(setImmediate);
var Visitors = {
  Literal: ($11, n) => n.value,
  Identifier: ($11, n) => {
    const id24 = n.name;
    return $11.memberDepth > 0 ? id24 : id24 === "datum" ? $11.datum : id24 === "event" ? $11.event : id24 === "item" ? $11.item : Constants2[id24] || $11.params["$" + id24];
  },
  MemberExpression: ($11, n) => {
    const d = !n.computed, o = $11(n.object);
    if (d)
      $11.memberDepth += 1;
    const p = $11(n.property);
    if (d)
      $11.memberDepth -= 1;
    if (DisallowedMethods.has(o[p])) {
      console.error(`Prevented interpretation of member "${p}" which could lead to insecure code execution`);
      return;
    }
    return o[p];
  },
  CallExpression: ($11, n) => {
    const args = n.arguments;
    let name = n.callee.name;
    if (name.startsWith("_")) {
      name = name.slice(1);
    }
    return name === "if" ? $11(args[0]) ? $11(args[1]) : $11(args[2]) : ($11.fn[name] || Functions2[name]).apply($11.fn, args.map($11));
  },
  ArrayExpression: ($11, n) => n.elements.map($11),
  BinaryExpression: ($11, n) => Ops[n.operator]($11(n.left), $11(n.right)),
  UnaryExpression: ($11, n) => Unary[n.operator]($11(n.argument)),
  ConditionalExpression: ($11, n) => $11(n.test) ? $11(n.consequent) : $11(n.alternate),
  LogicalExpression: ($11, n) => n.operator === "&&" ? $11(n.left) && $11(n.right) : $11(n.left) || $11(n.right),
  ObjectExpression: ($11, n) => n.properties.reduce((o, p) => {
    $11.memberDepth += 1;
    const k3 = $11(p.key);
    $11.memberDepth -= 1;
    const v2 = $11(p.value);
    if (DisallowedObjectProperties21.has(k3)) {
      console.error(`Prevented interpretation of property "${k3}" which could lead to insecure code execution`);
    } else if (DisallowedMethods.has(v2)) {
      console.error(`Prevented interpretation of method "${k3}" which could lead to insecure code execution`);
    } else {
      o[k3] = v2;
    }
    return o;
  }, {})
};
function interpret(ast, fn, params2, datum2, event2, item) {
  const $11 = (n) => Visitors[n.type]($11, n);
  $11.memberDepth = 0;
  $11.fn = Object.create(fn);
  $11.params = params2;
  $11.datum = datum2;
  $11.event = event2;
  $11.item = item;
  EventFunctions.forEach((f) => $11.fn[f] = (...args) => event2.vega[f](...args));
  return $11(ast);
}
var expression2 = {
  /**
   * Parse an expression used to update an operator value.
   */
  operator(ctx, expr2) {
    const ast = expr2.ast, fn = ctx.functions;
    return (_) => interpret(ast, fn, _);
  },
  /**
   * Parse an expression provided as an operator parameter value.
   */
  parameter(ctx, expr2) {
    const ast = expr2.ast, fn = ctx.functions;
    return (datum2, _) => interpret(ast, fn, _, datum2);
  },
  /**
   * Parse an expression applied to an event stream.
   */
  event(ctx, expr2) {
    const ast = expr2.ast, fn = ctx.functions;
    return (event2) => interpret(ast, fn, void 0, void 0, event2);
  },
  /**
   * Parse an expression used to handle an event-driven operator update.
   */
  handler(ctx, expr2) {
    const ast = expr2.ast, fn = ctx.functions;
    return (_, event2) => {
      const datum2 = event2.item && event2.item.datum;
      return interpret(ast, fn, _, datum2, event2);
    };
  },
  /**
   * Parse an expression that performs visual encoding.
   */
  encode(ctx, encode2) {
    const {
      marktype,
      channels
    } = encode2, fn = ctx.functions, swap3 = marktype === "group" || marktype === "image" || marktype === "rect";
    return (item, _) => {
      const datum2 = item.datum;
      let m3 = 0, v2;
      for (const name in channels) {
        v2 = interpret(channels[name].ast, fn, _, datum2, void 0, item);
        if (item[name] !== v2) {
          item[name] = v2;
          m3 = 1;
        }
      }
      if (marktype !== "rule") {
        adjustSpatial2(item, channels, swap3);
      }
      return m3;
    };
  }
};

// node_modules/vega-lite/build/index.js
var build_exports = {};
__export(build_exports, {
  accessPathDepth: () => accessPathDepth,
  accessPathWithDatum: () => accessPathWithDatum,
  accessWithDatumToUnescapedPath: () => accessWithDatumToUnescapedPath,
  compile: () => compile,
  contains: () => contains2,
  deepEqual: () => deepEqual,
  deleteNestedProperty: () => deleteNestedProperty,
  duplicate: () => duplicate,
  entries: () => entries$1,
  every: () => every2,
  fieldIntersection: () => fieldIntersection,
  flatAccessWithDatum: () => flatAccessWithDatum,
  getFirstDefined: () => getFirstDefined,
  hasIntersection: () => hasIntersection,
  hasProperty: () => hasProperty,
  hash: () => hash,
  internalField: () => internalField,
  isBoolean: () => isBoolean6,
  isEmpty: () => isEmpty,
  isEqual: () => isEqual,
  isInternalField: () => isInternalField,
  isNullOrFalse: () => isNullOrFalse,
  isNumeric: () => isNumeric,
  keys: () => keys4,
  logicalExpr: () => logicalExpr,
  mergeDeep: () => mergeDeep,
  never: () => never,
  normalize: () => normalize3,
  normalizeAngle: () => normalizeAngle,
  omit: () => omit,
  pick: () => pick6,
  prefixGenerator: () => prefixGenerator,
  removePathFromField: () => removePathFromField,
  replaceAll: () => replaceAll,
  replacePathInField: () => replacePathInField,
  resetIdCounter: () => resetIdCounter,
  setEqual: () => setEqual,
  some: () => some2,
  stringify: () => stringify2,
  titleCase: () => titleCase,
  unescapeSingleQuoteAndPathDot: () => unescapeSingleQuoteAndPathDot,
  unique: () => unique,
  uniqueId: () => uniqueId,
  vals: () => vals,
  varName: () => varName,
  version: () => version2
});

// node_modules/vega-lite/node_modules/vega-util/build/vega-util.js
function accessor22(fn, fields, name) {
  fn.fields = fields || [];
  fn.fname = name;
  return fn;
}
function getter23(path7) {
  return path7.length === 1 ? get122(path7[0]) : getN22(path7);
}
var get122 = (field25) => function(obj) {
  return obj[field25];
};
var getN22 = (path7) => {
  const len = path7.length;
  return function(obj) {
    for (let i = 0; i < len; ++i) {
      obj = obj[path7[i]];
    }
    return obj;
  };
};
function error22(message) {
  throw Error(message);
}
function splitAccessPath22(p) {
  const path7 = [], n = p.length;
  let q = null, b6 = 0, s2 = "", i, j, c5;
  p = p + "";
  function push() {
    path7.push(s2 + p.substring(i, j));
    s2 = "";
    i = j + 1;
  }
  for (i = j = 0; j < n; ++j) {
    c5 = p[j];
    if (c5 === "\\") {
      s2 += p.substring(i, j++);
      i = j;
    } else if (c5 === q) {
      push();
      q = null;
      b6 = -1;
    } else if (q) {
      continue;
    } else if (i === b6 && c5 === '"') {
      i = j + 1;
      q = c5;
    } else if (i === b6 && c5 === "'") {
      i = j + 1;
      q = c5;
    } else if (c5 === "." && !b6) {
      if (j > i) {
        push();
      } else {
        i = j + 1;
      }
    } else if (c5 === "[") {
      if (j > i)
        push();
      b6 = i = j + 1;
    } else if (c5 === "]") {
      if (!b6)
        error22("Access path missing open bracket: " + p);
      if (b6 > 0)
        push();
      b6 = 0;
      i = j + 1;
    }
  }
  if (b6)
    error22("Access path missing closing bracket: " + p);
  if (q)
    error22("Access path missing closing quote: " + p);
  if (j > i) {
    j++;
    push();
  }
  return path7;
}
function field23(field25, name, opt) {
  const path7 = splitAccessPath22(field25);
  field25 = path7.length === 1 ? path7[0] : field25;
  return accessor22((opt && opt.get || getter23)(path7), [field25], name || field25);
}
var id22 = field23("id");
var identity26 = accessor22((_) => _, [], "identity");
var zero25 = accessor22(() => 0, [], "zero");
var one24 = accessor22(() => 1, [], "one");
var truthy22 = accessor22(() => true, [], "true");
var falsy22 = accessor22(() => false, [], "false");
var DisallowedObjectProperties22 = /* @__PURE__ */ new Set([...Object.getOwnPropertyNames(Object.prototype).filter((name) => typeof Object.prototype[name] === "function"), "__proto__"]);
function log$13(method10, level, input) {
  const args = [level].concat([].slice.call(input));
  console[method10].apply(console, args);
}
var None9 = 0;
var Error$13 = 1;
var Warn3 = 2;
var Info3 = 3;
var Debug3 = 4;
function logger3(_, method10, handler = log$13) {
  let level = _ || None9;
  return {
    level(_2) {
      if (arguments.length) {
        level = +_2;
        return this;
      } else {
        return level;
      }
    },
    error() {
      if (level >= Error$13)
        handler(method10 || "error", "ERROR", arguments);
      return this;
    },
    warn() {
      if (level >= Warn3)
        handler(method10 || "warn", "WARN", arguments);
      return this;
    },
    info() {
      if (level >= Info3)
        handler(method10 || "log", "INFO", arguments);
      return this;
    },
    debug() {
      if (level >= Debug3)
        handler(method10 || "log", "DEBUG", arguments);
      return this;
    }
  };
}
var isArray22 = Array.isArray;
function isObject12(_) {
  return _ === Object(_);
}
var isLegalKey3 = (key4) => key4 !== "__proto__";
function mergeConfig3(...configs) {
  return configs.reduce((out, source3) => {
    for (const key4 in source3) {
      if (key4 === "signals") {
        out.signals = mergeNamed3(out.signals, source3.signals);
      } else {
        const r = key4 === "legend" ? {
          layout: 1
        } : key4 === "style" ? true : null;
        writeConfig3(out, key4, source3[key4], r);
      }
    }
    return out;
  }, {});
}
function writeConfig3(output3, key4, value7, recurse6) {
  if (!isLegalKey3(key4))
    return;
  let k3, o;
  if (isObject12(value7) && !isArray22(value7)) {
    o = isObject12(output3[key4]) ? output3[key4] : output3[key4] = {};
    for (k3 in value7) {
      if (recurse6 && (recurse6 === true || recurse6[k3])) {
        writeConfig3(o, k3, value7[k3]);
      } else if (isLegalKey3(k3)) {
        o[k3] = value7[k3];
      }
    }
  } else {
    output3[key4] = value7;
  }
}
function mergeNamed3(a4, b6) {
  if (a4 == null)
    return b6;
  const map13 = {}, out = [];
  function add10(_) {
    if (!map13[_.name]) {
      map13[_.name] = 1;
      out.push(_);
    }
  }
  b6.forEach(add10);
  a4.forEach(add10);
  return out;
}
function array21(_) {
  return _ != null ? isArray22(_) ? _ : [_] : [];
}
function isFunction14(_) {
  return typeof _ === "function";
}
function has19(object2, property2) {
  return Object.hasOwn(object2, property2);
}
function isBoolean5(_) {
  return typeof _ === "boolean";
}
function isNumber14(_) {
  return typeof _ === "number";
}
function isString14(_) {
  return typeof _ === "string";
}
function $10(x9) {
  return isArray22(x9) ? `[${x9.map((v2) => v2 === null ? "null" : $10(v2))}]` : isObject12(x9) || isString14(x9) ? (
    // Output valid JSON and JS source strings.
    // See https://github.com/judofyr/timeless/blob/master/posts/json-isnt-a-javascript-subset.md
    JSON.stringify(x9).replaceAll("\u2028", "\\u2028").replaceAll("\u2029", "\\u2029")
  ) : x9;
}

// node_modules/vega-lite/build/index.js
var version$12 = "6.4.1";
var pkg = {
  version: version$12
};
function isLogicalOr(op) {
  return hasProperty(op, "or");
}
function isLogicalAnd(op) {
  return hasProperty(op, "and");
}
function isLogicalNot(op) {
  return hasProperty(op, "not");
}
function forEachLeaf(op, fn) {
  if (isLogicalNot(op)) {
    forEachLeaf(op.not, fn);
  } else if (isLogicalAnd(op)) {
    for (const subop of op.and) {
      forEachLeaf(subop, fn);
    }
  } else if (isLogicalOr(op)) {
    for (const subop of op.or) {
      forEachLeaf(subop, fn);
    }
  } else {
    fn(op);
  }
}
function normalizeLogicalComposition(op, normalizer) {
  if (isLogicalNot(op)) {
    return { not: normalizeLogicalComposition(op.not, normalizer) };
  } else if (isLogicalAnd(op)) {
    return { and: op.and.map((o) => normalizeLogicalComposition(o, normalizer)) };
  } else if (isLogicalOr(op)) {
    return { or: op.or.map((o) => normalizeLogicalComposition(o, normalizer)) };
  } else {
    return normalizer(op);
  }
}
var duplicate = structuredClone;
function never(message) {
  throw new Error(message);
}
function pick6(obj, props) {
  const copy4 = {};
  for (const prop of props) {
    if (has19(obj, prop)) {
      copy4[prop] = obj[prop];
    }
  }
  return copy4;
}
function omit(obj, props) {
  const copy4 = { ...obj };
  for (const prop of props) {
    delete copy4[prop];
  }
  return copy4;
}
Set.prototype["toJSON"] = function() {
  return `Set(${[...this].map((x9) => stringify2(x9)).join(",")})`;
};
function hash(a4) {
  if (isNumber14(a4)) {
    return a4;
  }
  const str = isString14(a4) ? a4 : stringify2(a4);
  if (str.length < 250) {
    return str;
  }
  let h6 = 0;
  for (let i = 0; i < str.length; i++) {
    const char = str.charCodeAt(i);
    h6 = (h6 << 5) - h6 + char;
    h6 = h6 & h6;
  }
  return h6;
}
function isNullOrFalse(x9) {
  return x9 === false || x9 === null;
}
function contains2(array22, item) {
  return array22.includes(item);
}
function some2(arr, f) {
  let i = 0;
  for (const [k3, a4] of arr.entries()) {
    if (f(a4, k3, i++)) {
      return true;
    }
  }
  return false;
}
function every2(arr, f) {
  let i = 0;
  for (const [k3, a4] of arr.entries()) {
    if (!f(a4, k3, i++)) {
      return false;
    }
  }
  return true;
}
function mergeDeep(dest, ...src) {
  for (const s2 of src) {
    deepMerge_(dest, s2 ?? {});
  }
  return dest;
}
function deepMerge_(dest, src) {
  for (const property2 of keys4(src)) {
    writeConfig3(dest, property2, src[property2], true);
  }
}
function unique(values7, f) {
  const results = [];
  const u4 = {};
  let v2;
  for (const val of values7) {
    v2 = f(val);
    if (v2 in u4) {
      continue;
    }
    u4[v2] = 1;
    results.push(val);
  }
  return results;
}
function isEqual(dict, other) {
  const dictKeys = keys4(dict);
  const otherKeys = keys4(other);
  if (dictKeys.length !== otherKeys.length) {
    return false;
  }
  for (const key4 of dictKeys) {
    if (dict[key4] !== other[key4]) {
      return false;
    }
  }
  return true;
}
function setEqual(a4, b6) {
  if (a4.size !== b6.size) {
    return false;
  }
  for (const e3 of a4) {
    if (!b6.has(e3)) {
      return false;
    }
  }
  return true;
}
function hasIntersection(a4, b6) {
  for (const key4 of a4) {
    if (b6.has(key4)) {
      return true;
    }
  }
  return false;
}
function prefixGenerator(a4) {
  const prefixes2 = /* @__PURE__ */ new Set();
  for (const x9 of a4) {
    const splitField = splitAccessPath22(x9);
    const wrappedWithAccessors = splitField.map((y9, i) => i === 0 ? y9 : `[${y9}]`);
    const computedPrefixes = wrappedWithAccessors.map((_, i) => wrappedWithAccessors.slice(0, i + 1).join(""));
    for (const y9 of computedPrefixes) {
      prefixes2.add(y9);
    }
  }
  return prefixes2;
}
function fieldIntersection(a4, b6) {
  if (a4 === void 0 || b6 === void 0) {
    return true;
  }
  return hasIntersection(prefixGenerator(a4), prefixGenerator(b6));
}
function isEmpty(obj) {
  return keys4(obj).length === 0;
}
var keys4 = Object.keys;
var vals = Object.values;
var entries$1 = Object.entries;
function isBoolean6(b6) {
  return b6 === true || b6 === false;
}
function varName(s2) {
  const alphanumericS = s2.replace(/\W/g, "_");
  return (s2.match(/^\d+/) ? "_" : "") + alphanumericS;
}
function logicalExpr(op, cb) {
  if (isLogicalNot(op)) {
    return `!(${logicalExpr(op.not, cb)})`;
  } else if (isLogicalAnd(op)) {
    return `(${op.and.map((and) => logicalExpr(and, cb)).join(") && (")})`;
  } else if (isLogicalOr(op)) {
    return `(${op.or.map((or6) => logicalExpr(or6, cb)).join(") || (")})`;
  } else {
    return cb(op);
  }
}
function deleteNestedProperty(obj, orderedProps) {
  if (orderedProps.length === 0) {
    return true;
  }
  const prop = orderedProps.shift();
  if (prop in obj && deleteNestedProperty(obj[prop], orderedProps)) {
    delete obj[prop];
  }
  return isEmpty(obj);
}
function titleCase(s2) {
  return s2.charAt(0).toUpperCase() + s2.substr(1);
}
function accessPathWithDatum(path7, datum2 = "datum") {
  const pieces = splitAccessPath22(path7);
  const prefixes2 = [];
  for (let i = 1; i <= pieces.length; i++) {
    const prefix = `[${pieces.slice(0, i).map($10).join("][")}]`;
    prefixes2.push(`${datum2}${prefix}`);
  }
  return prefixes2.join(" && ");
}
function flatAccessWithDatum(path7, datum2 = "datum") {
  return `${datum2}[${$10(splitAccessPath22(path7).join("."))}]`;
}
function accessWithDatumToUnescapedPath(unescapedPath) {
  const singleQuoteEscapedPath = unescapedPath.replaceAll("'", "\\'");
  return `datum['${singleQuoteEscapedPath}']`;
}
function unescapeSingleQuoteAndPathDot(escapedPath) {
  return escapedPath.replaceAll("\\'", "'").replaceAll("\\.", ".");
}
function escapePathAccess(string) {
  return string.replace(/(\[|\]|\.|'|")/g, "\\$1");
}
function replacePathInField(path7) {
  return `${splitAccessPath22(path7).map(escapePathAccess).join("\\.")}`;
}
function replaceAll(string, find4, replacement) {
  return string.replace(new RegExp(find4.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&"), "g"), replacement);
}
function removePathFromField(path7) {
  return `${splitAccessPath22(path7).join(".")}`;
}
function accessPathDepth(path7) {
  if (!path7) {
    return 0;
  }
  return splitAccessPath22(path7).length;
}
function getFirstDefined(...args) {
  return args.find((a4) => a4 !== void 0);
}
var idCounter = 42;
function uniqueId(prefix) {
  const id24 = ++idCounter;
  return prefix ? String(prefix) + id24 : id24;
}
function resetIdCounter() {
  idCounter = 42;
}
function internalField(name) {
  return isInternalField(name) ? name : `__${name}`;
}
function isInternalField(name) {
  return name.startsWith("__");
}
function normalizeAngle(angle2) {
  if (angle2 === void 0) {
    return void 0;
  }
  return (angle2 % 360 + 360) % 360;
}
function isNumeric(value7) {
  if (isNumber14(value7)) {
    return true;
  }
  return !isNaN(value7) && !isNaN(parseFloat(value7));
}
var clonedProto = Object.getPrototypeOf(structuredClone({}));
function deepEqual(a4, b6) {
  if (a4 === b6)
    return true;
  if (a4 && b6 && typeof a4 == "object" && typeof b6 == "object") {
    if (a4.constructor.name !== b6.constructor.name)
      return false;
    let length2;
    let i;
    if (Array.isArray(a4)) {
      length2 = a4.length;
      if (length2 != b6.length)
        return false;
      for (i = length2; i-- !== 0; )
        if (!deepEqual(a4[i], b6[i]))
          return false;
      return true;
    }
    if (a4 instanceof Map && b6 instanceof Map) {
      if (a4.size !== b6.size)
        return false;
      for (const e3 of a4.entries())
        if (!b6.has(e3[0]))
          return false;
      for (const e3 of a4.entries())
        if (!deepEqual(e3[1], b6.get(e3[0])))
          return false;
      return true;
    }
    if (a4 instanceof Set && b6 instanceof Set) {
      if (a4.size !== b6.size)
        return false;
      for (const e3 of a4.entries())
        if (!b6.has(e3[0]))
          return false;
      return true;
    }
    if (ArrayBuffer.isView(a4) && ArrayBuffer.isView(b6)) {
      length2 = a4.length;
      if (length2 != b6.length)
        return false;
      for (i = length2; i-- !== 0; )
        if (a4[i] !== b6[i])
          return false;
      return true;
    }
    if (a4.constructor === RegExp)
      return a4.source === b6.source && a4.flags === b6.flags;
    if (a4.valueOf !== Object.prototype.valueOf && a4.valueOf !== clonedProto.valueOf)
      return a4.valueOf() === b6.valueOf();
    if (a4.toString !== Object.prototype.toString && a4.toString !== clonedProto.toString)
      return a4.toString() === b6.toString();
    const ks = Object.keys(a4);
    length2 = ks.length;
    if (length2 !== Object.keys(b6).length)
      return false;
    for (i = length2; i-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(b6, ks[i]))
        return false;
    for (i = length2; i-- !== 0; ) {
      const key4 = ks[i];
      if (!deepEqual(a4[key4], b6[key4]))
        return false;
    }
    return true;
  }
  return a4 !== a4 && b6 !== b6;
}
function stringify2(data3) {
  const seen = [];
  return function _stringify(node) {
    if ((node == null ? void 0 : node.toJSON) && typeof node.toJSON === "function") {
      node = node.toJSON();
    }
    if (node === void 0)
      return void 0;
    if (typeof node == "number")
      return isFinite(node) ? `${node}` : "null";
    if (typeof node !== "object")
      return JSON.stringify(node);
    let i;
    let out;
    if (Array.isArray(node)) {
      out = "[";
      for (i = 0; i < node.length; i++) {
        if (i)
          out += ",";
        out += _stringify(node[i]) || "null";
      }
      return `${out}]`;
    }
    if (node === null)
      return "null";
    if (seen.includes(node)) {
      throw new TypeError("Converting circular structure to JSON");
    }
    const seenIndex = seen.push(node) - 1;
    const ks = Object.keys(node).sort();
    out = "";
    for (i = 0; i < ks.length; i++) {
      const key4 = ks[i];
      const value7 = _stringify(node[key4]);
      if (!value7)
        continue;
      if (out)
        out += ",";
      out += `${JSON.stringify(key4)}:${value7}`;
    }
    seen.splice(seenIndex, 1);
    return `{${out}}`;
  }(data3);
}
function hasProperty(obj, key4) {
  return isObject12(obj) && has19(obj, key4) && obj[key4] !== void 0;
}
var ROW = "row";
var COLUMN = "column";
var FACET = "facet";
var X3 = "x";
var Y3 = "y";
var X23 = "x2";
var Y23 = "y2";
var XOFFSET = "xOffset";
var YOFFSET = "yOffset";
var RADIUS = "radius";
var RADIUS2 = "radius2";
var THETA = "theta";
var THETA2 = "theta2";
var LATITUDE = "latitude";
var LONGITUDE = "longitude";
var LATITUDE2 = "latitude2";
var LONGITUDE2 = "longitude2";
var TIME = "time";
var COLOR = "color";
var FILL = "fill";
var STROKE = "stroke";
var SHAPE = "shape";
var SIZE2 = "size";
var ANGLE = "angle";
var OPACITY = "opacity";
var FILLOPACITY = "fillOpacity";
var STROKEOPACITY = "strokeOpacity";
var STROKEWIDTH = "strokeWidth";
var STROKEDASH = "strokeDash";
var TEXT$1 = "text";
var ORDER = "order";
var DETAIL = "detail";
var KEY = "key";
var TOOLTIP = "tooltip";
var HREF = "href";
var URL2 = "url";
var DESCRIPTION = "description";
var POSITION_CHANNEL_INDEX = {
  x: 1,
  y: 1,
  x2: 1,
  y2: 1
};
var POLAR_POSITION_CHANNEL_INDEX = {
  theta: 1,
  theta2: 1,
  radius: 1,
  radius2: 1
};
function isPolarPositionChannel(c5) {
  return has19(POLAR_POSITION_CHANNEL_INDEX, c5);
}
var GEO_POSIITON_CHANNEL_INDEX = {
  longitude: 1,
  longitude2: 1,
  latitude: 1,
  latitude2: 1
};
function getPositionChannelFromLatLong(channel) {
  switch (channel) {
    case LATITUDE:
      return "y";
    case LATITUDE2:
      return "y2";
    case LONGITUDE:
      return "x";
    case LONGITUDE2:
      return "x2";
  }
}
function isGeoPositionChannel(c5) {
  return has19(GEO_POSIITON_CHANNEL_INDEX, c5);
}
var GEOPOSITION_CHANNELS = keys4(GEO_POSIITON_CHANNEL_INDEX);
var UNIT_CHANNEL_INDEX = {
  ...POSITION_CHANNEL_INDEX,
  ...POLAR_POSITION_CHANNEL_INDEX,
  ...GEO_POSIITON_CHANNEL_INDEX,
  xOffset: 1,
  yOffset: 1,
  // color
  color: 1,
  fill: 1,
  stroke: 1,
  // time
  time: 1,
  // other non-position with scale
  opacity: 1,
  fillOpacity: 1,
  strokeOpacity: 1,
  strokeWidth: 1,
  strokeDash: 1,
  size: 1,
  angle: 1,
  shape: 1,
  // channels without scales
  order: 1,
  text: 1,
  detail: 1,
  key: 1,
  tooltip: 1,
  href: 1,
  url: 1,
  description: 1
};
function isColorChannel(channel) {
  return channel === COLOR || channel === FILL || channel === STROKE;
}
var FACET_CHANNEL_INDEX = {
  row: 1,
  column: 1,
  facet: 1
};
var FACET_CHANNELS = keys4(FACET_CHANNEL_INDEX);
var CHANNEL_INDEX = {
  ...UNIT_CHANNEL_INDEX,
  ...FACET_CHANNEL_INDEX
};
var CHANNELS = keys4(CHANNEL_INDEX);
var { order: _o, detail: _d, tooltip: _tt1, ...SINGLE_DEF_CHANNEL_INDEX } = CHANNEL_INDEX;
var { row: _r, column: _c, facet: _f, ...SINGLE_DEF_UNIT_CHANNEL_INDEX } = SINGLE_DEF_CHANNEL_INDEX;
function isSingleDefUnitChannel(str) {
  return has19(SINGLE_DEF_UNIT_CHANNEL_INDEX, str);
}
function isChannel(str) {
  return has19(CHANNEL_INDEX, str);
}
var SECONDARY_RANGE_CHANNEL = [X23, Y23, LATITUDE2, LONGITUDE2, THETA2, RADIUS2];
function isSecondaryRangeChannel(c5) {
  const main2 = getMainRangeChannel(c5);
  return main2 !== c5;
}
function getMainRangeChannel(channel) {
  switch (channel) {
    case X23:
      return X3;
    case Y23:
      return Y3;
    case LATITUDE2:
      return LATITUDE;
    case LONGITUDE2:
      return LONGITUDE;
    case THETA2:
      return THETA;
    case RADIUS2:
      return RADIUS;
  }
  return channel;
}
function getVgPositionChannel(channel) {
  if (isPolarPositionChannel(channel)) {
    switch (channel) {
      case THETA:
        return "startAngle";
      case THETA2:
        return "endAngle";
      case RADIUS:
        return "outerRadius";
      case RADIUS2:
        return "innerRadius";
    }
  }
  return channel;
}
function getSecondaryRangeChannel(channel) {
  switch (channel) {
    case X3:
      return X23;
    case Y3:
      return Y23;
    case LATITUDE:
      return LATITUDE2;
    case LONGITUDE:
      return LONGITUDE2;
    case THETA:
      return THETA2;
    case RADIUS:
      return RADIUS2;
  }
  return void 0;
}
function getSizeChannel(channel) {
  switch (channel) {
    case X3:
    case X23:
      return "width";
    case Y3:
    case Y23:
      return "height";
  }
  return void 0;
}
function getOffsetChannel(channel) {
  switch (channel) {
    case X3:
      return "xOffset";
    case Y3:
      return "yOffset";
    case X23:
      return "x2Offset";
    case Y23:
      return "y2Offset";
    case THETA:
      return "thetaOffset";
    case RADIUS:
      return "radiusOffset";
    case THETA2:
      return "theta2Offset";
    case RADIUS2:
      return "radius2Offset";
  }
  return void 0;
}
function getOffsetScaleChannel(channel) {
  switch (channel) {
    case X3:
      return "xOffset";
    case Y3:
      return "yOffset";
  }
  return void 0;
}
function getMainChannelFromOffsetChannel(channel) {
  switch (channel) {
    case "xOffset":
      return "x";
    case "yOffset":
      return "y";
  }
}
var UNIT_CHANNELS = keys4(UNIT_CHANNEL_INDEX);
var {
  x: _x,
  y: _y,
  // x2 and y2 share the same scale as x and y
  x2: _x2,
  y2: _y2,
  //
  xOffset: _xo,
  yOffset: _yo,
  latitude: _latitude,
  longitude: _longitude,
  latitude2: _latitude2,
  longitude2: _longitude2,
  theta: _theta,
  theta2: _theta2,
  radius: _radius,
  radius2: _radius2,
  // The rest of unit channels then have scale
  ...NONPOSITION_CHANNEL_INDEX
} = UNIT_CHANNEL_INDEX;
var NONPOSITION_CHANNELS = keys4(NONPOSITION_CHANNEL_INDEX);
var POSITION_SCALE_CHANNEL_INDEX = {
  x: 1,
  y: 1
};
var POSITION_SCALE_CHANNELS = keys4(POSITION_SCALE_CHANNEL_INDEX);
function isXorY(channel) {
  return has19(POSITION_SCALE_CHANNEL_INDEX, channel);
}
var POLAR_POSITION_SCALE_CHANNEL_INDEX = {
  theta: 1,
  radius: 1
};
var POLAR_POSITION_SCALE_CHANNELS = keys4(POLAR_POSITION_SCALE_CHANNEL_INDEX);
function getPositionScaleChannel(sizeType) {
  return sizeType === "width" ? X3 : Y3;
}
var OFFSET_SCALE_CHANNEL_INDEX = { xOffset: 1, yOffset: 1 };
function isXorYOffset(channel) {
  return has19(OFFSET_SCALE_CHANNEL_INDEX, channel);
}
var TIME_SCALE_CHANNEL_INDEX = {
  time: 1
};
function isTime(channel) {
  return channel in TIME_SCALE_CHANNEL_INDEX;
}
var {
  // x2 and y2 share the same scale as x and y
  // text and tooltip have format instead of scale,
  // href has neither format, nor scale
  text: _t,
  tooltip: _tt,
  href: _hr,
  url: _u,
  description: _al,
  // detail and order have no scale
  detail: _dd,
  key: _k,
  order: _oo,
  ...NONPOSITION_SCALE_CHANNEL_INDEX
} = NONPOSITION_CHANNEL_INDEX;
var NONPOSITION_SCALE_CHANNELS = keys4(NONPOSITION_SCALE_CHANNEL_INDEX);
function isNonPositionScaleChannel(channel) {
  return has19(NONPOSITION_CHANNEL_INDEX, channel);
}
function supportLegend(channel) {
  switch (channel) {
    case COLOR:
    case FILL:
    case STROKE:
    case SIZE2:
    case SHAPE:
    case OPACITY:
    case STROKEWIDTH:
    case STROKEDASH:
      return true;
    case FILLOPACITY:
    case STROKEOPACITY:
    case ANGLE:
    case TIME:
      return false;
  }
}
var SCALE_CHANNEL_INDEX = {
  ...POSITION_SCALE_CHANNEL_INDEX,
  ...POLAR_POSITION_SCALE_CHANNEL_INDEX,
  ...OFFSET_SCALE_CHANNEL_INDEX,
  ...NONPOSITION_SCALE_CHANNEL_INDEX
};
var SCALE_CHANNELS = keys4(SCALE_CHANNEL_INDEX);
function isScaleChannel(channel) {
  return has19(SCALE_CHANNEL_INDEX, channel);
}
function supportMark(channel, mark) {
  return getSupportedMark(channel)[mark];
}
var ALL_MARKS = {
  // all marks
  arc: "always",
  area: "always",
  bar: "always",
  circle: "always",
  geoshape: "always",
  image: "always",
  line: "always",
  rule: "always",
  point: "always",
  rect: "always",
  square: "always",
  trail: "always",
  text: "always",
  tick: "always"
};
var { geoshape: _g, ...ALL_MARKS_EXCEPT_GEOSHAPE } = ALL_MARKS;
function getSupportedMark(channel) {
  switch (channel) {
    case COLOR:
    case FILL:
    case STROKE:
    case DESCRIPTION:
    case DETAIL:
    case KEY:
    case TOOLTIP:
    case HREF:
    case ORDER:
    case OPACITY:
    case FILLOPACITY:
    case STROKEOPACITY:
    case STROKEWIDTH:
    case FACET:
    case ROW:
    case COLUMN:
      return ALL_MARKS;
    case X3:
    case Y3:
    case XOFFSET:
    case YOFFSET:
    case LATITUDE:
    case LONGITUDE:
    case TIME:
      return ALL_MARKS_EXCEPT_GEOSHAPE;
    case X23:
    case Y23:
    case LATITUDE2:
    case LONGITUDE2:
      return {
        area: "always",
        bar: "always",
        image: "always",
        rect: "always",
        rule: "always",
        circle: "binned",
        point: "binned",
        square: "binned",
        tick: "binned",
        line: "binned",
        trail: "binned"
      };
    case SIZE2:
      return {
        point: "always",
        tick: "always",
        rule: "always",
        circle: "always",
        square: "always",
        bar: "always",
        text: "always",
        line: "always",
        trail: "always"
      };
    case STROKEDASH:
      return {
        line: "always",
        point: "always",
        tick: "always",
        rule: "always",
        circle: "always",
        square: "always",
        bar: "always",
        geoshape: "always"
      };
    case SHAPE:
      return { point: "always", geoshape: "always" };
    case TEXT$1:
      return { text: "always" };
    case ANGLE:
      return { point: "always", square: "always", text: "always" };
    case URL2:
      return { image: "always" };
    case THETA:
      return { text: "always", arc: "always" };
    case RADIUS:
      return { text: "always", arc: "always" };
    case THETA2:
    case RADIUS2:
      return { arc: "always" };
  }
}
function rangeType(channel) {
  switch (channel) {
    case X3:
    case Y3:
    case THETA:
    case RADIUS:
    case XOFFSET:
    case YOFFSET:
    case SIZE2:
    case ANGLE:
    case STROKEWIDTH:
    case OPACITY:
    case FILLOPACITY:
    case STROKEOPACITY:
    case TIME:
    case X23:
    case Y23:
    case THETA2:
    case RADIUS2:
      return void 0;
    case FACET:
    case ROW:
    case COLUMN:
    case SHAPE:
    case STROKEDASH:
    case TEXT$1:
    case TOOLTIP:
    case HREF:
    case URL2:
    case DESCRIPTION:
      return "discrete";
    case COLOR:
    case FILL:
    case STROKE:
      return "flexible";
    case LATITUDE:
    case LONGITUDE:
    case LATITUDE2:
    case LONGITUDE2:
    case DETAIL:
    case KEY:
    case ORDER:
      return void 0;
  }
}
var AGGREGATE_OP_INDEX = {
  argmax: 1,
  argmin: 1,
  average: 1,
  count: 1,
  distinct: 1,
  exponential: 1,
  exponentialb: 1,
  product: 1,
  max: 1,
  mean: 1,
  median: 1,
  min: 1,
  missing: 1,
  q1: 1,
  q3: 1,
  ci0: 1,
  ci1: 1,
  stderr: 1,
  stdev: 1,
  stdevp: 1,
  sum: 1,
  valid: 1,
  values: 1,
  variance: 1,
  variancep: 1
};
var MULTIDOMAIN_SORT_OP_INDEX = {
  count: 1,
  min: 1,
  max: 1
};
function isArgminDef(a4) {
  return hasProperty(a4, "argmin");
}
function isArgmaxDef(a4) {
  return hasProperty(a4, "argmax");
}
function isAggregateOp(a4) {
  return isString14(a4) && has19(AGGREGATE_OP_INDEX, a4);
}
var COUNTING_OPS = /* @__PURE__ */ new Set([
  "count",
  "valid",
  "missing",
  "distinct"
]);
function isCountingAggregateOp(aggregate) {
  return isString14(aggregate) && COUNTING_OPS.has(aggregate);
}
function isMinMaxOp(aggregate) {
  return isString14(aggregate) && contains2(["min", "max"], aggregate);
}
var SUM_OPS = /* @__PURE__ */ new Set([
  "count",
  "sum",
  "distinct",
  "valid",
  "missing"
]);
var SHARED_DOMAIN_OPS = /* @__PURE__ */ new Set([
  "mean",
  "average",
  "median",
  "q1",
  "q3",
  "min",
  "max"
]);
function binToString(bin5) {
  if (isBoolean5(bin5)) {
    bin5 = normalizeBin(bin5, void 0);
  }
  return `bin${keys4(bin5).map((p) => isParameterExtent(bin5[p]) ? varName(`_${p}_${entries$1(bin5[p])}`) : varName(`_${p}_${bin5[p]}`)).join("")}`;
}
function isBinning(bin5) {
  return bin5 === true || isBinParams(bin5) && !bin5.binned;
}
function isBinned(bin5) {
  return bin5 === "binned" || isBinParams(bin5) && bin5.binned === true;
}
function isBinParams(bin5) {
  return isObject12(bin5);
}
function isParameterExtent(extent8) {
  return hasProperty(extent8, "param");
}
function autoMaxBins(channel) {
  switch (channel) {
    case ROW:
    case COLUMN:
    case SIZE2:
    case COLOR:
    case FILL:
    case STROKE:
    case STROKEWIDTH:
    case OPACITY:
    case FILLOPACITY:
    case STROKEOPACITY:
    case SHAPE:
      return 6;
    case STROKEDASH:
      return 4;
    default:
      return 10;
  }
}
function isExprRef(o) {
  return hasProperty(o, "expr");
}
function replaceExprRef(index4, { level } = { level: 0 }) {
  const props = keys4(index4 || {});
  const newIndex = {};
  for (const prop of props) {
    newIndex[prop] = level === 0 ? signalRefOrValue(index4[prop]) : replaceExprRef(index4[prop], { level: level - 1 });
  }
  return newIndex;
}
function extractTitleConfig(titleConfig) {
  const {
    // These are non-mark title config that need to be hardcoded
    anchor,
    frame: frame2,
    offset: offset9,
    orient: orient2,
    angle: angle2,
    limit,
    // color needs to be redirect to fill
    color: color9,
    // subtitle properties
    subtitleColor,
    subtitleFont,
    subtitleFontSize,
    subtitleFontStyle,
    subtitleFontWeight,
    subtitleLineHeight,
    subtitlePadding,
    // The rest are mark config.
    ...rest
  } = titleConfig;
  const titleMarkConfig = {
    ...rest,
    ...color9 ? { fill: color9 } : {}
  };
  const nonMarkTitleProperties = {
    ...anchor ? { anchor } : {},
    ...frame2 ? { frame: frame2 } : {},
    ...offset9 ? { offset: offset9 } : {},
    ...orient2 ? { orient: orient2 } : {},
    ...angle2 !== void 0 ? { angle: angle2 } : {},
    ...limit !== void 0 ? { limit } : {}
  };
  const subtitle = {
    ...subtitleColor ? { subtitleColor } : {},
    ...subtitleFont ? { subtitleFont } : {},
    ...subtitleFontSize ? { subtitleFontSize } : {},
    ...subtitleFontStyle ? { subtitleFontStyle } : {},
    ...subtitleFontWeight ? { subtitleFontWeight } : {},
    ...subtitleLineHeight ? { subtitleLineHeight } : {},
    ...subtitlePadding ? { subtitlePadding } : {}
  };
  const subtitleMarkConfig = pick6(titleConfig, ["align", "baseline", "dx", "dy", "limit"]);
  return { titleMarkConfig, subtitleMarkConfig, nonMarkTitleProperties, subtitle };
}
function isText(v2) {
  return isString14(v2) || isArray22(v2) && isString14(v2[0]);
}
function isSignalRef(o) {
  return hasProperty(o, "signal");
}
function isVgRangeStep(range7) {
  return hasProperty(range7, "step");
}
function isDataRefUnionedDomain(domain3) {
  if (!isArray22(domain3)) {
    return hasProperty(domain3, "fields") && !hasProperty(domain3, "data");
  }
  return false;
}
function isFieldRefUnionDomain(domain3) {
  if (!isArray22(domain3)) {
    return hasProperty(domain3, "fields") && hasProperty(domain3, "data");
  }
  return false;
}
function isDataRefDomain(domain3) {
  if (!isArray22(domain3)) {
    return hasProperty(domain3, "field") && hasProperty(domain3, "data");
  }
  return false;
}
var VG_MARK_CONFIG_INDEX = {
  aria: 1,
  description: 1,
  ariaRole: 1,
  ariaRoleDescription: 1,
  blend: 1,
  opacity: 1,
  fill: 1,
  fillOpacity: 1,
  stroke: 1,
  strokeCap: 1,
  strokeWidth: 1,
  strokeOpacity: 1,
  strokeDash: 1,
  strokeDashOffset: 1,
  strokeJoin: 1,
  strokeOffset: 1,
  strokeMiterLimit: 1,
  startAngle: 1,
  endAngle: 1,
  padAngle: 1,
  innerRadius: 1,
  outerRadius: 1,
  size: 1,
  shape: 1,
  interpolate: 1,
  tension: 1,
  orient: 1,
  align: 1,
  baseline: 1,
  text: 1,
  dir: 1,
  dx: 1,
  dy: 1,
  ellipsis: 1,
  limit: 1,
  radius: 1,
  theta: 1,
  angle: 1,
  font: 1,
  fontSize: 1,
  fontWeight: 1,
  fontStyle: 1,
  lineBreak: 1,
  lineHeight: 1,
  cursor: 1,
  href: 1,
  tooltip: 1,
  cornerRadius: 1,
  cornerRadiusTopLeft: 1,
  cornerRadiusTopRight: 1,
  cornerRadiusBottomLeft: 1,
  cornerRadiusBottomRight: 1,
  aspect: 1,
  width: 1,
  height: 1,
  url: 1,
  smooth: 1
  // commented below are vg channel that do not have mark config.
  // x: 1,
  // y: 1,
  // x2: 1,
  // y2: 1,
  // xc'|'yc'
  // clip: 1,
  // path: 1,
  // url: 1,
};
var VG_MARK_CONFIGS = keys4(VG_MARK_CONFIG_INDEX);
var VG_MARK_INDEX = {
  arc: 1,
  area: 1,
  group: 1,
  image: 1,
  line: 1,
  path: 1,
  rect: 1,
  rule: 1,
  shape: 1,
  symbol: 1,
  text: 1,
  trail: 1
};
var VG_CORNERRADIUS_CHANNELS = [
  "cornerRadius",
  "cornerRadiusTopLeft",
  "cornerRadiusTopRight",
  "cornerRadiusBottomLeft",
  "cornerRadiusBottomRight"
];
var BIN_RANGE_DELIMITER = " – ";
function signalOrValueRefWithCondition(val) {
  const condition = isArray22(val.condition) ? val.condition.map(conditionalSignalRefOrValue) : conditionalSignalRefOrValue(val.condition);
  return {
    ...signalRefOrValue(val),
    condition
  };
}
function signalRefOrValue(value7) {
  if (isExprRef(value7)) {
    const { expr: expr2, ...rest } = value7;
    return { signal: expr2, ...rest };
  }
  return value7;
}
function conditionalSignalRefOrValue(value7) {
  if (isExprRef(value7)) {
    const { expr: expr2, ...rest } = value7;
    return { signal: expr2, ...rest };
  }
  return value7;
}
function signalOrValueRef(value7) {
  if (isExprRef(value7)) {
    const { expr: expr2, ...rest } = value7;
    return { signal: expr2, ...rest };
  }
  if (isSignalRef(value7)) {
    return value7;
  }
  return value7 !== void 0 ? { value: value7 } : void 0;
}
function exprFromSignalRefOrValue(ref2) {
  if (isSignalRef(ref2)) {
    return ref2.signal;
  }
  return $10(ref2);
}
function exprFromValueRefOrSignalRef(ref2) {
  if (isSignalRef(ref2)) {
    return ref2.signal;
  }
  return $10(ref2.value);
}
function signalOrStringValue(v2) {
  if (isSignalRef(v2)) {
    return v2.signal;
  }
  return v2 == null ? null : $10(v2);
}
function applyMarkConfig(e3, model, propsList) {
  for (const property2 of propsList) {
    const value7 = getMarkConfig(property2, model.markDef, model.config);
    if (value7 !== void 0) {
      e3[property2] = signalOrValueRef(value7);
    }
  }
  return e3;
}
function getStyles(mark) {
  return [].concat(mark.type, mark.style ?? []);
}
function getMarkPropOrConfig(channel, mark, config, opt = {}) {
  const { vgChannel, ignoreVgConfig } = opt;
  if (vgChannel && hasProperty(mark, vgChannel)) {
    return mark[vgChannel];
  } else if (mark[channel] !== void 0) {
    return mark[channel];
  } else if (ignoreVgConfig && (!vgChannel || vgChannel === channel)) {
    return void 0;
  }
  return getMarkConfig(channel, mark, config, opt);
}
function getMarkConfig(channel, mark, config, { vgChannel } = {}) {
  const cfg = getMarkStyleConfig(channel, mark, config.style);
  return getFirstDefined(
    // style config has highest precedence
    vgChannel ? cfg : void 0,
    cfg,
    // then mark-specific config
    vgChannel ? config[mark.type][vgChannel] : void 0,
    config[mark.type][channel],
    // Need to cast because MarkDef doesn't perfectly match with AnyMarkConfig, but if the type isn't available, we'll get nothing here, which is fine
    // If there is vgChannel, skip vl channel.
    // For example, vl size for text is vg fontSize, but config.mark.size is only for point size.
    vgChannel ? config.mark[vgChannel] : config.mark[channel]
  );
}
function getMarkStyleConfig(prop, mark, styleConfigIndex) {
  return getStyleConfig(prop, getStyles(mark), styleConfigIndex);
}
function getStyleConfig(p, styles, styleConfigIndex) {
  styles = array21(styles);
  let value7;
  for (const style6 of styles) {
    const styleConfig = styleConfigIndex[style6];
    if (hasProperty(styleConfig, p)) {
      value7 = styleConfig[p];
    }
  }
  return value7;
}
function sortParams(orderDef, fieldRefOption) {
  return array21(orderDef).reduce((s2, orderChannelDef) => {
    s2.field.push(vgField(orderChannelDef, fieldRefOption));
    s2.order.push(orderChannelDef.sort ?? "ascending");
    return s2;
  }, { field: [], order: [] });
}
function mergeTitleFieldDefs(f1, f2) {
  const merged = [...f1];
  f2.forEach((fdToMerge) => {
    for (const fieldDef1 of merged) {
      if (deepEqual(fieldDef1, fdToMerge)) {
        return;
      }
    }
    merged.push(fdToMerge);
  });
  return merged;
}
function mergeTitle(title1, title2) {
  if (deepEqual(title1, title2) || !title2) {
    return title1;
  } else if (!title1) {
    return title2;
  } else {
    return [...array21(title1), ...array21(title2)].join(", ");
  }
}
function mergeTitleComponent(v1, v2) {
  const v1Val = v1.value;
  const v2Val = v2.value;
  if (v1Val == null || v2Val === null) {
    return {
      explicit: v1.explicit,
      value: null
    };
  } else if ((isText(v1Val) || isSignalRef(v1Val)) && (isText(v2Val) || isSignalRef(v2Val))) {
    return {
      explicit: v1.explicit,
      value: mergeTitle(v1Val, v2Val)
    };
  } else if (isText(v1Val) || isSignalRef(v1Val)) {
    return {
      explicit: v1.explicit,
      value: v1Val
    };
  } else if (isText(v2Val) || isSignalRef(v2Val)) {
    return {
      explicit: v1.explicit,
      value: v2Val
    };
  } else if (!isText(v1Val) && !isSignalRef(v1Val) && !isText(v2Val) && !isSignalRef(v2Val)) {
    return {
      explicit: v1.explicit,
      value: mergeTitleFieldDefs(v1Val, v2Val)
    };
  }
  throw new Error("It should never reach here");
}
function invalidSpec(spec) {
  return `Invalid specification ${stringify2(spec)}. Make sure the specification includes at least one of the following properties: "mark", "layer", "facet", "hconcat", "vconcat", "concat", or "repeat".`;
}
var FIT_NON_SINGLE = 'Autosize "fit" only works for single views and layered views.';
function containerSizeNonSingle(name) {
  const uName = name == "width" ? "Width" : "Height";
  return `${uName} "container" only works for single views and layered views.`;
}
function containerSizeNotCompatibleWithAutosize(name) {
  const uName = name == "width" ? "Width" : "Height";
  const fitDirection = name == "width" ? "x" : "y";
  return `${uName} "container" only works well with autosize "fit" or "fit-${fitDirection}".`;
}
function droppingFit(channel) {
  return channel ? `Dropping "fit-${channel}" because spec has discrete ${getSizeChannel(channel)}.` : `Dropping "fit" because spec has discrete size.`;
}
function unknownField(channel) {
  return `Unknown field for ${channel}. Cannot calculate view size.`;
}
function cannotProjectOnChannelWithoutField(channel) {
  return `Cannot project a selection on encoding channel "${channel}", which has no field.`;
}
function cannotProjectAggregate(channel, aggregate) {
  return `Cannot project a selection on encoding channel "${channel}" as it uses an aggregate function ("${aggregate}").`;
}
function nearestNotSupportForContinuous(mark) {
  return `The "nearest" transform is not supported for ${mark} marks.`;
}
function selectionNotSupported(mark) {
  return `Selection not supported for ${mark} yet.`;
}
function selectionNotFound(name) {
  return `Cannot find a selection named "${name}".`;
}
var SCALE_BINDINGS_CONTINUOUS = "Scale bindings are currently only supported for scales with unbinned, continuous domains.";
var SEQUENTIAL_SCALE_DEPRECATED = "Sequntial scales are deprecated. The available quantitative scale type values are linear, log, pow, sqrt, symlog, time and utc";
var LEGEND_BINDINGS_MUST_HAVE_PROJECTION = "Legend bindings are only supported for selections over an individual field or encoding channel.";
function cannotLookupVariableParameter(name) {
  return `Lookups can only be performed on selection parameters. "${name}" is a variable parameter.`;
}
function noSameUnitLookup(name) {
  return `Cannot define and lookup the "${name}" selection in the same view. Try moving the lookup into a second, layered view?`;
}
var NEEDS_SAME_SELECTION = "The same selection must be used to override scale domains in a layered view.";
var INTERVAL_INITIALIZED_WITH_POS = 'Interval selections should be initialized using "x", "y", "longitude", or "latitude" keys.';
function noSuchRepeatedValue(field25) {
  return `Unknown repeated value "${field25}".`;
}
function columnsNotSupportByRowCol(type7) {
  return `The "columns" property cannot be used when "${type7}" has nested row/column.`;
}
var MULTIPLE_TIMER_ANIMATION_SELECTION = "Multiple timer selections in one unit spec are not supported. Ignoring all but the first.";
var MULTI_VIEW_ANIMATION_UNSUPPORTED = "Animation involving facet, layer, or concat is currently unsupported.";
function selectionAsScaleDomainWithoutField(field25) {
  return `A "field" or "encoding" must be specified when using a selection as a scale domain. Using "field": ${$(field25)}.`;
}
function selectionAsScaleDomainWrongEncodings(encodings, encoding, extent8, field25) {
  return `${!encodings.length ? "No " : "Multiple "}matching ${$(encoding)} encoding found for selection ${$(extent8.param)}. Using "field": ${$(field25)}.`;
}
var CONCAT_CANNOT_SHARE_AXIS = "Axes cannot be shared in concatenated or repeated views yet (https://github.com/vega/vega-lite/issues/2415).";
function unrecognizedParse(p) {
  return `Unrecognized parse "${p}".`;
}
function differentParse(field25, local, ancestor) {
  return `An ancestor parsed field "${field25}" as ${ancestor} but a child wants to parse the field as ${local}.`;
}
var ADD_SAME_CHILD_TWICE = "Attempt to add the same child twice.";
function invalidTransformIgnored(transform4) {
  return `Ignoring an invalid transform: ${stringify2(transform4)}.`;
}
var NO_FIELDS_NEEDS_AS = 'If "from.fields" is not specified, "as" has to be a string that specifies the key to be used for the data from the secondary source.';
function customFormatTypeNotAllowed(channel) {
  return `Config.customFormatTypes is not true, thus custom format type and format for channel ${channel} are dropped.`;
}
function projectionOverridden(opt) {
  const { parentProjection, projection: projection3 } = opt;
  return `Layer's shared projection ${stringify2(parentProjection)} is overridden by a child projection ${stringify2(projection3)}.`;
}
var REPLACE_ANGLE_WITH_THETA = "Arc marks uses theta channel rather than angle, replacing angle with theta.";
function offsetNestedInsideContinuousPositionScaleDropped(mainChannel) {
  return `${mainChannel}Offset dropped because ${mainChannel} is continuous`;
}
function primitiveChannelDef(channel, type7, value7) {
  return `Channel ${channel} is a ${type7}. Converted to {value: ${stringify2(value7)}}.`;
}
function invalidFieldType(type7) {
  return `Invalid field type "${type7}".`;
}
function invalidFieldTypeForCountAggregate(type7, aggregate) {
  return `Invalid field type "${type7}" for aggregate: "${aggregate}", using "quantitative" instead.`;
}
function invalidAggregate(aggregate) {
  return `Invalid aggregation operator "${aggregate}".`;
}
function droppingColor(type7, opt) {
  const { fill: fill6, stroke: stroke6 } = opt;
  return `Dropping color ${type7} as the plot also has ${fill6 && stroke6 ? "fill and stroke" : fill6 ? "fill" : "stroke"}.`;
}
function relativeBandSizeNotSupported(sizeChannel) {
  return `Position range does not support relative band size for ${sizeChannel}.`;
}
function emptyFieldDef(fieldDef, channel) {
  return `Dropping ${stringify2(fieldDef)} from channel "${channel}" since it does not contain any data field, datum, value, or signal.`;
}
var LINE_WITH_VARYING_SIZE = "Line marks cannot encode size with a non-groupby field. You may want to use trail marks instead.";
function incompatibleChannel(channel, markOrFacet, when) {
  return `${channel} dropped as it is incompatible with "${markOrFacet}"${""}.`;
}
function invalidEncodingChannel(channel) {
  return `${channel}-encoding is dropped as ${channel} is not a valid encoding channel.`;
}
function channelShouldBeDiscrete(channel) {
  return `${channel} encoding should be discrete (ordinal / nominal / binned).`;
}
function channelShouldBeDiscreteOrDiscretizing(channel) {
  return `${channel} encoding should be discrete (ordinal / nominal / binned) or use a discretizing scale (e.g. threshold).`;
}
function facetChannelDropped(channels) {
  return `Facet encoding dropped as ${channels.join(" and ")} ${channels.length > 1 ? "are" : "is"} also specified.`;
}
function discreteChannelCannotEncode(channel, type7) {
  return `Using discrete channel "${channel}" to encode "${type7}" field can be misleading as it does not encode ${type7 === "ordinal" ? "order" : "magnitude"}.`;
}
function rangeMarkAlignmentCannotBeExpression(align2) {
  return `The ${align2} for range marks cannot be an expression`;
}
function lineWithRange(hasX2, hasY2) {
  const channels = hasX2 && hasY2 ? "x2 and y2" : hasX2 ? "x2" : "y2";
  return `Line mark is for continuous lines and thus cannot be used with ${channels}. We will use the rule mark (line segments) instead.`;
}
function orientOverridden(original, actual) {
  return `Specified orient "${original}" overridden with "${actual}".`;
}
function cannotUseScalePropertyWithNonColor(prop) {
  return `Cannot use the scale property "${prop}" with non-color channel.`;
}
function cannotUseRelativeBandSizeWithNonBandScale(scaleType2) {
  return `Cannot use the relative band size with ${scaleType2} scale.`;
}
function unaggregateDomainHasNoEffectForRawField(fieldDef) {
  return `Using unaggregated domain with raw field has no effect (${stringify2(fieldDef)}).`;
}
function unaggregateDomainWithNonSharedDomainOp(aggregate) {
  return `Unaggregated domain not applicable for "${aggregate}" since it produces values outside the origin domain of the source data.`;
}
function unaggregatedDomainWithLogScale(fieldDef) {
  return `Unaggregated domain is currently unsupported for log scale (${stringify2(fieldDef)}).`;
}
function cannotApplySizeToNonOrientedMark(mark) {
  return `Cannot apply size to non-oriented mark "${mark}".`;
}
function scaleTypeNotWorkWithChannel(channel, scaleType2, defaultScaleType) {
  return `Channel "${channel}" does not work with "${scaleType2}" scale. We are using "${defaultScaleType}" scale instead.`;
}
function scaleTypeNotWorkWithFieldDef(scaleType2, defaultScaleType) {
  return `FieldDef does not work with "${scaleType2}" scale. We are using "${defaultScaleType}" scale instead.`;
}
function scalePropertyNotWorkWithScaleType(scaleType2, propName, channel) {
  return `${channel}-scale's "${propName}" is dropped as it does not work with ${scaleType2} scale.`;
}
function stepDropped(channel) {
  return `The step for "${channel}" is dropped because the ${channel === "width" ? "x" : "y"} is continuous.`;
}
function mergeConflictingProperty(property2, propertyOf, v1, v2) {
  return `Conflicting ${propertyOf.toString()} property "${property2.toString()}" (${stringify2(v1)} and ${stringify2(v2)}). Using ${stringify2(v1)}.`;
}
function mergeConflictingDomainProperty(property2, propertyOf, v1, v2) {
  return `Conflicting ${propertyOf.toString()} property "${property2.toString()}" (${stringify2(v1)} and ${stringify2(v2)}). Using the union of the two domains.`;
}
function independentScaleMeansIndependentGuide(channel) {
  return `Setting the scale to be independent for "${channel}" means we also have to set the guide (axis or legend) to be independent.`;
}
function domainSortDropped(sort4) {
  return `Dropping sort property ${stringify2(sort4)} as unioned domains only support boolean or op "count", "min", and "max".`;
}
var MORE_THAN_ONE_SORT = "Domains that should be unioned has conflicting sort properties. Sort will be set to true.";
var FACETED_INDEPENDENT_DIFFERENT_SOURCES = "Detected faceted independent scales that union domain of multiple fields from different data sources. We will use the first field. The result view size may be incorrect.";
var FACETED_INDEPENDENT_SAME_FIELDS_DIFFERENT_SOURCES = "Detected faceted independent scales that union domain of the same fields from different source. We will assume that this is the same field from a different fork of the same data source. However, if this is not the case, the result view size may be incorrect.";
var FACETED_INDEPENDENT_SAME_SOURCE = "Detected faceted independent scales that union domain of multiple fields from the same data source. We will use the first field. The result view size may be incorrect.";
function cannotStackRangedMark(channel) {
  return `Cannot stack "${channel}" if there is already "${channel}2".`;
}
function stackNonLinearScale(scaleType2) {
  return `Stack is applied to a non-linear scale (${scaleType2}).`;
}
function stackNonSummativeAggregate(aggregate) {
  return `Stacking is applied even though the aggregate function is non-summative ("${aggregate}").`;
}
function invalidTimeUnit(unitName2, value7) {
  return `Invalid ${unitName2}: ${stringify2(value7)}.`;
}
function droppedDay(d) {
  return `Dropping day from datetime ${stringify2(d)} as day cannot be combined with other units.`;
}
function errorBarCenterAndExtentAreNotNeeded(center, extent8) {
  return `${extent8 ? "extent " : ""}${extent8 && center ? "and " : ""}${center ? "center " : ""}${extent8 && center ? "are " : "is "}not needed when data are aggregated.`;
}
function errorBarCenterIsUsedWithWrongExtent(center, extent8, mark) {
  return `${center} is not usually used with ${extent8} for ${mark}.`;
}
function errorBarContinuousAxisHasCustomizedAggregate(aggregate, compositeMark) {
  return `Continuous axis should not have customized aggregation function ${aggregate}; ${compositeMark} already agregates the axis.`;
}
function errorBand1DNotSupport(property2) {
  return `1D error band does not support ${property2}.`;
}
function channelRequiredForBinned(channel) {
  return `Channel ${channel} is required for "binned" bin.`;
}
function channelShouldNotBeUsedForBinned(channel) {
  return `Channel ${channel} should not be used with "binned" bin.`;
}
function domainRequiredForThresholdScale(channel) {
  return `Domain for ${channel} is required for threshold scale.`;
}
var main = logger3(Warn3);
var current = main;
function set6(newLogger) {
  current = newLogger;
  return current;
}
function reset2() {
  current = main;
  return current;
}
function error23(...args) {
  current.error(...args);
}
function warn2(...args) {
  current.warn(...args);
}
function debug2(...args) {
  current.debug(...args);
}
function isDateTime(o) {
  if (o && isObject12(o)) {
    for (const part of TIMEUNIT_PARTS) {
      if (hasProperty(o, part)) {
        return true;
      }
    }
  }
  return false;
}
var MONTHS = [
  "january",
  "february",
  "march",
  "april",
  "may",
  "june",
  "july",
  "august",
  "september",
  "october",
  "november",
  "december"
];
var SHORT_MONTHS = MONTHS.map((m3) => m3.substr(0, 3));
var DAYS = ["sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday"];
var SHORT_DAYS = DAYS.map((d) => d.substr(0, 3));
function normalizeQuarter(q) {
  if (isNumeric(q)) {
    q = +q;
  }
  if (isNumber14(q)) {
    if (q > 4) {
      warn2(invalidTimeUnit("quarter", q));
    }
    return q - 1;
  } else {
    throw new Error(invalidTimeUnit("quarter", q));
  }
}
function normalizeMonth(m3) {
  if (isNumeric(m3)) {
    m3 = +m3;
  }
  if (isNumber14(m3)) {
    return m3 - 1;
  } else {
    const lowerM = m3.toLowerCase();
    const monthIndex = MONTHS.indexOf(lowerM);
    if (monthIndex !== -1) {
      return monthIndex;
    }
    const shortM = lowerM.substr(0, 3);
    const shortMonthIndex = SHORT_MONTHS.indexOf(shortM);
    if (shortMonthIndex !== -1) {
      return shortMonthIndex;
    }
    throw new Error(invalidTimeUnit("month", m3));
  }
}
function normalizeDay(d) {
  if (isNumeric(d)) {
    d = +d;
  }
  if (isNumber14(d)) {
    return d % 7;
  } else {
    const lowerD = d.toLowerCase();
    const dayIndex = DAYS.indexOf(lowerD);
    if (dayIndex !== -1) {
      return dayIndex;
    }
    const shortD = lowerD.substr(0, 3);
    const shortDayIndex = SHORT_DAYS.indexOf(shortD);
    if (shortDayIndex !== -1) {
      return shortDayIndex;
    }
    throw new Error(invalidTimeUnit("day", d));
  }
}
function dateTimeParts(d, normalize4) {
  const parts = [];
  if (normalize4 && d.day !== void 0) {
    if (keys4(d).length > 1) {
      warn2(droppedDay(d));
      d = duplicate(d);
      delete d.day;
    }
  }
  if (d.year !== void 0) {
    parts.push(d.year);
  } else {
    parts.push(2012);
  }
  if (d.month !== void 0) {
    const month = normalize4 ? normalizeMonth(d.month) : d.month;
    parts.push(month);
  } else if (d.quarter !== void 0) {
    const quarter3 = normalize4 ? normalizeQuarter(d.quarter) : d.quarter;
    parts.push(isNumber14(quarter3) ? quarter3 * 3 : `${quarter3}*3`);
  } else {
    parts.push(0);
  }
  if (d.date !== void 0) {
    parts.push(d.date);
  } else if (d.day !== void 0) {
    const day = normalize4 ? normalizeDay(d.day) : d.day;
    parts.push(isNumber14(day) ? day + 1 : `${day}+1`);
  } else {
    parts.push(1);
  }
  for (const timeUnit of ["hours", "minutes", "seconds", "milliseconds"]) {
    const unit2 = d[timeUnit];
    parts.push(typeof unit2 === "undefined" ? 0 : unit2);
  }
  return parts;
}
function dateTimeToExpr(d) {
  const parts = dateTimeParts(d, true);
  const string = parts.join(", ");
  if (d.utc) {
    return `utc(${string})`;
  } else {
    return `datetime(${string})`;
  }
}
function dateTimeExprToExpr(d) {
  const parts = dateTimeParts(d, false);
  const string = parts.join(", ");
  if (d.utc) {
    return `utc(${string})`;
  } else {
    return `datetime(${string})`;
  }
}
function dateTimeToTimestamp(d) {
  const parts = dateTimeParts(d, true);
  if (d.utc) {
    return +new Date(Date.UTC(...parts));
  } else {
    return +new Date(...parts);
  }
}
var LOCAL_SINGLE_TIMEUNIT_INDEX = {
  year: 1,
  quarter: 1,
  month: 1,
  week: 1,
  day: 1,
  dayofyear: 1,
  date: 1,
  hours: 1,
  minutes: 1,
  seconds: 1,
  milliseconds: 1
};
var TIMEUNIT_PARTS = keys4(LOCAL_SINGLE_TIMEUNIT_INDEX);
function isLocalSingleTimeUnit(timeUnit) {
  return has(LOCAL_SINGLE_TIMEUNIT_INDEX, timeUnit);
}
function isBinnedTimeUnit(timeUnit) {
  if (isObject12(timeUnit)) {
    return timeUnit.binned;
  }
  return isBinnedTimeUnitString(timeUnit);
}
function isBinnedTimeUnitString(timeUnit) {
  return timeUnit == null ? void 0 : timeUnit.startsWith("binned");
}
function isUTCTimeUnit(t) {
  return t.startsWith("utc");
}
function getLocalTimeUnitFromUTCTimeUnit(t) {
  return t.substring(3);
}
var VEGALITE_TIMEFORMAT = {
  "year-month": "%b %Y ",
  "year-month-date": "%b %d, %Y "
};
function getTimeUnitParts(timeUnit) {
  return TIMEUNIT_PARTS.filter((part) => containsTimeUnit(timeUnit, part));
}
function getSmallestTimeUnitPart(timeUnit) {
  const parts = getTimeUnitParts(timeUnit);
  return parts[parts.length - 1];
}
function containsTimeUnit(fullTimeUnit, timeUnit) {
  const index4 = fullTimeUnit.indexOf(timeUnit);
  if (index4 < 0) {
    return false;
  }
  if (index4 > 0 && timeUnit === "seconds" && fullTimeUnit.charAt(index4 - 1) === "i") {
    return false;
  }
  if (fullTimeUnit.length > index4 + 3 && timeUnit === "day" && fullTimeUnit.charAt(index4 + 3) === "o") {
    return false;
  }
  if (index4 > 0 && timeUnit === "year" && fullTimeUnit.charAt(index4 - 1) === "f") {
    return false;
  }
  return true;
}
function fieldExpr(fullTimeUnit, field25, { end } = { end: false }) {
  const fieldRef2 = accessPathWithDatum(field25);
  const utc = isUTCTimeUnit(fullTimeUnit) ? "utc" : "";
  function func(timeUnit) {
    if (timeUnit === "quarter") {
      return `(${utc}quarter(${fieldRef2})-1)`;
    } else {
      return `${utc}${timeUnit}(${fieldRef2})`;
    }
  }
  let lastTimeUnit;
  const dateExpr = {};
  for (const part of TIMEUNIT_PARTS) {
    if (containsTimeUnit(fullTimeUnit, part)) {
      dateExpr[part] = func(part);
      lastTimeUnit = part;
    }
  }
  if (end) {
    dateExpr[lastTimeUnit] += "+1";
  }
  return dateTimeExprToExpr(dateExpr);
}
function timeUnitSpecifierExpression(timeUnit) {
  if (!timeUnit) {
    return void 0;
  }
  const timeUnitParts = getTimeUnitParts(timeUnit);
  return `timeUnitSpecifier(${stringify2(timeUnitParts)}, ${stringify2(VEGALITE_TIMEFORMAT)})`;
}
function formatExpression(timeUnit, field25, isUTCScale) {
  if (!timeUnit) {
    return void 0;
  }
  const expr2 = timeUnitSpecifierExpression(timeUnit);
  const utc = isUTCScale || isUTCTimeUnit(timeUnit);
  return `${utc ? "utc" : "time"}Format(${field25}, ${expr2})`;
}
function normalizeTimeUnit(timeUnit) {
  if (!timeUnit) {
    return void 0;
  }
  let params2;
  if (isString14(timeUnit)) {
    if (isBinnedTimeUnitString(timeUnit)) {
      params2 = {
        unit: timeUnit.substring(6),
        binned: true
      };
    } else {
      params2 = {
        unit: timeUnit
      };
    }
  } else if (isObject12(timeUnit)) {
    params2 = {
      ...timeUnit,
      ...timeUnit.unit ? { unit: timeUnit.unit } : {}
    };
  }
  if (isUTCTimeUnit(params2.unit)) {
    params2.utc = true;
    params2.unit = getLocalTimeUnitFromUTCTimeUnit(params2.unit);
  }
  return params2;
}
function timeUnitToString(tu) {
  const { utc, ...rest } = normalizeTimeUnit(tu);
  if (rest.unit) {
    return (utc ? "utc" : "") + keys4(rest).map((p) => varName(`${p === "unit" ? "" : `_${p}_`}${rest[p]}`)).join("");
  } else {
    return `${utc ? "utc" : ""}timeunit${keys4(rest).map((p) => varName(`_${p}_${rest[p]}`)).join("")}`;
  }
}
function durationExpr(timeUnit, wrap2 = (x9) => x9) {
  const normalizedTimeUnit = normalizeTimeUnit(timeUnit);
  const smallestUnitPart = getSmallestTimeUnitPart(normalizedTimeUnit.unit);
  if (smallestUnitPart && smallestUnitPart !== "day") {
    const startDate = {
      year: 2001,
      // pick a non-leap year
      month: 1,
      date: 1,
      hours: 0,
      minutes: 0,
      seconds: 0,
      milliseconds: 0
    };
    const { step, part } = getDateTimePartAndStep(smallestUnitPart, normalizedTimeUnit.step);
    const endDate = {
      ...startDate,
      [part]: +startDate[part] + step
    };
    return `${wrap2(dateTimeToExpr(endDate))} - ${wrap2(dateTimeToExpr(startDate))}`;
  }
  return void 0;
}
var DATE_PARTS = {
  year: 1,
  month: 1,
  date: 1,
  hours: 1,
  minutes: 1,
  seconds: 1,
  milliseconds: 1
};
function isDatePart(timeUnit) {
  return has(DATE_PARTS, timeUnit);
}
function getDateTimePartAndStep(timeUnit, step = 1) {
  if (isDatePart(timeUnit)) {
    return { part: timeUnit, step };
  }
  switch (timeUnit) {
    case "day":
    case "dayofyear":
      return { part: "date", step };
    case "quarter":
      return { part: "month", step: step * 3 };
    case "week":
      return { part: "date", step: step * 7 };
  }
}
function isSelectionPredicate(predicate) {
  return hasProperty(predicate, "param");
}
function isFieldEqualPredicate(predicate) {
  return !!(predicate == null ? void 0 : predicate.field) && predicate.equal !== void 0;
}
function isFieldLTPredicate(predicate) {
  return !!(predicate == null ? void 0 : predicate.field) && predicate.lt !== void 0;
}
function isFieldLTEPredicate(predicate) {
  return !!(predicate == null ? void 0 : predicate.field) && predicate.lte !== void 0;
}
function isFieldGTPredicate(predicate) {
  return !!(predicate == null ? void 0 : predicate.field) && predicate.gt !== void 0;
}
function isFieldGTEPredicate(predicate) {
  return !!(predicate == null ? void 0 : predicate.field) && predicate.gte !== void 0;
}
function isFieldRangePredicate(predicate) {
  if (predicate == null ? void 0 : predicate.field) {
    if (isArray22(predicate.range) && predicate.range.length === 2) {
      return true;
    } else if (isSignalRef(predicate.range)) {
      return true;
    }
  }
  return false;
}
function isFieldOneOfPredicate(predicate) {
  return !!(predicate == null ? void 0 : predicate.field) && (isArray22(predicate.oneOf) || isArray22(predicate.in));
}
function isFieldValidPredicate(predicate) {
  return !!(predicate == null ? void 0 : predicate.field) && predicate.valid !== void 0;
}
function isFieldPredicate(predicate) {
  return isFieldOneOfPredicate(predicate) || isFieldEqualPredicate(predicate) || isFieldRangePredicate(predicate) || isFieldLTPredicate(predicate) || isFieldGTPredicate(predicate) || isFieldLTEPredicate(predicate) || isFieldGTEPredicate(predicate);
}
function predicateValueExpr(v2, timeUnit) {
  return valueExpr(v2, { timeUnit, wrapTime: true });
}
function predicateValuesExpr(vals2, timeUnit) {
  return vals2.map((v2) => predicateValueExpr(v2, timeUnit));
}
function fieldFilterExpression(predicate, useInRange = true) {
  const { field: field25 } = predicate;
  const normalizedTimeUnit = normalizeTimeUnit(predicate.timeUnit);
  const { unit: unit2, binned } = normalizedTimeUnit || {};
  const rawFieldExpr = vgField(predicate, { expr: "datum" });
  const fieldExpr$1 = unit2 ? (
    // For timeUnit, cast into integer with time() so we can use ===, inrange, indexOf to compare values directly.
    // TODO: We calculate timeUnit on the fly here. Consider if we would like to consolidate this with timeUnit pipeline
    // TODO: support utc
    `time(${!binned ? fieldExpr(unit2, field25) : rawFieldExpr})`
  ) : rawFieldExpr;
  if (isFieldEqualPredicate(predicate)) {
    return `${fieldExpr$1}===${predicateValueExpr(predicate.equal, unit2)}`;
  } else if (isFieldLTPredicate(predicate)) {
    const upper = predicate.lt;
    return `${fieldExpr$1}<${predicateValueExpr(upper, unit2)}`;
  } else if (isFieldGTPredicate(predicate)) {
    const lower = predicate.gt;
    return `${fieldExpr$1}>${predicateValueExpr(lower, unit2)}`;
  } else if (isFieldLTEPredicate(predicate)) {
    const upper = predicate.lte;
    return `${fieldExpr$1}<=${predicateValueExpr(upper, unit2)}`;
  } else if (isFieldGTEPredicate(predicate)) {
    const lower = predicate.gte;
    return `${fieldExpr$1}>=${predicateValueExpr(lower, unit2)}`;
  } else if (isFieldOneOfPredicate(predicate)) {
    return `indexof([${predicateValuesExpr(predicate.oneOf, unit2).join(",")}], ${fieldExpr$1}) !== -1`;
  } else if (isFieldValidPredicate(predicate)) {
    return fieldValidPredicate(fieldExpr$1, predicate.valid);
  } else if (isFieldRangePredicate(predicate)) {
    const { range: range7 } = replaceExprRef(predicate);
    const lower = isSignalRef(range7) ? { signal: `${range7.signal}[0]` } : range7[0];
    const upper = isSignalRef(range7) ? { signal: `${range7.signal}[1]` } : range7[1];
    if (lower !== null && upper !== null && useInRange) {
      return `inrange(${fieldExpr$1}, [${predicateValueExpr(lower, unit2)}, ${predicateValueExpr(upper, unit2)}])`;
    }
    const exprs = [];
    if (lower !== null) {
      exprs.push(`${fieldExpr$1} >= ${predicateValueExpr(lower, unit2)}`);
    }
    if (upper !== null) {
      exprs.push(`${fieldExpr$1} <= ${predicateValueExpr(upper, unit2)}`);
    }
    return exprs.length > 0 ? exprs.join(" && ") : "true";
  }
  throw new Error(`Invalid field predicate: ${stringify2(predicate)}`);
}
function fieldValidPredicate(fieldExpr2, valid = true) {
  if (valid) {
    return `isValid(${fieldExpr2}) && isFinite(+${fieldExpr2})`;
  } else {
    return `!isValid(${fieldExpr2}) || !isFinite(+${fieldExpr2})`;
  }
}
function normalizePredicate$1(f) {
  if (isFieldPredicate(f) && f.timeUnit) {
    return {
      ...f,
      timeUnit: normalizeTimeUnit(f.timeUnit)
    };
  }
  return f;
}
var Type = {
  quantitative: "quantitative",
  ordinal: "ordinal",
  temporal: "temporal",
  nominal: "nominal",
  geojson: "geojson"
};
function isContinuous3(type7) {
  return type7 === "quantitative" || type7 === "temporal";
}
function isDiscrete$1(type7) {
  return type7 === "ordinal" || type7 === "nominal";
}
var QUANTITATIVE = Type.quantitative;
var ORDINAL = Type.ordinal;
var TEMPORAL = Type.temporal;
var NOMINAL = Type.nominal;
var GEOJSON = Type.geojson;
function getFullName(type7) {
  if (type7) {
    type7 = type7.toLowerCase();
    switch (type7) {
      case "q":
      case QUANTITATIVE:
        return "quantitative";
      case "t":
      case TEMPORAL:
        return "temporal";
      case "o":
      case ORDINAL:
        return "ordinal";
      case "n":
      case NOMINAL:
        return "nominal";
      case GEOJSON:
        return "geojson";
    }
  }
  return void 0;
}
var ScaleType = {
  // Continuous - Quantitative
  LINEAR: "linear",
  LOG: "log",
  POW: "pow",
  SQRT: "sqrt",
  // Continuous - Time
  TIME: "time",
  UTC: "utc",
  POINT: "point",
  BAND: "band"
};
var SCALE_CATEGORY_INDEX = {
  linear: "numeric",
  log: "numeric",
  pow: "numeric",
  sqrt: "numeric",
  symlog: "numeric",
  identity: "numeric",
  sequential: "numeric",
  time: "time",
  utc: "time",
  ordinal: "ordinal",
  "bin-ordinal": "bin-ordinal",
  // TODO: should bin-ordinal support merging with other
  point: "ordinal-position",
  band: "ordinal-position",
  quantile: "discretizing",
  quantize: "discretizing",
  threshold: "discretizing"
};
function scaleCompatible(scaleType1, scaleType2) {
  const scaleCategory1 = SCALE_CATEGORY_INDEX[scaleType1];
  const scaleCategory2 = SCALE_CATEGORY_INDEX[scaleType2];
  return scaleCategory1 === scaleCategory2 || scaleCategory1 === "ordinal-position" && scaleCategory2 === "time" || scaleCategory2 === "ordinal-position" && scaleCategory1 === "time";
}
var SCALE_PRECEDENCE_INDEX = {
  // numeric
  linear: 0,
  log: 1,
  pow: 1,
  sqrt: 1,
  symlog: 1,
  identity: 1,
  sequential: 1,
  // time
  time: 0,
  utc: 0,
  // ordinal-position -- these have higher precedence than continuous scales as they support more types of data
  point: 10,
  band: 11,
  // band has higher precedence as it is better for interaction
  // non grouped types
  ordinal: 0,
  "bin-ordinal": 0,
  quantile: 0,
  quantize: 0,
  threshold: 0
};
function scaleTypePrecedence(scaleType2) {
  return SCALE_PRECEDENCE_INDEX[scaleType2];
}
var QUANTITATIVE_SCALES = /* @__PURE__ */ new Set([
  "linear",
  "log",
  "pow",
  "sqrt",
  "symlog"
]);
var CONTINUOUS_TO_CONTINUOUS_SCALES = /* @__PURE__ */ new Set([
  ...QUANTITATIVE_SCALES,
  "time",
  "utc"
]);
function isQuantitative(type7) {
  return QUANTITATIVE_SCALES.has(type7);
}
var CONTINUOUS_TO_DISCRETE_SCALES = /* @__PURE__ */ new Set([
  "quantile",
  "quantize",
  "threshold"
]);
var CONTINUOUS_DOMAIN_SCALES = /* @__PURE__ */ new Set([
  ...CONTINUOUS_TO_CONTINUOUS_SCALES,
  ...CONTINUOUS_TO_DISCRETE_SCALES,
  "sequential",
  "identity"
]);
var DISCRETE_DOMAIN_SCALES = /* @__PURE__ */ new Set([
  "ordinal",
  "bin-ordinal",
  "point",
  "band"
]);
function hasDiscreteDomain(type7) {
  return DISCRETE_DOMAIN_SCALES.has(type7);
}
function hasContinuousDomain(type7) {
  return CONTINUOUS_DOMAIN_SCALES.has(type7);
}
function isContinuousToContinuous(type7) {
  return CONTINUOUS_TO_CONTINUOUS_SCALES.has(type7);
}
function isContinuousToDiscrete(type7) {
  return CONTINUOUS_TO_DISCRETE_SCALES.has(type7);
}
var defaultScaleConfig = {
  pointPadding: 0.5,
  barBandPaddingInner: 0.1,
  rectBandPaddingInner: 0,
  tickBandPaddingInner: 0.25,
  bandWithNestedOffsetPaddingInner: 0.2,
  bandWithNestedOffsetPaddingOuter: 0.2,
  minBandSize: 2,
  minFontSize: 8,
  maxFontSize: 40,
  minOpacity: 0.3,
  maxOpacity: 0.8,
  // FIXME: revise if these *can* become ratios of width/height step
  minSize: 4,
  // Point size is area. For square point, 9 = 3 pixel ^ 2, not too small!
  minStrokeWidth: 1,
  maxStrokeWidth: 4,
  quantileCount: 4,
  quantizeCount: 4,
  zero: true,
  framesPerSecond: 2,
  animationDuration: 5
};
function isExtendedScheme(scheme38) {
  return !isString14(scheme38) && hasProperty(scheme38, "name");
}
function isParameterDomain(domain3) {
  return hasProperty(domain3, "param");
}
function isDomainUnionWith(domain3) {
  return hasProperty(domain3, "unionWith");
}
function isFieldRange(range7) {
  return isObject12(range7) && "field" in range7;
}
var SCALE_PROPERTY_INDEX = {
  type: 1,
  domain: 1,
  domainMax: 1,
  domainMin: 1,
  domainMid: 1,
  domainRaw: 1,
  align: 1,
  range: 1,
  rangeMax: 1,
  rangeMin: 1,
  scheme: 1,
  bins: 1,
  // Other properties
  reverse: 1,
  round: 1,
  // quantitative / time
  clamp: 1,
  nice: 1,
  // quantitative
  base: 1,
  exponent: 1,
  constant: 1,
  interpolate: 1,
  zero: 1,
  // zero depends on domain
  // band/point
  padding: 1,
  paddingInner: 1,
  paddingOuter: 1
};
var { type: type6, domain: domain$1, range: range5, rangeMax, rangeMin, scheme: scheme37, ...NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTY_INDEX } = SCALE_PROPERTY_INDEX;
var NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTIES = keys4(NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTY_INDEX);
function scaleTypeSupportProperty(scaleType2, propName) {
  switch (propName) {
    case "type":
    case "domain":
    case "reverse":
    case "range":
      return true;
    case "scheme":
    case "interpolate":
      return !["point", "band", "identity"].includes(scaleType2);
    case "bins":
      return !["point", "band", "identity", "ordinal"].includes(scaleType2);
    case "round":
      return isContinuousToContinuous(scaleType2) || scaleType2 === "band" || scaleType2 === "point";
    case "padding":
    case "rangeMin":
    case "rangeMax":
      return isContinuousToContinuous(scaleType2) || ["point", "band"].includes(scaleType2);
    case "paddingOuter":
    case "align":
      return ["point", "band"].includes(scaleType2);
    case "paddingInner":
      return scaleType2 === "band";
    case "domainMax":
    case "domainMid":
    case "domainMin":
    case "domainRaw":
    case "clamp":
      return isContinuousToContinuous(scaleType2);
    case "nice":
      return isContinuousToContinuous(scaleType2) || scaleType2 === "quantize" || scaleType2 === "threshold";
    case "exponent":
      return scaleType2 === "pow";
    case "base":
      return scaleType2 === "log";
    case "constant":
      return scaleType2 === "symlog";
    case "zero":
      return hasContinuousDomain(scaleType2) && !contains2([
        "log",
        // log scale cannot have zero value
        "time",
        "utc",
        // zero is not meaningful for time
        "threshold",
        // threshold requires custom domain so zero does not matter
        "quantile"
        // quantile depends on distribution so zero does not matter
      ], scaleType2);
  }
}
function channelScalePropertyIncompatability(channel, propName) {
  switch (propName) {
    case "interpolate":
    case "scheme":
    case "domainMid":
      if (!isColorChannel(channel)) {
        return cannotUseScalePropertyWithNonColor(propName);
      }
      return void 0;
    case "align":
    case "type":
    case "bins":
    case "domain":
    case "domainMax":
    case "domainMin":
    case "domainRaw":
    case "range":
    case "base":
    case "exponent":
    case "constant":
    case "nice":
    case "padding":
    case "paddingInner":
    case "paddingOuter":
    case "rangeMax":
    case "rangeMin":
    case "reverse":
    case "round":
    case "clamp":
    case "zero":
      return void 0;
  }
}
function scaleTypeSupportDataType(specifiedType, fieldDefType) {
  if (contains2([ORDINAL, NOMINAL], fieldDefType)) {
    return specifiedType === void 0 || hasDiscreteDomain(specifiedType);
  } else if (fieldDefType === TEMPORAL) {
    return contains2([ScaleType.TIME, ScaleType.UTC, void 0], specifiedType);
  } else if (fieldDefType === QUANTITATIVE) {
    return isQuantitative(specifiedType) || isContinuousToDiscrete(specifiedType) || specifiedType === void 0;
  }
  return true;
}
function channelSupportScaleType(channel, scaleType2, hasNestedOffsetScale = false) {
  if (!isScaleChannel(channel)) {
    return false;
  }
  switch (channel) {
    case X3:
    case Y3:
    case XOFFSET:
    case YOFFSET:
    case THETA:
    case RADIUS:
      if (isContinuousToContinuous(scaleType2)) {
        return true;
      } else if (scaleType2 === "band") {
        return true;
      } else if (scaleType2 === "point") {
        return !hasNestedOffsetScale;
      }
      return false;
    case TIME:
      return contains2(["linear", "band"], scaleType2);
    case SIZE2:
    case STROKEWIDTH:
    case OPACITY:
    case FILLOPACITY:
    case STROKEOPACITY:
    case ANGLE:
      return isContinuousToContinuous(scaleType2) || isContinuousToDiscrete(scaleType2) || contains2(["band", "point", "ordinal"], scaleType2);
    case COLOR:
    case FILL:
    case STROKE:
      return scaleType2 !== "band";
    case STROKEDASH:
    case SHAPE:
      return scaleType2 === "ordinal" || isContinuousToDiscrete(scaleType2);
  }
}
function isScaleInvalidDataIncludeAsValue(invalidDataMode) {
  return isObject12(invalidDataMode) && "value" in invalidDataMode;
}
var Mark3 = {
  arc: "arc",
  area: "area",
  bar: "bar",
  image: "image",
  line: "line",
  point: "point",
  rect: "rect",
  rule: "rule",
  text: "text",
  tick: "tick",
  trail: "trail",
  circle: "circle",
  square: "square",
  geoshape: "geoshape"
};
var ARC = Mark3.arc;
var AREA = Mark3.area;
var BAR = Mark3.bar;
var IMAGE = Mark3.image;
var LINE = Mark3.line;
var POINT = Mark3.point;
var RECT = Mark3.rect;
var RULE = Mark3.rule;
var TEXT = Mark3.text;
var TICK = Mark3.tick;
var TRAIL = Mark3.trail;
var CIRCLE = Mark3.circle;
var SQUARE = Mark3.square;
var GEOSHAPE = Mark3.geoshape;
function isPathMark(m3) {
  return ["line", "area", "trail"].includes(m3);
}
function isRectBasedMark(m3) {
  return [
    "rect",
    "bar",
    "image",
    "arc",
    "tick"
    /* arc is rect/interval in polar coordinate */
  ].includes(m3);
}
var PRIMITIVE_MARKS = new Set(keys4(Mark3));
function isMarkDef(mark) {
  return hasProperty(mark, "type");
}
var STROKE_CONFIG = [
  "stroke",
  "strokeWidth",
  "strokeDash",
  "strokeDashOffset",
  "strokeOpacity",
  "strokeJoin",
  "strokeMiterLimit"
];
var FILL_CONFIG = ["fill", "fillOpacity"];
var FILL_STROKE_CONFIG = [...STROKE_CONFIG, ...FILL_CONFIG];
var VL_ONLY_MARK_CONFIG_INDEX = {
  color: 1,
  filled: 1,
  invalid: 1,
  order: 1,
  radius2: 1,
  theta2: 1,
  timeUnitBandSize: 1,
  timeUnitBandPosition: 1
};
var VL_ONLY_MARK_CONFIG_PROPERTIES = keys4(VL_ONLY_MARK_CONFIG_INDEX);
var VL_ONLY_RECT_CONFIG = [
  "binSpacing",
  "continuousBandSize",
  "discreteBandSize",
  "minBandSize"
];
var VL_ONLY_MARK_SPECIFIC_CONFIG_PROPERTY_INDEX = {
  area: ["line", "point"],
  bar: VL_ONLY_RECT_CONFIG,
  rect: VL_ONLY_RECT_CONFIG,
  line: ["point"],
  tick: ["bandSize", "thickness", ...VL_ONLY_RECT_CONFIG]
};
var defaultMarkConfig = {
  color: "#4c78a8",
  invalid: "break-paths-show-path-domains",
  timeUnitBandSize: 1
};
var MARK_CONFIG_INDEX = {
  mark: 1,
  arc: 1,
  area: 1,
  bar: 1,
  circle: 1,
  image: 1,
  line: 1,
  point: 1,
  rect: 1,
  rule: 1,
  square: 1,
  text: 1,
  tick: 1,
  trail: 1,
  geoshape: 1
};
var MARK_CONFIGS = keys4(MARK_CONFIG_INDEX);
function isRelativeBandSize(o) {
  return hasProperty(o, "band");
}
var BAR_CORNER_RADIUS_INDEX = {
  horizontal: ["cornerRadiusTopRight", "cornerRadiusBottomRight"],
  vertical: ["cornerRadiusTopLeft", "cornerRadiusTopRight"]
};
var DEFAULT_RECT_BAND_SIZE = 5;
var defaultRectConfig = {
  binSpacing: 0,
  continuousBandSize: DEFAULT_RECT_BAND_SIZE,
  minBandSize: 0.25,
  timeUnitBandPosition: 0.5
};
var defaultBarConfig = {
  ...defaultRectConfig,
  binSpacing: 1
};
var defaultTickConfig = {
  ...defaultRectConfig,
  thickness: 1
};
function getMarkType(m3) {
  return isMarkDef(m3) ? m3.type : m3;
}
function normalizeInvalidDataMode(mode2, { isPath }) {
  if (mode2 === void 0 || mode2 === "break-paths-show-path-domains") {
    return isPath ? "break-paths-show-domains" : "filter";
  } else if (mode2 === null) {
    return "show";
  }
  return mode2;
}
function getScaleInvalidDataMode({ markDef, config, scaleChannel, scaleType: scaleType2, isCountAggregate }) {
  var _a2, _b;
  if (!scaleType2 || !hasContinuousDomain(scaleType2) || isCountAggregate) {
    return "always-valid";
  }
  const invalidMode = normalizeInvalidDataMode(getMarkPropOrConfig("invalid", markDef, config), {
    isPath: isPathMark(markDef.type)
  });
  const scaleOutputForInvalid = (_b = (_a2 = config.scale) == null ? void 0 : _a2.invalid) == null ? void 0 : _b[scaleChannel];
  if (scaleOutputForInvalid !== void 0) {
    return "show";
  }
  return invalidMode;
}
function shouldBreakPath(mode2) {
  return mode2 === "break-paths-filter-domains" || mode2 === "break-paths-show-domains";
}
function scaledZeroOrMinOrMax({ scaleName, scale: scale19, mode: mode2 }) {
  const domain3 = `domain('${scaleName}')`;
  if (!scale19 || !scaleName) {
    return void 0;
  }
  const min5 = `${domain3}[0]`;
  const max5 = `peek(${domain3})`;
  const domainHasZero = scale19.domainHasZero();
  if (domainHasZero === "definitely") {
    return {
      scale: scaleName,
      value: 0
    };
  } else if (domainHasZero === "maybe") {
    const nonZeroValue = mode2 === "zeroOrMin" ? min5 : max5;
    return { signal: `scale('${scaleName}', inrange(0, ${domain3}) ? 0 : ${nonZeroValue})` };
  } else {
    return { signal: `scale('${scaleName}', ${mode2 === "zeroOrMin" ? min5 : max5})` };
  }
}
function getConditionalValueRefForIncludingInvalidValue({ scaleChannel, channelDef, scale: scale19, scaleName, markDef, config }) {
  var _a2;
  const scaleType2 = scale19 == null ? void 0 : scale19.get("type");
  const fieldDef = getFieldDef(channelDef);
  const isCountAggregate = isCountingAggregateOp(fieldDef == null ? void 0 : fieldDef.aggregate);
  const invalidDataMode = getScaleInvalidDataMode({
    scaleChannel,
    markDef,
    config,
    scaleType: scaleType2,
    isCountAggregate
  });
  if (fieldDef && invalidDataMode === "show") {
    const includeAs = ((_a2 = config.scale.invalid) == null ? void 0 : _a2[scaleChannel]) ?? "zero-or-min";
    return {
      test: fieldValidPredicate(vgField(fieldDef, { expr: "datum" }), false),
      ...refForInvalidValues(includeAs, scale19, scaleName)
    };
  }
  return void 0;
}
function refForInvalidValues(includeAs, scale19, scaleName) {
  if (isScaleInvalidDataIncludeAsValue(includeAs)) {
    const { value: value7 } = includeAs;
    return isSignalRef(value7) ? { signal: value7.signal } : { value: value7 };
  }
  return scaledZeroOrMinOrMax({
    scale: scale19,
    scaleName,
    mode: "zeroOrMin"
  });
}
function midPointRefWithPositionInvalidTest(params2) {
  const { channel, channelDef, markDef, scale: scale19, scaleName, config } = params2;
  const scaleChannel = getMainRangeChannel(channel);
  const mainRef = midPoint(params2);
  const valueRefForIncludingInvalid = getConditionalValueRefForIncludingInvalidValue({
    scaleChannel,
    channelDef,
    scale: scale19,
    scaleName,
    markDef,
    config
  });
  return valueRefForIncludingInvalid !== void 0 ? [valueRefForIncludingInvalid, mainRef] : mainRef;
}
function datumDefToExpr(datumDef) {
  const { datum: datum2 } = datumDef;
  if (isDateTime(datum2)) {
    return dateTimeToExpr(datum2);
  }
  return `${stringify2(datum2)}`;
}
function valueRefForFieldOrDatumDef(fieldDef, scaleName, opt, encode2) {
  const ref2 = {};
  if (scaleName) {
    ref2.scale = scaleName;
  }
  if (isDatumDef(fieldDef)) {
    const { datum: datum2 } = fieldDef;
    if (isDateTime(datum2)) {
      ref2.signal = dateTimeToExpr(datum2);
    } else if (isSignalRef(datum2)) {
      ref2.signal = datum2.signal;
    } else if (isExprRef(datum2)) {
      ref2.signal = datum2.expr;
    } else {
      ref2.value = datum2;
    }
  } else {
    ref2.field = vgField(fieldDef, opt);
  }
  if (encode2) {
    const { offset: offset9, band: band11 } = encode2;
    if (offset9) {
      ref2.offset = offset9;
    }
    if (band11) {
      ref2.band = band11;
    }
  }
  return ref2;
}
function interpolatedSignalRef({ scaleName, fieldOrDatumDef, fieldOrDatumDef2, offset: offset9, startSuffix, endSuffix = "end", bandPosition = 0.5 }) {
  const expr2 = !isSignalRef(bandPosition) && 0 < bandPosition && bandPosition < 1 ? "datum" : void 0;
  const start = vgField(fieldOrDatumDef, { expr: expr2, suffix: startSuffix });
  const end = fieldOrDatumDef2 !== void 0 ? vgField(fieldOrDatumDef2, { expr: expr2 }) : vgField(fieldOrDatumDef, { suffix: endSuffix, expr: expr2 });
  const ref2 = {};
  if (bandPosition === 0 || bandPosition === 1) {
    ref2.scale = scaleName;
    const field25 = bandPosition === 0 ? start : end;
    ref2.field = field25;
  } else {
    const datum2 = isSignalRef(bandPosition) ? `(1-${bandPosition.signal}) * ${start} + ${bandPosition.signal} * ${end}` : `${1 - bandPosition} * ${start} + ${bandPosition} * ${end}`;
    ref2.signal = `scale("${scaleName}", ${datum2})`;
  }
  if (offset9) {
    ref2.offset = offset9;
  }
  return ref2;
}
function binSizeExpr({ scaleName, fieldDef }) {
  const start = vgField(fieldDef, { expr: "datum" });
  const end = vgField(fieldDef, { expr: "datum", suffix: "end" });
  return `abs(scale("${scaleName}", ${end}) - scale("${scaleName}", ${start}))`;
}
function midPoint({ channel, channelDef, channel2Def, markDef, config, scaleName, scale: scale19, stack: stack2, offset: offset9, defaultRef, bandPosition }) {
  if (channelDef) {
    if (isFieldOrDatumDef(channelDef)) {
      const scaleType2 = scale19 == null ? void 0 : scale19.get("type");
      if (isTypedFieldDef(channelDef)) {
        bandPosition ?? (bandPosition = getBandPosition({
          fieldDef: channelDef,
          fieldDef2: channel2Def,
          markDef,
          config
        }));
        const { bin: bin5, timeUnit, type: type7 } = channelDef;
        if (isBinning(bin5) || bandPosition && timeUnit && type7 === TEMPORAL) {
          if (stack2 == null ? void 0 : stack2.impute) {
            return valueRefForFieldOrDatumDef(channelDef, scaleName, { binSuffix: "mid" }, { offset: offset9 });
          }
          if (bandPosition && !hasDiscreteDomain(scaleType2)) {
            return interpolatedSignalRef({ scaleName, fieldOrDatumDef: channelDef, bandPosition, offset: offset9 });
          }
          return valueRefForFieldOrDatumDef(channelDef, scaleName, binRequiresRange(channelDef, channel) ? { binSuffix: "range" } : {}, {
            offset: offset9
          });
        } else if (isBinned(bin5)) {
          if (isFieldDef(channel2Def)) {
            return interpolatedSignalRef({
              scaleName,
              fieldOrDatumDef: channelDef,
              fieldOrDatumDef2: channel2Def,
              bandPosition,
              offset: offset9
            });
          } else {
            const channel2 = channel === X3 ? X23 : Y23;
            warn2(channelRequiredForBinned(channel2));
          }
        }
      }
      return valueRefForFieldOrDatumDef(
        channelDef,
        scaleName,
        hasDiscreteDomain(scaleType2) ? { binSuffix: "range" } : {},
        // no need for bin suffix if there is no scale
        {
          offset: offset9,
          // For band, to get mid point, need to offset by half of the band
          band: scaleType2 === "band" ? bandPosition ?? channelDef.bandPosition ?? 0.5 : void 0
        }
      );
    } else if (isValueDef(channelDef)) {
      const value7 = channelDef.value;
      const offsetMixins = offset9 ? { offset: offset9 } : {};
      return { ...widthHeightValueOrSignalRef(channel, value7), ...offsetMixins };
    }
  }
  if (isFunction14(defaultRef)) {
    defaultRef = defaultRef();
  }
  if (defaultRef) {
    return {
      ...defaultRef,
      // only include offset when it is non-zero (zero = no offset)
      ...offset9 ? { offset: offset9 } : {}
    };
  }
  return defaultRef;
}
function widthHeightValueOrSignalRef(channel, value7) {
  if (contains2(["x", "x2"], channel) && value7 === "width") {
    return { field: { group: "width" } };
  } else if (contains2(["y", "y2"], channel) && value7 === "height") {
    return { field: { group: "height" } };
  }
  return signalOrValueRef(value7);
}
function isCustomFormatType(formatType) {
  return formatType && formatType !== "number" && formatType !== "time";
}
function customFormatExpr(formatType, field25, format14) {
  return `${formatType}(${field25}${format14 ? `, ${stringify2(format14)}` : ""})`;
}
function formatSignalRef({ fieldOrDatumDef, format: format14, formatType, expr: expr2, normalizeStack, config }) {
  var _a2;
  if (isCustomFormatType(formatType)) {
    return formatCustomType({
      fieldOrDatumDef,
      format: format14,
      formatType,
      expr: expr2,
      config
    });
  }
  const field25 = fieldToFormat(fieldOrDatumDef, expr2, normalizeStack);
  const type7 = channelDefType(fieldOrDatumDef);
  if (format14 === void 0 && formatType === void 0 && config.customFormatTypes) {
    if (type7 === "quantitative") {
      if (normalizeStack && config.normalizedNumberFormatType)
        return formatCustomType({
          fieldOrDatumDef,
          format: config.normalizedNumberFormat,
          formatType: config.normalizedNumberFormatType,
          expr: expr2,
          config
        });
      if (config.numberFormatType) {
        return formatCustomType({
          fieldOrDatumDef,
          format: config.numberFormat,
          formatType: config.numberFormatType,
          expr: expr2,
          config
        });
      }
    }
    if (type7 === "temporal" && config.timeFormatType && isFieldDef(fieldOrDatumDef) && fieldOrDatumDef.timeUnit === void 0) {
      return formatCustomType({
        fieldOrDatumDef,
        format: config.timeFormat,
        formatType: config.timeFormatType,
        expr: expr2,
        config
      });
    }
  }
  function getTimeDef(def6) {
    if (!isFieldDef(def6)) {
      return {
        unit: void 0,
        utc: void 0
      };
    }
    return normalizeTimeUnit(def6.timeUnit) || {};
  }
  if (isFieldOrDatumDefForTimeFormat(fieldOrDatumDef)) {
    const { unit: timeUnit, utc: isUTCUnit } = getTimeDef(fieldOrDatumDef);
    const signal = timeFormatExpression({
      field: field25,
      timeUnit,
      format: format14,
      formatType: config.timeFormatType,
      rawTimeFormat: config.timeFormat,
      isUTCScale: isUTCUnit || isScaleFieldDef(fieldOrDatumDef) && ((_a2 = fieldOrDatumDef.scale) == null ? void 0 : _a2.type) === ScaleType.UTC
    });
    return signal ? { signal } : void 0;
  }
  format14 = numberFormat({ type: type7, specifiedFormat: format14, config, normalizeStack });
  if (isFieldDef(fieldOrDatumDef) && isBinning(fieldOrDatumDef.bin)) {
    const endField = vgField(fieldOrDatumDef, { expr: expr2, binSuffix: "end" });
    return {
      signal: binFormatExpression(field25, endField, format14, formatType, config)
    };
  } else if (format14 || channelDefType(fieldOrDatumDef) === "quantitative") {
    return {
      signal: `${formatExpr(field25, format14)}`
    };
  } else {
    return { signal: `isValid(${field25}) ? ${field25} : ""+${field25}` };
  }
}
function fieldToFormat(fieldOrDatumDef, expr2, normalizeStack) {
  if (isFieldDef(fieldOrDatumDef)) {
    if (normalizeStack) {
      return `${vgField(fieldOrDatumDef, { expr: expr2, suffix: "end" })}-${vgField(fieldOrDatumDef, {
        expr: expr2,
        suffix: "start"
      })}`;
    } else {
      return vgField(fieldOrDatumDef, { expr: expr2 });
    }
  } else {
    return datumDefToExpr(fieldOrDatumDef);
  }
}
function formatCustomType({ fieldOrDatumDef, format: format14, formatType, expr: expr2, normalizeStack, config, field: field25 }) {
  field25 ?? (field25 = fieldToFormat(fieldOrDatumDef, expr2, normalizeStack));
  if (field25 !== "datum.value" && // For axis/legend, we can't correctly know the end of the bin from `datum`
  isFieldDef(fieldOrDatumDef) && isBinning(fieldOrDatumDef.bin)) {
    const endField = vgField(fieldOrDatumDef, { expr: expr2, binSuffix: "end" });
    return {
      signal: binFormatExpression(field25, endField, format14, formatType, config)
    };
  }
  return { signal: customFormatExpr(formatType, field25, format14) };
}
function guideFormat(fieldOrDatumDef, type7, format14, formatType, config, omitTimeFormatConfig) {
  var _a2;
  if (isString14(formatType) && isCustomFormatType(formatType)) {
    return void 0;
  } else if (format14 === void 0 && formatType === void 0 && config.customFormatTypes) {
    if (channelDefType(fieldOrDatumDef) === "quantitative") {
      if (config.normalizedNumberFormatType && isPositionFieldOrDatumDef(fieldOrDatumDef) && fieldOrDatumDef.stack === "normalize") {
        return void 0;
      }
      if (config.numberFormatType) {
        return void 0;
      }
    }
  }
  if (isPositionFieldOrDatumDef(fieldOrDatumDef) && fieldOrDatumDef.stack === "normalize" && config.normalizedNumberFormat) {
    return numberFormat({
      type: "quantitative",
      config,
      normalizeStack: true
    });
  }
  if (isFieldOrDatumDefForTimeFormat(fieldOrDatumDef)) {
    const timeUnit = isFieldDef(fieldOrDatumDef) ? (_a2 = normalizeTimeUnit(fieldOrDatumDef.timeUnit)) == null ? void 0 : _a2.unit : void 0;
    if (timeUnit === void 0 && config.customFormatTypes && config.timeFormatType) {
      return void 0;
    }
    return timeFormat3({ specifiedFormat: format14, timeUnit, config, omitTimeFormatConfig });
  }
  return numberFormat({ type: type7, specifiedFormat: format14, config });
}
function guideFormatType(formatType, fieldOrDatumDef, scaleType2) {
  var _a2;
  if (formatType && (isSignalRef(formatType) || formatType === "number" || formatType === "time")) {
    return formatType;
  }
  if (isFieldOrDatumDefForTimeFormat(fieldOrDatumDef) && scaleType2 !== "time" && scaleType2 !== "utc") {
    return isFieldDef(fieldOrDatumDef) && ((_a2 = normalizeTimeUnit(fieldOrDatumDef == null ? void 0 : fieldOrDatumDef.timeUnit)) == null ? void 0 : _a2.utc) ? "utc" : "time";
  }
  return void 0;
}
function numberFormat({ type: type7, specifiedFormat, config, normalizeStack }) {
  if (isString14(specifiedFormat)) {
    return specifiedFormat;
  }
  if (type7 === QUANTITATIVE) {
    return normalizeStack ? config.normalizedNumberFormat : config.numberFormat;
  }
  return void 0;
}
function timeFormat3({ specifiedFormat, timeUnit, config, omitTimeFormatConfig }) {
  if (specifiedFormat) {
    return specifiedFormat;
  }
  if (timeUnit) {
    return {
      signal: timeUnitSpecifierExpression(timeUnit)
    };
  }
  return omitTimeFormatConfig ? void 0 : config.timeFormat;
}
function formatExpr(field25, format14) {
  return `format(${field25}, "${format14 || ""}")`;
}
function binNumberFormatExpr(field25, format14, formatType, config) {
  if (isCustomFormatType(formatType)) {
    return customFormatExpr(formatType, field25, format14);
  }
  return formatExpr(field25, (isString14(format14) ? format14 : void 0) ?? config.numberFormat);
}
function binFormatExpression(startField, endField, format14, formatType, config) {
  if (format14 === void 0 && formatType === void 0 && config.customFormatTypes && config.numberFormatType) {
    return binFormatExpression(startField, endField, config.numberFormat, config.numberFormatType, config);
  }
  const start = binNumberFormatExpr(startField, format14, formatType, config);
  const end = binNumberFormatExpr(endField, format14, formatType, config);
  return `${fieldValidPredicate(startField, false)} ? "null" : ${start} + "${BIN_RANGE_DELIMITER}" + ${end}`;
}
function timeFormatExpression({ field: field25, timeUnit, format: format14, formatType, rawTimeFormat, isUTCScale }) {
  if (!timeUnit || format14) {
    if (!timeUnit && formatType) {
      return `${formatType}(${field25}, ${stringify2(format14)})`;
    }
    format14 = isString14(format14) ? format14 : rawTimeFormat;
    return `${isUTCScale ? "utc" : "time"}Format(${field25}, ${stringify2(format14)})`;
  } else {
    return formatExpression(timeUnit, field25, isUTCScale);
  }
}
var DEFAULT_SORT_OP = "min";
var SORT_BY_CHANNEL_INDEX = {
  x: 1,
  y: 1,
  color: 1,
  fill: 1,
  stroke: 1,
  strokeWidth: 1,
  size: 1,
  shape: 1,
  fillOpacity: 1,
  strokeOpacity: 1,
  opacity: 1,
  text: 1
};
function isSortByChannel(c5) {
  return has19(SORT_BY_CHANNEL_INDEX, c5);
}
function isSortByEncoding(sort4) {
  return hasProperty(sort4, "encoding");
}
function isSortField(sort4) {
  return sort4 && (sort4.op === "count" || hasProperty(sort4, "field"));
}
function isSortArray(sort4) {
  return sort4 && isArray22(sort4);
}
function isFacetMapping(f) {
  return hasProperty(f, "row") || hasProperty(f, "column");
}
function isFacetFieldDef(channelDef) {
  return hasProperty(channelDef, "header");
}
function isFacetSpec(spec) {
  return hasProperty(spec, "facet");
}
function isConditionalParameter(c5) {
  return hasProperty(c5, "param");
}
function isRepeatRef(field25) {
  return !isString14(field25) && hasProperty(field25, "repeat");
}
function toFieldDefBase(fieldDef) {
  const { field: field25, timeUnit, bin: bin5, aggregate } = fieldDef;
  return {
    ...timeUnit ? { timeUnit } : {},
    ...bin5 ? { bin: bin5 } : {},
    ...aggregate ? { aggregate } : {},
    field: field25
  };
}
function isSortableFieldDef(fieldDef) {
  return hasProperty(fieldDef, "sort");
}
function getBandPosition({ fieldDef, fieldDef2, markDef: mark, config }) {
  if (isFieldOrDatumDef(fieldDef) && fieldDef.bandPosition !== void 0) {
    return fieldDef.bandPosition;
  }
  if (isFieldDef(fieldDef)) {
    const { timeUnit, bin: bin5 } = fieldDef;
    if (timeUnit && !fieldDef2) {
      return getMarkConfig("timeUnitBandPosition", mark, config);
    } else if (isBinning(bin5)) {
      return 0.5;
    }
  }
  return void 0;
}
function getBandSize({ channel, fieldDef, fieldDef2, markDef: mark, config, scaleType: scaleType2, useVlSizeChannel }) {
  var _a2, _b, _c2;
  const sizeChannel = getSizeChannel(channel);
  const size = getMarkPropOrConfig(useVlSizeChannel ? "size" : sizeChannel, mark, config, {
    vgChannel: sizeChannel
  });
  if (size !== void 0) {
    return size;
  }
  if (isFieldDef(fieldDef)) {
    const { timeUnit, bin: bin5 } = fieldDef;
    if (timeUnit && !fieldDef2) {
      return { band: getMarkConfig("timeUnitBandSize", mark, config) };
    } else if (isBinning(bin5) && !hasDiscreteDomain(scaleType2)) {
      return { band: 1 };
    }
  }
  if (isRectBasedMark(mark.type)) {
    if (scaleType2) {
      if (hasDiscreteDomain(scaleType2)) {
        return ((_a2 = config[mark.type]) == null ? void 0 : _a2.discreteBandSize) || { band: 1 };
      } else {
        return (_b = config[mark.type]) == null ? void 0 : _b.continuousBandSize;
      }
    }
    return (_c2 = config[mark.type]) == null ? void 0 : _c2.discreteBandSize;
  }
  return void 0;
}
function hasBandEnd(fieldDef, fieldDef2, markDef, config) {
  if (isBinning(fieldDef.bin) || fieldDef.timeUnit && isTypedFieldDef(fieldDef) && fieldDef.type === "temporal") {
    return getBandPosition({ fieldDef, fieldDef2, markDef, config }) !== void 0;
  }
  return false;
}
function isOrderOnlyDef(orderDef) {
  return hasProperty(orderDef, "sort") && !hasProperty(orderDef, "field");
}
function isConditionalDef(channelDef) {
  return hasProperty(channelDef, "condition");
}
function hasConditionalFieldDef(channelDef) {
  const condition = channelDef == null ? void 0 : channelDef["condition"];
  return !!condition && !isArray22(condition) && isFieldDef(condition);
}
function hasConditionalFieldOrDatumDef(channelDef) {
  const condition = channelDef == null ? void 0 : channelDef["condition"];
  return !!condition && !isArray22(condition) && isFieldOrDatumDef(condition);
}
function hasConditionalValueDef(channelDef) {
  const condition = channelDef == null ? void 0 : channelDef["condition"];
  return !!condition && (isArray22(condition) || isValueDef(condition));
}
function isFieldDef(channelDef) {
  return hasProperty(channelDef, "field") || (channelDef == null ? void 0 : channelDef.aggregate) === "count";
}
function channelDefType(channelDef) {
  return channelDef == null ? void 0 : channelDef["type"];
}
function isDatumDef(channelDef) {
  return hasProperty(channelDef, "datum");
}
function isContinuousFieldOrDatumDef(cd2) {
  return isTypedFieldDef(cd2) && !isDiscrete7(cd2) || isNumericDataDef(cd2);
}
function isUnbinnedQuantitativeFieldOrDatumDef(cd2) {
  return isTypedFieldDef(cd2) && cd2.type === "quantitative" && !cd2.bin || isNumericDataDef(cd2);
}
function isNumericDataDef(cd2) {
  return isDatumDef(cd2) && isNumber14(cd2.datum);
}
function isFieldOrDatumDef(channelDef) {
  return isFieldDef(channelDef) || isDatumDef(channelDef);
}
function isTypedFieldDef(channelDef) {
  return channelDef && (hasProperty(channelDef, "field") || channelDef["aggregate"] === "count") && hasProperty(channelDef, "type");
}
function isValueDef(channelDef) {
  return hasProperty(channelDef, "value");
}
function isScaleFieldDef(channelDef) {
  return hasProperty(channelDef, "scale") || hasProperty(channelDef, "sort");
}
function isPositionFieldOrDatumDef(channelDef) {
  return hasProperty(channelDef, "axis") || hasProperty(channelDef, "stack") || hasProperty(channelDef, "impute");
}
function isMarkPropFieldOrDatumDef(channelDef) {
  return hasProperty(channelDef, "legend");
}
function isStringFieldOrDatumDef(channelDef) {
  return hasProperty(channelDef, "format") || hasProperty(channelDef, "formatType");
}
function toStringFieldDef(fieldDef) {
  return omit(fieldDef, ["legend", "axis", "header", "scale"]);
}
function isOpFieldDef(fieldDef) {
  return hasProperty(fieldDef, "op");
}
function vgField(fieldDef, opt = {}) {
  let field25 = fieldDef.field;
  const prefix = opt.prefix;
  let suffix = opt.suffix;
  let argAccessor = "";
  if (isCount(fieldDef)) {
    field25 = internalField("count");
  } else {
    let fn;
    if (!opt.nofn) {
      if (isOpFieldDef(fieldDef)) {
        fn = fieldDef.op;
      } else {
        const { bin: bin5, aggregate, timeUnit } = fieldDef;
        if (isBinning(bin5)) {
          fn = binToString(bin5);
          suffix = (opt.binSuffix ?? "") + (opt.suffix ?? "");
        } else if (aggregate) {
          if (isArgmaxDef(aggregate)) {
            argAccessor = `["${field25}"]`;
            field25 = `argmax_${aggregate.argmax}`;
          } else if (isArgminDef(aggregate)) {
            argAccessor = `["${field25}"]`;
            field25 = `argmin_${aggregate.argmin}`;
          } else {
            fn = String(aggregate);
          }
        } else if (timeUnit && !isBinnedTimeUnit(timeUnit)) {
          fn = timeUnitToString(timeUnit);
          suffix = (!["range", "mid"].includes(opt.binSuffix) && opt.binSuffix || "") + (opt.suffix ?? "");
        }
      }
    }
    if (fn) {
      field25 = field25 ? `${fn}_${field25}` : fn;
    }
  }
  if (suffix) {
    field25 = `${field25}_${suffix}`;
  }
  if (prefix) {
    field25 = `${prefix}_${field25}`;
  }
  if (opt.forAs) {
    return removePathFromField(field25);
  } else if (opt.expr) {
    return flatAccessWithDatum(field25, opt.expr) + argAccessor;
  } else {
    return replacePathInField(field25) + argAccessor;
  }
}
function isDiscrete7(def6) {
  switch (def6.type) {
    case "nominal":
    case "ordinal":
    case "geojson":
      return true;
    case "quantitative":
      return isFieldDef(def6) && !!def6.bin;
    case "temporal":
      return false;
  }
  throw new Error(invalidFieldType(def6.type));
}
function isDiscretizing7(def6) {
  var _a2;
  return isScaleFieldDef(def6) && isContinuousToDiscrete((_a2 = def6.scale) == null ? void 0 : _a2.type);
}
function isCount(fieldDef) {
  return fieldDef.aggregate === "count";
}
function verbalTitleFormatter(fieldDef, config) {
  var _a2;
  const { field: field25, bin: bin5, timeUnit, aggregate } = fieldDef;
  if (aggregate === "count") {
    return config.countTitle;
  } else if (isBinning(bin5)) {
    return `${field25} (binned)`;
  } else if (timeUnit && !isBinnedTimeUnit(timeUnit)) {
    const unit2 = (_a2 = normalizeTimeUnit(timeUnit)) == null ? void 0 : _a2.unit;
    if (unit2) {
      return `${field25} (${getTimeUnitParts(unit2).join("-")})`;
    }
  } else if (aggregate) {
    if (isArgmaxDef(aggregate)) {
      return `${field25} for max ${aggregate.argmax}`;
    } else if (isArgminDef(aggregate)) {
      return `${field25} for min ${aggregate.argmin}`;
    } else {
      return `${titleCase(aggregate)} of ${field25}`;
    }
  }
  return field25;
}
function functionalTitleFormatter(fieldDef) {
  const { aggregate, bin: bin5, timeUnit, field: field25 } = fieldDef;
  if (isArgmaxDef(aggregate)) {
    return `${field25} for argmax(${aggregate.argmax})`;
  } else if (isArgminDef(aggregate)) {
    return `${field25} for argmin(${aggregate.argmin})`;
  }
  const timeUnitParams = timeUnit && !isBinnedTimeUnit(timeUnit) ? normalizeTimeUnit(timeUnit) : void 0;
  const fn = aggregate || (timeUnitParams == null ? void 0 : timeUnitParams.unit) || (timeUnitParams == null ? void 0 : timeUnitParams.maxbins) && "timeunit" || isBinning(bin5) && "bin";
  return fn ? `${fn.toUpperCase()}(${field25})` : field25;
}
var defaultTitleFormatter = (fieldDef, config) => {
  switch (config.fieldTitle) {
    case "plain":
      return fieldDef.field;
    case "functional":
      return functionalTitleFormatter(fieldDef);
    default:
      return verbalTitleFormatter(fieldDef, config);
  }
};
var titleFormatter = defaultTitleFormatter;
function setTitleFormatter(formatter) {
  titleFormatter = formatter;
}
function resetTitleFormatter() {
  setTitleFormatter(defaultTitleFormatter);
}
function title(fieldOrDatumDef, config, { allowDisabling, includeDefault = true }) {
  var _a2;
  const guideTitle = (_a2 = getGuide(fieldOrDatumDef)) == null ? void 0 : _a2.title;
  if (!isFieldDef(fieldOrDatumDef)) {
    return guideTitle ?? fieldOrDatumDef.title;
  }
  const fieldDef = fieldOrDatumDef;
  const def6 = includeDefault ? defaultTitle(fieldDef, config) : void 0;
  if (allowDisabling) {
    return getFirstDefined(guideTitle, fieldDef.title, def6);
  } else {
    return guideTitle ?? fieldDef.title ?? def6;
  }
}
function getGuide(fieldDef) {
  if (isPositionFieldOrDatumDef(fieldDef) && fieldDef.axis) {
    return fieldDef.axis;
  } else if (isMarkPropFieldOrDatumDef(fieldDef) && fieldDef.legend) {
    return fieldDef.legend;
  } else if (isFacetFieldDef(fieldDef) && fieldDef.header) {
    return fieldDef.header;
  }
  return void 0;
}
function defaultTitle(fieldDef, config) {
  return titleFormatter(fieldDef, config);
}
function getFormatMixins(fieldDef) {
  if (isStringFieldOrDatumDef(fieldDef)) {
    const { format: format14, formatType } = fieldDef;
    return { format: format14, formatType };
  } else {
    const guide = getGuide(fieldDef) ?? {};
    const { format: format14, formatType } = guide;
    return { format: format14, formatType };
  }
}
function defaultType$2(fieldDef, channel) {
  var _a2;
  switch (channel) {
    case "latitude":
    case "longitude":
      return "quantitative";
    case "row":
    case "column":
    case "facet":
    case "shape":
    case "strokeDash":
      return "nominal";
    case "order":
      return "ordinal";
  }
  if (isSortableFieldDef(fieldDef) && isArray22(fieldDef.sort)) {
    return "ordinal";
  }
  const { aggregate, bin: bin5, timeUnit } = fieldDef;
  if (timeUnit) {
    return "temporal";
  }
  if (bin5 || aggregate && !isArgmaxDef(aggregate) && !isArgminDef(aggregate)) {
    return "quantitative";
  }
  if (isScaleFieldDef(fieldDef) && ((_a2 = fieldDef.scale) == null ? void 0 : _a2.type)) {
    switch (SCALE_CATEGORY_INDEX[fieldDef.scale.type]) {
      case "numeric":
      case "discretizing":
        return "quantitative";
      case "time":
        return "temporal";
    }
  }
  return "nominal";
}
function getFieldDef(channelDef) {
  if (isFieldDef(channelDef)) {
    return channelDef;
  } else if (hasConditionalFieldDef(channelDef)) {
    return channelDef.condition;
  }
  return void 0;
}
function getFieldOrDatumDef(channelDef) {
  if (isFieldOrDatumDef(channelDef)) {
    return channelDef;
  } else if (hasConditionalFieldOrDatumDef(channelDef)) {
    return channelDef.condition;
  }
  return void 0;
}
function initChannelDef(channelDef, channel, config, opt = {}) {
  if (isString14(channelDef) || isNumber14(channelDef) || isBoolean5(channelDef)) {
    const primitiveType = isString14(channelDef) ? "string" : isNumber14(channelDef) ? "number" : "boolean";
    warn2(primitiveChannelDef(channel, primitiveType, channelDef));
    return { value: channelDef };
  }
  if (isFieldOrDatumDef(channelDef)) {
    return initFieldOrDatumDef(channelDef, channel, config, opt);
  } else if (hasConditionalFieldOrDatumDef(channelDef)) {
    return {
      ...channelDef,
      // Need to cast as normalizeFieldDef normally return FieldDef, but here we know that it is definitely Condition<FieldDef>
      condition: initFieldOrDatumDef(channelDef.condition, channel, config, opt)
    };
  }
  return channelDef;
}
function initFieldOrDatumDef(fd, channel, config, opt) {
  if (isStringFieldOrDatumDef(fd)) {
    const { format: format14, formatType, ...rest } = fd;
    if (isCustomFormatType(formatType) && !config.customFormatTypes) {
      warn2(customFormatTypeNotAllowed(channel));
      return initFieldOrDatumDef(rest, channel, config, opt);
    }
  } else {
    const guideType = isPositionFieldOrDatumDef(fd) ? "axis" : isMarkPropFieldOrDatumDef(fd) ? "legend" : isFacetFieldDef(fd) ? "header" : null;
    if (guideType && fd[guideType]) {
      const { format: format14, formatType, ...newGuide } = fd[guideType];
      if (isCustomFormatType(formatType) && !config.customFormatTypes) {
        warn2(customFormatTypeNotAllowed(channel));
        return initFieldOrDatumDef({ ...fd, [guideType]: newGuide }, channel, config, opt);
      }
    }
  }
  if (isFieldDef(fd)) {
    return initFieldDef(fd, channel, opt);
  }
  return initDatumDef(fd);
}
function initDatumDef(datumDef) {
  let type7 = datumDef["type"];
  if (type7) {
    return datumDef;
  }
  const { datum: datum2 } = datumDef;
  type7 = isNumber14(datum2) ? "quantitative" : isString14(datum2) ? "nominal" : isDateTime(datum2) ? "temporal" : void 0;
  return { ...datumDef, type: type7 };
}
function initFieldDef(fd, channel, { compositeMark = false } = {}) {
  const { aggregate, timeUnit, bin: bin5, field: field25 } = fd;
  const fieldDef = { ...fd };
  if (!compositeMark && aggregate && !isAggregateOp(aggregate) && !isArgmaxDef(aggregate) && !isArgminDef(aggregate)) {
    warn2(invalidAggregate(aggregate));
    delete fieldDef.aggregate;
  }
  if (timeUnit) {
    fieldDef.timeUnit = normalizeTimeUnit(timeUnit);
  }
  if (field25) {
    fieldDef.field = `${field25}`;
  }
  if (isBinning(bin5)) {
    fieldDef.bin = normalizeBin(bin5, channel);
  }
  if (isBinned(bin5) && !isXorY(channel)) {
    warn2(channelShouldNotBeUsedForBinned(channel));
  }
  if (isTypedFieldDef(fieldDef)) {
    const { type: type7 } = fieldDef;
    const fullType = getFullName(type7);
    if (type7 !== fullType) {
      fieldDef.type = fullType;
    }
    if (type7 !== "quantitative") {
      if (isCountingAggregateOp(aggregate)) {
        warn2(invalidFieldTypeForCountAggregate(type7, aggregate));
        fieldDef.type = "quantitative";
      }
    }
  } else if (!isSecondaryRangeChannel(channel)) {
    const newType = defaultType$2(fieldDef, channel);
    fieldDef["type"] = newType;
  }
  if (isTypedFieldDef(fieldDef)) {
    const { compatible, warning } = channelCompatibility(fieldDef, channel) || {};
    if (compatible === false) {
      warn2(warning);
    }
  }
  if (isSortableFieldDef(fieldDef) && isString14(fieldDef.sort)) {
    const { sort: sort4 } = fieldDef;
    if (isSortByChannel(sort4)) {
      return {
        ...fieldDef,
        sort: { encoding: sort4 }
      };
    }
    const sub = sort4.substring(1);
    if (sort4.charAt(0) === "-" && isSortByChannel(sub)) {
      return {
        ...fieldDef,
        sort: { encoding: sub, order: "descending" }
      };
    }
  }
  if (isFacetFieldDef(fieldDef)) {
    const { header } = fieldDef;
    if (header) {
      const { orient: orient2, ...rest } = header;
      if (orient2) {
        return {
          ...fieldDef,
          header: {
            ...rest,
            labelOrient: header.labelOrient || orient2,
            titleOrient: header.titleOrient || orient2
          }
        };
      }
    }
  }
  return fieldDef;
}
function normalizeBin(bin5, channel) {
  if (isBoolean5(bin5)) {
    return { maxbins: autoMaxBins(channel) };
  } else if (bin5 === "binned") {
    return {
      binned: true
    };
  } else if (!bin5.maxbins && !bin5.step) {
    return { ...bin5, maxbins: autoMaxBins(channel) };
  } else {
    return bin5;
  }
}
var COMPATIBLE = { compatible: true };
function channelCompatibility(fieldDef, channel) {
  const type7 = fieldDef.type;
  if (type7 === "geojson" && channel !== "shape") {
    return {
      compatible: false,
      warning: `Channel ${channel} should not be used with a geojson data.`
    };
  }
  switch (channel) {
    case ROW:
    case COLUMN:
    case FACET:
      if (!isDiscrete7(fieldDef)) {
        return {
          compatible: false,
          warning: channelShouldBeDiscrete(channel)
        };
      }
      return COMPATIBLE;
    case X3:
    case Y3:
    case XOFFSET:
    case YOFFSET:
    case COLOR:
    case FILL:
    case STROKE:
    case TEXT$1:
    case DETAIL:
    case KEY:
    case TOOLTIP:
    case HREF:
    case URL2:
    case ANGLE:
    case THETA:
    case RADIUS:
    case DESCRIPTION:
      return COMPATIBLE;
    case LONGITUDE:
    case LONGITUDE2:
    case LATITUDE:
    case LATITUDE2:
      if (type7 !== QUANTITATIVE) {
        return {
          compatible: false,
          warning: `Channel ${channel} should be used with a quantitative field only, not ${fieldDef.type} field.`
        };
      }
      return COMPATIBLE;
    case OPACITY:
    case FILLOPACITY:
    case STROKEOPACITY:
    case STROKEWIDTH:
    case SIZE2:
    case THETA2:
    case RADIUS2:
    case X23:
    case Y23:
    case TIME:
      if (type7 === "nominal" && !fieldDef["sort"]) {
        return {
          compatible: false,
          warning: `Channel ${channel} should not be used with an unsorted discrete field.`
        };
      }
      return COMPATIBLE;
    case SHAPE:
    case STROKEDASH:
      if (!isDiscrete7(fieldDef) && !isDiscretizing7(fieldDef)) {
        return {
          compatible: false,
          warning: channelShouldBeDiscreteOrDiscretizing(channel)
        };
      }
      return COMPATIBLE;
    case ORDER:
      if (fieldDef.type === "nominal" && !("sort" in fieldDef)) {
        return {
          compatible: false,
          warning: `Channel order is inappropriate for nominal field, which has no inherent order.`
        };
      }
      return COMPATIBLE;
  }
}
function isFieldOrDatumDefForTimeFormat(fieldOrDatumDef) {
  const { formatType } = getFormatMixins(fieldOrDatumDef);
  return formatType === "time" || !formatType && isTemporalFieldDef(fieldOrDatumDef);
}
function isTemporalFieldDef(def6) {
  return def6 && (def6["type"] === "temporal" || isFieldDef(def6) && !!def6.timeUnit);
}
function valueExpr(v2, { timeUnit, type: type7, wrapTime, undefinedIfExprNotRequired }) {
  var _a2;
  const unit2 = timeUnit && ((_a2 = normalizeTimeUnit(timeUnit)) == null ? void 0 : _a2.unit);
  let isTime2 = unit2 || type7 === "temporal";
  let expr2;
  if (isExprRef(v2)) {
    expr2 = v2.expr;
  } else if (isSignalRef(v2)) {
    expr2 = v2.signal;
  } else if (isDateTime(v2)) {
    isTime2 = true;
    expr2 = dateTimeToExpr(v2);
  } else if (isString14(v2) || isNumber14(v2)) {
    if (isTime2) {
      expr2 = `datetime(${stringify2(v2)})`;
      if (isLocalSingleTimeUnit(unit2)) {
        if (isNumber14(v2) && v2 < 1e4 || isString14(v2) && isNaN(Date.parse(v2))) {
          expr2 = dateTimeToExpr({ [unit2]: v2 });
        }
      }
    }
  }
  if (expr2) {
    return wrapTime && isTime2 ? `time(${expr2})` : expr2;
  }
  return undefinedIfExprNotRequired ? void 0 : stringify2(v2);
}
function valueArray(fieldOrDatumDef, values7) {
  const { type: type7 } = fieldOrDatumDef;
  return values7.map((v2) => {
    const timeUnit = isFieldDef(fieldOrDatumDef) && !isBinnedTimeUnit(fieldOrDatumDef.timeUnit) ? fieldOrDatumDef.timeUnit : void 0;
    const expr2 = valueExpr(v2, {
      timeUnit,
      type: type7,
      undefinedIfExprNotRequired: true
    });
    if (expr2 !== void 0) {
      return { signal: expr2 };
    }
    return v2;
  });
}
function binRequiresRange(fieldDef, channel) {
  if (!isBinning(fieldDef.bin)) {
    console.warn("Only call this method for binned field defs.");
    return false;
  }
  return isScaleChannel(channel) && ["ordinal", "nominal"].includes(fieldDef.type);
}
var CONDITIONAL_AXIS_PROP_INDEX = {
  labelAlign: {
    part: "labels",
    vgProp: "align"
  },
  labelBaseline: {
    part: "labels",
    vgProp: "baseline"
  },
  labelColor: {
    part: "labels",
    vgProp: "fill"
  },
  labelFont: {
    part: "labels",
    vgProp: "font"
  },
  labelFontSize: {
    part: "labels",
    vgProp: "fontSize"
  },
  labelFontStyle: {
    part: "labels",
    vgProp: "fontStyle"
  },
  labelFontWeight: {
    part: "labels",
    vgProp: "fontWeight"
  },
  labelOpacity: {
    part: "labels",
    vgProp: "opacity"
  },
  labelOffset: null,
  labelPadding: null,
  // There is no fixed vgProp for tickSize, need to use signal.
  gridColor: {
    part: "grid",
    vgProp: "stroke"
  },
  gridDash: {
    part: "grid",
    vgProp: "strokeDash"
  },
  gridDashOffset: {
    part: "grid",
    vgProp: "strokeDashOffset"
  },
  gridOpacity: {
    part: "grid",
    vgProp: "opacity"
  },
  gridWidth: {
    part: "grid",
    vgProp: "strokeWidth"
  },
  tickColor: {
    part: "ticks",
    vgProp: "stroke"
  },
  tickDash: {
    part: "ticks",
    vgProp: "strokeDash"
  },
  tickDashOffset: {
    part: "ticks",
    vgProp: "strokeDashOffset"
  },
  tickOpacity: {
    part: "ticks",
    vgProp: "opacity"
  },
  tickSize: null,
  // There is no fixed vgProp for tickSize, need to use signal.
  tickWidth: {
    part: "ticks",
    vgProp: "strokeWidth"
  }
};
function isConditionalAxisValue(v2) {
  return v2 == null ? void 0 : v2.condition;
}
var AXIS_PARTS = ["domain", "grid", "labels", "ticks", "title"];
var AXIS_PROPERTY_TYPE = {
  grid: "grid",
  gridCap: "grid",
  gridColor: "grid",
  gridDash: "grid",
  gridDashOffset: "grid",
  gridOpacity: "grid",
  gridScale: "grid",
  gridWidth: "grid",
  orient: "main",
  bandPosition: "both",
  // Need to be applied to grid axis too, so the grid will align with ticks.
  aria: "main",
  description: "main",
  domain: "main",
  domainCap: "main",
  domainColor: "main",
  domainDash: "main",
  domainDashOffset: "main",
  domainOpacity: "main",
  domainWidth: "main",
  format: "main",
  formatType: "main",
  labelAlign: "main",
  labelAngle: "main",
  labelBaseline: "main",
  labelBound: "main",
  labelColor: "main",
  labelFlush: "main",
  labelFlushOffset: "main",
  labelFont: "main",
  labelFontSize: "main",
  labelFontStyle: "main",
  labelFontWeight: "main",
  labelLimit: "main",
  labelLineHeight: "main",
  labelOffset: "main",
  labelOpacity: "main",
  labelOverlap: "main",
  labelPadding: "main",
  labels: "main",
  labelSeparation: "main",
  maxExtent: "main",
  minExtent: "main",
  offset: "both",
  position: "main",
  tickCap: "main",
  tickColor: "main",
  tickDash: "main",
  tickDashOffset: "main",
  tickMinStep: "both",
  tickOffset: "both",
  // Need to be applied to grid axis too, so the grid will align with ticks.
  tickOpacity: "main",
  tickRound: "both",
  // Apply rounding to grid and ticks so they are aligned.
  ticks: "main",
  tickSize: "main",
  tickWidth: "both",
  title: "main",
  titleAlign: "main",
  titleAnchor: "main",
  titleAngle: "main",
  titleBaseline: "main",
  titleColor: "main",
  titleFont: "main",
  titleFontSize: "main",
  titleFontStyle: "main",
  titleFontWeight: "main",
  titleLimit: "main",
  titleLineHeight: "main",
  titleOpacity: "main",
  titlePadding: "main",
  titleX: "main",
  titleY: "main",
  encode: "both",
  // we hide this in Vega-Lite
  scale: "both",
  tickBand: "both",
  tickCount: "both",
  tickExtra: "both",
  translate: "both",
  values: "both",
  zindex: "both"
  // this is actually set afterward, so it doesn't matter
};
var COMMON_AXIS_PROPERTIES_INDEX = {
  orient: 1,
  // other things can depend on orient
  aria: 1,
  bandPosition: 1,
  description: 1,
  domain: 1,
  domainCap: 1,
  domainColor: 1,
  domainDash: 1,
  domainDashOffset: 1,
  domainOpacity: 1,
  domainWidth: 1,
  format: 1,
  formatType: 1,
  grid: 1,
  gridCap: 1,
  gridColor: 1,
  gridDash: 1,
  gridDashOffset: 1,
  gridOpacity: 1,
  gridWidth: 1,
  labelAlign: 1,
  labelAngle: 1,
  labelBaseline: 1,
  labelBound: 1,
  labelColor: 1,
  labelFlush: 1,
  labelFlushOffset: 1,
  labelFont: 1,
  labelFontSize: 1,
  labelFontStyle: 1,
  labelFontWeight: 1,
  labelLimit: 1,
  labelLineHeight: 1,
  labelOffset: 1,
  labelOpacity: 1,
  labelOverlap: 1,
  labelPadding: 1,
  labels: 1,
  labelSeparation: 1,
  maxExtent: 1,
  minExtent: 1,
  offset: 1,
  position: 1,
  tickBand: 1,
  tickCap: 1,
  tickColor: 1,
  tickCount: 1,
  tickDash: 1,
  tickDashOffset: 1,
  tickExtra: 1,
  tickMinStep: 1,
  tickOffset: 1,
  tickOpacity: 1,
  tickRound: 1,
  ticks: 1,
  tickSize: 1,
  tickWidth: 1,
  title: 1,
  titleAlign: 1,
  titleAnchor: 1,
  titleAngle: 1,
  titleBaseline: 1,
  titleColor: 1,
  titleFont: 1,
  titleFontSize: 1,
  titleFontStyle: 1,
  titleFontWeight: 1,
  titleLimit: 1,
  titleLineHeight: 1,
  titleOpacity: 1,
  titlePadding: 1,
  titleX: 1,
  titleY: 1,
  translate: 1,
  values: 1,
  zindex: 1
};
var AXIS_PROPERTIES_INDEX = {
  ...COMMON_AXIS_PROPERTIES_INDEX,
  style: 1,
  labelExpr: 1,
  encoding: 1
};
function isAxisProperty(prop) {
  return has19(AXIS_PROPERTIES_INDEX, prop);
}
var AXIS_CONFIGS_INDEX = {
  axis: 1,
  axisBand: 1,
  axisBottom: 1,
  axisDiscrete: 1,
  axisLeft: 1,
  axisPoint: 1,
  axisQuantitative: 1,
  axisRight: 1,
  axisTemporal: 1,
  axisTop: 1,
  axisX: 1,
  axisXBand: 1,
  axisXDiscrete: 1,
  axisXPoint: 1,
  axisXQuantitative: 1,
  axisXTemporal: 1,
  axisY: 1,
  axisYBand: 1,
  axisYDiscrete: 1,
  axisYPoint: 1,
  axisYQuantitative: 1,
  axisYTemporal: 1
};
var AXIS_CONFIGS = keys4(AXIS_CONFIGS_INDEX);
function isUnitSpec(spec) {
  return hasProperty(spec, "mark");
}
var CompositeMarkNormalizer = class {
  constructor(name, run2) {
    __publicField(this, "name");
    __publicField(this, "run");
    this.name = name;
    this.run = run2;
  }
  hasMatchingType(spec) {
    if (isUnitSpec(spec)) {
      return getMarkType(spec.mark) === this.name;
    }
    return false;
  }
};
function channelHasField(encoding, channel) {
  const channelDef = encoding == null ? void 0 : encoding[channel];
  if (channelDef) {
    if (isArray22(channelDef)) {
      return some2(channelDef, (fieldDef) => !!fieldDef.field);
    } else {
      return isFieldDef(channelDef) || hasConditionalFieldDef(channelDef);
    }
  }
  return false;
}
function channelHasFieldOrDatum(encoding, channel) {
  const channelDef = encoding == null ? void 0 : encoding[channel];
  if (channelDef) {
    if (isArray22(channelDef)) {
      return some2(channelDef, (fieldDef) => !!fieldDef.field);
    } else {
      return isFieldDef(channelDef) || isDatumDef(channelDef) || hasConditionalFieldOrDatumDef(channelDef);
    }
  }
  return false;
}
function channelHasNestedOffsetScale(encoding, channel) {
  if (isXorY(channel)) {
    const fieldDef = encoding[channel];
    if ((isFieldDef(fieldDef) || isDatumDef(fieldDef)) && (isDiscrete$1(fieldDef.type) || isFieldDef(fieldDef) && fieldDef.timeUnit)) {
      const offsetChannel = getOffsetScaleChannel(channel);
      return channelHasFieldOrDatum(encoding, offsetChannel);
    }
  }
  return false;
}
function isAggregate$1(encoding) {
  return some2(CHANNELS, (channel) => {
    if (channelHasField(encoding, channel)) {
      const channelDef = encoding[channel];
      if (isArray22(channelDef)) {
        return some2(channelDef, (fieldDef) => !!fieldDef.aggregate);
      } else {
        const fieldDef = getFieldDef(channelDef);
        return fieldDef && !!fieldDef.aggregate;
      }
    }
    return false;
  });
}
function extractTransformsFromEncoding(oldEncoding, config) {
  const groupby = [];
  const bins2 = [];
  const timeUnits4 = [];
  const aggregate = [];
  const encoding = {};
  forEach(oldEncoding, (channelDef, channel) => {
    if (isFieldDef(channelDef)) {
      const { field: field25, aggregate: aggOp, bin: bin5, timeUnit, ...remaining } = channelDef;
      if (aggOp || timeUnit || bin5) {
        const guide = getGuide(channelDef);
        const isTitleDefined = guide == null ? void 0 : guide.title;
        let newField = vgField(channelDef, { forAs: true });
        const newFieldDef = {
          // Only add title if it doesn't exist
          ...isTitleDefined ? [] : { title: title(channelDef, config, { allowDisabling: true }) },
          ...remaining,
          // Always overwrite field
          field: newField
        };
        if (aggOp) {
          let op;
          if (isArgmaxDef(aggOp)) {
            op = "argmax";
            newField = vgField({ op: "argmax", field: aggOp.argmax }, { forAs: true });
            newFieldDef.field = `${newField}.${field25}`;
          } else if (isArgminDef(aggOp)) {
            op = "argmin";
            newField = vgField({ op: "argmin", field: aggOp.argmin }, { forAs: true });
            newFieldDef.field = `${newField}.${field25}`;
          } else if (aggOp !== "boxplot" && aggOp !== "errorbar" && aggOp !== "errorband") {
            op = aggOp;
          }
          if (op) {
            const aggregateEntry = {
              op,
              as: newField
            };
            if (field25) {
              aggregateEntry.field = field25;
            }
            aggregate.push(aggregateEntry);
          }
        } else {
          groupby.push(newField);
          if (isTypedFieldDef(channelDef) && isBinning(bin5)) {
            bins2.push({ bin: bin5, field: field25, as: newField });
            groupby.push(vgField(channelDef, { binSuffix: "end" }));
            if (binRequiresRange(channelDef, channel)) {
              groupby.push(vgField(channelDef, { binSuffix: "range" }));
            }
            if (isXorY(channel)) {
              const secondaryChannel = {
                field: `${newField}_end`
              };
              encoding[`${channel}2`] = secondaryChannel;
            }
            newFieldDef.bin = "binned";
            if (!isSecondaryRangeChannel(channel)) {
              newFieldDef["type"] = QUANTITATIVE;
            }
          } else if (timeUnit && !isBinnedTimeUnit(timeUnit)) {
            timeUnits4.push({
              timeUnit,
              field: field25,
              as: newField
            });
            const formatType = isTypedFieldDef(channelDef) && channelDef.type !== TEMPORAL && "time";
            if (formatType) {
              if (channel === TEXT$1 || channel === TOOLTIP) {
                newFieldDef["formatType"] = formatType;
              } else if (isNonPositionScaleChannel(channel)) {
                newFieldDef["legend"] = {
                  formatType,
                  ...newFieldDef["legend"]
                };
              } else if (isXorY(channel)) {
                newFieldDef["axis"] = {
                  formatType,
                  ...newFieldDef["axis"]
                };
              }
            }
          }
        }
        encoding[channel] = newFieldDef;
      } else {
        groupby.push(field25);
        encoding[channel] = oldEncoding[channel];
      }
    } else {
      encoding[channel] = oldEncoding[channel];
    }
  });
  return {
    bins: bins2,
    timeUnits: timeUnits4,
    aggregate,
    groupby,
    encoding
  };
}
function markChannelCompatible(encoding, channel, mark) {
  const markSupported = supportMark(channel, mark);
  if (!markSupported) {
    return false;
  } else if (markSupported === "binned") {
    const primaryFieldDef = encoding[channel === X23 ? X3 : Y3];
    if (isFieldDef(primaryFieldDef) && isFieldDef(encoding[channel]) && isBinned(primaryFieldDef.bin)) {
      return true;
    } else {
      return false;
    }
  }
  return true;
}
function initEncoding(encoding, mark, filled, config) {
  const normalizedEncoding = {};
  for (const key4 of keys4(encoding)) {
    if (!isChannel(key4)) {
      warn2(invalidEncodingChannel(key4));
    }
  }
  for (let channel of UNIT_CHANNELS) {
    if (!encoding[channel]) {
      continue;
    }
    const channelDef = encoding[channel];
    if (isXorYOffset(channel)) {
      const mainChannel = getMainChannelFromOffsetChannel(channel);
      const positionDef = normalizedEncoding[mainChannel];
      if (isFieldDef(positionDef)) {
        if (isContinuous3(positionDef.type)) {
          if (isFieldDef(channelDef) && !positionDef.timeUnit) {
            warn2(offsetNestedInsideContinuousPositionScaleDropped(mainChannel));
            continue;
          }
        }
      }
    }
    if (channel === "angle" && mark === "arc" && !encoding.theta) {
      warn2(REPLACE_ANGLE_WITH_THETA);
      channel = THETA;
    }
    if (!markChannelCompatible(encoding, channel, mark)) {
      warn2(incompatibleChannel(channel, mark));
      continue;
    }
    if (channel === SIZE2 && mark === "line") {
      const fieldDef = getFieldDef(encoding[channel]);
      if (fieldDef == null ? void 0 : fieldDef.aggregate) {
        warn2(LINE_WITH_VARYING_SIZE);
        continue;
      }
    }
    if (channel === COLOR && (filled ? "fill" in encoding : "stroke" in encoding)) {
      warn2(droppingColor("encoding", { fill: "fill" in encoding, stroke: "stroke" in encoding }));
      continue;
    }
    if (channel === DETAIL || channel === ORDER && !isArray22(channelDef) && !isValueDef(channelDef) || channel === TOOLTIP && isArray22(channelDef)) {
      if (channelDef) {
        if (channel === ORDER) {
          const def6 = encoding[channel];
          if (isOrderOnlyDef(def6)) {
            normalizedEncoding[channel] = def6;
            continue;
          }
        }
        normalizedEncoding[channel] = array21(channelDef).reduce((defs, fieldDef) => {
          if (!isFieldDef(fieldDef)) {
            warn2(emptyFieldDef(fieldDef, channel));
          } else {
            defs.push(initFieldDef(fieldDef, channel));
          }
          return defs;
        }, []);
      }
    } else {
      if (channel === TOOLTIP && channelDef === null) {
        normalizedEncoding[channel] = null;
      } else if (!isFieldDef(channelDef) && !isDatumDef(channelDef) && !isValueDef(channelDef) && !isConditionalDef(channelDef) && !isSignalRef(channelDef)) {
        warn2(emptyFieldDef(channelDef, channel));
        continue;
      }
      normalizedEncoding[channel] = initChannelDef(channelDef, channel, config);
    }
  }
  return normalizedEncoding;
}
function normalizeEncoding(encoding, config) {
  const normalizedEncoding = {};
  for (const channel of keys4(encoding)) {
    const newChannelDef = initChannelDef(encoding[channel], channel, config, { compositeMark: true });
    normalizedEncoding[channel] = newChannelDef;
  }
  return normalizedEncoding;
}
function fieldDefs(encoding) {
  const arr = [];
  for (const channel of keys4(encoding)) {
    if (channelHasField(encoding, channel)) {
      const channelDef = encoding[channel];
      const channelDefArray = array21(channelDef);
      for (const def6 of channelDefArray) {
        if (isFieldDef(def6)) {
          arr.push(def6);
        } else if (hasConditionalFieldDef(def6)) {
          arr.push(def6.condition);
        }
      }
    }
  }
  return arr;
}
function forEach(mapping, f, thisArg) {
  if (!mapping) {
    return;
  }
  for (const channel of keys4(mapping)) {
    const el = mapping[channel];
    if (isArray22(el)) {
      for (const channelDef of el) {
        f.call(thisArg, channelDef, channel);
      }
    } else {
      f.call(thisArg, el, channel);
    }
  }
}
function reduce2(mapping, f, init2, thisArg) {
  if (!mapping) {
    return init2;
  }
  return keys4(mapping).reduce((r, channel) => {
    const map13 = mapping[channel];
    if (isArray22(map13)) {
      return map13.reduce((r1, channelDef) => {
        return f.call(thisArg, r1, channelDef, channel);
      }, r);
    } else {
      return f.call(thisArg, r, map13, channel);
    }
  }, init2);
}
function pathGroupingFields(mark, encoding) {
  return keys4(encoding).reduce((details, channel) => {
    switch (channel) {
      case X3:
      case Y3:
      case HREF:
      case DESCRIPTION:
      case URL2:
      case X23:
      case Y23:
      case XOFFSET:
      case YOFFSET:
      case THETA:
      case THETA2:
      case RADIUS:
      case RADIUS2:
      case TIME:
      case LATITUDE:
      case LONGITUDE:
      case LATITUDE2:
      case LONGITUDE2:
      case TEXT$1:
      case SHAPE:
      case ANGLE:
      case TOOLTIP:
        return details;
      case ORDER:
        if (mark === "line" || mark === "trail") {
          return details;
        }
      case DETAIL:
      case KEY: {
        const channelDef = encoding[channel];
        if (isArray22(channelDef) || isFieldDef(channelDef)) {
          for (const fieldDef of array21(channelDef)) {
            if (!fieldDef.aggregate) {
              details.push(vgField(fieldDef, {}));
            }
          }
        }
        return details;
      }
      case SIZE2:
        if (mark === "trail") {
          return details;
        }
      case COLOR:
      case FILL:
      case STROKE:
      case OPACITY:
      case FILLOPACITY:
      case STROKEOPACITY:
      case STROKEDASH:
      case STROKEWIDTH: {
        const fieldDef = getFieldDef(encoding[channel]);
        if (fieldDef && !fieldDef.aggregate) {
          details.push(vgField(fieldDef, {}));
        }
        return details;
      }
    }
  }, []);
}
function filterTooltipWithAggregatedField(oldEncoding) {
  const { tooltip: tooltip2, ...filteredEncoding } = oldEncoding;
  if (!tooltip2) {
    return { filteredEncoding };
  }
  let customTooltipWithAggregatedField;
  let customTooltipWithoutAggregatedField;
  if (isArray22(tooltip2)) {
    for (const t of tooltip2) {
      if (t.aggregate) {
        if (!customTooltipWithAggregatedField) {
          customTooltipWithAggregatedField = [];
        }
        customTooltipWithAggregatedField.push(t);
      } else {
        if (!customTooltipWithoutAggregatedField) {
          customTooltipWithoutAggregatedField = [];
        }
        customTooltipWithoutAggregatedField.push(t);
      }
    }
    if (customTooltipWithAggregatedField) {
      filteredEncoding.tooltip = customTooltipWithAggregatedField;
    }
  } else {
    if (tooltip2.aggregate) {
      filteredEncoding.tooltip = tooltip2;
    } else {
      customTooltipWithoutAggregatedField = tooltip2;
    }
  }
  if (isArray22(customTooltipWithoutAggregatedField) && customTooltipWithoutAggregatedField.length === 1) {
    customTooltipWithoutAggregatedField = customTooltipWithoutAggregatedField[0];
  }
  return { customTooltipWithoutAggregatedField, filteredEncoding };
}
function getCompositeMarkTooltip(tooltipSummary, continuousAxisChannelDef, encodingWithoutContinuousAxis, withFieldName = true) {
  if ("tooltip" in encodingWithoutContinuousAxis) {
    return { tooltip: encodingWithoutContinuousAxis.tooltip };
  }
  const fiveSummaryTooltip = tooltipSummary.map(({ fieldPrefix, titlePrefix }) => {
    const mainTitle = withFieldName ? ` of ${getTitle(continuousAxisChannelDef)}` : "";
    return {
      field: fieldPrefix + continuousAxisChannelDef.field,
      type: continuousAxisChannelDef.type,
      title: isSignalRef(titlePrefix) ? { signal: `${titlePrefix}"${escape(mainTitle)}"` } : titlePrefix + mainTitle
    };
  });
  const tooltipFieldDefs = fieldDefs(encodingWithoutContinuousAxis).map(toStringFieldDef);
  return {
    tooltip: [
      ...fiveSummaryTooltip,
      // need to cast because TextFieldDef supports fewer types of bin
      ...unique(tooltipFieldDefs, hash)
    ]
  };
}
function getTitle(continuousAxisChannelDef) {
  const { title: title2, field: field25 } = continuousAxisChannelDef;
  return getFirstDefined(title2, field25);
}
function makeCompositeAggregatePartFactory(compositeMarkDef, continuousAxis, continuousAxisChannelDef, sharedEncoding, compositeMarkConfig) {
  const { scale: scale19, axis } = continuousAxisChannelDef;
  return ({ partName, mark, positionPrefix, endPositionPrefix = void 0, extraEncoding = {} }) => {
    const title2 = getTitle(continuousAxisChannelDef);
    return partLayerMixins(compositeMarkDef, partName, compositeMarkConfig, {
      mark,
      // TODO better remove this method and just have mark as a parameter of the method
      encoding: {
        [continuousAxis]: {
          field: `${positionPrefix}_${continuousAxisChannelDef.field}`,
          type: continuousAxisChannelDef.type,
          ...title2 !== void 0 ? { title: title2 } : {},
          ...scale19 !== void 0 ? { scale: scale19 } : {},
          ...axis !== void 0 ? { axis } : {}
        },
        ...isString14(endPositionPrefix) ? {
          [`${continuousAxis}2`]: {
            field: `${endPositionPrefix}_${continuousAxisChannelDef.field}`
          }
        } : {},
        ...sharedEncoding,
        ...extraEncoding
      }
    });
  };
}
function partLayerMixins(markDef, part, compositeMarkConfig, partBaseSpec) {
  const { clip: clip7, color: color9, opacity: opacity2 } = markDef;
  const mark = markDef.type;
  if (markDef[part] || markDef[part] === void 0 && compositeMarkConfig[part]) {
    return [
      {
        ...partBaseSpec,
        mark: {
          ...compositeMarkConfig[part],
          ...clip7 ? { clip: clip7 } : {},
          ...color9 ? { color: color9 } : {},
          ...opacity2 ? { opacity: opacity2 } : {},
          ...isMarkDef(partBaseSpec.mark) ? partBaseSpec.mark : { type: partBaseSpec.mark },
          style: `${mark}-${String(part)}`,
          ...isBoolean5(markDef[part]) ? {} : markDef[part]
        }
      }
    ];
  }
  return [];
}
function compositeMarkContinuousAxis(spec, orient2, compositeMark) {
  const { encoding } = spec;
  const continuousAxis = orient2 === "vertical" ? "y" : "x";
  const continuousAxisChannelDef = encoding[continuousAxis];
  const continuousAxisChannelDef2 = encoding[`${continuousAxis}2`];
  const continuousAxisChannelDefError = encoding[`${continuousAxis}Error`];
  const continuousAxisChannelDefError2 = encoding[`${continuousAxis}Error2`];
  return {
    continuousAxisChannelDef: filterAggregateFromChannelDef(continuousAxisChannelDef, compositeMark),
    continuousAxisChannelDef2: filterAggregateFromChannelDef(continuousAxisChannelDef2, compositeMark),
    continuousAxisChannelDefError: filterAggregateFromChannelDef(continuousAxisChannelDefError, compositeMark),
    continuousAxisChannelDefError2: filterAggregateFromChannelDef(continuousAxisChannelDefError2, compositeMark),
    continuousAxis
  };
}
function filterAggregateFromChannelDef(continuousAxisChannelDef, compositeMark) {
  if (continuousAxisChannelDef == null ? void 0 : continuousAxisChannelDef.aggregate) {
    const { aggregate, ...continuousAxisWithoutAggregate } = continuousAxisChannelDef;
    if (aggregate !== compositeMark) {
      warn2(errorBarContinuousAxisHasCustomizedAggregate(aggregate, compositeMark));
    }
    return continuousAxisWithoutAggregate;
  } else {
    return continuousAxisChannelDef;
  }
}
function compositeMarkOrient(spec, compositeMark) {
  const { mark, encoding } = spec;
  const { x: x9, y: y9 } = encoding;
  if (isMarkDef(mark) && mark.orient) {
    return mark.orient;
  }
  if (isContinuousFieldOrDatumDef(x9)) {
    if (isContinuousFieldOrDatumDef(y9)) {
      const xAggregate = isFieldDef(x9) && x9.aggregate;
      const yAggregate = isFieldDef(y9) && y9.aggregate;
      if (!xAggregate && yAggregate === compositeMark) {
        return "vertical";
      } else if (!yAggregate && xAggregate === compositeMark) {
        return "horizontal";
      } else if (xAggregate === compositeMark && yAggregate === compositeMark) {
        throw new Error("Both x and y cannot have aggregate");
      } else {
        if (isFieldOrDatumDefForTimeFormat(y9) && !isFieldOrDatumDefForTimeFormat(x9)) {
          return "horizontal";
        }
        return "vertical";
      }
    }
    return "horizontal";
  } else if (isContinuousFieldOrDatumDef(y9)) {
    return "vertical";
  } else {
    throw new Error(`Need a valid continuous axis for ${compositeMark}s`);
  }
}
var BOXPLOT = "boxplot";
var BOXPLOT_PARTS = ["box", "median", "outliers", "rule", "ticks"];
var boxPlotNormalizer = new CompositeMarkNormalizer(BOXPLOT, normalizeBoxPlot);
function getBoxPlotType(extent8) {
  if (isNumber14(extent8)) {
    return "tukey";
  }
  return extent8;
}
function normalizeBoxPlot(spec, { config }) {
  spec = {
    ...spec,
    encoding: normalizeEncoding(spec.encoding, config)
  };
  const { mark, encoding: _encoding, params: params2, projection: _p, ...outerSpec } = spec;
  const markDef = isMarkDef(mark) ? mark : { type: mark };
  if (params2) {
    warn2(selectionNotSupported("boxplot"));
  }
  const extent8 = markDef.extent ?? config.boxplot.extent;
  const sizeValue = getMarkPropOrConfig(
    "size",
    markDef,
    // TODO: https://github.com/vega/vega-lite/issues/6245
    config
  );
  const invalid = markDef.invalid;
  const boxPlotType = getBoxPlotType(extent8);
  const { bins: bins2, timeUnits: timeUnits4, transform: transform4, continuousAxisChannelDef, continuousAxis, groupby, aggregate, encodingWithoutContinuousAxis, ticksOrient, boxOrient, customTooltipWithoutAggregatedField } = boxParams(spec, extent8, config);
  const aliasedFieldName = removePathFromField(continuousAxisChannelDef.field);
  const { color: color9, size, ...encodingWithoutSizeColorAndContinuousAxis } = encodingWithoutContinuousAxis;
  const makeBoxPlotPart = (sharedEncoding) => {
    return makeCompositeAggregatePartFactory(markDef, continuousAxis, continuousAxisChannelDef, sharedEncoding, config.boxplot);
  };
  const makeBoxPlotExtent = makeBoxPlotPart(encodingWithoutSizeColorAndContinuousAxis);
  const makeBoxPlotBox = makeBoxPlotPart(encodingWithoutContinuousAxis);
  const defaultBoxColor = (isObject12(config.boxplot.box) ? config.boxplot.box.color : config.mark.color) || "#4c78a8";
  const makeBoxPlotMidTick = makeBoxPlotPart({
    ...encodingWithoutSizeColorAndContinuousAxis,
    ...size ? { size } : {},
    color: {
      condition: {
        test: `${accessWithDatumToUnescapedPath(`lower_box_${continuousAxisChannelDef.field}`)} >= ${accessWithDatumToUnescapedPath(`upper_box_${continuousAxisChannelDef.field}`)}`,
        ...color9 || { value: defaultBoxColor }
      }
    }
  });
  const fiveSummaryTooltipEncoding = getCompositeMarkTooltip([
    { fieldPrefix: boxPlotType === "min-max" ? "upper_whisker_" : "max_", titlePrefix: "Max" },
    { fieldPrefix: "upper_box_", titlePrefix: "Q3" },
    { fieldPrefix: "mid_box_", titlePrefix: "Median" },
    { fieldPrefix: "lower_box_", titlePrefix: "Q1" },
    { fieldPrefix: boxPlotType === "min-max" ? "lower_whisker_" : "min_", titlePrefix: "Min" }
  ], continuousAxisChannelDef, encodingWithoutContinuousAxis);
  const endTick = { type: "tick", color: "black", opacity: 1, orient: ticksOrient, invalid, aria: false };
  const whiskerTooltipEncoding = boxPlotType === "min-max" ? fiveSummaryTooltipEncoding : (
    // for tukey / k-IQR, just show upper/lower-whisker
    getCompositeMarkTooltip([
      { fieldPrefix: "upper_whisker_", titlePrefix: "Upper Whisker" },
      { fieldPrefix: "lower_whisker_", titlePrefix: "Lower Whisker" }
    ], continuousAxisChannelDef, encodingWithoutContinuousAxis)
  );
  const whiskerLayers = [
    ...makeBoxPlotExtent({
      partName: "rule",
      mark: { type: "rule", invalid, aria: false },
      positionPrefix: "lower_whisker",
      endPositionPrefix: "lower_box",
      extraEncoding: whiskerTooltipEncoding
    }),
    ...makeBoxPlotExtent({
      partName: "rule",
      mark: { type: "rule", invalid, aria: false },
      positionPrefix: "upper_box",
      endPositionPrefix: "upper_whisker",
      extraEncoding: whiskerTooltipEncoding
    }),
    ...makeBoxPlotExtent({
      partName: "ticks",
      mark: endTick,
      positionPrefix: "lower_whisker",
      extraEncoding: whiskerTooltipEncoding
    }),
    ...makeBoxPlotExtent({
      partName: "ticks",
      mark: endTick,
      positionPrefix: "upper_whisker",
      extraEncoding: whiskerTooltipEncoding
    })
  ];
  const boxLayers = [
    ...boxPlotType !== "tukey" ? whiskerLayers : [],
    ...makeBoxPlotBox({
      partName: "box",
      mark: {
        type: "bar",
        ...sizeValue ? { size: sizeValue } : {},
        orient: boxOrient,
        invalid,
        ariaRoleDescription: "box"
      },
      positionPrefix: "lower_box",
      endPositionPrefix: "upper_box",
      extraEncoding: fiveSummaryTooltipEncoding
    }),
    ...makeBoxPlotMidTick({
      partName: "median",
      mark: {
        type: "tick",
        invalid,
        ...isObject12(config.boxplot.median) && config.boxplot.median.color ? { color: config.boxplot.median.color } : {},
        ...sizeValue ? { size: sizeValue } : {},
        orient: ticksOrient,
        aria: false
      },
      positionPrefix: "mid_box",
      extraEncoding: fiveSummaryTooltipEncoding
    })
  ];
  if (boxPlotType === "min-max") {
    return {
      ...outerSpec,
      transform: (outerSpec.transform ?? []).concat(transform4),
      layer: boxLayers
    };
  }
  const lowerBoxExpr = accessWithDatumToUnescapedPath(`lower_box_${continuousAxisChannelDef.field}`);
  const upperBoxExpr = accessWithDatumToUnescapedPath(`upper_box_${continuousAxisChannelDef.field}`);
  const iqrExpr = `(${upperBoxExpr} - ${lowerBoxExpr})`;
  const lowerWhiskerExpr = `${lowerBoxExpr} - ${extent8} * ${iqrExpr}`;
  const upperWhiskerExpr = `${upperBoxExpr} + ${extent8} * ${iqrExpr}`;
  const fieldExpr2 = accessWithDatumToUnescapedPath(continuousAxisChannelDef.field);
  const joinaggregateTransform = {
    joinaggregate: boxParamsQuartiles(continuousAxisChannelDef.field),
    groupby
  };
  const filteredWhiskerSpec = {
    transform: [
      {
        filter: `(${lowerWhiskerExpr} <= ${fieldExpr2}) && (${fieldExpr2} <= ${upperWhiskerExpr})`
      },
      {
        aggregate: [
          {
            op: "min",
            field: continuousAxisChannelDef.field,
            as: `lower_whisker_${aliasedFieldName}`
          },
          {
            op: "max",
            field: continuousAxisChannelDef.field,
            as: `upper_whisker_${aliasedFieldName}`
          },
          // preserve lower_box / upper_box
          {
            op: "min",
            field: `lower_box_${continuousAxisChannelDef.field}`,
            as: `lower_box_${aliasedFieldName}`
          },
          {
            op: "max",
            field: `upper_box_${continuousAxisChannelDef.field}`,
            as: `upper_box_${aliasedFieldName}`
          },
          ...aggregate
        ],
        groupby
      }
    ],
    layer: whiskerLayers
  };
  const { tooltip: tooltip2, ...encodingWithoutSizeColorContinuousAxisAndTooltip } = encodingWithoutSizeColorAndContinuousAxis;
  const { scale: scale19, axis } = continuousAxisChannelDef;
  const title2 = getTitle(continuousAxisChannelDef);
  const outlierLayersMixins = partLayerMixins(markDef, "outliers", config.boxplot, {
    transform: [{ filter: `(${fieldExpr2} < ${lowerWhiskerExpr}) || (${fieldExpr2} > ${upperWhiskerExpr})` }],
    mark: "point",
    encoding: {
      [continuousAxis]: {
        field: continuousAxisChannelDef.field,
        type: continuousAxisChannelDef.type,
        ...title2 !== void 0 ? { title: title2 } : {},
        ...scale19 !== void 0 ? { scale: scale19 } : {},
        ...axis !== void 0 ? { axis } : {}
      },
      ...encodingWithoutSizeColorContinuousAxisAndTooltip,
      ...color9 ? { color: color9 } : {},
      ...customTooltipWithoutAggregatedField ? { tooltip: customTooltipWithoutAggregatedField } : {}
    }
  })[0];
  let filteredLayersMixins;
  const filteredLayersMixinsTransforms = [...bins2, ...timeUnits4, joinaggregateTransform];
  if (outlierLayersMixins) {
    filteredLayersMixins = {
      transform: filteredLayersMixinsTransforms,
      layer: [outlierLayersMixins, filteredWhiskerSpec]
    };
  } else {
    filteredLayersMixins = filteredWhiskerSpec;
    filteredLayersMixins.transform.unshift(...filteredLayersMixinsTransforms);
  }
  return {
    ...outerSpec,
    layer: [
      filteredLayersMixins,
      {
        // boxplot
        transform: transform4,
        layer: boxLayers
      }
    ]
  };
}
function boxParamsQuartiles(continousAxisField) {
  const aliasedFieldName = removePathFromField(continousAxisField);
  return [
    {
      op: "q1",
      field: continousAxisField,
      as: `lower_box_${aliasedFieldName}`
    },
    {
      op: "q3",
      field: continousAxisField,
      as: `upper_box_${aliasedFieldName}`
    }
  ];
}
function boxParams(spec, extent8, config) {
  const orient2 = compositeMarkOrient(spec, BOXPLOT);
  const { continuousAxisChannelDef, continuousAxis } = compositeMarkContinuousAxis(spec, orient2, BOXPLOT);
  const continuousFieldName = continuousAxisChannelDef.field;
  const aliasedFieldName = removePathFromField(continuousFieldName);
  const boxPlotType = getBoxPlotType(extent8);
  const boxplotSpecificAggregate = [
    ...boxParamsQuartiles(continuousFieldName),
    {
      op: "median",
      field: continuousFieldName,
      as: `mid_box_${aliasedFieldName}`
    },
    {
      op: "min",
      field: continuousFieldName,
      as: (boxPlotType === "min-max" ? "lower_whisker_" : "min_") + aliasedFieldName
    },
    {
      op: "max",
      field: continuousFieldName,
      as: (boxPlotType === "min-max" ? "upper_whisker_" : "max_") + aliasedFieldName
    }
  ];
  const postAggregateCalculates = boxPlotType === "min-max" || boxPlotType === "tukey" ? [] : [
    // This is for the  original k-IQR, which we do not expose
    {
      calculate: `${accessWithDatumToUnescapedPath(`upper_box_${aliasedFieldName}`)} - ${accessWithDatumToUnescapedPath(`lower_box_${aliasedFieldName}`)}`,
      as: `iqr_${aliasedFieldName}`
    },
    {
      calculate: `min(${accessWithDatumToUnescapedPath(`upper_box_${aliasedFieldName}`)} + ${accessWithDatumToUnescapedPath(`iqr_${aliasedFieldName}`)} * ${extent8}, ${accessWithDatumToUnescapedPath(`max_${aliasedFieldName}`)})`,
      as: `upper_whisker_${aliasedFieldName}`
    },
    {
      calculate: `max(${accessWithDatumToUnescapedPath(`lower_box_${aliasedFieldName}`)} - ${accessWithDatumToUnescapedPath(`iqr_${aliasedFieldName}`)} * ${extent8}, ${accessWithDatumToUnescapedPath(`min_${aliasedFieldName}`)})`,
      as: `lower_whisker_${aliasedFieldName}`
    }
  ];
  const { [continuousAxis]: oldContinuousAxisChannelDef, ...oldEncodingWithoutContinuousAxis } = spec.encoding;
  const { customTooltipWithoutAggregatedField, filteredEncoding } = filterTooltipWithAggregatedField(oldEncodingWithoutContinuousAxis);
  const { bins: bins2, timeUnits: timeUnits4, aggregate, groupby, encoding: encodingWithoutContinuousAxis } = extractTransformsFromEncoding(filteredEncoding, config);
  const ticksOrient = orient2 === "vertical" ? "horizontal" : "vertical";
  const boxOrient = orient2;
  const transform4 = [
    ...bins2,
    ...timeUnits4,
    {
      aggregate: [...aggregate, ...boxplotSpecificAggregate],
      groupby
    },
    ...postAggregateCalculates
  ];
  return {
    bins: bins2,
    timeUnits: timeUnits4,
    transform: transform4,
    groupby,
    aggregate,
    continuousAxisChannelDef,
    continuousAxis,
    encodingWithoutContinuousAxis,
    ticksOrient,
    boxOrient,
    customTooltipWithoutAggregatedField
  };
}
var ERRORBAR = "errorbar";
var ERRORBAR_PARTS = ["ticks", "rule"];
var errorBarNormalizer = new CompositeMarkNormalizer(ERRORBAR, normalizeErrorBar);
function normalizeErrorBar(spec, { config }) {
  spec = {
    ...spec,
    encoding: normalizeEncoding(spec.encoding, config)
  };
  const { transform: transform4, continuousAxisChannelDef, continuousAxis, encodingWithoutContinuousAxis, ticksOrient, markDef, outerSpec, tooltipEncoding } = errorBarParams(spec, ERRORBAR, config);
  delete encodingWithoutContinuousAxis.size;
  const makeErrorBarPart = makeCompositeAggregatePartFactory(markDef, continuousAxis, continuousAxisChannelDef, encodingWithoutContinuousAxis, config.errorbar);
  const thickness = markDef.thickness;
  const size = markDef.size;
  const tick2 = {
    type: "tick",
    orient: ticksOrient,
    aria: false,
    ...thickness !== void 0 ? { thickness } : {},
    ...size !== void 0 ? { size } : {}
  };
  const layer = [
    ...makeErrorBarPart({
      partName: "ticks",
      mark: tick2,
      positionPrefix: "lower",
      extraEncoding: tooltipEncoding
    }),
    ...makeErrorBarPart({
      partName: "ticks",
      mark: tick2,
      positionPrefix: "upper",
      extraEncoding: tooltipEncoding
    }),
    ...makeErrorBarPart({
      partName: "rule",
      mark: {
        type: "rule",
        ariaRoleDescription: "errorbar",
        ...thickness !== void 0 ? { size: thickness } : {}
      },
      positionPrefix: "lower",
      endPositionPrefix: "upper",
      extraEncoding: tooltipEncoding
    })
  ];
  return {
    ...outerSpec,
    transform: transform4,
    ...layer.length > 1 ? { layer } : { ...layer[0] }
  };
}
function errorBarOrientAndInputType(spec, compositeMark) {
  const { encoding } = spec;
  if (errorBarIsInputTypeRaw(encoding)) {
    return {
      orient: compositeMarkOrient(spec, compositeMark),
      inputType: "raw"
    };
  }
  const isTypeAggregatedUpperLower = errorBarIsInputTypeAggregatedUpperLower(encoding);
  const isTypeAggregatedError = errorBarIsInputTypeAggregatedError(encoding);
  const x9 = encoding.x;
  const y9 = encoding.y;
  if (isTypeAggregatedUpperLower) {
    if (isTypeAggregatedError) {
      throw new Error(`${compositeMark} cannot be both type aggregated-upper-lower and aggregated-error`);
    }
    const x22 = encoding.x2;
    const y22 = encoding.y2;
    if (isFieldOrDatumDef(x22) && isFieldOrDatumDef(y22)) {
      throw new Error(`${compositeMark} cannot have both x2 and y2`);
    } else if (isFieldOrDatumDef(x22)) {
      if (isContinuousFieldOrDatumDef(x9)) {
        return { orient: "horizontal", inputType: "aggregated-upper-lower" };
      } else {
        throw new Error(`Both x and x2 have to be quantitative in ${compositeMark}`);
      }
    } else if (isFieldOrDatumDef(y22)) {
      if (isContinuousFieldOrDatumDef(y9)) {
        return { orient: "vertical", inputType: "aggregated-upper-lower" };
      } else {
        throw new Error(`Both y and y2 have to be quantitative in ${compositeMark}`);
      }
    }
    throw new Error("No ranged axis");
  } else {
    const xError = encoding.xError;
    const xError2 = encoding.xError2;
    const yError = encoding.yError;
    const yError2 = encoding.yError2;
    if (isFieldOrDatumDef(xError2) && !isFieldOrDatumDef(xError)) {
      throw new Error(`${compositeMark} cannot have xError2 without xError`);
    }
    if (isFieldOrDatumDef(yError2) && !isFieldOrDatumDef(yError)) {
      throw new Error(`${compositeMark} cannot have yError2 without yError`);
    }
    if (isFieldOrDatumDef(xError) && isFieldOrDatumDef(yError)) {
      throw new Error(`${compositeMark} cannot have both xError and yError with both are quantiative`);
    } else if (isFieldOrDatumDef(xError)) {
      if (isContinuousFieldOrDatumDef(x9)) {
        return { orient: "horizontal", inputType: "aggregated-error" };
      } else {
        throw new Error("All x, xError, and xError2 (if exist) have to be quantitative");
      }
    } else if (isFieldOrDatumDef(yError)) {
      if (isContinuousFieldOrDatumDef(y9)) {
        return { orient: "vertical", inputType: "aggregated-error" };
      } else {
        throw new Error("All y, yError, and yError2 (if exist) have to be quantitative");
      }
    }
    throw new Error("No ranged axis");
  }
}
function errorBarIsInputTypeRaw(encoding) {
  return (isFieldOrDatumDef(encoding.x) || isFieldOrDatumDef(encoding.y)) && !isFieldOrDatumDef(encoding.x2) && !isFieldOrDatumDef(encoding.y2) && !isFieldOrDatumDef(encoding.xError) && !isFieldOrDatumDef(encoding.xError2) && !isFieldOrDatumDef(encoding.yError) && !isFieldOrDatumDef(encoding.yError2);
}
function errorBarIsInputTypeAggregatedUpperLower(encoding) {
  return isFieldOrDatumDef(encoding.x2) || isFieldOrDatumDef(encoding.y2);
}
function errorBarIsInputTypeAggregatedError(encoding) {
  return isFieldOrDatumDef(encoding.xError) || isFieldOrDatumDef(encoding.xError2) || isFieldOrDatumDef(encoding.yError) || isFieldOrDatumDef(encoding.yError2);
}
function errorBarParams(spec, compositeMark, config) {
  const { mark, encoding, params: params2, projection: _p, ...outerSpec } = spec;
  const markDef = isMarkDef(mark) ? mark : { type: mark };
  if (params2) {
    warn2(selectionNotSupported(compositeMark));
  }
  const { orient: orient2, inputType } = errorBarOrientAndInputType(spec, compositeMark);
  const { continuousAxisChannelDef, continuousAxisChannelDef2, continuousAxisChannelDefError, continuousAxisChannelDefError2, continuousAxis } = compositeMarkContinuousAxis(spec, orient2, compositeMark);
  const { errorBarSpecificAggregate, postAggregateCalculates, tooltipSummary, tooltipTitleWithFieldName } = errorBarAggregationAndCalculation(markDef, continuousAxisChannelDef, continuousAxisChannelDef2, continuousAxisChannelDefError, continuousAxisChannelDefError2, inputType, compositeMark, config);
  const { [continuousAxis]: oldContinuousAxisChannelDef, [continuousAxis === "x" ? "x2" : "y2"]: oldContinuousAxisChannelDef2, [continuousAxis === "x" ? "xError" : "yError"]: oldContinuousAxisChannelDefError, [continuousAxis === "x" ? "xError2" : "yError2"]: oldContinuousAxisChannelDefError2, ...oldEncodingWithoutContinuousAxis } = encoding;
  const { bins: bins2, timeUnits: timeUnits4, aggregate: oldAggregate, groupby: oldGroupBy, encoding: encodingWithoutContinuousAxis } = extractTransformsFromEncoding(oldEncodingWithoutContinuousAxis, config);
  const aggregate = [...oldAggregate, ...errorBarSpecificAggregate];
  const groupby = inputType !== "raw" ? [] : oldGroupBy;
  const tooltipEncoding = getCompositeMarkTooltip(tooltipSummary, continuousAxisChannelDef, encodingWithoutContinuousAxis, tooltipTitleWithFieldName);
  return {
    transform: [
      ...outerSpec.transform ?? [],
      ...bins2,
      ...timeUnits4,
      ...aggregate.length === 0 ? [] : [{ aggregate, groupby }],
      ...postAggregateCalculates
    ],
    groupby,
    continuousAxisChannelDef,
    continuousAxis,
    encodingWithoutContinuousAxis,
    ticksOrient: orient2 === "vertical" ? "horizontal" : "vertical",
    markDef,
    outerSpec,
    tooltipEncoding
  };
}
function errorBarAggregationAndCalculation(markDef, continuousAxisChannelDef, continuousAxisChannelDef2, continuousAxisChannelDefError, continuousAxisChannelDefError2, inputType, compositeMark, config) {
  let errorBarSpecificAggregate = [];
  let postAggregateCalculates = [];
  const continuousFieldName = continuousAxisChannelDef.field;
  let tooltipSummary;
  let tooltipTitleWithFieldName = false;
  if (inputType === "raw") {
    const center = markDef.center ? markDef.center : markDef.extent ? markDef.extent === "iqr" ? "median" : "mean" : config.errorbar.center;
    const extent8 = markDef.extent ? markDef.extent : center === "mean" ? "stderr" : "iqr";
    if (center === "median" !== (extent8 === "iqr")) {
      warn2(errorBarCenterIsUsedWithWrongExtent(center, extent8, compositeMark));
    }
    if (extent8 === "stderr" || extent8 === "stdev") {
      errorBarSpecificAggregate = [
        { op: extent8, field: continuousFieldName, as: `extent_${continuousFieldName}` },
        { op: center, field: continuousFieldName, as: `center_${continuousFieldName}` }
      ];
      postAggregateCalculates = [
        {
          calculate: `${accessWithDatumToUnescapedPath(`center_${continuousFieldName}`)} + ${accessWithDatumToUnescapedPath(`extent_${continuousFieldName}`)}`,
          as: `upper_${continuousFieldName}`
        },
        {
          calculate: `${accessWithDatumToUnescapedPath(`center_${continuousFieldName}`)} - ${accessWithDatumToUnescapedPath(`extent_${continuousFieldName}`)}`,
          as: `lower_${continuousFieldName}`
        }
      ];
      tooltipSummary = [
        { fieldPrefix: "center_", titlePrefix: titleCase(center) },
        { fieldPrefix: "upper_", titlePrefix: getTitlePrefix(center, extent8, "+") },
        { fieldPrefix: "lower_", titlePrefix: getTitlePrefix(center, extent8, "-") }
      ];
      tooltipTitleWithFieldName = true;
    } else {
      let centerOp;
      let lowerExtentOp;
      let upperExtentOp;
      if (extent8 === "ci") {
        centerOp = "mean";
        lowerExtentOp = "ci0";
        upperExtentOp = "ci1";
      } else {
        centerOp = "median";
        lowerExtentOp = "q1";
        upperExtentOp = "q3";
      }
      errorBarSpecificAggregate = [
        { op: lowerExtentOp, field: continuousFieldName, as: `lower_${continuousFieldName}` },
        { op: upperExtentOp, field: continuousFieldName, as: `upper_${continuousFieldName}` },
        { op: centerOp, field: continuousFieldName, as: `center_${continuousFieldName}` }
      ];
      tooltipSummary = [
        {
          fieldPrefix: "upper_",
          titlePrefix: title({ field: continuousFieldName, aggregate: upperExtentOp, type: "quantitative" }, config, {
            allowDisabling: false
          })
        },
        {
          fieldPrefix: "lower_",
          titlePrefix: title({ field: continuousFieldName, aggregate: lowerExtentOp, type: "quantitative" }, config, {
            allowDisabling: false
          })
        },
        {
          fieldPrefix: "center_",
          titlePrefix: title({ field: continuousFieldName, aggregate: centerOp, type: "quantitative" }, config, {
            allowDisabling: false
          })
        }
      ];
    }
  } else {
    if (markDef.center || markDef.extent) {
      warn2(errorBarCenterAndExtentAreNotNeeded(markDef.center, markDef.extent));
    }
    if (inputType === "aggregated-upper-lower") {
      tooltipSummary = [];
      postAggregateCalculates = [
        {
          calculate: accessWithDatumToUnescapedPath(continuousAxisChannelDef2.field),
          as: `upper_${continuousFieldName}`
        },
        { calculate: accessWithDatumToUnescapedPath(continuousFieldName), as: `lower_${continuousFieldName}` }
      ];
    } else if (inputType === "aggregated-error") {
      tooltipSummary = [{ fieldPrefix: "", titlePrefix: continuousFieldName }];
      postAggregateCalculates = [
        {
          calculate: `${accessWithDatumToUnescapedPath(continuousFieldName)} + ${accessWithDatumToUnescapedPath(continuousAxisChannelDefError.field)}`,
          as: `upper_${continuousFieldName}`
        }
      ];
      if (continuousAxisChannelDefError2) {
        postAggregateCalculates.push({
          calculate: `${accessWithDatumToUnescapedPath(continuousFieldName)} + ${accessWithDatumToUnescapedPath(continuousAxisChannelDefError2.field)}`,
          as: `lower_${continuousFieldName}`
        });
      } else {
        postAggregateCalculates.push({
          calculate: `${accessWithDatumToUnescapedPath(continuousFieldName)} - ${accessWithDatumToUnescapedPath(continuousAxisChannelDefError.field)}`,
          as: `lower_${continuousFieldName}`
        });
      }
    }
    for (const postAggregateCalculate of postAggregateCalculates) {
      tooltipSummary.push({
        fieldPrefix: postAggregateCalculate.as.substring(0, 6),
        titlePrefix: replaceAll(replaceAll(postAggregateCalculate.calculate, "datum['", ""), "']", "")
      });
    }
  }
  return { postAggregateCalculates, errorBarSpecificAggregate, tooltipSummary, tooltipTitleWithFieldName };
}
function getTitlePrefix(center, extent8, operation) {
  return `${titleCase(center)} ${operation} ${extent8}`;
}
var ERRORBAND = "errorband";
var ERRORBAND_PARTS = ["band", "borders"];
var errorBandNormalizer = new CompositeMarkNormalizer(ERRORBAND, normalizeErrorBand);
function normalizeErrorBand(spec, { config }) {
  spec = {
    ...spec,
    encoding: normalizeEncoding(spec.encoding, config)
  };
  const { transform: transform4, continuousAxisChannelDef, continuousAxis, encodingWithoutContinuousAxis, markDef, outerSpec, tooltipEncoding } = errorBarParams(spec, ERRORBAND, config);
  const errorBandDef = markDef;
  const makeErrorBandPart = makeCompositeAggregatePartFactory(errorBandDef, continuousAxis, continuousAxisChannelDef, encodingWithoutContinuousAxis, config.errorband);
  const is2D = spec.encoding.x !== void 0 && spec.encoding.y !== void 0;
  let bandMark = { type: is2D ? "area" : "rect" };
  let bordersMark = { type: is2D ? "line" : "rule" };
  const interpolate11 = {
    ...errorBandDef.interpolate ? { interpolate: errorBandDef.interpolate } : {},
    ...errorBandDef.tension && errorBandDef.interpolate ? { tension: errorBandDef.tension } : {}
  };
  if (is2D) {
    bandMark = {
      ...bandMark,
      ...interpolate11,
      ariaRoleDescription: "errorband"
    };
    bordersMark = {
      ...bordersMark,
      ...interpolate11,
      aria: false
    };
  } else if (errorBandDef.interpolate) {
    warn2(errorBand1DNotSupport("interpolate"));
  } else if (errorBandDef.tension) {
    warn2(errorBand1DNotSupport("tension"));
  }
  return {
    ...outerSpec,
    transform: transform4,
    layer: [
      ...makeErrorBandPart({
        partName: "band",
        mark: bandMark,
        positionPrefix: "lower",
        endPositionPrefix: "upper",
        extraEncoding: tooltipEncoding
      }),
      ...makeErrorBandPart({
        partName: "borders",
        mark: bordersMark,
        positionPrefix: "lower",
        extraEncoding: tooltipEncoding
      }),
      ...makeErrorBandPart({
        partName: "borders",
        mark: bordersMark,
        positionPrefix: "upper",
        extraEncoding: tooltipEncoding
      })
    ]
  };
}
var compositeMarkRegistry = {};
function add9(mark, run2, parts) {
  const normalizer = new CompositeMarkNormalizer(mark, run2);
  compositeMarkRegistry[mark] = { normalizer, parts };
}
function getAllCompositeMarks() {
  return keys4(compositeMarkRegistry);
}
add9(BOXPLOT, normalizeBoxPlot, BOXPLOT_PARTS);
add9(ERRORBAR, normalizeErrorBar, ERRORBAR_PARTS);
add9(ERRORBAND, normalizeErrorBand, ERRORBAND_PARTS);
var VL_ONLY_LEGEND_CONFIG = [
  "gradientHorizontalMaxLength",
  "gradientHorizontalMinLength",
  "gradientVerticalMaxLength",
  "gradientVerticalMinLength",
  "unselectedOpacity"
];
var HEADER_TITLE_PROPERTIES_MAP = {
  titleAlign: "align",
  titleAnchor: "anchor",
  titleAngle: "angle",
  titleBaseline: "baseline",
  titleColor: "color",
  titleFont: "font",
  titleFontSize: "fontSize",
  titleFontStyle: "fontStyle",
  titleFontWeight: "fontWeight",
  titleLimit: "limit",
  titleLineHeight: "lineHeight",
  titleOrient: "orient",
  titlePadding: "offset"
};
var HEADER_LABEL_PROPERTIES_MAP = {
  labelAlign: "align",
  labelAnchor: "anchor",
  labelAngle: "angle",
  labelBaseline: "baseline",
  labelColor: "color",
  labelFont: "font",
  labelFontSize: "fontSize",
  labelFontStyle: "fontStyle",
  labelFontWeight: "fontWeight",
  labelLimit: "limit",
  labelLineHeight: "lineHeight",
  labelOrient: "orient",
  labelPadding: "offset"
};
var HEADER_TITLE_PROPERTIES = keys4(HEADER_TITLE_PROPERTIES_MAP);
var HEADER_LABEL_PROPERTIES = keys4(HEADER_LABEL_PROPERTIES_MAP);
var HEADER_CONFIGS_INDEX = {
  header: 1,
  headerRow: 1,
  headerColumn: 1,
  headerFacet: 1
};
var HEADER_CONFIGS = keys4(HEADER_CONFIGS_INDEX);
var LEGEND_SCALE_CHANNELS = [
  "size",
  "shape",
  "fill",
  "stroke",
  "strokeDash",
  "strokeWidth",
  "opacity"
];
var defaultLegendConfig = {
  gradientHorizontalMaxLength: 200,
  gradientHorizontalMinLength: 100,
  gradientVerticalMaxLength: 200,
  gradientVerticalMinLength: 64,
  // This is Vega's minimum.
  unselectedOpacity: 0.35
};
var COMMON_LEGEND_PROPERTY_INDEX = {
  aria: 1,
  clipHeight: 1,
  columnPadding: 1,
  columns: 1,
  cornerRadius: 1,
  description: 1,
  direction: 1,
  fillColor: 1,
  format: 1,
  formatType: 1,
  gradientLength: 1,
  gradientOpacity: 1,
  gradientStrokeColor: 1,
  gradientStrokeWidth: 1,
  gradientThickness: 1,
  gridAlign: 1,
  labelAlign: 1,
  labelBaseline: 1,
  labelColor: 1,
  labelFont: 1,
  labelFontSize: 1,
  labelFontStyle: 1,
  labelFontWeight: 1,
  labelLimit: 1,
  labelOffset: 1,
  labelOpacity: 1,
  labelOverlap: 1,
  labelPadding: 1,
  labelSeparation: 1,
  legendX: 1,
  legendY: 1,
  offset: 1,
  orient: 1,
  padding: 1,
  rowPadding: 1,
  strokeColor: 1,
  symbolDash: 1,
  symbolDashOffset: 1,
  symbolFillColor: 1,
  symbolLimit: 1,
  symbolOffset: 1,
  symbolOpacity: 1,
  symbolSize: 1,
  symbolStrokeColor: 1,
  symbolStrokeWidth: 1,
  symbolType: 1,
  tickCount: 1,
  tickMinStep: 1,
  title: 1,
  titleAlign: 1,
  titleAnchor: 1,
  titleBaseline: 1,
  titleColor: 1,
  titleFont: 1,
  titleFontSize: 1,
  titleFontStyle: 1,
  titleFontWeight: 1,
  titleLimit: 1,
  titleLineHeight: 1,
  titleOpacity: 1,
  titleOrient: 1,
  titlePadding: 1,
  type: 1,
  values: 1,
  zindex: 1
};
var SELECTION_ID = "_vgsid_";
var defaultConfig$1 = {
  point: {
    on: "click",
    fields: [SELECTION_ID],
    toggle: "event.shiftKey",
    resolve: "global",
    clear: "dblclick"
  },
  interval: {
    on: "[pointerdown, window:pointerup] > window:pointermove!",
    encodings: ["x", "y"],
    translate: "[pointerdown, window:pointerup] > window:pointermove!",
    zoom: "wheel!",
    mark: { fill: "#333", fillOpacity: 0.125, stroke: "white" },
    resolve: "global",
    clear: "dblclick"
  }
};
function isLegendBinding(bind7) {
  return bind7 === "legend" || !!(bind7 == null ? void 0 : bind7.legend);
}
function isLegendStreamBinding(bind7) {
  return isLegendBinding(bind7) && isObject12(bind7);
}
function isSelectionParameter(param2) {
  return !!(param2 == null ? void 0 : param2["select"]);
}
function assembleParameterSignals(params2) {
  const signals = [];
  for (const param2 of params2 || []) {
    if (isSelectionParameter(param2))
      continue;
    const { expr: expr2, bind: bind7, ...rest } = param2;
    if (bind7 && expr2) {
      const signal = {
        ...rest,
        bind: bind7,
        init: expr2
      };
      signals.push(signal);
    } else {
      const signal = {
        ...rest,
        ...expr2 ? { update: expr2 } : {},
        ...bind7 ? { bind: bind7 } : {}
      };
      signals.push(signal);
    }
  }
  return signals;
}
function isAnyConcatSpec(spec) {
  return isVConcatSpec(spec) || isHConcatSpec(spec) || isConcatSpec(spec);
}
function isConcatSpec(spec) {
  return hasProperty(spec, "concat");
}
function isVConcatSpec(spec) {
  return hasProperty(spec, "vconcat");
}
function isHConcatSpec(spec) {
  return hasProperty(spec, "hconcat");
}
function getStepFor({ step, offsetIsDiscrete }) {
  if (offsetIsDiscrete) {
    return step.for ?? "offset";
  } else {
    return "position";
  }
}
function isStep(size) {
  return hasProperty(size, "step");
}
function isFrameMixins(o) {
  return hasProperty(o, "view") || hasProperty(o, "width") || hasProperty(o, "height");
}
var DEFAULT_SPACING = 20;
var COMPOSITION_LAYOUT_INDEX = {
  align: 1,
  bounds: 1,
  center: 1,
  columns: 1,
  spacing: 1
};
var COMPOSITION_LAYOUT_PROPERTIES = keys4(COMPOSITION_LAYOUT_INDEX);
function extractCompositionLayout(spec, specType, config) {
  const compositionConfig = config[specType];
  const layout = {};
  const { spacing: spacingConfig, columns } = compositionConfig;
  if (spacingConfig !== void 0) {
    layout.spacing = spacingConfig;
  }
  if (columns !== void 0) {
    if (isFacetSpec(spec) && !isFacetMapping(spec.facet) || isConcatSpec(spec)) {
      layout.columns = columns;
    }
  }
  if (isVConcatSpec(spec)) {
    layout.columns = 1;
  }
  for (const prop of COMPOSITION_LAYOUT_PROPERTIES) {
    if (spec[prop] !== void 0) {
      if (prop === "spacing") {
        const spacing = spec[prop];
        layout[prop] = isNumber14(spacing) ? spacing : {
          row: spacing.row ?? spacingConfig,
          column: spacing.column ?? spacingConfig
        };
      } else {
        layout[prop] = spec[prop];
      }
    }
  }
  return layout;
}
function getViewConfigContinuousSize(viewConfig, channel) {
  return viewConfig[channel] ?? viewConfig[channel === "width" ? "continuousWidth" : "continuousHeight"];
}
function getViewConfigDiscreteStep(viewConfig, channel) {
  const size = getViewConfigDiscreteSize(viewConfig, channel);
  return isStep(size) ? size.step : DEFAULT_STEP;
}
function getViewConfigDiscreteSize(viewConfig, channel) {
  const size = viewConfig[channel] ?? viewConfig[channel === "width" ? "discreteWidth" : "discreteHeight"];
  return getFirstDefined(size, { step: viewConfig.step });
}
var DEFAULT_STEP = 20;
var defaultViewConfig = {
  continuousWidth: 300,
  continuousHeight: 300,
  step: DEFAULT_STEP
};
var defaultConfig = {
  background: "white",
  padding: 5,
  timeFormat: "%b %d, %Y",
  countTitle: "Count of Records",
  view: defaultViewConfig,
  mark: defaultMarkConfig,
  arc: {},
  area: {},
  bar: defaultBarConfig,
  circle: {},
  geoshape: {},
  image: {},
  line: {},
  point: {},
  rect: defaultRectConfig,
  rule: { color: "black" },
  // Need this to override default color in mark config
  square: {},
  text: { color: "black" },
  // Need this to override default color in mark config
  tick: defaultTickConfig,
  trail: {},
  boxplot: {
    size: 14,
    extent: 1.5,
    box: {},
    median: { color: "white" },
    outliers: {},
    rule: {},
    ticks: null
  },
  errorbar: {
    center: "mean",
    rule: true,
    ticks: false
  },
  errorband: {
    band: {
      opacity: 0.3
    },
    borders: false
  },
  scale: defaultScaleConfig,
  projection: {},
  legend: defaultLegendConfig,
  header: { titlePadding: 10, labelPadding: 10 },
  headerColumn: {},
  headerRow: {},
  headerFacet: {},
  selection: defaultConfig$1,
  style: {},
  title: {},
  facet: { spacing: DEFAULT_SPACING },
  concat: { spacing: DEFAULT_SPACING },
  normalizedNumberFormat: ".0%"
};
var tab10 = [
  "#4c78a8",
  "#f58518",
  "#e45756",
  "#72b7b2",
  "#54a24b",
  "#eeca3b",
  "#b279a2",
  "#ff9da6",
  "#9d755d",
  "#bab0ac"
];
var DEFAULT_FONT_SIZE = {
  text: 11,
  guideLabel: 10,
  guideTitle: 11,
  groupTitle: 13,
  groupSubtitle: 12
};
var DEFAULT_COLOR = {
  blue: tab10[0],
  orange: tab10[1],
  red: tab10[2],
  teal: tab10[3],
  green: tab10[4],
  yellow: tab10[5],
  purple: tab10[6],
  pink: tab10[7],
  brown: tab10[8],
  gray0: "#000",
  gray1: "#111",
  gray2: "#222",
  gray3: "#333",
  gray4: "#444",
  gray5: "#555",
  gray6: "#666",
  gray7: "#777",
  gray8: "#888",
  gray9: "#999",
  gray10: "#aaa",
  gray11: "#bbb",
  gray12: "#ccc",
  gray13: "#ddd",
  gray14: "#eee",
  gray15: "#fff"
};
function colorSignalConfig(color9 = {}) {
  return {
    signals: [
      {
        name: "color",
        value: isObject12(color9) ? { ...DEFAULT_COLOR, ...color9 } : DEFAULT_COLOR
      }
    ],
    mark: { color: { signal: "color.blue" } },
    rule: { color: { signal: "color.gray0" } },
    text: {
      color: { signal: "color.gray0" }
    },
    style: {
      "guide-label": {
        fill: { signal: "color.gray0" }
      },
      "guide-title": {
        fill: { signal: "color.gray0" }
      },
      "group-title": {
        fill: { signal: "color.gray0" }
      },
      "group-subtitle": {
        fill: { signal: "color.gray0" }
      },
      cell: {
        stroke: { signal: "color.gray8" }
      }
    },
    axis: {
      domainColor: { signal: "color.gray13" },
      gridColor: { signal: "color.gray8" },
      tickColor: { signal: "color.gray13" }
    },
    range: {
      category: [
        { signal: "color.blue" },
        { signal: "color.orange" },
        { signal: "color.red" },
        { signal: "color.teal" },
        { signal: "color.green" },
        { signal: "color.yellow" },
        { signal: "color.purple" },
        { signal: "color.pink" },
        { signal: "color.brown" },
        { signal: "color.grey8" }
      ]
    }
  };
}
function fontSizeSignalConfig(fontSize6) {
  return {
    signals: [
      {
        name: "fontSize",
        value: isObject12(fontSize6) ? { ...DEFAULT_FONT_SIZE, ...fontSize6 } : DEFAULT_FONT_SIZE
      }
    ],
    text: {
      fontSize: { signal: "fontSize.text" }
    },
    style: {
      "guide-label": {
        fontSize: { signal: "fontSize.guideLabel" }
      },
      "guide-title": {
        fontSize: { signal: "fontSize.guideTitle" }
      },
      "group-title": {
        fontSize: { signal: "fontSize.groupTitle" }
      },
      "group-subtitle": {
        fontSize: { signal: "fontSize.groupSubtitle" }
      }
    }
  };
}
function fontConfig(font7) {
  return {
    text: { font: font7 },
    style: {
      "guide-label": { font: font7 },
      "guide-title": { font: font7 },
      "group-title": { font: font7 },
      "group-subtitle": { font: font7 }
    }
  };
}
function getAxisConfigInternal(axisConfig2) {
  const props = keys4(axisConfig2 || {});
  const axisConfigInternal = {};
  for (const prop of props) {
    const val = axisConfig2[prop];
    axisConfigInternal[prop] = isConditionalAxisValue(val) ? signalOrValueRefWithCondition(val) : signalRefOrValue(val);
  }
  return axisConfigInternal;
}
function getStyleConfigInternal(styleConfig) {
  const props = keys4(styleConfig);
  const styleConfigInternal = {};
  for (const prop of props) {
    styleConfigInternal[prop] = getAxisConfigInternal(styleConfig[prop]);
  }
  return styleConfigInternal;
}
var configPropsWithExpr = [
  ...MARK_CONFIGS,
  ...AXIS_CONFIGS,
  ...HEADER_CONFIGS,
  "background",
  "padding",
  "legend",
  "lineBreak",
  "scale",
  "style",
  "title",
  "view"
];
function initConfig(specifiedConfig = {}) {
  const { color: color9, font: font7, fontSize: fontSize6, selection, ...restConfig } = specifiedConfig;
  const mergedConfig = mergeConfig3({}, duplicate(defaultConfig), font7 ? fontConfig(font7) : {}, color9 ? colorSignalConfig(color9) : {}, fontSize6 ? fontSizeSignalConfig(fontSize6) : {}, restConfig || {});
  if (selection) {
    writeConfig3(mergedConfig, "selection", selection, true);
  }
  const outputConfig = omit(mergedConfig, configPropsWithExpr);
  for (const prop of ["background", "lineBreak", "padding"]) {
    if (mergedConfig[prop]) {
      outputConfig[prop] = signalRefOrValue(mergedConfig[prop]);
    }
  }
  for (const markConfigType of MARK_CONFIGS) {
    if (mergedConfig[markConfigType]) {
      outputConfig[markConfigType] = replaceExprRef(mergedConfig[markConfigType]);
    }
  }
  for (const axisConfigType of AXIS_CONFIGS) {
    if (mergedConfig[axisConfigType]) {
      outputConfig[axisConfigType] = getAxisConfigInternal(mergedConfig[axisConfigType]);
    }
  }
  for (const headerConfigType of HEADER_CONFIGS) {
    if (mergedConfig[headerConfigType]) {
      outputConfig[headerConfigType] = replaceExprRef(mergedConfig[headerConfigType]);
    }
  }
  if (mergedConfig.legend) {
    outputConfig.legend = replaceExprRef(mergedConfig.legend);
  }
  if (mergedConfig.scale) {
    const { invalid, ...otherScaleConfig } = mergedConfig.scale;
    const newScaleInvalid = replaceExprRef(invalid, { level: 1 });
    outputConfig.scale = {
      ...replaceExprRef(otherScaleConfig),
      ...keys4(newScaleInvalid).length > 0 ? { invalid: newScaleInvalid } : {}
    };
  }
  if (mergedConfig.style) {
    outputConfig.style = getStyleConfigInternal(mergedConfig.style);
  }
  if (mergedConfig.title) {
    outputConfig.title = replaceExprRef(mergedConfig.title);
  }
  if (mergedConfig.view) {
    outputConfig.view = replaceExprRef(mergedConfig.view);
  }
  return outputConfig;
}
var MARK_STYLES = /* @__PURE__ */ new Set(["view", ...PRIMITIVE_MARKS]);
var VL_ONLY_CONFIG_PROPERTIES = [
  "color",
  "fontSize",
  "background",
  // We apply background to the spec directly.
  "padding",
  "facet",
  "concat",
  "numberFormat",
  "numberFormatType",
  "normalizedNumberFormat",
  "normalizedNumberFormatType",
  "timeFormat",
  "countTitle",
  "header",
  "axisQuantitative",
  "axisTemporal",
  "axisDiscrete",
  "axisPoint",
  "axisXBand",
  "axisXPoint",
  "axisXDiscrete",
  "axisXQuantitative",
  "axisXTemporal",
  "axisYBand",
  "axisYPoint",
  "axisYDiscrete",
  "axisYQuantitative",
  "axisYTemporal",
  "scale",
  "selection",
  "overlay"
];
var VL_ONLY_ALL_MARK_SPECIFIC_CONFIG_PROPERTY_INDEX = {
  view: ["continuousWidth", "continuousHeight", "discreteWidth", "discreteHeight", "step"],
  ...VL_ONLY_MARK_SPECIFIC_CONFIG_PROPERTY_INDEX
};
function stripAndRedirectConfig(config) {
  config = duplicate(config);
  for (const prop of VL_ONLY_CONFIG_PROPERTIES) {
    delete config[prop];
  }
  if (config.axis) {
    for (const prop in config.axis) {
      if (isConditionalAxisValue(config.axis[prop])) {
        delete config.axis[prop];
      }
    }
  }
  if (config.legend) {
    for (const prop of VL_ONLY_LEGEND_CONFIG) {
      delete config.legend[prop];
    }
  }
  if (config.mark) {
    for (const prop of VL_ONLY_MARK_CONFIG_PROPERTIES) {
      delete config.mark[prop];
    }
    if (config.mark.tooltip && isObject12(config.mark.tooltip)) {
      delete config.mark.tooltip;
    }
  }
  if (config.params) {
    config.signals = (config.signals || []).concat(assembleParameterSignals(config.params));
    delete config.params;
  }
  for (const markType2 of MARK_STYLES) {
    for (const prop of VL_ONLY_MARK_CONFIG_PROPERTIES) {
      delete config[markType2][prop];
    }
    const vlOnlyMarkSpecificConfigs = VL_ONLY_ALL_MARK_SPECIFIC_CONFIG_PROPERTY_INDEX[markType2];
    if (vlOnlyMarkSpecificConfigs) {
      for (const prop of vlOnlyMarkSpecificConfigs) {
        delete config[markType2][prop];
      }
    }
    redirectConfigToStyleConfig(config, markType2);
  }
  for (const m3 of getAllCompositeMarks()) {
    delete config[m3];
  }
  redirectTitleConfig(config);
  for (const prop in config) {
    if (isObject12(config[prop]) && isEmpty(config[prop])) {
      delete config[prop];
    }
  }
  return isEmpty(config) ? void 0 : config;
}
function redirectTitleConfig(config) {
  const { titleMarkConfig, subtitleMarkConfig, subtitle } = extractTitleConfig(config.title);
  if (!isEmpty(titleMarkConfig)) {
    config.style["group-title"] = {
      ...config.style["group-title"],
      ...titleMarkConfig
      // config.title has higher precedence than config.style.group-title in Vega
    };
  }
  if (!isEmpty(subtitleMarkConfig)) {
    config.style["group-subtitle"] = {
      ...config.style["group-subtitle"],
      ...subtitleMarkConfig
    };
  }
  if (!isEmpty(subtitle)) {
    config.title = subtitle;
  } else {
    delete config.title;
  }
}
function redirectConfigToStyleConfig(config, prop, toProp, compositeMarkPart) {
  const propConfig = config[prop];
  if (prop === "view") {
    toProp = "cell";
  }
  const style6 = {
    ...propConfig,
    ...config.style[toProp ?? prop]
  };
  if (!isEmpty(style6)) {
    config.style[toProp ?? prop] = style6;
  }
  {
    delete config[prop];
  }
}
function isLayerSpec(spec) {
  return hasProperty(spec, "layer");
}
function isRepeatSpec(spec) {
  return hasProperty(spec, "repeat");
}
function isLayerRepeatSpec(spec) {
  return !isArray22(spec.repeat) && hasProperty(spec.repeat, "layer");
}
var SpecMapper = class {
  map(spec, params2) {
    if (isFacetSpec(spec)) {
      return this.mapFacet(spec, params2);
    } else if (isRepeatSpec(spec)) {
      return this.mapRepeat(spec, params2);
    } else if (isHConcatSpec(spec)) {
      return this.mapHConcat(spec, params2);
    } else if (isVConcatSpec(spec)) {
      return this.mapVConcat(spec, params2);
    } else if (isConcatSpec(spec)) {
      return this.mapConcat(spec, params2);
    } else {
      return this.mapLayerOrUnit(spec, params2);
    }
  }
  mapLayerOrUnit(spec, params2) {
    if (isLayerSpec(spec)) {
      return this.mapLayer(spec, params2);
    } else if (isUnitSpec(spec)) {
      return this.mapUnit(spec, params2);
    }
    throw new Error(invalidSpec(spec));
  }
  mapLayer(spec, params2) {
    return {
      ...spec,
      layer: spec.layer.map((subspec) => this.mapLayerOrUnit(subspec, params2))
    };
  }
  mapHConcat(spec, params2) {
    return {
      ...spec,
      hconcat: spec.hconcat.map((subspec) => this.map(subspec, params2))
    };
  }
  mapVConcat(spec, params2) {
    return {
      ...spec,
      vconcat: spec.vconcat.map((subspec) => this.map(subspec, params2))
    };
  }
  mapConcat(spec, params2) {
    const { concat, ...rest } = spec;
    return {
      ...rest,
      concat: concat.map((subspec) => this.map(subspec, params2))
    };
  }
  mapFacet(spec, params2) {
    return {
      // as any is required here since TS cannot infer that FO may only be FieldName or Field, but not RepeatRef
      ...spec,
      // TODO: remove "any" once we support all facet listed in https://github.com/vega/vega-lite/issues/2760
      spec: this.map(spec.spec, params2)
    };
  }
  mapRepeat(spec, params2) {
    return {
      ...spec,
      // as any is required here since TS cannot infer that the output type satisfies the input type
      spec: this.map(spec.spec, params2)
    };
  }
};
var STACK_OFFSET_INDEX = {
  zero: 1,
  center: 1,
  normalize: 1
};
function isStackOffset(s2) {
  return has19(STACK_OFFSET_INDEX, s2);
}
var STACKABLE_MARKS = /* @__PURE__ */ new Set([ARC, BAR, AREA, RULE, POINT, CIRCLE, SQUARE, LINE, TEXT, TICK]);
var STACK_BY_DEFAULT_MARKS = /* @__PURE__ */ new Set([BAR, AREA, ARC]);
function isUnbinnedQuantitative(channelDef) {
  return isFieldDef(channelDef) && channelDefType(channelDef) === "quantitative" && !channelDef.bin;
}
function potentialStackedChannel(encoding, x9, { orient: orient2, type: mark }) {
  const y9 = x9 === "x" ? "y" : "radius";
  const isCartesianBarOrArea = x9 === "x" && ["bar", "area"].includes(mark);
  const xDef = encoding[x9];
  const yDef = encoding[y9];
  if (isFieldDef(xDef) && isFieldDef(yDef)) {
    if (isUnbinnedQuantitative(xDef) && isUnbinnedQuantitative(yDef)) {
      if (xDef.stack) {
        return x9;
      } else if (yDef.stack) {
        return y9;
      }
      const xAggregate = isFieldDef(xDef) && !!xDef.aggregate;
      const yAggregate = isFieldDef(yDef) && !!yDef.aggregate;
      if (xAggregate !== yAggregate) {
        return xAggregate ? x9 : y9;
      }
      if (isCartesianBarOrArea) {
        if (orient2 === "vertical") {
          return y9;
        } else if (orient2 === "horizontal") {
          return x9;
        }
      }
    } else if (isUnbinnedQuantitative(xDef)) {
      return x9;
    } else if (isUnbinnedQuantitative(yDef)) {
      return y9;
    }
  } else if (isUnbinnedQuantitative(xDef)) {
    if (isCartesianBarOrArea && orient2 === "vertical") {
      return void 0;
    }
    return x9;
  } else if (isUnbinnedQuantitative(yDef)) {
    if (isCartesianBarOrArea && orient2 === "horizontal") {
      return void 0;
    }
    return y9;
  }
  return void 0;
}
function getDimensionChannel(channel) {
  switch (channel) {
    case "x":
      return "y";
    case "y":
      return "x";
    case "theta":
      return "radius";
    case "radius":
      return "theta";
  }
}
function stack(m3, encoding) {
  var _a2, _b;
  const markDef = isMarkDef(m3) ? m3 : { type: m3 };
  const mark = markDef.type;
  if (!STACKABLE_MARKS.has(mark)) {
    return null;
  }
  const fieldChannel = potentialStackedChannel(encoding, "x", markDef) || potentialStackedChannel(encoding, "theta", markDef);
  if (!fieldChannel) {
    return null;
  }
  const stackedFieldDef = encoding[fieldChannel];
  const stackedField = isFieldDef(stackedFieldDef) ? vgField(stackedFieldDef, {}) : void 0;
  const dimensionChannel = getDimensionChannel(fieldChannel);
  const groupbyChannels = [];
  const groupbyFields = /* @__PURE__ */ new Set();
  if (encoding[dimensionChannel]) {
    const dimensionDef = encoding[dimensionChannel];
    const dimensionField = isFieldDef(dimensionDef) ? vgField(dimensionDef, {}) : void 0;
    if (dimensionField && dimensionField !== stackedField) {
      groupbyChannels.push(dimensionChannel);
      groupbyFields.add(dimensionField);
    }
  }
  const dimensionOffsetChannel = dimensionChannel === "x" ? "xOffset" : "yOffset";
  const dimensionOffsetDef = encoding[dimensionOffsetChannel];
  const dimensionOffsetField = isFieldDef(dimensionOffsetDef) ? vgField(dimensionOffsetDef, {}) : void 0;
  if (dimensionOffsetField && dimensionOffsetField !== stackedField) {
    groupbyChannels.push(dimensionOffsetChannel);
    groupbyFields.add(dimensionOffsetField);
  }
  const stackBy = NONPOSITION_CHANNELS.reduce((sc, channel) => {
    if (channel !== "tooltip" && channelHasField(encoding, channel)) {
      const channelDef = encoding[channel];
      for (const cDef of array21(channelDef)) {
        const fieldDef = getFieldDef(cDef);
        if (fieldDef.aggregate) {
          continue;
        }
        const f = vgField(fieldDef, {});
        if (
          // if fielddef is a repeat, just include it in the stack by
          !f || // otherwise, the field must be different from the groupBy fields.
          !groupbyFields.has(f)
        ) {
          sc.push({ channel, fieldDef });
        }
      }
    }
    return sc;
  }, []);
  let offset9;
  if (stackedFieldDef.stack !== void 0) {
    if (isBoolean5(stackedFieldDef.stack)) {
      offset9 = stackedFieldDef.stack ? "zero" : null;
    } else {
      offset9 = stackedFieldDef.stack;
    }
  } else if (STACK_BY_DEFAULT_MARKS.has(mark)) {
    offset9 = "zero";
  }
  if (!offset9 || !isStackOffset(offset9)) {
    return null;
  }
  if (isAggregate$1(encoding) && stackBy.length === 0) {
    return null;
  }
  if (((_a2 = stackedFieldDef == null ? void 0 : stackedFieldDef.scale) == null ? void 0 : _a2.type) && ((_b = stackedFieldDef == null ? void 0 : stackedFieldDef.scale) == null ? void 0 : _b.type) !== ScaleType.LINEAR) {
    if (stackedFieldDef == null ? void 0 : stackedFieldDef.stack) {
      warn2(stackNonLinearScale(stackedFieldDef.scale.type));
    }
  }
  if (isFieldOrDatumDef(encoding[getSecondaryRangeChannel(fieldChannel)])) {
    if (stackedFieldDef.stack !== void 0) {
      warn2(cannotStackRangedMark(fieldChannel));
    }
    return null;
  }
  if (isFieldDef(stackedFieldDef) && stackedFieldDef.aggregate && !SUM_OPS.has(stackedFieldDef.aggregate)) {
    warn2(stackNonSummativeAggregate(stackedFieldDef.aggregate));
  }
  return {
    groupbyChannels,
    groupbyFields,
    fieldChannel,
    impute: stackedFieldDef.impute === null ? false : isPathMark(mark),
    stackBy,
    offset: offset9
  };
}
function initMarkdef(originalMarkDef, encoding, config) {
  const markDef = replaceExprRef(originalMarkDef);
  const specifiedOrient = getMarkPropOrConfig("orient", markDef, config);
  markDef.orient = orient(markDef.type, encoding, specifiedOrient);
  if (specifiedOrient !== void 0 && specifiedOrient !== markDef.orient) {
    warn2(orientOverridden(markDef.orient, specifiedOrient));
  }
  if (markDef.type === "bar" && markDef.orient) {
    const cornerRadiusEnd = getMarkPropOrConfig("cornerRadiusEnd", markDef, config);
    if (cornerRadiusEnd !== void 0) {
      const newProps = markDef.orient === "horizontal" && encoding.x2 || markDef.orient === "vertical" && encoding.y2 ? ["cornerRadius"] : BAR_CORNER_RADIUS_INDEX[markDef.orient];
      for (const newProp of newProps) {
        markDef[newProp] = cornerRadiusEnd;
      }
      if (markDef.cornerRadiusEnd !== void 0) {
        delete markDef.cornerRadiusEnd;
      }
    }
  }
  const specifiedOpacity = getMarkPropOrConfig("opacity", markDef, config);
  const specifiedFillOpacity = getMarkPropOrConfig("fillOpacity", markDef, config);
  if (specifiedOpacity === void 0 && specifiedFillOpacity === void 0) {
    markDef.opacity = opacity(markDef.type, encoding);
  }
  const specifiedCursor = getMarkPropOrConfig("cursor", markDef, config);
  if (specifiedCursor === void 0) {
    markDef.cursor = cursor2(markDef, encoding, config);
  }
  return markDef;
}
function cursor2(markDef, encoding, config) {
  if (encoding.href || markDef.href || getMarkPropOrConfig("href", markDef, config)) {
    return "pointer";
  }
  return markDef.cursor;
}
var DEFAULT_REDUCED_OPACITY = 0.7;
function opacity(mark, encoding) {
  if (contains2([POINT, TICK, CIRCLE, SQUARE], mark) && !isAggregate$1(encoding)) {
    return DEFAULT_REDUCED_OPACITY;
  }
  return void 0;
}
function defaultFilled(markDef, config, { graticule: graticule2 }) {
  if (graticule2) {
    return false;
  }
  const filledConfig = getMarkConfig("filled", markDef, config);
  const mark = markDef.type;
  return getFirstDefined(filledConfig, mark !== POINT && mark !== LINE && mark !== RULE);
}
function orient(mark, encoding, specifiedOrient) {
  switch (mark) {
    case POINT:
    case CIRCLE:
    case SQUARE:
    case RECT:
    case IMAGE:
      return void 0;
  }
  const { x: x9, y: y9, x2: x22, y2: y22 } = encoding;
  switch (mark) {
    case TEXT:
    case BAR:
      if (isFieldDef(x9) && (isBinned(x9.bin) || isFieldDef(y9) && y9.aggregate && !x9.aggregate)) {
        return "vertical";
      }
      if (isFieldDef(y9) && (isBinned(y9.bin) || isFieldDef(x9) && x9.aggregate && !y9.aggregate)) {
        return "horizontal";
      }
      if (y22 || x22) {
        if (specifiedOrient) {
          return specifiedOrient;
        }
        if (!x22) {
          if (isFieldDef(x9) && x9.type === QUANTITATIVE && !isBinning(x9.bin) || isNumericDataDef(x9)) {
            if (isFieldDef(y9) && isBinned(y9.bin)) {
              return "horizontal";
            }
          }
          return "vertical";
        }
        if (!y22) {
          if (isFieldDef(y9) && y9.type === QUANTITATIVE && !isBinning(y9.bin) || isNumericDataDef(y9)) {
            if (isFieldDef(x9) && isBinned(x9.bin)) {
              return "vertical";
            }
          }
          return "horizontal";
        }
      }
    case RULE:
      if (x22 && !(isFieldDef(x9) && isBinned(x9.bin)) && y22 && !(isFieldDef(y9) && isBinned(y9.bin))) {
        return void 0;
      }
    case AREA:
      if (y22) {
        if (isFieldDef(y9) && isBinned(y9.bin)) {
          return "horizontal";
        } else {
          return "vertical";
        }
      } else if (x22) {
        if (isFieldDef(x9) && isBinned(x9.bin)) {
          return "vertical";
        } else {
          return "horizontal";
        }
      } else if (mark === RULE) {
        if (x9 && !y9) {
          return "vertical";
        } else if (y9 && !x9) {
          return "horizontal";
        }
      }
    case LINE:
    case TICK: {
      const xIsMeasure = isUnbinnedQuantitativeFieldOrDatumDef(x9);
      const yIsMeasure = isUnbinnedQuantitativeFieldOrDatumDef(y9);
      if (specifiedOrient) {
        return specifiedOrient;
      } else if (xIsMeasure && !yIsMeasure) {
        return mark !== "tick" ? "horizontal" : "vertical";
      } else if (!xIsMeasure && yIsMeasure) {
        return mark !== "tick" ? "vertical" : "horizontal";
      } else if (xIsMeasure && yIsMeasure) {
        return "vertical";
      } else {
        const xIsTemporal = isTypedFieldDef(x9) && x9.type === TEMPORAL;
        const yIsTemporal = isTypedFieldDef(y9) && y9.type === TEMPORAL;
        if (xIsTemporal && !yIsTemporal) {
          return "vertical";
        } else if (!xIsTemporal && yIsTemporal) {
          return "horizontal";
        }
      }
      return void 0;
    }
  }
  return "vertical";
}
function dropLineAndPoint(markDef) {
  const { point: _point, line: _line, ...mark } = markDef;
  return keys4(mark).length > 1 ? mark : mark.type;
}
function dropLineAndPointFromConfig(config) {
  for (const mark of ["line", "area", "rule", "trail"]) {
    if (config[mark]) {
      config = {
        ...config,
        // TODO: remove as any
        [mark]: omit(config[mark], ["point", "line"])
      };
    }
  }
  return config;
}
function getPointOverlay(markDef, markConfig = {}, encoding) {
  if (markDef.point === "transparent") {
    return { opacity: 0 };
  } else if (markDef.point) {
    return isObject12(markDef.point) ? markDef.point : {};
  } else if (markDef.point !== void 0) {
    return null;
  } else {
    if (markConfig.point || encoding.shape) {
      return isObject12(markConfig.point) ? markConfig.point : {};
    }
    return void 0;
  }
}
function getLineOverlay(markDef, markConfig = {}) {
  if (markDef.line) {
    return markDef.line === true ? {} : markDef.line;
  } else if (markDef.line !== void 0) {
    return null;
  } else {
    if (markConfig.line) {
      return markConfig.line === true ? {} : markConfig.line;
    }
    return void 0;
  }
}
var PathOverlayNormalizer = class {
  constructor() {
    __publicField(this, "name", "path-overlay");
  }
  hasMatchingType(spec, config) {
    if (isUnitSpec(spec)) {
      const { mark, encoding } = spec;
      const markDef = isMarkDef(mark) ? mark : { type: mark };
      switch (markDef.type) {
        case "line":
        case "rule":
        case "trail":
          return !!getPointOverlay(markDef, config[markDef.type], encoding);
        case "area":
          return (
            // false / null are also included as we want to remove the properties
            !!getPointOverlay(markDef, config[markDef.type], encoding) || !!getLineOverlay(markDef, config[markDef.type])
          );
      }
    }
    return false;
  }
  run(spec, normParams, normalize4) {
    const { config } = normParams;
    const { params: params2, projection: projection3, mark, name, encoding: e3, ...outerSpec } = spec;
    const encoding = normalizeEncoding(e3, config);
    const markDef = isMarkDef(mark) ? mark : { type: mark };
    const pointOverlay = getPointOverlay(markDef, config[markDef.type], encoding);
    const lineOverlay = markDef.type === "area" && getLineOverlay(markDef, config[markDef.type]);
    const layer = [
      {
        name,
        ...params2 ? { params: params2 } : {},
        mark: dropLineAndPoint({
          ...markDef.type === "area" && getMarkPropOrConfig("opacity", markDef, config) == void 0 && getMarkPropOrConfig("fillOpacity", markDef, config) == void 0 ? { opacity: DEFAULT_REDUCED_OPACITY } : {},
          ...markDef
        }),
        // drop shape from encoding as this might be used to trigger point overlay
        encoding: omit(encoding, ["shape"])
      }
    ];
    const stackProps = stack(initMarkdef(markDef, encoding, config), encoding);
    let overlayEncoding = encoding;
    if (stackProps) {
      const { fieldChannel: stackFieldChannel, offset: offset9 } = stackProps;
      overlayEncoding = {
        ...encoding,
        [stackFieldChannel]: {
          ...encoding[stackFieldChannel],
          ...offset9 ? { stack: offset9 } : {}
        }
      };
    }
    overlayEncoding = omit(overlayEncoding, ["y2", "x2"]);
    if (lineOverlay) {
      layer.push({
        ...projection3 ? { projection: projection3 } : {},
        mark: {
          type: "line",
          ...pick6(markDef, ["clip", "interpolate", "tension", "tooltip"]),
          ...lineOverlay
        },
        encoding: overlayEncoding
      });
    }
    if (pointOverlay) {
      layer.push({
        ...projection3 ? { projection: projection3 } : {},
        mark: {
          type: "point",
          opacity: 1,
          filled: true,
          ...pick6(markDef, ["clip", "tooltip"]),
          ...pointOverlay
        },
        encoding: overlayEncoding
      });
    }
    return normalize4({
      ...outerSpec,
      layer
    }, {
      ...normParams,
      config: dropLineAndPointFromConfig(config)
    });
  }
};
function replaceRepeaterInFacet(facet, repeater) {
  if (!repeater) {
    return facet;
  }
  if (isFacetMapping(facet)) {
    return replaceRepeaterInMapping(facet, repeater);
  }
  return replaceRepeaterInFieldDef(facet, repeater);
}
function replaceRepeaterInEncoding(encoding, repeater) {
  if (!repeater) {
    return encoding;
  }
  return replaceRepeaterInMapping(encoding, repeater);
}
function replaceRepeatInProp(prop, o, repeater) {
  const val = o[prop];
  if (isRepeatRef(val)) {
    if (val.repeat in repeater) {
      return { ...o, [prop]: repeater[val.repeat] };
    } else {
      warn2(noSuchRepeatedValue(val.repeat));
      return void 0;
    }
  }
  return o;
}
function replaceRepeaterInFieldDef(fieldDef, repeater) {
  fieldDef = replaceRepeatInProp("field", fieldDef, repeater);
  if (fieldDef === void 0) {
    return void 0;
  } else if (fieldDef === null) {
    return null;
  }
  if (isSortableFieldDef(fieldDef) && isSortField(fieldDef.sort)) {
    const sort4 = replaceRepeatInProp("field", fieldDef.sort, repeater);
    fieldDef = {
      ...fieldDef,
      ...sort4 ? { sort: sort4 } : {}
    };
  }
  return fieldDef;
}
function replaceRepeaterInFieldOrDatumDef(def6, repeater) {
  if (isFieldDef(def6)) {
    return replaceRepeaterInFieldDef(def6, repeater);
  } else {
    const datumDef = replaceRepeatInProp("datum", def6, repeater);
    if (datumDef !== def6 && !datumDef.type) {
      datumDef.type = "nominal";
    }
    return datumDef;
  }
}
function replaceRepeaterInChannelDef(channelDef, repeater) {
  if (isFieldOrDatumDef(channelDef)) {
    const fd = replaceRepeaterInFieldOrDatumDef(channelDef, repeater);
    if (fd) {
      return fd;
    } else if (isConditionalDef(channelDef)) {
      return { condition: channelDef.condition };
    }
  } else {
    if (hasConditionalFieldOrDatumDef(channelDef)) {
      const fd = replaceRepeaterInFieldOrDatumDef(channelDef.condition, repeater);
      if (fd) {
        return {
          ...channelDef,
          condition: fd
        };
      } else {
        const { condition, ...channelDefWithoutCondition } = channelDef;
        return channelDefWithoutCondition;
      }
    }
    return channelDef;
  }
  return void 0;
}
function replaceRepeaterInMapping(mapping, repeater) {
  const out = {};
  for (const channel in mapping) {
    if (hasProperty(mapping, channel)) {
      const channelDef = mapping[channel];
      if (isArray22(channelDef)) {
        out[channel] = channelDef.map((cd2) => replaceRepeaterInChannelDef(cd2, repeater)).filter((cd2) => cd2);
      } else {
        const cd2 = replaceRepeaterInChannelDef(channelDef, repeater);
        if (cd2 !== void 0) {
          out[channel] = cd2;
        }
      }
    }
  }
  return out;
}
var RuleForRangedLineNormalizer = class {
  constructor() {
    __publicField(this, "name", "RuleForRangedLine");
  }
  hasMatchingType(spec) {
    if (isUnitSpec(spec)) {
      const { encoding, mark } = spec;
      if (mark === "line" || isMarkDef(mark) && mark.type === "line") {
        for (const channel of SECONDARY_RANGE_CHANNEL) {
          const mainChannel = getMainRangeChannel(channel);
          const mainChannelDef = encoding[mainChannel];
          if (encoding[channel]) {
            if (isFieldDef(mainChannelDef) && !isBinned(mainChannelDef.bin) || isDatumDef(mainChannelDef)) {
              return true;
            }
          }
        }
      }
    }
    return false;
  }
  run(spec, params2, normalize4) {
    const { encoding, mark } = spec;
    warn2(lineWithRange(!!encoding.x2, !!encoding.y2));
    return normalize4({
      ...spec,
      mark: isObject12(mark) ? { ...mark, type: "rule" } : "rule"
    }, params2);
  }
};
var CoreNormalizer = class extends SpecMapper {
  constructor() {
    super(...arguments);
    __publicField(this, "nonFacetUnitNormalizers", [
      boxPlotNormalizer,
      errorBarNormalizer,
      errorBandNormalizer,
      new PathOverlayNormalizer(),
      new RuleForRangedLineNormalizer()
    ]);
  }
  map(spec, params2) {
    if (isUnitSpec(spec)) {
      const hasRow = channelHasField(spec.encoding, ROW);
      const hasColumn = channelHasField(spec.encoding, COLUMN);
      const hasFacet = channelHasField(spec.encoding, FACET);
      if (hasRow || hasColumn || hasFacet) {
        return this.mapFacetedUnit(spec, params2);
      }
    }
    return super.map(spec, params2);
  }
  // This is for normalizing non-facet unit
  mapUnit(spec, params2) {
    const { parentEncoding, parentProjection } = params2;
    const encoding = replaceRepeaterInEncoding(spec.encoding, params2.repeater);
    const specWithReplacedEncoding = {
      ...spec,
      ...spec.name ? { name: [params2.repeaterPrefix, spec.name].filter((n) => n).join("_") } : {},
      ...encoding ? { encoding } : {}
    };
    if (parentEncoding || parentProjection) {
      return this.mapUnitWithParentEncodingOrProjection(specWithReplacedEncoding, params2);
    }
    const normalizeLayerOrUnit = this.mapLayerOrUnit.bind(this);
    for (const unitNormalizer of this.nonFacetUnitNormalizers) {
      if (unitNormalizer.hasMatchingType(specWithReplacedEncoding, params2.config)) {
        return unitNormalizer.run(specWithReplacedEncoding, params2, normalizeLayerOrUnit);
      }
    }
    return specWithReplacedEncoding;
  }
  mapRepeat(spec, params2) {
    if (isLayerRepeatSpec(spec)) {
      return this.mapLayerRepeat(spec, params2);
    } else {
      return this.mapNonLayerRepeat(spec, params2);
    }
  }
  mapLayerRepeat(spec, params2) {
    const { repeat: repeat3, spec: childSpec, ...rest } = spec;
    const { row, column, layer } = repeat3;
    const { repeater = {}, repeaterPrefix = "" } = params2;
    if (row || column) {
      return this.mapRepeat({
        ...spec,
        repeat: {
          ...row ? { row } : {},
          ...column ? { column } : {}
        },
        spec: {
          repeat: { layer },
          spec: childSpec
        }
      }, params2);
    } else {
      return {
        ...rest,
        layer: layer.map((layerValue) => {
          const childRepeater = {
            ...repeater,
            layer: layerValue
          };
          const childName = `${(childSpec.name ? `${childSpec.name}_` : "") + repeaterPrefix}child__layer_${varName(layerValue)}`;
          const child = this.mapLayerOrUnit(childSpec, { ...params2, repeater: childRepeater, repeaterPrefix: childName });
          child.name = childName;
          return child;
        })
      };
    }
  }
  mapNonLayerRepeat(spec, params2) {
    const { repeat: repeat3, spec: childSpec, data: data3, ...remainingProperties } = spec;
    if (!isArray22(repeat3) && spec.columns) {
      spec = omit(spec, ["columns"]);
      warn2(columnsNotSupportByRowCol("repeat"));
    }
    const concat = [];
    const { repeater = {}, repeaterPrefix = "" } = params2;
    const row = !isArray22(repeat3) && repeat3.row || [repeater ? repeater.row : null];
    const column = !isArray22(repeat3) && repeat3.column || [repeater ? repeater.column : null];
    const repeatValues = isArray22(repeat3) && repeat3 || [repeater ? repeater.repeat : null];
    for (const repeatValue of repeatValues) {
      for (const rowValue of row) {
        for (const columnValue of column) {
          const childRepeater = {
            repeat: repeatValue,
            row: rowValue,
            column: columnValue,
            layer: repeater.layer
          };
          const childName = `${(childSpec.name ? `${childSpec.name}_` : "") + repeaterPrefix}child__${isArray22(repeat3) ? `${varName(repeatValue)}` : (repeat3.row ? `row_${varName(rowValue)}` : "") + (repeat3.column ? `column_${varName(columnValue)}` : "")}`;
          const child = this.map(childSpec, { ...params2, repeater: childRepeater, repeaterPrefix: childName });
          child.name = childName;
          concat.push(omit(child, ["data"]));
        }
      }
    }
    const columns = isArray22(repeat3) ? spec.columns : repeat3.column ? repeat3.column.length : 1;
    return {
      data: childSpec.data ?? data3,
      // data from child spec should have precedence
      align: "all",
      ...remainingProperties,
      columns,
      concat
    };
  }
  mapFacet(spec, params2) {
    const { facet } = spec;
    if (isFacetMapping(facet) && spec.columns) {
      spec = omit(spec, ["columns"]);
      warn2(columnsNotSupportByRowCol("facet"));
    }
    return super.mapFacet(spec, params2);
  }
  mapUnitWithParentEncodingOrProjection(spec, params2) {
    const { encoding, projection: projection3 } = spec;
    const { parentEncoding, parentProjection, config } = params2;
    const mergedProjection = mergeProjection({ parentProjection, projection: projection3 });
    const mergedEncoding = mergeEncoding({
      parentEncoding,
      encoding: replaceRepeaterInEncoding(encoding, params2.repeater)
    });
    return this.mapUnit({
      ...spec,
      ...mergedProjection ? { projection: mergedProjection } : {},
      ...mergedEncoding ? { encoding: mergedEncoding } : {}
    }, { config });
  }
  mapFacetedUnit(spec, normParams) {
    const { row, column, facet, ...encoding } = spec.encoding;
    const { mark, width: width2, projection: projection3, height: height2, view, params: params2, encoding: _, ...outerSpec } = spec;
    const { facetMapping, layout } = this.getFacetMappingAndLayout({ row, column, facet }, normParams);
    const newEncoding = replaceRepeaterInEncoding(encoding, normParams.repeater);
    return this.mapFacet({
      ...outerSpec,
      ...layout,
      // row / column has higher precedence than facet
      facet: facetMapping,
      spec: {
        ...width2 ? { width: width2 } : {},
        ...height2 ? { height: height2 } : {},
        ...view ? { view } : {},
        ...projection3 ? { projection: projection3 } : {},
        mark,
        encoding: newEncoding,
        ...params2 ? { params: params2 } : {}
      }
    }, normParams);
  }
  getFacetMappingAndLayout(facets, params2) {
    const { row, column, facet } = facets;
    if (row || column) {
      if (facet) {
        warn2(facetChannelDropped([...row ? [ROW] : [], ...column ? [COLUMN] : []]));
      }
      const facetMapping = {};
      const layout = {};
      for (const channel of [ROW, COLUMN]) {
        const def6 = facets[channel];
        if (def6) {
          const { align: align2, center, spacing, columns, ...defWithoutLayout } = def6;
          facetMapping[channel] = defWithoutLayout;
          for (const prop of ["align", "center", "spacing"]) {
            if (def6[prop] !== void 0) {
              layout[prop] ?? (layout[prop] = {});
              layout[prop][channel] = def6[prop];
            }
          }
        }
      }
      return { facetMapping, layout };
    } else {
      const { align: align2, center, spacing, columns, ...facetMapping } = facet;
      return {
        facetMapping: replaceRepeaterInFacet(facetMapping, params2.repeater),
        layout: {
          ...align2 ? { align: align2 } : {},
          ...center ? { center } : {},
          ...spacing ? { spacing } : {},
          ...columns ? { columns } : {}
        }
      };
    }
  }
  mapLayer(spec, { parentEncoding, parentProjection, ...otherParams }) {
    const { encoding, projection: projection3, ...rest } = spec;
    const params2 = {
      ...otherParams,
      parentEncoding: mergeEncoding({ parentEncoding, encoding, layer: true }),
      parentProjection: mergeProjection({ parentProjection, projection: projection3 })
    };
    return super.mapLayer({
      ...rest,
      ...spec.name ? { name: [params2.repeaterPrefix, spec.name].filter((n) => n).join("_") } : {}
    }, params2);
  }
};
function mergeEncoding({ parentEncoding, encoding = {}, layer }) {
  let merged = {};
  if (parentEncoding) {
    const channels = /* @__PURE__ */ new Set([...keys4(parentEncoding), ...keys4(encoding)]);
    for (const channel of channels) {
      const channelDef = encoding[channel];
      const parentChannelDef = parentEncoding[channel];
      if (isFieldOrDatumDef(channelDef)) {
        const mergedChannelDef = {
          ...parentChannelDef,
          ...channelDef
        };
        merged[channel] = mergedChannelDef;
      } else if (hasConditionalFieldOrDatumDef(channelDef)) {
        merged[channel] = {
          ...channelDef,
          condition: {
            ...parentChannelDef,
            ...channelDef.condition
          }
        };
      } else if (channelDef || channelDef === null) {
        merged[channel] = channelDef;
      } else if (layer || isValueDef(parentChannelDef) || isSignalRef(parentChannelDef) || isFieldOrDatumDef(parentChannelDef) || isArray22(parentChannelDef)) {
        merged[channel] = parentChannelDef;
      }
    }
  } else {
    merged = encoding;
  }
  return !merged || isEmpty(merged) ? void 0 : merged;
}
function mergeProjection(opt) {
  const { parentProjection, projection: projection3 } = opt;
  if (parentProjection && projection3) {
    warn2(projectionOverridden({ parentProjection, projection: projection3 }));
  }
  return projection3 ?? parentProjection;
}
function isFilter(t) {
  return hasProperty(t, "filter");
}
function isImputeSequence(t) {
  return hasProperty(t, "stop");
}
function isLookup(t) {
  return hasProperty(t, "lookup");
}
function isLookupData(from) {
  return hasProperty(from, "data");
}
function isLookupSelection(from) {
  return hasProperty(from, "param");
}
function isPivot(t) {
  return hasProperty(t, "pivot");
}
function isDensity(t) {
  return hasProperty(t, "density");
}
function isQuantile2(t) {
  return hasProperty(t, "quantile");
}
function isRegression(t) {
  return hasProperty(t, "regression");
}
function isLoess(t) {
  return hasProperty(t, "loess");
}
function isSample(t) {
  return hasProperty(t, "sample");
}
function isWindow(t) {
  return hasProperty(t, "window");
}
function isJoinAggregate(t) {
  return hasProperty(t, "joinaggregate");
}
function isFlatten(t) {
  return hasProperty(t, "flatten");
}
function isCalculate(t) {
  return hasProperty(t, "calculate");
}
function isBin(t) {
  return hasProperty(t, "bin");
}
function isImpute(t) {
  return hasProperty(t, "impute");
}
function isTimeUnit(t) {
  return hasProperty(t, "timeUnit");
}
function isAggregate(t) {
  return hasProperty(t, "aggregate");
}
function isStack(t) {
  return hasProperty(t, "stack");
}
function isFold(t) {
  return hasProperty(t, "fold");
}
function isExtent(t) {
  return hasProperty(t, "extent") && !hasProperty(t, "density") && !hasProperty(t, "regression");
}
function normalizeTransform(transform4) {
  return transform4.map((t) => {
    if (isFilter(t)) {
      return {
        filter: normalizeLogicalComposition(t.filter, normalizePredicate$1)
      };
    }
    return t;
  });
}
var SelectionCompatibilityNormalizer = class extends SpecMapper {
  map(spec, normParams) {
    normParams.emptySelections ?? (normParams.emptySelections = {});
    normParams.selectionPredicates ?? (normParams.selectionPredicates = {});
    spec = normalizeTransforms(spec, normParams);
    return super.map(spec, normParams);
  }
  mapLayerOrUnit(spec, normParams) {
    spec = normalizeTransforms(spec, normParams);
    if (spec.encoding) {
      const encoding = {};
      for (const [channel, enc] of entries$1(spec.encoding)) {
        encoding[channel] = normalizeChannelDef(enc, normParams);
      }
      spec = { ...spec, encoding };
    }
    return super.mapLayerOrUnit(spec, normParams);
  }
  mapUnit(spec, normParams) {
    const { selection, ...rest } = spec;
    if (selection) {
      return {
        ...rest,
        params: entries$1(selection).map(([name, selDef]) => {
          const { init: value7, bind: bind7, empty, ...select2 } = selDef;
          if (select2.type === "single") {
            select2.type = "point";
            select2.toggle = false;
          } else if (select2.type === "multi") {
            select2.type = "point";
          }
          normParams.emptySelections[name] = empty !== "none";
          for (const pred of vals(normParams.selectionPredicates[name] ?? {})) {
            pred.empty = empty !== "none";
          }
          return { name, value: value7, select: select2, bind: bind7 };
        })
      };
    }
    return spec;
  }
};
function normalizeTransforms(spec, normParams) {
  const { transform: tx, ...rest } = spec;
  if (tx) {
    const transform4 = tx.map((t) => {
      if (isFilter(t)) {
        return { filter: normalizePredicate(t, normParams) };
      } else if (isBin(t) && isBinParams(t.bin)) {
        return {
          ...t,
          bin: normalizeBinExtent(t.bin)
        };
      } else if (isLookup(t)) {
        const { selection: param2, ...from } = t.from;
        return param2 ? {
          ...t,
          from: { param: param2, ...from }
        } : t;
      }
      return t;
    });
    return { ...rest, transform: transform4 };
  }
  return spec;
}
function normalizeChannelDef(obj, normParams) {
  var _a2, _b;
  const enc = duplicate(obj);
  if (isFieldDef(enc) && isBinParams(enc.bin)) {
    enc.bin = normalizeBinExtent(enc.bin);
  }
  if (isScaleFieldDef(enc) && ((_b = (_a2 = enc.scale) == null ? void 0 : _a2.domain) == null ? void 0 : _b.selection)) {
    const { selection: param2, ...domain3 } = enc.scale.domain;
    enc.scale.domain = { ...domain3, ...param2 ? { param: param2 } : {} };
  }
  if (isConditionalDef(enc)) {
    if (isArray22(enc.condition)) {
      enc.condition = enc.condition.map((c5) => {
        const { selection, param: param2, test: test2, ...cond } = c5;
        return param2 ? c5 : { ...cond, test: normalizePredicate(c5, normParams) };
      });
    } else {
      const { selection, param: param2, test: test2, ...cond } = normalizeChannelDef(enc.condition, normParams);
      enc.condition = param2 ? enc.condition : {
        ...cond,
        test: normalizePredicate(enc.condition, normParams)
      };
    }
  }
  return enc;
}
function normalizeBinExtent(bin5) {
  const ext = bin5.extent;
  if (ext == null ? void 0 : ext.selection) {
    const { selection: param2, ...rest } = ext;
    return { ...bin5, extent: { ...rest, param: param2 } };
  }
  return bin5;
}
function normalizePredicate(op, normParams) {
  const normalizeSelectionComposition = (o) => {
    return normalizeLogicalComposition(o, (param2) => {
      var _a2;
      const empty = normParams.emptySelections[param2] ?? true;
      const pred = { param: param2, empty };
      (_a2 = normParams.selectionPredicates)[param2] ?? (_a2[param2] = []);
      normParams.selectionPredicates[param2].push(pred);
      return pred;
    });
  };
  return op.selection ? normalizeSelectionComposition(op.selection) : normalizeLogicalComposition(op.test || op.filter, (o) => o.selection ? normalizeSelectionComposition(o.selection) : o);
}
var TopLevelSelectionsNormalizer = class extends SpecMapper {
  map(spec, normParams) {
    const selections = normParams.selections ?? [];
    if (spec.params && !isUnitSpec(spec)) {
      const params2 = [];
      for (const param2 of spec.params) {
        if (isSelectionParameter(param2)) {
          selections.push(param2);
        } else {
          params2.push(param2);
        }
      }
      spec.params = params2;
    }
    normParams.selections = selections;
    return super.map(spec, normParams);
  }
  mapUnit(spec, normParams) {
    const selections = normParams.selections;
    if (!selections || !selections.length)
      return spec;
    const path7 = (normParams.path ?? []).concat(spec.name);
    const params2 = [];
    for (const selection of selections) {
      if (!selection.views || !selection.views.length) {
        params2.push(selection);
      } else {
        for (const view of selection.views) {
          if (isString14(view) && (view === spec.name || path7.includes(view)) || isArray22(view) && // logic for backwards compatibility with view paths before we had unique names
          view.map((v2) => path7.indexOf(v2)).every((v2, i, arr) => v2 !== -1 && (i === 0 || v2 > arr[i - 1]))) {
            params2.push(selection);
          }
        }
      }
    }
    if (params2.length)
      spec.params = params2;
    return spec;
  }
};
for (const method10 of ["mapFacet", "mapRepeat", "mapHConcat", "mapVConcat", "mapLayer"]) {
  const proto = TopLevelSelectionsNormalizer.prototype[method10];
  TopLevelSelectionsNormalizer.prototype[method10] = function(spec, params2) {
    return proto.call(this, spec, addSpecNameToParams(spec, params2));
  };
}
function addSpecNameToParams(spec, params2) {
  return spec.name ? {
    ...params2,
    path: (params2.path ?? []).concat(spec.name)
  } : params2;
}
function normalize3(spec, config) {
  if (config === void 0) {
    config = initConfig(spec.config);
  }
  const normalizedSpec = normalizeGenericSpec(spec, config);
  const { width: width2, height: height2 } = spec;
  const autosize = normalizeAutoSize(normalizedSpec, { width: width2, height: height2, autosize: spec.autosize }, config);
  return {
    ...normalizedSpec,
    ...autosize ? { autosize } : {}
  };
}
var coreNormalizer = new CoreNormalizer();
var selectionCompatNormalizer = new SelectionCompatibilityNormalizer();
var topLevelSelectionNormalizer = new TopLevelSelectionsNormalizer();
function normalizeGenericSpec(spec, config = {}) {
  const normParams = { config };
  return topLevelSelectionNormalizer.map(coreNormalizer.map(selectionCompatNormalizer.map(spec, normParams), normParams), normParams);
}
function _normalizeAutoSize(autosize) {
  return isString14(autosize) ? { type: autosize } : autosize ?? {};
}
function normalizeAutoSize(spec, sizeInfo, config) {
  let { width: width2, height: height2 } = sizeInfo;
  const isFitCompatible = isUnitSpec(spec) || isLayerSpec(spec);
  const autosizeDefault = {};
  if (!isFitCompatible) {
    if (width2 == "container") {
      warn2(containerSizeNonSingle("width"));
      width2 = void 0;
    }
    if (height2 == "container") {
      warn2(containerSizeNonSingle("height"));
      height2 = void 0;
    }
  } else {
    if (width2 == "container" && height2 == "container") {
      autosizeDefault.type = "fit";
      autosizeDefault.contains = "padding";
    } else if (width2 == "container") {
      autosizeDefault.type = "fit-x";
      autosizeDefault.contains = "padding";
    } else if (height2 == "container") {
      autosizeDefault.type = "fit-y";
      autosizeDefault.contains = "padding";
    }
  }
  const autosize = {
    type: "pad",
    ...autosizeDefault,
    ...config ? _normalizeAutoSize(config.autosize) : {},
    ..._normalizeAutoSize(spec.autosize)
  };
  if (autosize.type === "fit" && !isFitCompatible) {
    warn2(FIT_NON_SINGLE);
    autosize.type = "pad";
  }
  if (width2 == "container" && !(autosize.type == "fit" || autosize.type == "fit-x")) {
    warn2(containerSizeNotCompatibleWithAutosize("width"));
  }
  if (height2 == "container" && !(autosize.type == "fit" || autosize.type == "fit-y")) {
    warn2(containerSizeNotCompatibleWithAutosize("height"));
  }
  if (deepEqual(autosize, { type: "pad" })) {
    return void 0;
  }
  return autosize;
}
function isFitType(autoSizeType) {
  return ["fit", "fit-x", "fit-y"].includes(autoSizeType);
}
function getFitType(sizeType) {
  return sizeType ? `fit-${getPositionScaleChannel(sizeType)}` : "fit";
}
var TOP_LEVEL_PROPERTIES = [
  "background",
  "padding"
  // We do not include "autosize" here as it is supported by only unit and layer specs and thus need to be normalized
];
function extractTopLevelProperties(t, includeParams) {
  const o = {};
  for (const p of TOP_LEVEL_PROPERTIES) {
    if (t && t[p] !== void 0) {
      o[p] = signalRefOrValue(t[p]);
    }
  }
  if (includeParams) {
    o.params = t.params;
  }
  return o;
}
var Split = class _Split {
  constructor(explicit = {}, implicit2 = {}) {
    __publicField(this, "explicit");
    __publicField(this, "implicit");
    this.explicit = explicit;
    this.implicit = implicit2;
  }
  clone() {
    return new _Split(duplicate(this.explicit), duplicate(this.implicit));
  }
  combine() {
    return {
      ...this.explicit,
      // Explicit properties comes first
      ...this.implicit
    };
  }
  get(key4) {
    return getFirstDefined(this.explicit[key4], this.implicit[key4]);
  }
  getWithExplicit(key4) {
    if (this.explicit[key4] !== void 0) {
      return { explicit: true, value: this.explicit[key4] };
    } else if (this.implicit[key4] !== void 0) {
      return { explicit: false, value: this.implicit[key4] };
    }
    return { explicit: false, value: void 0 };
  }
  setWithExplicit(key4, { value: value7, explicit }) {
    if (value7 !== void 0) {
      this.set(key4, value7, explicit);
    }
  }
  set(key4, value7, explicit) {
    delete this[explicit ? "implicit" : "explicit"][key4];
    this[explicit ? "explicit" : "implicit"][key4] = value7;
    return this;
  }
  copyKeyFromSplit(key4, { explicit, implicit: implicit2 }) {
    if (explicit[key4] !== void 0) {
      this.set(key4, explicit[key4], true);
    } else if (implicit2[key4] !== void 0) {
      this.set(key4, implicit2[key4], false);
    }
  }
  copyKeyFromObject(key4, s2) {
    if (s2[key4] !== void 0) {
      this.set(key4, s2[key4], true);
    }
  }
  /**
   * Merge split object into this split object. Properties from the other split
   * overwrite properties from this split.
   */
  copyAll(other) {
    for (const key4 of keys4(other.combine())) {
      const val = other.getWithExplicit(key4);
      this.setWithExplicit(key4, val);
    }
  }
};
function makeExplicit(value7) {
  return {
    explicit: true,
    value: value7
  };
}
function makeImplicit(value7) {
  return {
    explicit: false,
    value: value7
  };
}
function tieBreakByComparing(compare10) {
  return (v1, v2, property2, propertyOf) => {
    const diff = compare10(v1.value, v2.value);
    if (diff > 0) {
      return v1;
    } else if (diff < 0) {
      return v2;
    }
    return defaultTieBreaker(v1, v2, property2, propertyOf);
  };
}
function defaultTieBreaker(v1, v2, property2, propertyOf) {
  if (v1.explicit && v2.explicit) {
    warn2(mergeConflictingProperty(property2, propertyOf, v1.value, v2.value));
  }
  return v1;
}
function mergeValuesWithExplicit(v1, v2, property2, propertyOf, tieBreaker = defaultTieBreaker) {
  if (v1 === void 0 || v1.value === void 0) {
    return v2;
  }
  if (v1.explicit && !v2.explicit) {
    return v1;
  } else if (v2.explicit && !v1.explicit) {
    return v2;
  } else if (deepEqual(v1.value, v2.value)) {
    return v1;
  } else {
    return tieBreaker(v1, v2, property2, propertyOf);
  }
}
var AncestorParse = class extends Split {
  constructor(explicit = {}, implicit2 = {}, parseNothing = false) {
    super(explicit, implicit2);
    __publicField(this, "explicit");
    __publicField(this, "implicit");
    __publicField(this, "parseNothing");
    this.explicit = explicit;
    this.implicit = implicit2;
    this.parseNothing = parseNothing;
  }
  clone() {
    const clone = super.clone();
    clone.parseNothing = this.parseNothing;
    return clone;
  }
};
function isUrlData(data3) {
  return hasProperty(data3, "url");
}
function isInlineData(data3) {
  return hasProperty(data3, "values");
}
function isNamedData(data3) {
  return hasProperty(data3, "name") && !isUrlData(data3) && !isInlineData(data3) && !isGenerator(data3);
}
function isGenerator(data3) {
  return data3 && (isSequenceGenerator(data3) || isSphereGenerator(data3) || isGraticuleGenerator(data3));
}
function isSequenceGenerator(data3) {
  return hasProperty(data3, "sequence");
}
function isSphereGenerator(data3) {
  return hasProperty(data3, "sphere");
}
function isGraticuleGenerator(data3) {
  return hasProperty(data3, "graticule");
}
var DataSourceType;
(function(DataSourceType2) {
  DataSourceType2[DataSourceType2["Raw"] = 0] = "Raw";
  DataSourceType2[DataSourceType2["Main"] = 1] = "Main";
  DataSourceType2[DataSourceType2["Row"] = 2] = "Row";
  DataSourceType2[DataSourceType2["Column"] = 3] = "Column";
  DataSourceType2[DataSourceType2["Lookup"] = 4] = "Lookup";
  DataSourceType2[DataSourceType2["PreFilterInvalid"] = 5] = "PreFilterInvalid";
  DataSourceType2[DataSourceType2["PostFilterInvalid"] = 6] = "PostFilterInvalid";
})(DataSourceType || (DataSourceType = {}));
function getDataSourcesForHandlingInvalidValues({ invalid, isPath }) {
  const normalizedInvalid = normalizeInvalidDataMode(invalid, { isPath });
  switch (normalizedInvalid) {
    case "filter":
      return {
        marks: "exclude-invalid-values",
        scales: "exclude-invalid-values"
      };
    case "break-paths-show-domains":
      return {
        // Path-based marks use pre-filter data so we know to skip these invalid points in the path.
        // For non-path based marks, we skip by not showing them at all.
        marks: isPath ? "include-invalid-values" : "exclude-invalid-values",
        scales: "include-invalid-values"
      };
    case "break-paths-filter-domains":
      return {
        marks: isPath ? "include-invalid-values" : "exclude-invalid-values",
        // Unlike 'break-paths-show-domains', 'break-paths-filter-domains' uses post-filter data to feed scale.
        scales: "exclude-invalid-values"
      };
    case "show":
      return {
        marks: "include-invalid-values",
        scales: "include-invalid-values"
      };
  }
}
function getScaleDataSourceForHandlingInvalidValues(props) {
  const { marks, scales: scales10 } = getDataSourcesForHandlingInvalidValues(props);
  if (marks === scales10) {
    return DataSourceType.Main;
  }
  return scales10 === "include-invalid-values" ? DataSourceType.PreFilterInvalid : DataSourceType.PostFilterInvalid;
}
var DataFlowNode = class {
  constructor(parent, debugName) {
    __publicField(this, "debugName");
    __publicField(this, "_children", []);
    __publicField(this, "_parent", null);
    __publicField(this, "_hash");
    this.debugName = debugName;
    if (parent) {
      this.parent = parent;
    }
  }
  /**
   * Clone this node with a deep copy but don't clone links to children or parents.
   */
  clone() {
    throw new Error("Cannot clone node");
  }
  get parent() {
    return this._parent;
  }
  /**
   * Set the parent of the node and also add this node to the parent's children.
   */
  set parent(parent) {
    this._parent = parent;
    if (parent) {
      parent.addChild(this);
    }
  }
  get children() {
    return this._children;
  }
  numChildren() {
    return this._children.length;
  }
  addChild(child, loc) {
    if (this._children.includes(child)) {
      warn2(ADD_SAME_CHILD_TWICE);
      return;
    }
    if (loc !== void 0) {
      this._children.splice(loc, 0, child);
    } else {
      this._children.push(child);
    }
  }
  removeChild(oldChild) {
    const loc = this._children.indexOf(oldChild);
    this._children.splice(loc, 1);
    return loc;
  }
  /**
   * Remove node from the dataflow.
   */
  remove() {
    let loc = this._parent.removeChild(this);
    for (const child of this._children) {
      child._parent = this._parent;
      this._parent.addChild(child, loc++);
    }
  }
  /**
   * Insert another node as a parent of this node.
   */
  insertAsParentOf(other) {
    const parent = other.parent;
    parent.removeChild(this);
    this.parent = parent;
    other.parent = this;
  }
  swapWithParent() {
    const parent = this._parent;
    const newParent = parent.parent;
    for (const child of this._children) {
      child.parent = parent;
    }
    this._children = [];
    parent.removeChild(this);
    const loc = parent.parent.removeChild(parent);
    this._parent = newParent;
    newParent.addChild(this, loc);
    parent.parent = this;
  }
};
var OutputNode = class extends DataFlowNode {
  /**
   * @param source The name of the source. Will change in assemble.
   * @param type The type of the output node.
   * @param refCounts A global ref counter map.
   */
  constructor(parent, source3, type7, refCounts) {
    super(parent, source3);
    __publicField(this, "type");
    __publicField(this, "refCounts");
    __publicField(this, "_source");
    __publicField(this, "_name");
    this.type = type7;
    this.refCounts = refCounts;
    this._source = this._name = source3;
    if (this.refCounts && !(this._name in this.refCounts)) {
      this.refCounts[this._name] = 0;
    }
  }
  clone() {
    const cloneObj = new this.constructor();
    cloneObj.debugName = `clone_${this.debugName}`;
    cloneObj._source = this._source;
    cloneObj._name = `clone_${this._name}`;
    cloneObj.type = this.type;
    cloneObj.refCounts = this.refCounts;
    cloneObj.refCounts[cloneObj._name] = 0;
    return cloneObj;
  }
  dependentFields() {
    return /* @__PURE__ */ new Set();
  }
  producedFields() {
    return /* @__PURE__ */ new Set();
  }
  hash() {
    if (this._hash === void 0) {
      this._hash = `Output ${uniqueId()}`;
    }
    return this._hash;
  }
  /**
   * Request the datasource name and increase the ref counter.
   *
   * During the parsing phase, this will return the simple name such as 'main' or 'raw'.
   * It is crucial to request the name from an output node to mark it as a required node.
   * If nobody ever requests the name, this datasource will not be instantiated in the assemble phase.
   *
   * In the assemble phase, this will return the correct name.
   */
  getSource() {
    this.refCounts[this._name]++;
    return this._source;
  }
  isRequired() {
    return !!this.refCounts[this._name];
  }
  setSource(source3) {
    this._source = source3;
  }
};
function isTimeUnitTransformComponent(timeUnitComponent) {
  return timeUnitComponent.as !== void 0;
}
function offsetAs(field25) {
  return `${field25}_end`;
}
var TimeUnitNode = class _TimeUnitNode extends DataFlowNode {
  constructor(parent, timeUnits4) {
    super(parent);
    __publicField(this, "timeUnits");
    this.timeUnits = timeUnits4;
  }
  clone() {
    return new _TimeUnitNode(null, duplicate(this.timeUnits));
  }
  static makeFromEncoding(parent, model) {
    const formula = model.reduceFieldDef((timeUnitComponent, fieldDef, channel) => {
      const { field: field25, timeUnit } = fieldDef;
      if (timeUnit) {
        let component;
        if (isBinnedTimeUnit(timeUnit)) {
          if (isUnitModel(model)) {
            const { mark, markDef, config } = model;
            const bandPosition = getBandPosition({ fieldDef, markDef, config });
            if (isRectBasedMark(mark) || !!bandPosition) {
              component = {
                timeUnit: normalizeTimeUnit(timeUnit),
                field: field25
              };
            }
          }
        } else {
          component = {
            as: vgField(fieldDef, { forAs: true }),
            field: field25,
            timeUnit
          };
        }
        if (isUnitModel(model)) {
          const { mark, markDef, config } = model;
          const bandPosition = getBandPosition({ fieldDef, markDef, config });
          if (isRectBasedMark(mark) && isXorY(channel) && bandPosition !== 0.5) {
            component.rectBandPosition = bandPosition;
          }
        }
        if (component) {
          timeUnitComponent[hash(component)] = component;
        }
      }
      return timeUnitComponent;
    }, {});
    if (isEmpty(formula)) {
      return null;
    }
    return new _TimeUnitNode(parent, formula);
  }
  static makeFromTransform(parent, t) {
    const { timeUnit, ...other } = { ...t };
    const normalizedTimeUnit = normalizeTimeUnit(timeUnit);
    const component = {
      ...other,
      timeUnit: normalizedTimeUnit
    };
    return new _TimeUnitNode(parent, {
      [hash(component)]: component
    });
  }
  /**
   * Merge together TimeUnitNodes assigning the children of `other` to `this`
   * and removing `other`.
   */
  merge(other) {
    this.timeUnits = { ...this.timeUnits };
    for (const key4 in other.timeUnits) {
      if (!this.timeUnits[key4]) {
        this.timeUnits[key4] = other.timeUnits[key4];
      }
    }
    for (const child of other.children) {
      other.removeChild(child);
      child.parent = this;
    }
    other.remove();
  }
  /**
   * Remove time units coming from the other node.
   */
  removeFormulas(fields) {
    const newFormula = {};
    for (const [key4, timeUnitComponent] of entries$1(this.timeUnits)) {
      const fieldAs = isTimeUnitTransformComponent(timeUnitComponent) ? timeUnitComponent.as : `${timeUnitComponent.field}_end`;
      if (!fields.has(fieldAs)) {
        newFormula[key4] = timeUnitComponent;
      }
    }
    this.timeUnits = newFormula;
  }
  producedFields() {
    return new Set(vals(this.timeUnits).map((f) => {
      return isTimeUnitTransformComponent(f) ? f.as : offsetAs(f.field);
    }));
  }
  dependentFields() {
    return new Set(vals(this.timeUnits).map((f) => f.field));
  }
  hash() {
    return `TimeUnit ${hash(this.timeUnits)}`;
  }
  assemble() {
    const transforms2 = [];
    for (const f of vals(this.timeUnits)) {
      const { rectBandPosition } = f;
      const normalizedTimeUnit = normalizeTimeUnit(f.timeUnit);
      if (isTimeUnitTransformComponent(f)) {
        const { field: field25, as } = f;
        const { unit: unit2, utc, ...params2 } = normalizedTimeUnit;
        const startEnd = [as, `${as}_end`];
        transforms2.push({
          field: replacePathInField(field25),
          type: "timeunit",
          ...unit2 ? { units: getTimeUnitParts(unit2) } : {},
          ...utc ? { timezone: "utc" } : {},
          ...params2,
          as: startEnd
        });
        transforms2.push(...offsetedRectFormulas(startEnd, rectBandPosition, normalizedTimeUnit));
      } else if (f) {
        const { field: escapedField } = f;
        const field25 = unescapeSingleQuoteAndPathDot(escapedField);
        const expr2 = offsetExpr({ timeUnit: normalizedTimeUnit, field: field25 });
        const endAs = offsetAs(field25);
        transforms2.push({
          type: "formula",
          expr: expr2,
          as: endAs
        });
        transforms2.push(...offsetedRectFormulas([field25, endAs], rectBandPosition, normalizedTimeUnit));
      }
    }
    return transforms2;
  }
};
var OFFSETTED_RECT_START_SUFFIX = "offsetted_rect_start";
var OFFSETTED_RECT_END_SUFFIX = "offsetted_rect_end";
function offsetExpr({ timeUnit, field: field25, reverse: reverse4 }) {
  const { unit: unit2, utc } = timeUnit;
  const smallestUnit = getSmallestTimeUnitPart(unit2);
  const { part, step } = getDateTimePartAndStep(smallestUnit, timeUnit.step);
  const offsetFn = utc ? "utcOffset" : "timeOffset";
  const expr2 = `${offsetFn}('${part}', ${accessWithDatumToUnescapedPath(field25)}, ${reverse4 ? -step : step})`;
  return expr2;
}
function offsetedRectFormulas([startField, endField], rectBandPosition, timeUnit) {
  if (rectBandPosition !== void 0 && rectBandPosition !== 0.5) {
    const startExpr = accessWithDatumToUnescapedPath(startField);
    const endExpr = accessWithDatumToUnescapedPath(endField);
    return [
      {
        type: "formula",
        expr: interpolateExpr([
          offsetExpr({
            timeUnit,
            field: startField,
            reverse: true
          }),
          startExpr
        ], rectBandPosition + 0.5),
        as: `${startField}_${OFFSETTED_RECT_START_SUFFIX}`
      },
      {
        type: "formula",
        expr: interpolateExpr([startExpr, endExpr], rectBandPosition + 0.5),
        as: `${startField}_${OFFSETTED_RECT_END_SUFFIX}`
      }
    ];
  }
  return [];
}
function interpolateExpr([start, end], fraction) {
  return `${1 - fraction} * ${start} + ${fraction} * ${end}`;
}
var TUPLE_FIELDS = "_tuple_fields";
var SelectionProjectionComponent = class {
  constructor(...items) {
    __publicField(this, "hasChannel");
    __publicField(this, "hasField");
    __publicField(this, "hasSelectionId");
    __publicField(this, "timeUnit");
    __publicField(this, "items");
    this.items = items;
    this.hasChannel = {};
    this.hasField = {};
    this.hasSelectionId = false;
  }
};
var project2 = {
  defined: () => {
    return true;
  },
  parse: (model, selCmpt, selDef) => {
    const name = selCmpt.name;
    const proj = selCmpt.project ?? (selCmpt.project = new SelectionProjectionComponent());
    const parsed = {};
    const timeUnits4 = {};
    const signals = /* @__PURE__ */ new Set();
    const signalName = (p, range7) => {
      const suffix = range7 === "visual" ? p.channel : p.field;
      let sg = varName(`${name}_${suffix}`);
      for (let counter = 1; signals.has(sg); counter++) {
        sg = varName(`${name}_${suffix}_${counter}`);
      }
      signals.add(sg);
      return { [range7]: sg };
    };
    const type7 = selCmpt.type;
    const cfg = model.config.selection[type7];
    const init2 = selDef.value !== void 0 ? array21(selDef.value) : null;
    let { fields, encodings } = isObject12(selDef.select) ? selDef.select : {};
    if (!fields && !encodings && init2) {
      for (const initVal of init2) {
        if (!isObject12(initVal)) {
          continue;
        }
        for (const key4 of keys4(initVal)) {
          if (isSingleDefUnitChannel(key4)) {
            (encodings || (encodings = [])).push(key4);
          } else {
            if (type7 === "interval") {
              warn2(INTERVAL_INITIALIZED_WITH_POS);
              encodings = cfg.encodings;
            } else {
              (fields ?? (fields = [])).push(key4);
            }
          }
        }
      }
    }
    if (!fields && !encodings) {
      encodings = cfg.encodings;
      if ("fields" in cfg) {
        fields = cfg.fields;
      }
    }
    for (const channel of encodings ?? []) {
      const fieldDef = model.fieldDef(channel);
      if (fieldDef) {
        let field25 = fieldDef.field;
        if (fieldDef.aggregate) {
          warn2(cannotProjectAggregate(channel, fieldDef.aggregate));
          continue;
        } else if (!field25) {
          warn2(cannotProjectOnChannelWithoutField(channel));
          continue;
        }
        if (fieldDef.timeUnit && !isBinnedTimeUnit(fieldDef.timeUnit)) {
          field25 = model.vgField(channel);
          const component = {
            timeUnit: fieldDef.timeUnit,
            as: field25,
            field: fieldDef.field
          };
          timeUnits4[hash(component)] = component;
        }
        if (!parsed[field25]) {
          const tplType = type7 === "interval" && isScaleChannel(channel) && hasContinuousDomain(model.getScaleComponent(channel).get("type")) ? "R" : fieldDef.bin ? "R-RE" : "E";
          const p = { field: field25, channel, type: tplType, index: proj.items.length };
          p.signals = { ...signalName(p, "data"), ...signalName(p, "visual") };
          proj.items.push(parsed[field25] = p);
          proj.hasField[field25] = parsed[field25];
          proj.hasSelectionId = proj.hasSelectionId || field25 === SELECTION_ID;
          if (isGeoPositionChannel(channel)) {
            p.geoChannel = channel;
            p.channel = getPositionChannelFromLatLong(channel);
            proj.hasChannel[p.channel] = parsed[field25];
          } else {
            proj.hasChannel[channel] = parsed[field25];
          }
        }
      } else {
        warn2(cannotProjectOnChannelWithoutField(channel));
      }
    }
    for (const field25 of fields ?? []) {
      if (proj.hasField[field25])
        continue;
      const p = { type: "E", field: field25, index: proj.items.length };
      p.signals = { ...signalName(p, "data") };
      proj.items.push(p);
      proj.hasField[field25] = p;
      proj.hasSelectionId = proj.hasSelectionId || field25 === SELECTION_ID;
    }
    if (init2) {
      selCmpt.init = init2.map((v2) => {
        return proj.items.map((p) => isObject12(v2) ? v2[p.geoChannel || p.channel] !== void 0 ? v2[p.geoChannel || p.channel] : v2[p.field] : v2);
      });
    }
    if (!isEmpty(timeUnits4)) {
      proj.timeUnit = new TimeUnitNode(null, timeUnits4);
    }
  },
  signals: (model, selCmpt, allSignals) => {
    const name = selCmpt.name + TUPLE_FIELDS;
    const hasSignal2 = allSignals.filter((s2) => s2.name === name);
    return hasSignal2.length > 0 || selCmpt.project.hasSelectionId ? allSignals : allSignals.concat({
      name,
      value: selCmpt.project.items.map(assembleProjection)
    });
  }
};
var CURR = "_curr";
var ANIM_VALUE = "anim_value";
var ANIM_CLOCK = "anim_clock";
var EASED_ANIM_CLOCK = "eased_anim_clock";
var MIN_EXTENT = "min_extent";
var MAX_RANGE_EXTENT = "max_range_extent";
var LAST_TICK = "last_tick_at";
var IS_PLAYING = "is_playing";
var THROTTLE = 1 / 60 * 1e3;
var animationSignals = (selectionName, scaleName) => {
  return [
    // timer signals
    {
      name: EASED_ANIM_CLOCK,
      // update: 'easeLinear(anim_clock / max_range_extent) * max_range_extent'
      update: ANIM_CLOCK
      // TODO: replace with above once easing functions are implemented in vega-functions
    },
    // scale signals
    // TODO(jzong): uncomment commented signals below when implementing interpolation
    { name: `${selectionName}_domain`, init: `domain('${scaleName}')` },
    { name: MIN_EXTENT, init: `extent(${selectionName}_domain)[0]` },
    // {name: 'max_extent', init: `extent(${selectionName}_domain)[1]`},
    { name: MAX_RANGE_EXTENT, init: `extent(range('${scaleName}'))[1]` },
    // {name: 't_index', update: `indexof(${selectionName}_domain, anim_value)`},
    { name: ANIM_VALUE, update: `invert('${scaleName}', ${EASED_ANIM_CLOCK})` }
  ];
};
var point$1 = {
  defined: (selCmpt) => selCmpt.type === "point",
  topLevelSignals: (model, selCmpt, signals) => {
    if (isTimerSelection(selCmpt)) {
      signals = signals.concat([
        {
          name: ANIM_CLOCK,
          init: "0",
          on: [
            {
              events: { type: "timer", throttle: THROTTLE },
              update: `${IS_PLAYING} ? (${ANIM_CLOCK} + (now() - ${LAST_TICK}) > ${MAX_RANGE_EXTENT} ? 0 : ${ANIM_CLOCK} + (now() - ${LAST_TICK})) : ${ANIM_CLOCK}`
            }
          ]
        },
        {
          name: LAST_TICK,
          init: "now()",
          on: [{ events: [{ signal: ANIM_CLOCK }, { signal: IS_PLAYING }], update: "now()" }]
        },
        {
          name: IS_PLAYING,
          init: "true"
        }
      ]);
    }
    return signals;
  },
  signals: (model, selCmpt, signals) => {
    const name = selCmpt.name;
    const fieldsSg = name + TUPLE_FIELDS;
    const project3 = selCmpt.project;
    const datum2 = "(item().isVoronoi ? datum.datum : datum)";
    const brushes = vals(model.component.selection ?? {}).reduce((acc, cmpt) => {
      return cmpt.type === "interval" ? acc.concat(cmpt.name + BRUSH) : acc;
    }, []).map((b6) => `indexof(item().mark.name, '${b6}') < 0`).join(" && ");
    const test2 = `datum && item().mark.marktype !== 'group' && indexof(item().mark.role, 'legend') < 0${brushes ? ` && ${brushes}` : ""}`;
    let update3 = `unit: ${unitName(model)}, `;
    if (selCmpt.project.hasSelectionId) {
      update3 += `${SELECTION_ID}: ${datum2}[${$10(SELECTION_ID)}]`;
    } else if (isTimerSelection(selCmpt)) {
      update3 += `fields: ${fieldsSg}, values: [${ANIM_VALUE} ? ${ANIM_VALUE} : ${MIN_EXTENT}]`;
    } else {
      const values7 = project3.items.map((p) => {
        const fieldDef = model.fieldDef(p.channel);
        return (fieldDef == null ? void 0 : fieldDef.bin) ? `[${datum2}[${$10(model.vgField(p.channel, {}))}], ${datum2}[${$10(model.vgField(p.channel, { binSuffix: "end" }))}]]` : `${datum2}[${$10(p.field)}]`;
      }).join(", ");
      update3 += `fields: ${fieldsSg}, values: [${values7}]`;
    }
    if (isTimerSelection(selCmpt)) {
      return signals.concat(animationSignals(selCmpt.name, model.scaleName(TIME)), [
        {
          name: name + TUPLE,
          on: [
            {
              events: [{ signal: EASED_ANIM_CLOCK }, { signal: ANIM_VALUE }],
              update: `{${update3}}`,
              force: true
            }
          ]
        }
      ]);
    } else {
      const events3 = selCmpt.events;
      return signals.concat([
        {
          name: name + TUPLE,
          on: events3 ? [
            {
              events: events3,
              update: `${test2} ? {${update3}} : null`,
              force: true
            }
          ] : []
        }
      ]);
    }
  }
};
function assembleProjection(proj) {
  const { signals, hasLegend, index: index4, ...rest } = proj;
  rest.field = replacePathInField(rest.field);
  return rest;
}
function assembleInit(init2, isExpr2 = true, wrap2 = identity26) {
  if (isArray22(init2)) {
    const assembled = init2.map((v2) => assembleInit(v2, isExpr2, wrap2));
    return isExpr2 ? `[${assembled.join(", ")}]` : assembled;
  } else if (isDateTime(init2)) {
    if (isExpr2) {
      return wrap2(dateTimeToExpr(init2));
    } else {
      return wrap2(dateTimeToTimestamp(init2));
    }
  }
  return isExpr2 ? wrap2(stringify2(init2)) : init2;
}
function assembleUnitSelectionSignals(model, signals) {
  for (const selCmpt of vals(model.component.selection ?? {})) {
    const name = selCmpt.name;
    let modifyExpr = `${name}${TUPLE}, ${selCmpt.resolve === "global" ? "true" : `{unit: ${unitName(model)}}`}`;
    for (const c5 of selectionCompilers) {
      if (!c5.defined(selCmpt))
        continue;
      if (c5.signals)
        signals = c5.signals(model, selCmpt, signals);
      if (c5.modifyExpr)
        modifyExpr = c5.modifyExpr(model, selCmpt, modifyExpr);
    }
    signals.push({
      name: name + MODIFY,
      on: [
        {
          events: { signal: selCmpt.name + TUPLE },
          update: `modify(${$10(selCmpt.name + STORE)}, ${modifyExpr})`
        }
      ]
    });
  }
  return cleanupEmptyOnArray(signals);
}
function assembleFacetSignals(model, signals) {
  if (model.component.selection && keys4(model.component.selection).length) {
    const name = $10(model.getName("cell"));
    signals.unshift({
      name: "facet",
      value: {},
      on: [
        {
          events: eventSelector("pointermove", "scope"),
          update: `isTuple(facet) ? facet : group(${name}).datum`
        }
      ]
    });
  }
  return cleanupEmptyOnArray(signals);
}
function assembleTopLevelSignals(model, signals) {
  let hasSelections = false;
  for (const selCmpt of vals(model.component.selection ?? {})) {
    const name = selCmpt.name;
    const store = $10(name + STORE);
    const hasSg = signals.filter((s2) => s2.name === name);
    if (hasSg.length === 0) {
      const resolve2 = selCmpt.resolve === "global" ? "union" : selCmpt.resolve;
      const isPoint2 = selCmpt.type === "point" ? ", true, true)" : ")";
      signals.push({
        name: selCmpt.name,
        update: `${VL_SELECTION_RESOLVE}(${store}, ${$10(resolve2)}${isPoint2}`
      });
    }
    hasSelections = true;
    for (const c5 of selectionCompilers) {
      if (c5.defined(selCmpt) && c5.topLevelSignals) {
        signals = c5.topLevelSignals(model, selCmpt, signals);
      }
    }
  }
  if (hasSelections) {
    const hasUnit = signals.filter((s2) => s2.name === "unit");
    if (hasUnit.length === 0) {
      signals.unshift({
        name: "unit",
        value: {},
        on: [{ events: "pointermove", update: "isTuple(group()) ? group() : unit" }]
      });
    }
  }
  return cleanupEmptyOnArray(signals);
}
function assembleUnitSelectionData(model, data3) {
  const selectionData = [];
  const animationData = [];
  const unit2 = unitName(model, { escape: false });
  for (const selCmpt of vals(model.component.selection ?? {})) {
    const store = { name: selCmpt.name + STORE };
    if (selCmpt.project.hasSelectionId) {
      store.transform = [{ type: "collect", sort: { field: SELECTION_ID } }];
    }
    if (selCmpt.init) {
      const fields = selCmpt.project.items.map(assembleProjection);
      store.values = selCmpt.project.hasSelectionId ? selCmpt.init.map((i) => ({ unit: unit2, [SELECTION_ID]: assembleInit(i, false)[0] })) : selCmpt.init.map((i) => ({ unit: unit2, fields, values: assembleInit(i, false) }));
    }
    const contains3 = [...selectionData, ...data3].filter((d) => d.name === selCmpt.name + STORE);
    if (!contains3.length) {
      selectionData.push(store);
    }
    if (isTimerSelection(selCmpt) && data3.length) {
      const sourceName = model.lookupDataSource(model.getDataName(DataSourceType.Main));
      const sourceData = data3.find((d) => d.name === sourceName);
      const sourceDataFilter = sourceData.transform.find((t) => t.type === "filter" && t.expr.includes("vlSelectionTest"));
      if (sourceDataFilter) {
        sourceData.transform = sourceData.transform.filter((t) => t !== sourceDataFilter);
        const currentFrame = {
          name: sourceData.name + CURR,
          source: sourceData.name,
          transform: [sourceDataFilter]
          // add the selection filter to the animation dataset
        };
        animationData.push(currentFrame);
      }
    }
  }
  return selectionData.concat(data3, animationData);
}
function assembleUnitSelectionMarks(model, marks) {
  for (const selCmpt of vals(model.component.selection ?? {})) {
    for (const c5 of selectionCompilers) {
      if (c5.defined(selCmpt) && c5.marks) {
        marks = c5.marks(model, selCmpt, marks);
      }
    }
  }
  return marks;
}
function assembleLayerSelectionMarks(model, marks) {
  for (const child of model.children) {
    if (isUnitModel(child)) {
      marks = assembleUnitSelectionMarks(child, marks);
    }
  }
  return marks;
}
function assembleSelectionScaleDomain(model, extent8, scaleCmpt, domain3) {
  const parsedExtent = parseSelectionExtent(model, extent8.param, extent8);
  return {
    signal: hasContinuousDomain(scaleCmpt.get("type")) && isArray22(domain3) && domain3[0] > domain3[1] ? `isValid(${parsedExtent}) && reverse(${parsedExtent})` : parsedExtent
  };
}
function cleanupEmptyOnArray(signals) {
  return signals.map((s2) => {
    if (s2.on && !s2.on.length)
      delete s2.on;
    return s2;
  });
}
var scaleBindings = {
  defined: (selCmpt) => {
    return selCmpt.type === "interval" && selCmpt.resolve === "global" && selCmpt.bind && selCmpt.bind === "scales";
  },
  parse: (model, selCmpt) => {
    const bound6 = selCmpt.scales = [];
    for (const proj of selCmpt.project.items) {
      const channel = proj.channel;
      if (!isScaleChannel(channel)) {
        continue;
      }
      const scale19 = model.getScaleComponent(channel);
      const scaleType2 = scale19 ? scale19.get("type") : void 0;
      if (scaleType2 == "sequential") {
        warn2(SEQUENTIAL_SCALE_DEPRECATED);
      }
      if (!scale19 || !hasContinuousDomain(scaleType2)) {
        warn2(SCALE_BINDINGS_CONTINUOUS);
        continue;
      }
      scale19.set("selectionExtent", { param: selCmpt.name, field: proj.field }, true);
      bound6.push(proj);
    }
  },
  topLevelSignals: (model, selCmpt, signals) => {
    const bound6 = selCmpt.scales.filter((proj) => signals.filter((s2) => s2.name === proj.signals.data).length === 0);
    if (!model.parent || isTopLevelLayer(model) || bound6.length === 0) {
      return signals;
    }
    const namedSg = signals.find((s2) => s2.name === selCmpt.name);
    let update3 = namedSg.update;
    if (update3.includes(VL_SELECTION_RESOLVE)) {
      namedSg.update = `{${bound6.map((proj) => `${$10(replacePathInField(proj.field))}: ${proj.signals.data}`).join(", ")}}`;
    } else {
      for (const proj of bound6) {
        const mapping = `${$10(replacePathInField(proj.field))}: ${proj.signals.data}`;
        if (!update3.includes(mapping)) {
          update3 = `${update3.substring(0, update3.length - 1)}, ${mapping}}`;
        }
      }
      namedSg.update = update3;
    }
    return signals.concat(bound6.map((proj) => ({ name: proj.signals.data })));
  },
  signals: (model, selCmpt, signals) => {
    if (model.parent && !isTopLevelLayer(model)) {
      for (const proj of selCmpt.scales) {
        const signal = signals.find((s2) => s2.name === proj.signals.data);
        signal.push = "outer";
        delete signal.value;
        delete signal.update;
      }
    }
    return signals;
  }
};
function domain2(model, channel) {
  const scale19 = $10(model.scaleName(channel));
  return `domain(${scale19})`;
}
function isTopLevelLayer(model) {
  return model.parent && isLayerModel(model.parent) && (!model.parent.parent || isTopLevelLayer(model.parent.parent));
}
var BRUSH = "_brush";
var SCALE_TRIGGER = "_scale_trigger";
var GEO_INIT_TICK = "geo_interval_init_tick";
var INIT = "_init";
var CENTER2 = "_center";
var interval2 = {
  defined: (selCmpt) => selCmpt.type === "interval",
  parse: (model, selCmpt, selDef) => {
    var _a2;
    if (model.hasProjection) {
      const def6 = { ...isObject(selDef.select) ? selDef.select : {} };
      def6.fields = [SELECTION_ID];
      if (!def6.encodings) {
        def6.encodings = selDef.value ? keys4(selDef.value) : [LONGITUDE, LATITUDE];
      }
      selDef.select = { type: "interval", ...def6 };
    }
    if (selCmpt.translate && !scaleBindings.defined(selCmpt)) {
      const filterExpr = `!event.item || event.item.mark.name !== ${$10(selCmpt.name + BRUSH)}`;
      for (const evt of selCmpt.events) {
        if (!evt.between) {
          warn2(`${evt} is not an ordered event stream for interval selections.`);
          continue;
        }
        const filters7 = array21((_a2 = evt.between[0]).filter ?? (_a2.filter = []));
        if (!filters7.includes(filterExpr)) {
          filters7.push(filterExpr);
        }
      }
    }
  },
  signals: (model, selCmpt, signals) => {
    const name = selCmpt.name;
    const tupleSg = name + TUPLE;
    const channels = vals(selCmpt.project.hasChannel).filter((p) => p.channel === X3 || p.channel === Y3);
    const init2 = selCmpt.init ? selCmpt.init[0] : null;
    signals.push(...channels.reduce((arr, proj) => arr.concat(channelSignals(model, selCmpt, proj, init2 == null ? void 0 : init2[proj.index])), []));
    if (!model.hasProjection) {
      if (!scaleBindings.defined(selCmpt)) {
        const triggerSg = name + SCALE_TRIGGER;
        const scaleTriggers = channels.map((proj) => {
          const channel = proj.channel;
          const { data: dname, visual: vname } = proj.signals;
          const scaleName = $10(model.scaleName(channel));
          const scaleType2 = model.getScaleComponent(channel).get("type");
          const toNum = hasContinuousDomain(scaleType2) ? "+" : "";
          return `(!isArray(${dname}) || (${toNum}invert(${scaleName}, ${vname})[0] === ${toNum}${dname}[0] && ${toNum}invert(${scaleName}, ${vname})[1] === ${toNum}${dname}[1]))`;
        });
        if (scaleTriggers.length) {
          signals.push({
            name: triggerSg,
            value: {},
            on: [
              {
                events: channels.map((proj) => ({ scale: model.scaleName(proj.channel) })),
                update: `${scaleTriggers.join(" && ")} ? ${triggerSg} : {}`
              }
            ]
          });
        }
      }
      const dataSignals = channels.map((proj) => proj.signals.data);
      const update3 = `unit: ${unitName(model)}, fields: ${name + TUPLE_FIELDS}, values`;
      return signals.concat({
        name: tupleSg,
        ...init2 ? { init: `{${update3}: ${assembleInit(init2)}}` } : {},
        ...dataSignals.length ? {
          on: [
            {
              events: [{ signal: dataSignals.join(" || ") }],
              // Prevents double invocation, see https://github.com/vega/vega/issues/1672.
              update: `${dataSignals.join(" && ")} ? {${update3}: [${dataSignals}]} : null`
            }
          ]
        } : {}
      });
    } else {
      const projection3 = $10(model.projectionName());
      const centerSg = model.projectionName() + CENTER2;
      const { x: x9, y: y9 } = selCmpt.project.hasChannel;
      const xvname = x9 == null ? void 0 : x9.signals.visual;
      const yvname = y9 == null ? void 0 : y9.signals.visual;
      const xinit = x9 ? init2 == null ? void 0 : init2[x9.index] : `${centerSg}[0]`;
      const yinit = y9 ? init2 == null ? void 0 : init2[y9.index] : `${centerSg}[1]`;
      const sizeSg = (layout) => model.getSizeSignalRef(layout).signal;
      const bbox = `[[${xvname ? `${xvname}[0]` : "0"}, ${yvname ? `${yvname}[0]` : "0"}],[${xvname ? `${xvname}[1]` : sizeSg("width")}, ${yvname ? `${yvname}[1]` : sizeSg("height")}]]`;
      if (init2) {
        signals.unshift({
          name: name + INIT,
          init: `[scale(${projection3}, [${x9 ? xinit[0] : xinit}, ${y9 ? yinit[0] : yinit}]), scale(${projection3}, [${x9 ? xinit[1] : xinit}, ${y9 ? yinit[1] : yinit}])]`
        });
        if (!x9 || !y9) {
          const hasCenterSg = signals.find((s2) => s2.name === centerSg);
          if (!hasCenterSg) {
            signals.unshift({
              name: centerSg,
              update: `invert(${projection3}, [${sizeSg("width")}/2, ${sizeSg("height")}/2])`
            });
          }
        }
      }
      const intersect6 = `intersect(${bbox}, {markname: ${$10(model.getName("marks"))}}, unit.mark)`;
      const base = `{unit: ${unitName(model)}}`;
      const update3 = `vlSelectionTuples(${intersect6}, ${base})`;
      const visualSignals = channels.map((proj) => proj.signals.visual);
      return signals.concat({
        name: tupleSg,
        on: [
          {
            events: [
              ...visualSignals.length ? [{ signal: visualSignals.join(" || ") }] : [],
              ...init2 ? [{ signal: GEO_INIT_TICK }] : []
            ],
            update: update3
          }
        ]
      });
    }
  },
  topLevelSignals: (model, selCmpt, signals) => {
    if (isUnitModel(model) && model.hasProjection && selCmpt.init) {
      const hasTick = signals.filter((s2) => s2.name === GEO_INIT_TICK);
      if (!hasTick.length) {
        signals.unshift({
          name: GEO_INIT_TICK,
          value: null,
          on: [
            {
              events: "timer{1}",
              update: `${GEO_INIT_TICK} === null ? {} : ${GEO_INIT_TICK}`
            }
          ]
        });
      }
    }
    return signals;
  },
  marks: (model, selCmpt, marks) => {
    const name = selCmpt.name;
    const { x: x9, y: y9 } = selCmpt.project.hasChannel;
    const xvname = x9 == null ? void 0 : x9.signals.visual;
    const yvname = y9 == null ? void 0 : y9.signals.visual;
    const store = `data(${$10(selCmpt.name + STORE)})`;
    if (scaleBindings.defined(selCmpt) || !x9 && !y9) {
      return marks;
    }
    const update3 = {
      x: x9 !== void 0 ? { signal: `${xvname}[0]` } : { value: 0 },
      y: y9 !== void 0 ? { signal: `${yvname}[0]` } : { value: 0 },
      x2: x9 !== void 0 ? { signal: `${xvname}[1]` } : { field: { group: "width" } },
      y2: y9 !== void 0 ? { signal: `${yvname}[1]` } : { field: { group: "height" } }
    };
    if (selCmpt.resolve === "global") {
      for (const key4 of keys4(update3)) {
        update3[key4] = [
          {
            test: `${store}.length && ${store}[0].unit === ${unitName(model)}`,
            ...update3[key4]
          },
          { value: 0 }
        ];
      }
    }
    const { fill: fill6, fillOpacity, cursor: cursor3, ...stroke6 } = selCmpt.mark;
    const vgStroke = keys4(stroke6).reduce((def6, k3) => {
      def6[k3] = [
        {
          test: [
            x9 !== void 0 && `${xvname}[0] !== ${xvname}[1]`,
            y9 !== void 0 && `${yvname}[0] !== ${yvname}[1]`
          ].filter((t) => t).join(" && "),
          value: stroke6[k3]
        },
        { value: null }
      ];
      return def6;
    }, {});
    const vgCursor = cursor3 ?? (selCmpt.translate ? "move" : null);
    return [
      {
        name: `${name + BRUSH}_bg`,
        type: "rect",
        clip: true,
        encode: {
          enter: {
            fill: { value: fill6 },
            fillOpacity: { value: fillOpacity }
          },
          update: update3
        }
      },
      ...marks,
      {
        name: name + BRUSH,
        type: "rect",
        clip: true,
        encode: {
          enter: {
            ...vgCursor ? { cursor: { value: vgCursor } } : {},
            fill: { value: "transparent" }
          },
          update: { ...update3, ...vgStroke }
        }
      }
    ];
  }
};
function channelSignals(model, selCmpt, proj, init2) {
  const scaledInterval = !model.hasProjection;
  const channel = proj.channel;
  const vname = proj.signals.visual;
  const scaleName = $10(scaledInterval ? model.scaleName(channel) : model.projectionName());
  const scaled = (str) => `scale(${scaleName}, ${str})`;
  const size = model.getSizeSignalRef(channel === X3 ? "width" : "height").signal;
  const coord = `${channel}(unit)`;
  const von = selCmpt.events.reduce((def6, evt) => {
    return [
      ...def6,
      { events: evt.between[0], update: `[${coord}, ${coord}]` },
      // Brush Start
      { events: evt, update: `[${vname}[0], clamp(${coord}, 0, ${size})]` }
      // Brush End
    ];
  }, []);
  if (scaledInterval) {
    const dname = proj.signals.data;
    const hasScales = scaleBindings.defined(selCmpt);
    const scale19 = model.getScaleComponent(channel);
    const scaleType2 = scale19 ? scale19.get("type") : void 0;
    const vinit = init2 ? { init: assembleInit(init2, true, scaled) } : { value: [] };
    von.push({
      events: { signal: selCmpt.name + SCALE_TRIGGER },
      update: hasContinuousDomain(scaleType2) ? `[${scaled(`${dname}[0]`)}, ${scaled(`${dname}[1]`)}]` : `[0, 0]`
    });
    return hasScales ? [{ name: dname, on: [] }] : [
      { name: vname, ...vinit, on: von },
      {
        name: dname,
        ...init2 ? { init: assembleInit(init2) } : {},
        // Cannot be `value` as `init` may require datetime exprs.
        on: [
          {
            events: { signal: vname },
            update: `${vname}[0] === ${vname}[1] ? null : invert(${scaleName}, ${vname})`
          }
        ]
      }
    ];
  } else {
    const initIdx = channel === X3 ? 0 : 1;
    const initSg = selCmpt.name + INIT;
    const vinit = init2 ? { init: `[${initSg}[0][${initIdx}], ${initSg}[1][${initIdx}]]` } : { value: [] };
    return [{ name: vname, ...vinit, on: von }];
  }
}
function wrapCondition({ model, channelDef, vgChannel, invalidValueRef, mainRefFn }) {
  const condition = isConditionalDef(channelDef) && channelDef.condition;
  let valueRefs = [];
  if (condition) {
    const conditions = array21(condition);
    valueRefs = conditions.map((c5) => {
      const conditionValueRef = mainRefFn(c5);
      if (isConditionalParameter(c5)) {
        const { param: param2, empty } = c5;
        const test2 = parseSelectionPredicate(model, { param: param2, empty });
        return { test: test2, ...conditionValueRef };
      } else {
        const test2 = expression3(model, c5.test);
        return { test: test2, ...conditionValueRef };
      }
    });
  }
  if (invalidValueRef !== void 0) {
    valueRefs.push(invalidValueRef);
  }
  const mainValueRef = mainRefFn(channelDef);
  if (mainValueRef !== void 0) {
    valueRefs.push(mainValueRef);
  }
  if (valueRefs.length > 1 || valueRefs.length === 1 && Boolean(valueRefs[0].test)) {
    return { [vgChannel]: valueRefs };
  } else if (valueRefs.length === 1) {
    return { [vgChannel]: valueRefs[0] };
  }
  return {};
}
function text$1(model, channel = "text") {
  const channelDef = model.encoding[channel];
  return wrapCondition({
    model,
    channelDef,
    vgChannel: channel,
    mainRefFn: (cDef) => textRef(cDef, model.config),
    invalidValueRef: void 0
    // text encoding doesn't have continuous scales and thus can't have invalid values
  });
}
function textRef(channelDef, config, expr2 = "datum") {
  if (channelDef) {
    if (isValueDef(channelDef)) {
      return signalOrValueRef(channelDef.value);
    }
    if (isFieldOrDatumDef(channelDef)) {
      const { format: format14, formatType } = getFormatMixins(channelDef);
      return formatSignalRef({ fieldOrDatumDef: channelDef, format: format14, formatType, expr: expr2, config });
    }
  }
  return void 0;
}
function tooltip(model, opt = {}) {
  const { encoding, markDef, config, stack: stack2 } = model;
  const channelDef = encoding.tooltip;
  if (isArray22(channelDef)) {
    return { tooltip: tooltipRefForEncoding({ tooltip: channelDef }, stack2, config, opt) };
  } else {
    const datum2 = opt.reactiveGeom ? "datum.datum" : "datum";
    const mainRefFn = (cDef) => {
      const tooltipRefFromChannelDef = addLineBreaksToTooltip(cDef, config, datum2);
      if (tooltipRefFromChannelDef) {
        return tooltipRefFromChannelDef;
      }
      if (cDef === null) {
        return void 0;
      }
      let markTooltip = getMarkPropOrConfig("tooltip", markDef, config);
      if (markTooltip === true) {
        markTooltip = { content: "encoding" };
      }
      if (isString14(markTooltip)) {
        return { value: markTooltip };
      } else if (isObject12(markTooltip)) {
        if (isSignalRef(markTooltip)) {
          return markTooltip;
        } else if (markTooltip.content === "encoding") {
          return tooltipRefForEncoding(encoding, stack2, config, opt);
        } else {
          return { signal: datum2 };
        }
      }
      return void 0;
    };
    return wrapCondition({
      model,
      channelDef,
      vgChannel: "tooltip",
      mainRefFn,
      invalidValueRef: void 0
      // tooltip encoding doesn't have continuous scales and thus can't have invalid values
    });
  }
}
function tooltipData(encoding, stack2, config, { reactiveGeom } = {}) {
  const formatConfig = { ...config, ...config.tooltipFormat };
  const toSkip = /* @__PURE__ */ new Set();
  const expr2 = reactiveGeom ? "datum.datum" : "datum";
  const tuples = [];
  function add10(fDef, channel) {
    const mainChannel = getMainRangeChannel(channel);
    const fieldDef = isTypedFieldDef(fDef) ? fDef : {
      ...fDef,
      type: encoding[mainChannel].type
      // for secondary field def, copy type from main channel
    };
    const title2 = fieldDef.title || defaultTitle(fieldDef, formatConfig);
    const key4 = array21(title2).join(", ").replaceAll(/"/g, '\\"');
    let value7;
    if (isXorY(channel)) {
      const channel2 = channel === "x" ? "x2" : "y2";
      const fieldDef2 = getFieldDef(encoding[channel2]);
      if (isBinned(fieldDef.bin) && fieldDef2) {
        const startField = vgField(fieldDef, { expr: expr2 });
        const endField = vgField(fieldDef2, { expr: expr2 });
        const { format: format14, formatType } = getFormatMixins(fieldDef);
        value7 = binFormatExpression(startField, endField, format14, formatType, formatConfig);
        toSkip.add(channel2);
      }
    }
    if ((isXorY(channel) || channel === THETA || channel === RADIUS) && stack2 && stack2.fieldChannel === channel && stack2.offset === "normalize") {
      const { format: format14, formatType } = getFormatMixins(fieldDef);
      value7 = formatSignalRef({
        fieldOrDatumDef: fieldDef,
        format: format14,
        formatType,
        expr: expr2,
        config: formatConfig,
        normalizeStack: true
      }).signal;
    }
    value7 ?? (value7 = addLineBreaksToTooltip(fieldDef, formatConfig, expr2).signal);
    tuples.push({ channel, key: key4, value: value7 });
  }
  forEach(encoding, (channelDef, channel) => {
    if (isFieldDef(channelDef)) {
      add10(channelDef, channel);
    } else if (hasConditionalFieldDef(channelDef)) {
      add10(channelDef.condition, channel);
    }
  });
  const out = {};
  for (const { channel, key: key4, value: value7 } of tuples) {
    if (!toSkip.has(channel) && !out[key4]) {
      out[key4] = value7;
    }
  }
  return out;
}
function tooltipRefForEncoding(encoding, stack2, config, { reactiveGeom } = {}) {
  const data3 = tooltipData(encoding, stack2, config, { reactiveGeom });
  const keyValues = entries$1(data3).map(([key4, value7]) => `"${key4}": ${value7}`);
  return keyValues.length > 0 ? { signal: `{${keyValues.join(", ")}}` } : void 0;
}
function addLineBreaksToTooltip(channelDef, config, expr2 = "datum") {
  if (isFieldDef(channelDef) && isDiscrete$1(channelDef.type) && !hasProperty(channelDef, "format")) {
    const fieldString = `datum["${channelDef.field}"]`;
    return {
      signal: `isValid(${fieldString}) ? isArray(${fieldString}) ? join(${fieldString}, '\\n') : ${fieldString} : ""+${fieldString}`
    };
  }
  return textRef(channelDef, config, expr2);
}
function aria(model) {
  const { markDef, config } = model;
  const enableAria = getMarkPropOrConfig("aria", markDef, config);
  if (enableAria === false) {
    return {};
  }
  return {
    ...enableAria ? { aria: enableAria } : {},
    ...ariaRoleDescription(model),
    ...description(model)
  };
}
function ariaRoleDescription(model) {
  const { mark, markDef, config } = model;
  if (config.aria === false) {
    return {};
  }
  const ariaRoleDesc = getMarkPropOrConfig("ariaRoleDescription", markDef, config);
  if (ariaRoleDesc != null) {
    return { ariaRoleDescription: { value: ariaRoleDesc } };
  }
  return has19(VG_MARK_INDEX, mark) ? {} : { ariaRoleDescription: { value: mark } };
}
function description(model) {
  const { encoding, markDef, config, stack: stack2 } = model;
  const channelDef = encoding.description;
  if (channelDef) {
    return wrapCondition({
      model,
      channelDef,
      vgChannel: "description",
      mainRefFn: (cDef) => textRef(cDef, model.config),
      invalidValueRef: void 0
      // aria encoding doesn't have continuous scales and thus can't have invalid values
    });
  }
  const descriptionValue = getMarkPropOrConfig("description", markDef, config);
  if (descriptionValue != null) {
    return {
      description: signalOrValueRef(descriptionValue)
    };
  }
  if (config.aria === false) {
    return {};
  }
  const data3 = tooltipData(encoding, stack2, config);
  if (isEmpty(data3)) {
    return void 0;
  }
  return {
    description: {
      signal: entries$1(data3).filter(([key4]) => !key4.startsWith("_")).map(([key4, value7]) => [key4, value7.replaceAll("\\n", " ")]).map(([key4, value7], index4) => `"${index4 > 0 ? "; " : ""}${key4}: " + (${value7})`).join(" + ")
    }
  };
}
function nonPosition(channel, model, opt = {}) {
  const { markDef, encoding, config } = model;
  const { vgChannel } = opt;
  let { defaultRef, defaultValue } = opt;
  const channelDef = encoding[channel];
  if (defaultRef === void 0) {
    defaultValue ?? (defaultValue = getMarkPropOrConfig(channel, markDef, config, {
      vgChannel,
      // If there is no conditonal def, we ignore vgConfig so the output spec is concise.
      // However, if there is a conditional def, we must include vgConfig so the default is respected.
      ignoreVgConfig: !isConditionalDef(channelDef)
    }));
    if (defaultValue !== void 0) {
      defaultRef = signalOrValueRef(defaultValue);
    }
  }
  const commonProps = {
    markDef,
    config,
    scaleName: model.scaleName(channel),
    scale: model.getScaleComponent(channel)
  };
  const invalidValueRef = getConditionalValueRefForIncludingInvalidValue({
    ...commonProps,
    scaleChannel: channel,
    channelDef
  });
  const mainRefFn = (cDef) => {
    return midPoint({
      ...commonProps,
      channel,
      channelDef: cDef,
      stack: null,
      // No need to provide stack for non-position as it does not affect mid point
      defaultRef
    });
  };
  return wrapCondition({
    model,
    channelDef,
    vgChannel: vgChannel ?? channel,
    invalidValueRef,
    mainRefFn
  });
}
function color8(model, opt = { filled: void 0 }) {
  const { markDef, encoding, config } = model;
  const { type: markType2 } = markDef;
  const filled = opt.filled ?? getMarkPropOrConfig("filled", markDef, config);
  const transparentIfNeeded = contains2(["bar", "point", "circle", "square", "geoshape"], markType2) ? "transparent" : void 0;
  const defaultFill = getMarkPropOrConfig(filled === true ? "color" : void 0, markDef, config, { vgChannel: "fill" }) ?? // need to add this manually as getMarkConfig normally drops config.mark[channel] if vgChannel is specified
  config.mark[filled === true && "color"] ?? // If there is no fill, always fill symbols, bar, geoshape
  // with transparent fills https://github.com/vega/vega-lite/issues/1316
  transparentIfNeeded;
  const defaultStroke = getMarkPropOrConfig(filled === false ? "color" : void 0, markDef, config, { vgChannel: "stroke" }) ?? // need to add this manually as getMarkConfig normally drops config.mark[channel] if vgChannel is specified
  config.mark[filled === false && "color"];
  const colorVgChannel = filled ? "fill" : "stroke";
  const fillStrokeMarkDefAndConfig = {
    ...defaultFill ? { fill: signalOrValueRef(defaultFill) } : {},
    ...defaultStroke ? { stroke: signalOrValueRef(defaultStroke) } : {}
  };
  if (markDef.color && (filled ? markDef.fill : markDef.stroke)) {
    warn2(droppingColor("property", { fill: "fill" in markDef, stroke: "stroke" in markDef }));
  }
  return {
    ...fillStrokeMarkDefAndConfig,
    ...nonPosition("color", model, {
      vgChannel: colorVgChannel,
      defaultValue: filled ? defaultFill : defaultStroke
    }),
    ...nonPosition("fill", model, {
      // if there is encoding.fill, include default fill just in case we have conditional-only fill encoding
      defaultValue: encoding.fill ? defaultFill : void 0
    }),
    ...nonPosition("stroke", model, {
      // if there is encoding.stroke, include default fill just in case we have conditional-only stroke encoding
      defaultValue: encoding.stroke ? defaultStroke : void 0
    })
  };
}
function zindex(model) {
  const { encoding, mark } = model;
  const order = encoding.order;
  if (!isPathMark(mark) && isValueDef(order)) {
    return wrapCondition({
      model,
      channelDef: order,
      vgChannel: "zindex",
      mainRefFn: (cd2) => signalOrValueRef(cd2.value),
      invalidValueRef: void 0
      // zindex encoding doesn't have continuous scales and thus can't have invalid values
    });
  }
  return {};
}
function positionOffset({ channel: baseChannel, markDef, encoding = {}, model, bandPosition }) {
  const channel = `${baseChannel}Offset`;
  const defaultValue = markDef[channel];
  const channelDef = encoding[channel];
  if ((channel === "xOffset" || channel === "yOffset") && channelDef) {
    const ref2 = midPoint({
      channel,
      channelDef,
      markDef,
      config: model == null ? void 0 : model.config,
      scaleName: model.scaleName(channel),
      scale: model.getScaleComponent(channel),
      stack: null,
      defaultRef: signalOrValueRef(defaultValue),
      bandPosition
    });
    return { offsetType: "encoding", offset: ref2 };
  }
  const markDefOffsetValue = markDef[channel];
  if (markDefOffsetValue) {
    return { offsetType: "visual", offset: markDefOffsetValue };
  }
  return {};
}
function pointPosition(channel, model, { defaultPos, vgChannel }) {
  const { encoding, markDef, config, stack: stack2 } = model;
  const channelDef = encoding[channel];
  const channel2Def = encoding[getSecondaryRangeChannel(channel)];
  const scaleName = model.scaleName(channel);
  const scale19 = model.getScaleComponent(channel);
  const { offset: offset9, offsetType } = positionOffset({
    channel,
    markDef,
    encoding,
    model,
    bandPosition: 0.5
  });
  const defaultRef = pointPositionDefaultRef({
    model,
    defaultPos,
    channel,
    scaleName,
    scale: scale19
  });
  const valueRef = !channelDef && isXorY(channel) && (encoding.latitude || encoding.longitude) ? (
    // use geopoint output if there are lat/long and there is no point position overriding lat/long.
    { field: model.getName(channel) }
  ) : positionRef({
    channel,
    channelDef,
    channel2Def,
    markDef,
    config,
    scaleName,
    scale: scale19,
    stack: stack2,
    offset: offset9,
    defaultRef,
    bandPosition: offsetType === "encoding" ? 0 : void 0
  });
  return valueRef ? { [vgChannel || channel]: valueRef } : void 0;
}
function positionRef(params2) {
  const { channel, channelDef, scaleName, stack: stack2, offset: offset9, markDef } = params2;
  if (isFieldOrDatumDef(channelDef) && stack2 && channel === stack2.fieldChannel) {
    if (isFieldDef(channelDef)) {
      let bandPosition = channelDef.bandPosition;
      if (bandPosition === void 0 && markDef.type === "text" && (channel === "radius" || channel === "theta")) {
        bandPosition = 0.5;
      }
      if (bandPosition !== void 0) {
        return interpolatedSignalRef({
          scaleName,
          fieldOrDatumDef: channelDef,
          // positionRef always have type
          startSuffix: "start",
          bandPosition,
          offset: offset9
        });
      }
    }
    return valueRefForFieldOrDatumDef(channelDef, scaleName, { suffix: "end" }, { offset: offset9 });
  }
  return midPointRefWithPositionInvalidTest(params2);
}
function pointPositionDefaultRef({ model, defaultPos, channel, scaleName, scale: scale19 }) {
  const { markDef, config } = model;
  return () => {
    const mainChannel = getMainRangeChannel(channel);
    const vgChannel = getVgPositionChannel(channel);
    const definedValueOrConfig = getMarkPropOrConfig(channel, markDef, config, { vgChannel });
    if (definedValueOrConfig !== void 0) {
      return widthHeightValueOrSignalRef(channel, definedValueOrConfig);
    }
    switch (defaultPos) {
      case "zeroOrMin":
        return zeroOrMinOrMaxPosition({ scaleName, scale: scale19, mode: "zeroOrMin", mainChannel, config });
      case "zeroOrMax":
        return zeroOrMinOrMaxPosition({
          scaleName,
          scale: scale19,
          mode: { zeroOrMax: { widthSignal: model.width.signal, heightSignal: model.height.signal } },
          mainChannel,
          config
        });
      case "mid": {
        const sizeRef = model[getSizeChannel(channel)];
        return { ...sizeRef, mult: 0.5 };
      }
    }
    return void 0;
  };
}
function zeroOrMinOrMaxPosition({ mainChannel, config, ...otherProps }) {
  const scaledValueRef = scaledZeroOrMinOrMax(otherProps);
  const { mode: mode2 } = otherProps;
  if (scaledValueRef) {
    return scaledValueRef;
  }
  switch (mainChannel) {
    case "radius": {
      if (mode2 === "zeroOrMin") {
        return { value: 0 };
      }
      const { widthSignal, heightSignal } = mode2.zeroOrMax;
      return {
        signal: `min(${widthSignal},${heightSignal})/2`
      };
    }
    case "theta":
      return mode2 === "zeroOrMin" ? { value: 0 } : { signal: "2*PI" };
    case "x":
      return mode2 === "zeroOrMin" ? { value: 0 } : { field: { group: "width" } };
    case "y":
      return mode2 === "zeroOrMin" ? { field: { group: "height" } } : { value: 0 };
  }
}
var ALIGNED_X_CHANNEL = {
  left: "x",
  center: "xc",
  right: "x2"
};
var BASELINED_Y_CHANNEL = {
  top: "y",
  middle: "yc",
  bottom: "y2"
};
function vgAlignedPositionChannel(channel, markDef, config, defaultAlign = "middle") {
  if (channel === "radius" || channel === "theta") {
    return getVgPositionChannel(channel);
  }
  const alignChannel = channel === "x" ? "align" : "baseline";
  const align2 = getMarkPropOrConfig(alignChannel, markDef, config);
  let alignExcludingSignal;
  if (isSignalRef(align2)) {
    warn2(rangeMarkAlignmentCannotBeExpression(alignChannel));
    alignExcludingSignal = void 0;
  } else {
    alignExcludingSignal = align2;
  }
  if (channel === "x") {
    return ALIGNED_X_CHANNEL[alignExcludingSignal || (defaultAlign === "top" ? "left" : "center")];
  } else {
    return BASELINED_Y_CHANNEL[alignExcludingSignal || defaultAlign];
  }
}
function pointOrRangePosition(channel, model, { defaultPos, defaultPos2, range: range7 }) {
  if (range7) {
    return rangePosition(channel, model, { defaultPos, defaultPos2 });
  }
  return pointPosition(channel, model, { defaultPos });
}
function rangePosition(channel, model, { defaultPos, defaultPos2 }) {
  const { markDef, config } = model;
  const channel2 = getSecondaryRangeChannel(channel);
  const sizeChannel = getSizeChannel(channel);
  const pos2Mixins = pointPosition2OrSize(model, defaultPos2, channel2);
  const vgChannel = pos2Mixins[sizeChannel] ? (
    // If there is width/height, we need to position the marks based on the alignment.
    vgAlignedPositionChannel(channel, markDef, config)
  ) : (
    // Otherwise, make sure to apply to the right Vg Channel (for arc mark)
    getVgPositionChannel(channel)
  );
  return {
    ...pointPosition(channel, model, { defaultPos, vgChannel }),
    ...pos2Mixins
  };
}
function pointPosition2OrSize(model, defaultPos, channel) {
  const { encoding, mark, markDef, stack: stack2, config } = model;
  const baseChannel = getMainRangeChannel(channel);
  const sizeChannel = getSizeChannel(channel);
  const vgChannel = getVgPositionChannel(channel);
  const channelDef = encoding[baseChannel];
  const scaleName = model.scaleName(baseChannel);
  const scale19 = model.getScaleComponent(baseChannel);
  const { offset: offset9 } = channel in encoding || channel in markDef ? positionOffset({ channel, markDef, encoding, model }) : positionOffset({ channel: baseChannel, markDef, encoding, model });
  if (!channelDef && (channel === "x2" || channel === "y2") && (encoding.latitude || encoding.longitude)) {
    const vgSizeChannel = getSizeChannel(channel);
    const size = model.markDef[vgSizeChannel];
    if (size != null) {
      return {
        [vgSizeChannel]: { value: size }
      };
    } else {
      return {
        [vgChannel]: { field: model.getName(channel) }
      };
    }
  }
  const valueRef = position2Ref({
    channel,
    channelDef,
    channel2Def: encoding[channel],
    markDef,
    config,
    scaleName,
    scale: scale19,
    stack: stack2,
    offset: offset9,
    defaultRef: void 0
  });
  if (valueRef !== void 0) {
    return { [vgChannel]: valueRef };
  }
  return position2orSize(channel, markDef) || position2orSize(channel, {
    [channel]: getMarkStyleConfig(channel, markDef, config.style),
    [sizeChannel]: getMarkStyleConfig(sizeChannel, markDef, config.style)
  }) || position2orSize(channel, config[mark]) || position2orSize(channel, config.mark) || {
    [vgChannel]: pointPositionDefaultRef({
      model,
      defaultPos,
      channel,
      scaleName,
      scale: scale19
    })()
  };
}
function position2Ref({ channel, channelDef, channel2Def, markDef, config, scaleName, scale: scale19, stack: stack2, offset: offset9, defaultRef }) {
  if (isFieldOrDatumDef(channelDef) && stack2 && // If fieldChannel is X and channel is X2 (or Y and Y2)
  channel.charAt(0) === stack2.fieldChannel.charAt(0)) {
    return valueRefForFieldOrDatumDef(channelDef, scaleName, { suffix: "start" }, { offset: offset9 });
  }
  return midPointRefWithPositionInvalidTest({
    channel,
    channelDef: channel2Def,
    scaleName,
    scale: scale19,
    stack: stack2,
    markDef,
    config,
    offset: offset9,
    defaultRef
  });
}
function position2orSize(channel, markDef) {
  const sizeChannel = getSizeChannel(channel);
  const vgChannel = getVgPositionChannel(channel);
  if (markDef[vgChannel] !== void 0) {
    return { [vgChannel]: widthHeightValueOrSignalRef(channel, markDef[vgChannel]) };
  } else if (markDef[channel] !== void 0) {
    return { [vgChannel]: widthHeightValueOrSignalRef(channel, markDef[channel]) };
  } else if (markDef[sizeChannel]) {
    const dimensionSize = markDef[sizeChannel];
    if (isRelativeBandSize(dimensionSize)) {
      warn2(relativeBandSizeNotSupported(sizeChannel));
    } else {
      return { [sizeChannel]: widthHeightValueOrSignalRef(channel, dimensionSize) };
    }
  }
  return void 0;
}
function rectPosition(model, channel) {
  const { config, encoding, markDef } = model;
  const mark = markDef.type;
  const channel2 = getSecondaryRangeChannel(channel);
  const sizeChannel = getSizeChannel(channel);
  const channelDef = encoding[channel];
  const channelDef2 = encoding[channel2];
  const scale19 = model.getScaleComponent(channel);
  const scaleType2 = scale19 ? scale19.get("type") : void 0;
  const orient2 = markDef.orient;
  const hasSizeDef = encoding[sizeChannel] ?? encoding.size ?? getMarkPropOrConfig("size", markDef, config, { vgChannel: sizeChannel });
  const offsetScaleChannel = getOffsetChannel(channel);
  const isBarOrTickBand = mark === "bar" && (channel === "x" ? orient2 === "vertical" : orient2 === "horizontal") || mark === "tick" && (channel === "y" ? orient2 === "vertical" : orient2 === "horizontal");
  if (isFieldDef(channelDef) && (isBinning(channelDef.bin) || isBinned(channelDef.bin) || channelDef.timeUnit && !channelDef2) && !(hasSizeDef && !isRelativeBandSize(hasSizeDef)) && !encoding[offsetScaleChannel] && !hasDiscreteDomain(scaleType2)) {
    return rectBinPosition({
      fieldDef: channelDef,
      fieldDef2: channelDef2,
      channel,
      model
    });
  } else if ((isFieldOrDatumDef(channelDef) && hasDiscreteDomain(scaleType2) || isBarOrTickBand) && !channelDef2) {
    return positionAndSize(channelDef, channel, model);
  } else {
    return rangePosition(channel, model, { defaultPos: "zeroOrMax", defaultPos2: "zeroOrMin" });
  }
}
function defaultSizeRef(sizeChannel, scaleName, scale19, config, bandSize, hasFieldDef, mark) {
  if (isRelativeBandSize(bandSize)) {
    if (scale19) {
      const scaleType2 = scale19.get("type");
      if (scaleType2 === "band") {
        let bandWidth = `bandwidth('${scaleName}')`;
        if (bandSize.band !== 1) {
          bandWidth = `${bandSize.band} * ${bandWidth}`;
        }
        const minBandSize = getMarkConfig("minBandSize", { type: mark }, config);
        return { signal: minBandSize ? `max(${signalOrStringValue(minBandSize)}, ${bandWidth})` : bandWidth };
      } else if (bandSize.band !== 1) {
        warn2(cannotUseRelativeBandSizeWithNonBandScale(scaleType2));
        bandSize = void 0;
      }
    } else {
      return {
        mult: bandSize.band,
        field: { group: sizeChannel }
      };
    }
  } else if (isSignalRef(bandSize)) {
    return bandSize;
  } else if (bandSize) {
    return { value: bandSize };
  }
  if (scale19) {
    const scaleRange = scale19.get("range");
    if (isVgRangeStep(scaleRange) && isNumber14(scaleRange.step)) {
      return { value: scaleRange.step - 2 };
    }
  }
  if (!hasFieldDef) {
    const { bandPaddingInner, barBandPaddingInner, rectBandPaddingInner, tickBandPaddingInner } = config.scale;
    const padding3 = getFirstDefined(bandPaddingInner, mark === "tick" ? tickBandPaddingInner : mark === "bar" ? barBandPaddingInner : rectBandPaddingInner);
    if (isSignalRef(padding3)) {
      return { signal: `(1 - (${padding3.signal})) * ${sizeChannel}` };
    } else if (isNumber14(padding3)) {
      return { signal: `${1 - padding3} * ${sizeChannel}` };
    }
  }
  const defaultStep = getViewConfigDiscreteStep(config.view, sizeChannel);
  return { value: defaultStep - 2 };
}
function positionAndSize(fieldDef, channel, model) {
  var _a2, _b;
  const { markDef, encoding, config, stack: stack2 } = model;
  const orient2 = markDef.orient;
  const scaleName = model.scaleName(channel);
  const scale19 = model.getScaleComponent(channel);
  const vgSizeChannel = getSizeChannel(channel);
  const channel2 = getSecondaryRangeChannel(channel);
  const offsetScaleChannel = getOffsetChannel(channel);
  const offsetScaleName = model.scaleName(offsetScaleChannel);
  const offsetScale = model.getScaleComponent(getOffsetScaleChannel(channel));
  const useVlSizeChannel = (
    // Always uses size channel for ticks, because tick only calls rectPosition() for the size channel
    markDef.type === "tick" || // use "size" channel for bars, if there is orient and the channel matches the right orientation
    orient2 === "horizontal" && channel === "y" || orient2 === "vertical" && channel === "x"
  );
  let sizeMixins;
  if (encoding.size || markDef.size) {
    if (useVlSizeChannel) {
      sizeMixins = nonPosition("size", model, {
        vgChannel: vgSizeChannel,
        defaultRef: signalOrValueRef(markDef.size)
      });
    } else {
      warn2(cannotApplySizeToNonOrientedMark(markDef.type));
    }
  }
  const hasSizeFromMarkOrEncoding = !!sizeMixins;
  const bandSize = getBandSize({
    channel,
    fieldDef,
    markDef,
    config,
    scaleType: (_a2 = scale19 || offsetScale) == null ? void 0 : _a2.get("type"),
    useVlSizeChannel
  });
  sizeMixins = sizeMixins || {
    [vgSizeChannel]: defaultSizeRef(vgSizeChannel, offsetScaleName || scaleName, offsetScale || scale19, config, bandSize, !!fieldDef, markDef.type)
  };
  const defaultBandAlign = ((_b = scale19 || offsetScale) == null ? void 0 : _b.get("type")) === "band" && isRelativeBandSize(bandSize) && !hasSizeFromMarkOrEncoding ? "top" : "middle";
  const vgChannel = vgAlignedPositionChannel(channel, markDef, config, defaultBandAlign);
  const center = vgChannel === "xc" || vgChannel === "yc";
  const { offset: offset9, offsetType } = positionOffset({ channel, markDef, encoding, model, bandPosition: center ? 0.5 : 0 });
  const posRef = midPointRefWithPositionInvalidTest({
    channel,
    channelDef: fieldDef,
    markDef,
    config,
    scaleName,
    scale: scale19,
    stack: stack2,
    offset: offset9,
    defaultRef: pointPositionDefaultRef({ model, defaultPos: "mid", channel, scaleName, scale: scale19 }),
    bandPosition: center ? offsetType === "encoding" ? 0 : 0.5 : isSignalRef(bandSize) ? { signal: `(1-${bandSize})/2` } : isRelativeBandSize(bandSize) ? (1 - bandSize.band) / 2 : 0
  });
  if (vgSizeChannel) {
    return { [vgChannel]: posRef, ...sizeMixins };
  } else {
    const vgChannel2 = getVgPositionChannel(channel2);
    const sizeRef = sizeMixins[vgSizeChannel];
    const sizeOffset = offset9 ? { ...sizeRef, offset: offset9 } : sizeRef;
    return {
      [vgChannel]: posRef,
      // posRef might be an array that wraps position invalid test
      [vgChannel2]: isArray22(posRef) ? [posRef[0], { ...posRef[1], offset: sizeOffset }] : {
        ...posRef,
        offset: sizeOffset
      }
    };
  }
}
function getBinSpacing(channel, spacing, reverse4, axisTranslate, offset9, minBandSize, bandSizeExpr) {
  if (isPolarPositionChannel(channel)) {
    return 0;
  }
  const isEnd = channel === "x" || channel === "y2";
  const spacingOffset = isEnd ? -spacing / 2 : spacing / 2;
  if (isSignalRef(reverse4) || isSignalRef(offset9) || isSignalRef(axisTranslate) || minBandSize) {
    const reverseExpr = signalOrStringValue(reverse4);
    const offsetExpr2 = signalOrStringValue(offset9);
    const axisTranslateExpr = signalOrStringValue(axisTranslate);
    const minBandSizeExpr = signalOrStringValue(minBandSize);
    const sign4 = isEnd ? "" : "-";
    const spacingAndSizeOffset = minBandSize ? `(${bandSizeExpr} < ${minBandSizeExpr} ? ${sign4}0.5 * (${minBandSizeExpr} - (${bandSizeExpr})) : ${spacingOffset})` : spacingOffset;
    const t = axisTranslateExpr ? `${axisTranslateExpr} + ` : "";
    const r = reverseExpr ? `(${reverseExpr} ? -1 : 1) * ` : "";
    const o = offsetExpr2 ? `(${offsetExpr2} + ${spacingAndSizeOffset})` : spacingAndSizeOffset;
    return {
      signal: t + r + o
    };
  } else {
    offset9 = offset9 || 0;
    return axisTranslate + (reverse4 ? -offset9 - spacingOffset : +offset9 + spacingOffset);
  }
}
function rectBinPosition({ fieldDef, fieldDef2, channel, model }) {
  var _a2;
  const { config, markDef, encoding } = model;
  const scale19 = model.getScaleComponent(channel);
  const scaleName = model.scaleName(channel);
  const scaleType2 = scale19 ? scale19.get("type") : void 0;
  const reverse4 = scale19.get("reverse");
  const bandSize = getBandSize({ channel, fieldDef, markDef, config, scaleType: scaleType2 });
  const axis = (_a2 = model.component.axes[channel]) == null ? void 0 : _a2[0];
  const axisTranslate = (axis == null ? void 0 : axis.get("translate")) ?? 0.5;
  const spacing = isXorY(channel) ? getMarkPropOrConfig("binSpacing", markDef, config) ?? 0 : 0;
  const channel2 = getSecondaryRangeChannel(channel);
  const vgChannel = getVgPositionChannel(channel);
  const vgChannel2 = getVgPositionChannel(channel2);
  const minBandSize = getMarkConfig("minBandSize", markDef, config);
  const { offset: offset9 } = positionOffset({ channel, markDef, encoding, model, bandPosition: 0 });
  const { offset: offset22 } = positionOffset({ channel: channel2, markDef, encoding, model, bandPosition: 0 });
  const bandSizeExpr = binSizeExpr({ fieldDef, scaleName });
  const binSpacingOffset = getBinSpacing(channel, spacing, reverse4, axisTranslate, offset9, minBandSize, bandSizeExpr);
  const binSpacingOffset2 = getBinSpacing(channel2, spacing, reverse4, axisTranslate, offset22 ?? offset9, minBandSize, bandSizeExpr);
  const bandPositionForBandSize = isSignalRef(bandSize) ? { signal: `(1-${bandSize.signal})/2` } : isRelativeBandSize(bandSize) ? (1 - bandSize.band) / 2 : 0.5;
  const bandPosition = getBandPosition({ fieldDef, fieldDef2, markDef, config });
  if (isBinning(fieldDef.bin) || fieldDef.timeUnit) {
    const useRectOffsetField = fieldDef.timeUnit && bandPosition !== 0.5;
    return {
      [vgChannel2]: rectBinRef({
        fieldDef,
        scaleName,
        bandPosition: bandPositionForBandSize,
        offset: binSpacingOffset2,
        useRectOffsetField
      }),
      [vgChannel]: rectBinRef({
        fieldDef,
        scaleName,
        bandPosition: isSignalRef(bandPositionForBandSize) ? { signal: `1-${bandPositionForBandSize.signal}` } : 1 - bandPositionForBandSize,
        offset: binSpacingOffset,
        useRectOffsetField
      })
    };
  } else if (isBinned(fieldDef.bin)) {
    const startRef = valueRefForFieldOrDatumDef(fieldDef, scaleName, {}, { offset: binSpacingOffset2 });
    if (isFieldDef(fieldDef2)) {
      return {
        [vgChannel2]: startRef,
        [vgChannel]: valueRefForFieldOrDatumDef(fieldDef2, scaleName, {}, { offset: binSpacingOffset })
      };
    } else if (isBinParams(fieldDef.bin) && fieldDef.bin.step) {
      return {
        [vgChannel2]: startRef,
        [vgChannel]: {
          signal: `scale("${scaleName}", ${vgField(fieldDef, { expr: "datum" })} + ${fieldDef.bin.step})`,
          offset: binSpacingOffset
        }
      };
    }
  }
  warn2(channelRequiredForBinned(channel2));
  return void 0;
}
function rectBinRef({ fieldDef, scaleName, bandPosition, offset: offset9, useRectOffsetField }) {
  return interpolatedSignalRef({
    scaleName,
    fieldOrDatumDef: fieldDef,
    bandPosition,
    offset: offset9,
    ...useRectOffsetField ? {
      startSuffix: OFFSETTED_RECT_START_SUFFIX,
      endSuffix: OFFSETTED_RECT_END_SUFFIX
    } : {}
  });
}
var ALWAYS_IGNORE = /* @__PURE__ */ new Set(["aria", "width", "height"]);
function baseEncodeEntry(model, ignore) {
  const { fill: fill6 = void 0, stroke: stroke6 = void 0 } = ignore.color === "include" ? color8(model) : {};
  return {
    ...markDefProperties(model.markDef, ignore),
    ...colorRef("fill", fill6),
    ...colorRef("stroke", stroke6),
    ...nonPosition("opacity", model),
    ...nonPosition("fillOpacity", model),
    ...nonPosition("strokeOpacity", model),
    ...nonPosition("strokeWidth", model),
    ...nonPosition("strokeDash", model),
    ...zindex(model),
    ...tooltip(model),
    ...text$1(model, "href"),
    ...aria(model)
  };
}
function colorRef(channel, valueRef) {
  return valueRef ? { [channel]: valueRef } : {};
}
function markDefProperties(mark, ignore) {
  return VG_MARK_CONFIGS.reduce((m3, prop) => {
    if (!ALWAYS_IGNORE.has(prop) && hasProperty(mark, prop) && ignore[prop] !== "ignore") {
      m3[prop] = signalOrValueRef(mark[prop]);
    }
    return m3;
  }, {});
}
function defined(model) {
  const { config, markDef } = model;
  const fieldsToBreakPath = /* @__PURE__ */ new Set();
  model.forEachFieldDef((fieldDef, channel) => {
    var _a2;
    let scaleType2;
    if (!isScaleChannel(channel) || !(scaleType2 = model.getScaleType(channel))) {
      return;
    }
    const isCountAggregate = isCountingAggregateOp(fieldDef.aggregate);
    const invalidDataMode = getScaleInvalidDataMode({
      scaleChannel: channel,
      markDef,
      config,
      scaleType: scaleType2,
      isCountAggregate
    });
    if (shouldBreakPath(invalidDataMode)) {
      const field25 = model.vgField(channel, { expr: "datum", binSuffix: ((_a2 = model.stack) == null ? void 0 : _a2.impute) ? "mid" : void 0 });
      if (field25) {
        fieldsToBreakPath.add(field25);
      }
    }
  });
  if (fieldsToBreakPath.size > 0) {
    const signal = [...fieldsToBreakPath].map((field25) => fieldValidPredicate(field25, true)).join(" && ");
    return { defined: { signal } };
  }
  return void 0;
}
function valueIfDefined(prop, value7) {
  if (value7 !== void 0) {
    return { [prop]: signalOrValueRef(value7) };
  }
  return void 0;
}
var VORONOI = "voronoi";
var nearest = {
  defined: (selCmpt) => {
    return selCmpt.type === "point" && selCmpt.nearest;
  },
  parse: (model, selCmpt) => {
    if (selCmpt.events) {
      for (const s2 of selCmpt.events) {
        s2.markname = model.getName(VORONOI);
      }
    }
  },
  marks: (model, selCmpt, marks) => {
    const { x: x9, y: y9 } = selCmpt.project.hasChannel;
    const markType2 = model.mark;
    if (isPathMark(markType2)) {
      warn2(nearestNotSupportForContinuous(markType2));
      return marks;
    }
    const cellDef = {
      name: model.getName(VORONOI),
      type: "path",
      interactive: true,
      aria: false,
      from: { data: model.getName("marks") },
      encode: {
        update: {
          fill: { value: "transparent" },
          strokeWidth: { value: 0.35 },
          stroke: { value: "transparent" },
          isVoronoi: { value: true },
          ...tooltip(model, { reactiveGeom: true })
        }
      },
      transform: [
        {
          type: "voronoi",
          x: { expr: x9 || !y9 ? "datum.datum.x || 0" : "0" },
          y: { expr: y9 || !x9 ? "datum.datum.y || 0" : "0" },
          size: [model.getSizeSignalRef("width"), model.getSizeSignalRef("height")]
        }
      ]
    };
    let index4 = 0;
    let exists = false;
    marks.forEach((mark, i) => {
      const name = mark.name ?? "";
      if (name === model.component.mark[0].name) {
        index4 = i;
      } else if (name.includes(VORONOI)) {
        exists = true;
      }
    });
    if (!exists) {
      marks.splice(index4 + 1, 0, cellDef);
    }
    return marks;
  }
};
var inputBindings = {
  defined: (selCmpt) => {
    return selCmpt.type === "point" && selCmpt.resolve === "global" && selCmpt.bind && selCmpt.bind !== "scales" && !isLegendBinding(selCmpt.bind);
  },
  parse: (model, selCmpt, selDef) => disableDirectManipulation(selCmpt, selDef),
  topLevelSignals: (model, selCmpt, signals) => {
    var _a2;
    const name = selCmpt.name;
    const proj = selCmpt.project;
    const bind7 = selCmpt.bind;
    const init2 = (_a2 = selCmpt.init) == null ? void 0 : _a2[0];
    const datum2 = nearest.defined(selCmpt) ? "(item().isVoronoi ? datum.datum : datum)" : "datum";
    proj.items.forEach((p, i) => {
      const sgname = varName(`${name}_${p.field}`);
      const hasSignal2 = signals.filter((s2) => s2.name === sgname);
      if (!hasSignal2.length) {
        signals.unshift({
          name: sgname,
          ...init2 ? { init: assembleInit(init2[i]) } : { value: null },
          on: selCmpt.events ? [
            {
              events: selCmpt.events,
              update: `datum && item().mark.marktype !== 'group' ? ${datum2}[${$10(p.field)}] : null`
            }
          ] : [],
          bind: bind7[p.field] ?? bind7[p.channel] ?? bind7
        });
      }
    });
    return signals;
  },
  signals: (model, selCmpt, signals) => {
    const name = selCmpt.name;
    const proj = selCmpt.project;
    const signal = signals.find((s2) => s2.name === name + TUPLE);
    const fields = name + TUPLE_FIELDS;
    const values7 = proj.items.map((p) => varName(`${name}_${p.field}`));
    const valid = values7.map((v2) => `${v2} !== null`).join(" && ");
    if (values7.length) {
      signal.update = `${valid} ? {fields: ${fields}, values: [${values7.join(", ")}]} : null`;
    }
    delete signal.value;
    delete signal.on;
    return signals;
  }
};
var TOGGLE = "_toggle";
var toggle = {
  defined: (selCmpt) => {
    return selCmpt.type === "point" && !isTimerSelection(selCmpt) && !!selCmpt.toggle;
  },
  signals: (model, selCmpt, signals) => {
    return signals.concat({
      name: selCmpt.name + TOGGLE,
      value: false,
      on: [{ events: selCmpt.events, update: selCmpt.toggle }]
    });
  },
  modifyExpr: (model, selCmpt) => {
    const tpl = selCmpt.name + TUPLE;
    const signal = selCmpt.name + TOGGLE;
    return `${signal} ? null : ${tpl}, ${selCmpt.resolve === "global" ? `${signal} ? null : true, ` : `${signal} ? null : {unit: ${unitName(model)}}, `}${signal} ? ${tpl} : null`;
  }
};
var clear = {
  defined: (selCmpt) => {
    return selCmpt.clear !== void 0 && selCmpt.clear !== false && !isTimerSelection(selCmpt);
  },
  parse: (model, selCmpt) => {
    if (selCmpt.clear) {
      selCmpt.clear = isString14(selCmpt.clear) ? eventSelector(selCmpt.clear, "view") : selCmpt.clear;
    }
  },
  topLevelSignals: (model, selCmpt, signals) => {
    if (inputBindings.defined(selCmpt)) {
      for (const proj of selCmpt.project.items) {
        const idx = signals.findIndex((n) => n.name === varName(`${selCmpt.name}_${proj.field}`));
        if (idx !== -1) {
          signals[idx].on.push({ events: selCmpt.clear, update: "null" });
        }
      }
    }
    return signals;
  },
  signals: (model, selCmpt, signals) => {
    function addClear(idx, update3) {
      if (idx !== -1 && signals[idx].on) {
        signals[idx].on.push({ events: selCmpt.clear, update: update3 });
      }
    }
    if (selCmpt.type === "interval") {
      for (const proj of selCmpt.project.items) {
        const vIdx = signals.findIndex((n) => n.name === proj.signals.visual);
        addClear(vIdx, "[0, 0]");
        if (vIdx === -1) {
          const dIdx = signals.findIndex((n) => n.name === proj.signals.data);
          addClear(dIdx, "null");
        }
      }
    } else {
      let tIdx = signals.findIndex((n) => n.name === selCmpt.name + TUPLE);
      addClear(tIdx, "null");
      if (toggle.defined(selCmpt)) {
        tIdx = signals.findIndex((n) => n.name === selCmpt.name + TOGGLE);
        addClear(tIdx, "false");
      }
    }
    return signals;
  }
};
var legendBindings = {
  defined: (selCmpt) => {
    const spec = selCmpt.resolve === "global" && selCmpt.bind && isLegendBinding(selCmpt.bind);
    const projLen = selCmpt.project.items.length === 1 && selCmpt.project.items[0].field !== SELECTION_ID;
    if (spec && !projLen) {
      warn2(LEGEND_BINDINGS_MUST_HAVE_PROJECTION);
    }
    return spec && projLen;
  },
  parse: (model, selCmpt, selDef) => {
    const selDef_ = duplicate(selDef);
    selDef_.select = isString14(selDef_.select) ? { type: selDef_.select, toggle: selCmpt.toggle } : { ...selDef_.select, toggle: selCmpt.toggle };
    disableDirectManipulation(selCmpt, selDef_);
    if (isObject(selDef.select) && (selDef.select.on || selDef.select.clear)) {
      const legendFilter = 'event.item && indexof(event.item.mark.role, "legend") < 0';
      for (const evt2 of selCmpt.events) {
        evt2.filter = array21(evt2.filter ?? []);
        if (!evt2.filter.includes(legendFilter)) {
          evt2.filter.push(legendFilter);
        }
      }
    }
    const evt = isLegendStreamBinding(selCmpt.bind) ? selCmpt.bind.legend : "click";
    const stream2 = isString14(evt) ? eventSelector(evt, "view") : array21(evt);
    selCmpt.bind = { legend: { merge: stream2 } };
  },
  topLevelSignals: (model, selCmpt, signals) => {
    const selName = selCmpt.name;
    const stream2 = isLegendStreamBinding(selCmpt.bind) && selCmpt.bind.legend;
    const markName = (name) => (s2) => {
      const ds = duplicate(s2);
      ds.markname = name;
      return ds;
    };
    for (const proj of selCmpt.project.items) {
      if (!proj.hasLegend)
        continue;
      const prefix = `${varName(proj.field)}_legend`;
      const sgName = `${selName}_${prefix}`;
      const hasSignal2 = signals.filter((s2) => s2.name === sgName);
      if (hasSignal2.length === 0) {
        const events3 = stream2.merge.map(markName(`${prefix}_symbols`)).concat(stream2.merge.map(markName(`${prefix}_labels`))).concat(stream2.merge.map(markName(`${prefix}_entries`)));
        signals.unshift({
          name: sgName,
          ...!selCmpt.init ? { value: null } : {},
          on: [
            // Legend entries do not store values, so we need to walk the scenegraph to the symbol datum.
            {
              events: events3,
              update: "isDefined(datum.value) ? datum.value : item().items[0].items[0].datum.value",
              force: true
            },
            { events: stream2.merge, update: `!event.item || !datum ? null : ${sgName}`, force: true }
          ]
        });
      }
    }
    return signals;
  },
  signals: (model, selCmpt, signals) => {
    const name = selCmpt.name;
    const proj = selCmpt.project;
    const tuple = signals.find((s2) => s2.name === name + TUPLE);
    const fields = name + TUPLE_FIELDS;
    const values7 = proj.items.filter((p) => p.hasLegend).map((p) => varName(`${name}_${varName(p.field)}_legend`));
    const valid = values7.map((v2) => `${v2} !== null`).join(" && ");
    const update3 = `${valid} ? {fields: ${fields}, values: [${values7.join(", ")}]} : null`;
    if (selCmpt.events && values7.length > 0) {
      tuple.on.push({
        events: values7.map((signal) => ({ signal })),
        update: update3
      });
    } else if (values7.length > 0) {
      tuple.update = update3;
      delete tuple.value;
      delete tuple.on;
    }
    const toggle2 = signals.find((s2) => s2.name === name + TOGGLE);
    const events3 = isLegendStreamBinding(selCmpt.bind) && selCmpt.bind.legend;
    if (toggle2) {
      if (!selCmpt.events)
        toggle2.on[0].events = events3;
      else
        toggle2.on.push({ ...toggle2.on[0], events: events3 });
    }
    return signals;
  }
};
function parseInteractiveLegend(model, channel, legendCmpt) {
  var _a2;
  const field25 = (_a2 = model.fieldDef(channel)) == null ? void 0 : _a2.field;
  for (const selCmpt of vals(model.component.selection ?? {})) {
    const proj = selCmpt.project.hasField[field25] ?? selCmpt.project.hasChannel[channel];
    if (proj && legendBindings.defined(selCmpt)) {
      const legendSelections = legendCmpt.get("selections") ?? [];
      legendSelections.push(selCmpt.name);
      legendCmpt.set("selections", legendSelections, false);
      proj.hasLegend = true;
    }
  }
}
var ANCHOR$1 = "_translate_anchor";
var DELTA$1 = "_translate_delta";
var translate7 = {
  defined: (selCmpt) => {
    return selCmpt.type === "interval" && selCmpt.translate;
  },
  signals: (model, selCmpt, signals) => {
    const name = selCmpt.name;
    const boundScales = scaleBindings.defined(selCmpt);
    const anchor = name + ANCHOR$1;
    const { x: x9, y: y9 } = selCmpt.project.hasChannel;
    let events3 = eventSelector(selCmpt.translate, "scope");
    if (!boundScales) {
      events3 = events3.map((e3) => (e3.between[0].markname = name + BRUSH, e3));
    }
    signals.push({
      name: anchor,
      value: {},
      on: [
        {
          events: events3.map((e3) => e3.between[0]),
          update: `{x: x(unit), y: y(unit)${x9 !== void 0 ? `, extent_x: ${boundScales ? domain2(model, X3) : `slice(${x9.signals.visual})`}` : ""}${y9 !== void 0 ? `, extent_y: ${boundScales ? domain2(model, Y3) : `slice(${y9.signals.visual})`}` : ""}}`
        }
      ]
    }, {
      name: name + DELTA$1,
      value: {},
      on: [
        {
          events: events3,
          update: `{x: ${anchor}.x - x(unit), y: ${anchor}.y - y(unit)}`
        }
      ]
    });
    if (x9 !== void 0) {
      onDelta$1(model, selCmpt, x9, "width", signals);
    }
    if (y9 !== void 0) {
      onDelta$1(model, selCmpt, y9, "height", signals);
    }
    return signals;
  }
};
function onDelta$1(model, selCmpt, proj, size, signals) {
  const name = selCmpt.name;
  const anchor = name + ANCHOR$1;
  const delta = name + DELTA$1;
  const channel = proj.channel;
  const boundScales = scaleBindings.defined(selCmpt);
  const signal = signals.find((s2) => s2.name === proj.signals[boundScales ? "data" : "visual"]);
  const sizeSg = model.getSizeSignalRef(size).signal;
  const scaleCmpt = model.getScaleComponent(channel);
  const scaleType2 = scaleCmpt == null ? void 0 : scaleCmpt.get("type");
  const reversed = scaleCmpt == null ? void 0 : scaleCmpt.get("reverse");
  const sign4 = !boundScales ? "" : channel === X3 ? reversed ? "" : "-" : reversed ? "-" : "";
  const extent8 = `${anchor}.extent_${channel}`;
  const offset9 = `${sign4}${delta}.${channel} / ${boundScales ? `${sizeSg}` : `span(${extent8})`}`;
  const panFn = !boundScales || !scaleCmpt ? "panLinear" : scaleType2 === "log" ? "panLog" : scaleType2 === "symlog" ? "panSymlog" : scaleType2 === "pow" ? "panPow" : "panLinear";
  const arg = !boundScales ? "" : scaleType2 === "pow" ? `, ${scaleCmpt.get("exponent") ?? 1}` : scaleType2 === "symlog" ? `, ${scaleCmpt.get("constant") ?? 1}` : "";
  const update3 = `${panFn}(${extent8}, ${offset9}${arg})`;
  signal.on.push({
    events: { signal: delta },
    update: boundScales ? update3 : `clampRange(${update3}, 0, ${sizeSg})`
  });
}
var ANCHOR = "_zoom_anchor";
var DELTA = "_zoom_delta";
var zoom4 = {
  defined: (selCmpt) => {
    return selCmpt.type === "interval" && selCmpt.zoom;
  },
  signals: (model, selCmpt, signals) => {
    const name = selCmpt.name;
    const boundScales = scaleBindings.defined(selCmpt);
    const delta = name + DELTA;
    const { x: x9, y: y9 } = selCmpt.project.hasChannel;
    const sx = $10(model.scaleName(X3));
    const sy = $10(model.scaleName(Y3));
    let events3 = eventSelector(selCmpt.zoom, "scope");
    if (!boundScales) {
      events3 = events3.map((e3) => (e3.markname = name + BRUSH, e3));
    }
    signals.push({
      name: name + ANCHOR,
      on: [
        {
          events: events3,
          update: !boundScales ? `{x: x(unit), y: y(unit)}` : `{${[sx ? `x: invert(${sx}, x(unit))` : "", sy ? `y: invert(${sy}, y(unit))` : ""].filter((expr2) => expr2).join(", ")}}`
        }
      ]
    }, {
      name: delta,
      on: [
        {
          events: events3,
          force: true,
          update: "pow(1.001, event.deltaY * pow(16, event.deltaMode))"
        }
      ]
    });
    if (x9 !== void 0) {
      onDelta(model, selCmpt, x9, "width", signals);
    }
    if (y9 !== void 0) {
      onDelta(model, selCmpt, y9, "height", signals);
    }
    return signals;
  }
};
function onDelta(model, selCmpt, proj, size, signals) {
  const name = selCmpt.name;
  const channel = proj.channel;
  const boundScales = scaleBindings.defined(selCmpt);
  const signal = signals.find((s2) => s2.name === proj.signals[boundScales ? "data" : "visual"]);
  const sizeSg = model.getSizeSignalRef(size).signal;
  const scaleCmpt = model.getScaleComponent(channel);
  const scaleType2 = scaleCmpt == null ? void 0 : scaleCmpt.get("type");
  const base = boundScales ? domain2(model, channel) : signal.name;
  const delta = name + DELTA;
  const anchor = `${name}${ANCHOR}.${channel}`;
  const zoomFn = !boundScales || !scaleCmpt ? "zoomLinear" : scaleType2 === "log" ? "zoomLog" : scaleType2 === "symlog" ? "zoomSymlog" : scaleType2 === "pow" ? "zoomPow" : "zoomLinear";
  const arg = !boundScales ? "" : scaleType2 === "pow" ? `, ${scaleCmpt.get("exponent") ?? 1}` : scaleType2 === "symlog" ? `, ${scaleCmpt.get("constant") ?? 1}` : "";
  const update3 = `${zoomFn}(${base}, ${anchor}, ${delta}${arg})`;
  signal.on.push({
    events: { signal: delta },
    update: boundScales ? update3 : `clampRange(${update3}, 0, ${sizeSg})`
  });
}
var STORE = "_store";
var TUPLE = "_tuple";
var MODIFY = "_modify";
var VL_SELECTION_RESOLVE = "vlSelectionResolve";
var selectionCompilers = [
  point$1,
  interval2,
  project2,
  toggle,
  // Bindings may disable direct manipulation.
  inputBindings,
  scaleBindings,
  legendBindings,
  clear,
  translate7,
  zoom4,
  nearest
];
function getFacetModel(model) {
  let parent = model.parent;
  while (parent) {
    if (isFacetModel(parent))
      break;
    parent = parent.parent;
  }
  return parent;
}
function unitName(model, { escape: escape2 } = { escape: true }) {
  let name = escape2 ? $10(model.name) : model.name;
  const facetModel = getFacetModel(model);
  if (facetModel) {
    const { facet } = facetModel;
    for (const channel of FACET_CHANNELS) {
      if (facet[channel]) {
        name += ` + '__facet_${channel}_' + (facet[${$10(facetModel.vgField(channel))}])`;
      }
    }
  }
  return name;
}
function requiresSelectionId(model) {
  return vals(model.component.selection ?? {}).reduce((identifier, selCmpt) => {
    return identifier || selCmpt.project.hasSelectionId;
  }, false);
}
function disableDirectManipulation(selCmpt, selDef) {
  if (isString(selDef.select) || !selDef.select.on)
    delete selCmpt.events;
  if (isString(selDef.select) || !selDef.select.clear)
    delete selCmpt.clear;
  if (isString(selDef.select) || !selDef.select.toggle)
    delete selCmpt.toggle;
}
function isTimerSelection(selCmpt) {
  var _a2;
  return (_a2 = selCmpt.events) == null ? void 0 : _a2.find((e3) => "type" in e3 && e3.type === "timer");
}
function getName(node) {
  const name = [];
  if (node.type === "Identifier") {
    return [node.name];
  }
  if (node.type === "Literal") {
    return [node.value];
  }
  if (node.type === "MemberExpression") {
    name.push(...getName(node.object));
    name.push(...getName(node.property));
  }
  return name;
}
function startsWithDatum(node) {
  if (node.object.type === "MemberExpression") {
    return startsWithDatum(node.object);
  }
  return node.object.name === "datum";
}
function getDependentFields(expression4) {
  const ast = parser(expression4);
  const dependents = /* @__PURE__ */ new Set();
  ast.visit((node) => {
    if (node.type === "MemberExpression" && startsWithDatum(node)) {
      dependents.add(getName(node).slice(1).join("."));
    }
  });
  return dependents;
}
var FilterNode = class _FilterNode extends DataFlowNode {
  constructor(parent, model, filter4) {
    super(parent);
    __publicField(this, "model");
    __publicField(this, "filter");
    __publicField(this, "expr");
    __publicField(this, "_dependentFields");
    this.model = model;
    this.filter = filter4;
    this.expr = expression3(this.model, this.filter, this);
    this._dependentFields = getDependentFields(this.expr);
  }
  clone() {
    return new _FilterNode(null, this.model, duplicate(this.filter));
  }
  dependentFields() {
    return this._dependentFields;
  }
  producedFields() {
    return /* @__PURE__ */ new Set();
  }
  assemble() {
    return {
      type: "filter",
      expr: this.expr
    };
  }
  hash() {
    return `Filter ${this.expr}`;
  }
};
function parseUnitSelection(model, selDefs) {
  const selCmpts = {};
  const selectionConfig = model.config.selection;
  if (!selDefs || !selDefs.length)
    return selCmpts;
  let nTimerSelections = 0;
  for (const def6 of selDefs) {
    const name = varName(def6.name);
    const selDef = def6.select;
    const type7 = isString14(selDef) ? selDef : selDef.type;
    const defaults2 = isObject12(selDef) ? duplicate(selDef) : { type: type7 };
    const cfg = selectionConfig[type7];
    for (const key4 in cfg) {
      if (key4 === "fields" || key4 === "encodings") {
        continue;
      }
      if (key4 === "mark") {
        defaults2.mark = { ...cfg.mark, ...defaults2.mark };
      }
      if (defaults2[key4] === void 0 || defaults2[key4] === true) {
        defaults2[key4] = duplicate(cfg[key4] ?? defaults2[key4]);
      }
    }
    const selCmpt = selCmpts[name] = {
      ...defaults2,
      name,
      type: type7,
      init: def6.value,
      bind: def6.bind,
      events: isString14(defaults2.on) ? eventSelector(defaults2.on, "scope") : array21(duplicate(defaults2.on))
    };
    if (isTimerSelection(selCmpt)) {
      nTimerSelections++;
      if (nTimerSelections > 1) {
        delete selCmpts[name];
        continue;
      }
    }
    const def_ = duplicate(def6);
    for (const c5 of selectionCompilers) {
      if (c5.defined(selCmpt) && c5.parse) {
        c5.parse(model, selCmpt, def_);
      }
    }
  }
  if (nTimerSelections > 1) {
    warn2(MULTIPLE_TIMER_ANIMATION_SELECTION);
  }
  return selCmpts;
}
function parseSelectionPredicate(model, pred, dfnode, datum2 = "datum") {
  const name = isString14(pred) ? pred : pred.param;
  const vname = varName(name);
  const store = $10(vname + STORE);
  let selCmpt;
  try {
    selCmpt = model.getSelectionComponent(vname, name);
  } catch {
    return `!!${vname}`;
  }
  if (selCmpt.project.timeUnit) {
    const child = dfnode ?? model.component.data.raw;
    const tunode = selCmpt.project.timeUnit.clone();
    if (child.parent) {
      tunode.insertAsParentOf(child);
    } else {
      child.parent = tunode;
    }
  }
  const fn = selCmpt.project.hasSelectionId ? "vlSelectionIdTest(" : "vlSelectionTest(";
  const resolve2 = selCmpt.resolve === "global" ? ")" : `, ${$10(selCmpt.resolve)})`;
  const test2 = `${fn}${store}, ${datum2}${resolve2}`;
  const length2 = `length(data(${store}))`;
  return pred.empty === false ? `${length2} && ${test2}` : `!${length2} || ${test2}`;
}
function parseSelectionExtent(model, name, extent8) {
  const vname = varName(name);
  const encoding = extent8.encoding;
  let field25 = extent8.field;
  let selCmpt;
  try {
    selCmpt = model.getSelectionComponent(vname, name);
  } catch {
    return vname;
  }
  if (!encoding && !field25) {
    field25 = selCmpt.project.items[0].field;
    if (selCmpt.project.items.length > 1) {
      warn2(selectionAsScaleDomainWithoutField(field25));
    }
  } else if (encoding && !field25) {
    const encodings = selCmpt.project.items.filter((p) => p.channel === encoding);
    if (!encodings.length || encodings.length > 1) {
      field25 = selCmpt.project.items[0].field;
      warn2(selectionAsScaleDomainWrongEncodings(encodings, encoding, extent8, field25));
    } else {
      field25 = encodings[0].field;
    }
  }
  return `${selCmpt.name}[${$10(replacePathInField(field25))}]`;
}
function materializeSelections(model, main2) {
  for (const [selection, selCmpt] of entries$1(model.component.selection ?? {})) {
    const lookupName = model.getName(`lookup_${selection}`);
    model.component.data.outputNodes[lookupName] = selCmpt.materialized = new OutputNode(new FilterNode(main2, model, { param: selection }), lookupName, DataSourceType.Lookup, model.component.data.outputNodeRefCounts);
  }
}
function expression3(model, filterOp, node) {
  return logicalExpr(filterOp, (predicate) => {
    if (isString14(predicate)) {
      return predicate;
    } else if (isSelectionPredicate(predicate)) {
      return parseSelectionPredicate(model, predicate, node);
    } else {
      return fieldFilterExpression(predicate);
    }
  });
}
function assembleTitle(title2, config) {
  if (!title2) {
    return void 0;
  }
  if (isArray22(title2) && !isText(title2)) {
    return title2.map((fieldDef) => defaultTitle(fieldDef, config)).join(", ");
  }
  return title2;
}
function setAxisEncode(axis, part, vgProp, vgRef) {
  var _a2, _b;
  axis.encode ?? (axis.encode = {});
  (_a2 = axis.encode)[part] ?? (_a2[part] = {});
  (_b = axis.encode[part]).update ?? (_b.update = {});
  axis.encode[part].update[vgProp] = vgRef;
}
function assembleAxis(axisCmpt, kind, config, opt = { header: false }) {
  var _a2, _b;
  const { disable, orient: orient2, scale: scale19, labelExpr, title: title2, zindex: zindex2, ...axis } = axisCmpt.combine();
  if (disable) {
    return void 0;
  }
  for (const p in axis) {
    const prop = p;
    const propType = AXIS_PROPERTY_TYPE[prop];
    const propValue = axis[prop];
    if (propType && propType !== kind && propType !== "both") {
      delete axis[prop];
    } else if (isConditionalAxisValue(propValue)) {
      const { condition, ...valueOrSignalRef } = propValue;
      const conditions = array21(condition);
      const propIndex = CONDITIONAL_AXIS_PROP_INDEX[prop];
      if (propIndex) {
        const { vgProp, part } = propIndex;
        const vgRef = [
          ...conditions.map((c5) => {
            const { test: test2, ...valueOrSignalCRef } = c5;
            return {
              test: expression3(null, test2),
              ...valueOrSignalCRef
            };
          }),
          valueOrSignalRef
        ];
        setAxisEncode(axis, part, vgProp, vgRef);
        delete axis[prop];
      } else if (propIndex === null) {
        const signalRef = {
          signal: conditions.map((c5) => {
            const { test: test2, ...valueOrSignalCRef } = c5;
            return `${expression3(null, test2)} ? ${exprFromValueRefOrSignalRef(valueOrSignalCRef)} : `;
          }).join("") + exprFromValueRefOrSignalRef(valueOrSignalRef)
        };
        axis[prop] = signalRef;
      }
    } else if (isSignalRef(propValue)) {
      const propIndex = CONDITIONAL_AXIS_PROP_INDEX[prop];
      if (propIndex) {
        const { vgProp, part } = propIndex;
        setAxisEncode(axis, part, vgProp, propValue);
        delete axis[prop];
      }
    }
    if (contains2(["labelAlign", "labelBaseline"], prop) && axis[prop] === null) {
      delete axis[prop];
    }
  }
  if (kind === "grid") {
    if (!axis.grid) {
      return void 0;
    }
    if (axis.encode) {
      const { grid } = axis.encode;
      axis.encode = {
        ...grid ? { grid } : {}
      };
      if (isEmpty(axis.encode)) {
        delete axis.encode;
      }
    }
    return {
      scale: scale19,
      orient: orient2,
      ...axis,
      domain: false,
      labels: false,
      aria: false,
      // always hide grid axis
      // Always set min/maxExtent to 0 to ensure that `config.axis*.minExtent` and `config.axis*.maxExtent`
      // would not affect gridAxis
      maxExtent: 0,
      minExtent: 0,
      ticks: false,
      zindex: getFirstDefined(zindex2, 0)
      // put grid behind marks by default
    };
  } else {
    if (!opt.header && axisCmpt.mainExtracted) {
      return void 0;
    }
    if (labelExpr !== void 0) {
      let expr2 = labelExpr;
      if (((_b = (_a2 = axis.encode) == null ? void 0 : _a2.labels) == null ? void 0 : _b.update) && isSignalRef(axis.encode.labels.update.text)) {
        expr2 = replaceAll(labelExpr, "datum.label", axis.encode.labels.update.text.signal);
      }
      setAxisEncode(axis, "labels", "text", { signal: expr2 });
    }
    if (axis.labelAlign === null) {
      delete axis.labelAlign;
    }
    if (axis.encode) {
      for (const part of AXIS_PARTS) {
        if (!axisCmpt.hasAxisPart(part)) {
          delete axis.encode[part];
        }
      }
      if (isEmpty(axis.encode)) {
        delete axis.encode;
      }
    }
    const titleString = assembleTitle(title2, config);
    return {
      scale: scale19,
      orient: orient2,
      grid: false,
      ...titleString ? { title: titleString } : {},
      ...axis,
      ...config.aria === false ? { aria: false } : {},
      zindex: getFirstDefined(zindex2, 0)
      // put axis line above marks by default
    };
  }
}
function assembleAxisSignals(model) {
  const { axes } = model.component;
  const signals = [];
  for (const channel of POSITION_SCALE_CHANNELS) {
    if (axes[channel]) {
      for (const axis of axes[channel]) {
        if (!axis.get("disable") && !axis.get("gridScale")) {
          const sizeType = channel === "x" ? "height" : "width";
          const update3 = model.getSizeSignalRef(sizeType).signal;
          if (sizeType !== update3) {
            signals.push({
              name: sizeType,
              update: update3
            });
          }
        }
      }
    }
  }
  return signals;
}
function assembleAxes(axisComponents, config) {
  const { x: x9 = [], y: y9 = [] } = axisComponents;
  return [
    ...x9.map((a4) => assembleAxis(a4, "grid", config)),
    ...y9.map((a4) => assembleAxis(a4, "grid", config)),
    ...x9.map((a4) => assembleAxis(a4, "main", config)),
    ...y9.map((a4) => assembleAxis(a4, "main", config))
  ].filter((a4) => a4);
}
function getAxisConfigFromConfigTypes(configTypes, config, channel, orient2) {
  return Object.assign.apply(null, [
    {},
    ...configTypes.map((configType) => {
      if (configType === "axisOrient") {
        const orient1 = channel === "x" ? "bottom" : "left";
        const orientConfig1 = config[channel === "x" ? "axisBottom" : "axisLeft"] || {};
        const orientConfig2 = config[channel === "x" ? "axisTop" : "axisRight"] || {};
        const props = /* @__PURE__ */ new Set([...keys4(orientConfig1), ...keys4(orientConfig2)]);
        const conditionalOrientAxisConfig = {};
        for (const prop of props.values()) {
          conditionalOrientAxisConfig[prop] = {
            // orient is surely signal in this case
            signal: `${orient2["signal"]} === "${orient1}" ? ${signalOrStringValue(orientConfig1[prop])} : ${signalOrStringValue(orientConfig2[prop])}`
          };
        }
        return conditionalOrientAxisConfig;
      }
      return config[configType];
    })
  ]);
}
function getAxisConfigs(channel, scaleType2, orient2, config) {
  const typeBasedConfigTypes = scaleType2 === "band" ? ["axisDiscrete", "axisBand"] : scaleType2 === "point" ? ["axisDiscrete", "axisPoint"] : isQuantitative(scaleType2) ? ["axisQuantitative"] : scaleType2 === "time" || scaleType2 === "utc" ? ["axisTemporal"] : [];
  const axisChannel = channel === "x" ? "axisX" : "axisY";
  const axisOrient = isSignalRef(orient2) ? "axisOrient" : `axis${titleCase(orient2)}`;
  const vlOnlyConfigTypes = [
    // technically Vega does have axisBand, but if we make another separation here,
    // it will further introduce complexity in the code
    ...typeBasedConfigTypes,
    ...typeBasedConfigTypes.map((c5) => axisChannel + c5.substr(4))
  ];
  const vgConfigTypes = ["axis", axisOrient, axisChannel];
  return {
    vlOnlyAxisConfig: getAxisConfigFromConfigTypes(vlOnlyConfigTypes, config, channel, orient2),
    vgAxisConfig: getAxisConfigFromConfigTypes(vgConfigTypes, config, channel, orient2),
    axisConfigStyle: getAxisConfigStyle([...vgConfigTypes, ...vlOnlyConfigTypes], config)
  };
}
function getAxisConfigStyle(axisConfigTypes, config) {
  var _a2;
  const toMerge = [{}];
  for (const configType of axisConfigTypes) {
    let style6 = (_a2 = config[configType]) == null ? void 0 : _a2.style;
    if (style6) {
      style6 = array21(style6);
      for (const s2 of style6) {
        toMerge.push(config.style[s2]);
      }
    }
  }
  return Object.assign.apply(null, toMerge);
}
function getAxisConfig(property2, styleConfigIndex, style6, axisConfigs = {}) {
  var _a2;
  const styleConfig = getStyleConfig(property2, style6, styleConfigIndex);
  if (styleConfig !== void 0) {
    return {
      configFrom: "style",
      configValue: styleConfig
    };
  }
  for (const configFrom of ["vlOnlyAxisConfig", "vgAxisConfig", "axisConfigStyle"]) {
    if (((_a2 = axisConfigs[configFrom]) == null ? void 0 : _a2[property2]) !== void 0) {
      return { configFrom, configValue: axisConfigs[configFrom][property2] };
    }
  }
  return {};
}
var axisRules = {
  scale: ({ model, channel }) => model.scaleName(channel),
  format: ({ format: format14 }) => format14,
  // we already calculate this in parse
  formatType: ({ formatType }) => formatType,
  // we already calculate this in parse
  grid: ({ fieldOrDatumDef, axis, scaleType: scaleType2 }) => axis.grid ?? defaultGrid(scaleType2, fieldOrDatumDef),
  gridScale: ({ model, channel }) => gridScale(model, channel),
  labelAlign: ({ axis, labelAngle, orient: orient2, channel }) => axis.labelAlign || defaultLabelAlign(labelAngle, orient2, channel),
  labelAngle: ({ labelAngle }) => labelAngle,
  // we already calculate this in parse
  labelBaseline: ({ axis, labelAngle, orient: orient2, channel }) => axis.labelBaseline || defaultLabelBaseline(labelAngle, orient2, channel),
  labelFlush: ({ axis, fieldOrDatumDef, channel }) => axis.labelFlush ?? defaultLabelFlush(fieldOrDatumDef.type, channel),
  labelOverlap: ({ axis, fieldOrDatumDef, scaleType: scaleType2 }) => axis.labelOverlap ?? defaultLabelOverlap$1(fieldOrDatumDef.type, scaleType2, isFieldDef(fieldOrDatumDef) && !!fieldOrDatumDef.timeUnit, isFieldDef(fieldOrDatumDef) ? fieldOrDatumDef.sort : void 0),
  // we already calculate orient in parse
  orient: ({ orient: orient2 }) => orient2,
  // Need to cast until Vega supports signal
  tickCount: ({ channel, model, axis, fieldOrDatumDef, scaleType: scaleType2 }) => {
    const sizeType = channel === "x" ? "width" : channel === "y" ? "height" : void 0;
    const size = sizeType ? model.getSizeSignalRef(sizeType) : void 0;
    return axis.tickCount ?? defaultTickCount({ fieldOrDatumDef, scaleType: scaleType2, size, values: axis.values });
  },
  tickMinStep: ({ axis, format: format14, fieldOrDatumDef }) => axis.tickMinStep ?? defaultTickMinStep({ format: format14, fieldOrDatumDef }),
  title: ({ axis, model, channel }) => {
    if (axis.title !== void 0) {
      return axis.title;
    }
    const fieldDefTitle = getFieldDefTitle(model, channel);
    if (fieldDefTitle !== void 0) {
      return fieldDefTitle;
    }
    const fieldDef = model.typedFieldDef(channel);
    const channel2 = channel === "x" ? "x2" : "y2";
    const fieldDef2 = model.fieldDef(channel2);
    return mergeTitleFieldDefs(fieldDef ? [toFieldDefBase(fieldDef)] : [], isFieldDef(fieldDef2) ? [toFieldDefBase(fieldDef2)] : []);
  },
  values: ({ axis, fieldOrDatumDef }) => values$1(axis, fieldOrDatumDef),
  zindex: ({ axis, fieldOrDatumDef, mark }) => axis.zindex ?? defaultZindex(mark, fieldOrDatumDef)
};
function defaultGrid(scaleType2, fieldDef) {
  return !hasDiscreteDomain(scaleType2) && isFieldDef(fieldDef) && !isBinning(fieldDef == null ? void 0 : fieldDef.bin) && !isBinned(fieldDef == null ? void 0 : fieldDef.bin);
}
function gridScale(model, channel) {
  const gridChannel = channel === "x" ? "y" : "x";
  if (model.getScaleComponent(gridChannel)) {
    return model.scaleName(gridChannel);
  }
  return void 0;
}
function getLabelAngle(fieldOrDatumDef, axis, channel, styleConfig, axisConfigs) {
  const labelAngle = axis == null ? void 0 : axis.labelAngle;
  if (labelAngle !== void 0) {
    return isSignalRef(labelAngle) ? labelAngle : normalizeAngle(labelAngle);
  } else {
    const { configValue: angle2 } = getAxisConfig("labelAngle", styleConfig, axis == null ? void 0 : axis.style, axisConfigs);
    if (angle2 !== void 0) {
      return normalizeAngle(angle2);
    } else {
      if (channel === X3 && contains2([NOMINAL, ORDINAL], fieldOrDatumDef.type) && !(isFieldDef(fieldOrDatumDef) && fieldOrDatumDef.timeUnit)) {
        return 270;
      }
      return void 0;
    }
  }
}
function normalizeAngleExpr(angle2) {
  return `(((${angle2.signal} % 360) + 360) % 360)`;
}
function defaultLabelBaseline(angle2, orient2, channel, alwaysIncludeMiddle) {
  if (angle2 !== void 0) {
    if (channel === "x") {
      if (isSignalRef(angle2)) {
        const a4 = normalizeAngleExpr(angle2);
        const orientIsTop = isSignalRef(orient2) ? `(${orient2.signal} === "top")` : orient2 === "top";
        return {
          signal: `(45 < ${a4} && ${a4} < 135) || (225 < ${a4} && ${a4} < 315) ? "middle" :(${a4} <= 45 || 315 <= ${a4}) === ${orientIsTop} ? "bottom" : "top"`
        };
      }
      if (45 < angle2 && angle2 < 135 || 225 < angle2 && angle2 < 315) {
        return "middle";
      }
      if (isSignalRef(orient2)) {
        const op = angle2 <= 45 || 315 <= angle2 ? "===" : "!==";
        return { signal: `${orient2.signal} ${op} "top" ? "bottom" : "top"` };
      }
      return (angle2 <= 45 || 315 <= angle2) === (orient2 === "top") ? "bottom" : "top";
    } else {
      if (isSignalRef(angle2)) {
        const a4 = normalizeAngleExpr(angle2);
        const orientIsLeft = isSignalRef(orient2) ? `(${orient2.signal} === "left")` : orient2 === "left";
        const middle = alwaysIncludeMiddle ? '"middle"' : "null";
        return {
          signal: `${a4} <= 45 || 315 <= ${a4} || (135 <= ${a4} && ${a4} <= 225) ? ${middle} : (45 <= ${a4} && ${a4} <= 135) === ${orientIsLeft} ? "top" : "bottom"`
        };
      }
      if (angle2 <= 45 || 315 <= angle2 || 135 <= angle2 && angle2 <= 225) {
        return alwaysIncludeMiddle ? "middle" : null;
      }
      if (isSignalRef(orient2)) {
        const op = 45 <= angle2 && angle2 <= 135 ? "===" : "!==";
        return { signal: `${orient2.signal} ${op} "left" ? "top" : "bottom"` };
      }
      return (45 <= angle2 && angle2 <= 135) === (orient2 === "left") ? "top" : "bottom";
    }
  }
  return void 0;
}
function defaultLabelAlign(angle2, orient2, channel) {
  if (angle2 === void 0) {
    return void 0;
  }
  const isX2 = channel === "x";
  const startAngle = isX2 ? 0 : 90;
  const mainOrient = isX2 ? "bottom" : "left";
  if (isSignalRef(angle2)) {
    const a4 = normalizeAngleExpr(angle2);
    const orientIsMain = isSignalRef(orient2) ? `(${orient2.signal} === "${mainOrient}")` : orient2 === mainOrient;
    return {
      signal: `(${startAngle ? `(${a4} + 90)` : a4} % 180 === 0) ? ${isX2 ? null : '"center"'} :(${startAngle} < ${a4} && ${a4} < ${180 + startAngle}) === ${orientIsMain} ? "left" : "right"`
    };
  }
  if ((angle2 + startAngle) % 180 === 0) {
    return isX2 ? null : "center";
  }
  if (isSignalRef(orient2)) {
    const op = startAngle < angle2 && angle2 < 180 + startAngle ? "===" : "!==";
    const orientIsMain = `${orient2.signal} ${op} "${mainOrient}"`;
    return {
      signal: `${orientIsMain} ? "left" : "right"`
    };
  }
  if ((startAngle < angle2 && angle2 < 180 + startAngle) === (orient2 === mainOrient)) {
    return "left";
  }
  return "right";
}
function defaultLabelFlush(type7, channel) {
  if (channel === "x" && contains2(["quantitative", "temporal"], type7)) {
    return true;
  }
  return void 0;
}
function defaultLabelOverlap$1(type7, scaleType2, hasTimeUnit, sort4) {
  if (hasTimeUnit && !isObject12(sort4) || type7 !== "nominal" && type7 !== "ordinal") {
    if (scaleType2 === "log" || scaleType2 === "symlog") {
      return "greedy";
    }
    return true;
  }
  return void 0;
}
function defaultOrient(channel) {
  return channel === "x" ? "bottom" : "left";
}
function defaultTickCount({ fieldOrDatumDef, scaleType: scaleType2, size, values: vals2 }) {
  var _a2;
  if (!vals2 && !hasDiscreteDomain(scaleType2) && scaleType2 !== "log") {
    if (isFieldDef(fieldOrDatumDef)) {
      if (isBinning(fieldOrDatumDef.bin)) {
        return { signal: `ceil(${size.signal}/10)` };
      }
      if (fieldOrDatumDef.timeUnit && contains2(["month", "hours", "day", "quarter"], (_a2 = normalizeTimeUnit(fieldOrDatumDef.timeUnit)) == null ? void 0 : _a2.unit)) {
        return void 0;
      }
    }
    return { signal: `ceil(${size.signal}/40)` };
  }
  return void 0;
}
function defaultTickMinStep({ format: format14, fieldOrDatumDef }) {
  if (format14 === "d") {
    return 1;
  }
  if (isFieldDef(fieldOrDatumDef)) {
    const { timeUnit } = fieldOrDatumDef;
    if (timeUnit) {
      const signal = durationExpr(timeUnit);
      if (signal) {
        return { signal };
      }
    }
  }
  return void 0;
}
function getFieldDefTitle(model, channel) {
  const channel2 = channel === "x" ? "x2" : "y2";
  const fieldDef = model.fieldDef(channel);
  const fieldDef2 = model.fieldDef(channel2);
  const title1 = fieldDef ? fieldDef.title : void 0;
  const title2 = fieldDef2 ? fieldDef2.title : void 0;
  if (title1 && title2) {
    return mergeTitle(title1, title2);
  } else if (title1) {
    return title1;
  } else if (title2) {
    return title2;
  } else if (title1 !== void 0) {
    return title1;
  } else if (title2 !== void 0) {
    return title2;
  }
  return void 0;
}
function values$1(axis, fieldOrDatumDef) {
  const vals2 = axis.values;
  if (isArray22(vals2)) {
    return valueArray(fieldOrDatumDef, vals2);
  } else if (isSignalRef(vals2)) {
    return vals2;
  }
  return void 0;
}
function defaultZindex(mark, fieldDef) {
  if (mark === "rect" && isDiscrete7(fieldDef)) {
    return 1;
  }
  return 0;
}
var CalculateNode = class _CalculateNode extends DataFlowNode {
  constructor(parent, transform4) {
    super(parent);
    __publicField(this, "transform");
    __publicField(this, "_dependentFields");
    this.transform = transform4;
    this._dependentFields = getDependentFields(this.transform.calculate);
  }
  clone() {
    return new _CalculateNode(null, duplicate(this.transform));
  }
  static parseAllForSortIndex(parent, model) {
    model.forEachFieldDef((fieldDef, channel) => {
      if (!isScaleFieldDef(fieldDef)) {
        return;
      }
      if (isSortArray(fieldDef.sort)) {
        const { field: field25, timeUnit } = fieldDef;
        const sort4 = fieldDef.sort;
        const calculate = sort4.map((sortValue, i) => {
          return `${fieldFilterExpression({ field: field25, timeUnit, equal: sortValue })} ? ${i} : `;
        }).join("") + sort4.length;
        parent = new _CalculateNode(parent, {
          calculate,
          as: sortArrayIndexField(fieldDef, channel, { forAs: true })
        });
      }
    });
    return parent;
  }
  producedFields() {
    return /* @__PURE__ */ new Set([this.transform.as]);
  }
  dependentFields() {
    return this._dependentFields;
  }
  assemble() {
    return {
      type: "formula",
      expr: this.transform.calculate,
      as: this.transform.as
    };
  }
  hash() {
    return `Calculate ${hash(this.transform)}`;
  }
};
function sortArrayIndexField(fieldDef, channel, opt) {
  return vgField(fieldDef, { prefix: channel, suffix: "sort_index", ...opt });
}
function getHeaderChannel(channel, orient2) {
  if (contains2(["top", "bottom"], orient2)) {
    return "column";
  } else if (contains2(["left", "right"], orient2)) {
    return "row";
  }
  return channel === "row" ? "row" : "column";
}
function getHeaderProperty(prop, header, config, channel) {
  const headerSpecificConfig = channel === "row" ? config.headerRow : channel === "column" ? config.headerColumn : config.headerFacet;
  return getFirstDefined((header || {})[prop], headerSpecificConfig[prop], config.header[prop]);
}
function getHeaderProperties(properties, header, config, channel) {
  const props = {};
  for (const prop of properties) {
    const value7 = getHeaderProperty(prop, header || {}, config, channel);
    if (value7 !== void 0) {
      props[prop] = value7;
    }
  }
  return props;
}
var HEADER_CHANNELS = ["row", "column"];
var HEADER_TYPES = ["header", "footer"];
function assembleTitleGroup(model, channel) {
  const title2 = model.component.layoutHeaders[channel].title;
  const config = model.config ? model.config : void 0;
  const facetFieldDef = model.component.layoutHeaders[channel].facetFieldDef ? model.component.layoutHeaders[channel].facetFieldDef : void 0;
  const { titleAnchor, titleAngle: ta, titleOrient } = getHeaderProperties(["titleAnchor", "titleAngle", "titleOrient"], facetFieldDef.header, config, channel);
  const headerChannel = getHeaderChannel(channel, titleOrient);
  const titleAngle = normalizeAngle(ta);
  return {
    name: `${channel}-title`,
    type: "group",
    role: `${headerChannel}-title`,
    title: {
      text: title2,
      ...channel === "row" ? { orient: "left" } : {},
      style: "guide-title",
      ...defaultHeaderGuideBaseline(titleAngle, headerChannel),
      ...defaultHeaderGuideAlign(headerChannel, titleAngle, titleAnchor),
      ...assembleHeaderProperties(config, facetFieldDef, channel, HEADER_TITLE_PROPERTIES, HEADER_TITLE_PROPERTIES_MAP)
    }
  };
}
function defaultHeaderGuideAlign(headerChannel, angle2, anchor = "middle") {
  switch (anchor) {
    case "start":
      return { align: "left" };
    case "end":
      return { align: "right" };
  }
  const align2 = defaultLabelAlign(angle2, headerChannel === "row" ? "left" : "top", headerChannel === "row" ? "y" : "x");
  return align2 ? { align: align2 } : {};
}
function defaultHeaderGuideBaseline(angle2, channel) {
  const baseline3 = defaultLabelBaseline(angle2, channel === "row" ? "left" : "top", channel === "row" ? "y" : "x", true);
  return baseline3 ? { baseline: baseline3 } : {};
}
function assembleHeaderGroups(model, channel) {
  const layoutHeader = model.component.layoutHeaders[channel];
  const groups2 = [];
  for (const headerType of HEADER_TYPES) {
    if (layoutHeader[headerType]) {
      for (const headerComponent of layoutHeader[headerType]) {
        const group7 = assembleHeaderGroup(model, channel, headerType, layoutHeader, headerComponent);
        if (group7 != null) {
          groups2.push(group7);
        }
      }
    }
  }
  return groups2;
}
function getSort$1(facetFieldDef, channel) {
  const { sort: sort4 } = facetFieldDef;
  if (isSortField(sort4)) {
    return {
      field: vgField(sort4, { expr: "datum" }),
      order: sort4.order ?? "ascending"
    };
  } else if (isArray22(sort4)) {
    return {
      field: sortArrayIndexField(facetFieldDef, channel, { expr: "datum" }),
      order: "ascending"
    };
  } else {
    return {
      field: vgField(facetFieldDef, { expr: "datum" }),
      order: sort4 ?? "ascending"
    };
  }
}
function assembleLabelTitle(facetFieldDef, channel, config) {
  const { format: format14, formatType, labelAngle, labelAnchor, labelOrient, labelExpr } = getHeaderProperties(["format", "formatType", "labelAngle", "labelAnchor", "labelOrient", "labelExpr"], facetFieldDef.header, config, channel);
  const titleTextExpr = formatSignalRef({
    fieldOrDatumDef: facetFieldDef,
    format: format14,
    formatType,
    expr: "parent",
    config
  }).signal;
  const headerChannel = getHeaderChannel(channel, labelOrient);
  return {
    text: {
      signal: labelExpr ? replaceAll(replaceAll(labelExpr, "datum.label", titleTextExpr), "datum.value", vgField(facetFieldDef, { expr: "parent" })) : titleTextExpr
    },
    ...channel === "row" ? { orient: "left" } : {},
    style: "guide-label",
    frame: "group",
    ...defaultHeaderGuideBaseline(labelAngle, headerChannel),
    ...defaultHeaderGuideAlign(headerChannel, labelAngle, labelAnchor),
    ...assembleHeaderProperties(config, facetFieldDef, channel, HEADER_LABEL_PROPERTIES, HEADER_LABEL_PROPERTIES_MAP)
  };
}
function assembleHeaderGroup(model, channel, headerType, layoutHeader, headerComponent) {
  if (headerComponent) {
    let title2 = null;
    const { facetFieldDef } = layoutHeader;
    const config = model.config ? model.config : void 0;
    if (facetFieldDef && headerComponent.labels) {
      const { labelOrient } = getHeaderProperties(["labelOrient"], facetFieldDef.header, config, channel);
      if (channel === "row" && !contains2(["top", "bottom"], labelOrient) || channel === "column" && !contains2(["left", "right"], labelOrient)) {
        title2 = assembleLabelTitle(facetFieldDef, channel, config);
      }
    }
    const isFacetWithoutRowCol = isFacetModel(model) && !isFacetMapping(model.facet);
    const axes = headerComponent.axes;
    const hasAxes = (axes == null ? void 0 : axes.length) > 0;
    if (title2 || hasAxes) {
      const sizeChannel = channel === "row" ? "height" : "width";
      return {
        name: model.getName(`${channel}_${headerType}`),
        type: "group",
        role: `${channel}-${headerType}`,
        ...layoutHeader.facetFieldDef ? {
          from: { data: model.getName(`${channel}_domain`) },
          sort: getSort$1(facetFieldDef, channel)
        } : {},
        ...hasAxes && isFacetWithoutRowCol ? {
          from: { data: model.getName(`facet_domain_${channel}`) }
        } : {},
        ...title2 ? { title: title2 } : {},
        ...headerComponent.sizeSignal ? {
          encode: {
            update: {
              [sizeChannel]: headerComponent.sizeSignal
            }
          }
        } : {},
        ...hasAxes ? { axes } : {}
      };
    }
  }
  return null;
}
var LAYOUT_TITLE_BAND = {
  column: {
    start: 0,
    end: 1
  },
  row: {
    start: 1,
    end: 0
  }
};
function getLayoutTitleBand(titleAnchor, headerChannel) {
  return LAYOUT_TITLE_BAND[headerChannel][titleAnchor];
}
function assembleLayoutTitleBand(headerComponentIndex, config) {
  const titleBand = {};
  for (const channel of FACET_CHANNELS) {
    const headerComponent = headerComponentIndex[channel];
    if (headerComponent == null ? void 0 : headerComponent.facetFieldDef) {
      const { titleAnchor, titleOrient } = getHeaderProperties(["titleAnchor", "titleOrient"], headerComponent.facetFieldDef.header, config, channel);
      const headerChannel = getHeaderChannel(channel, titleOrient);
      const band11 = getLayoutTitleBand(titleAnchor, headerChannel);
      if (band11 !== void 0) {
        titleBand[headerChannel] = band11;
      }
    }
  }
  return isEmpty(titleBand) ? void 0 : titleBand;
}
function assembleHeaderProperties(config, facetFieldDef, channel, properties, propertiesMap) {
  const props = {};
  for (const prop of properties) {
    if (!propertiesMap[prop]) {
      continue;
    }
    const value7 = getHeaderProperty(prop, facetFieldDef == null ? void 0 : facetFieldDef.header, config, channel);
    if (value7 !== void 0) {
      props[propertiesMap[prop]] = value7;
    }
  }
  return props;
}
function assembleLayoutSignals(model) {
  return [
    ...sizeSignals(model, "width"),
    ...sizeSignals(model, "height"),
    ...sizeSignals(model, "childWidth"),
    ...sizeSignals(model, "childHeight")
  ];
}
function sizeSignals(model, sizeType) {
  const channel = sizeType === "width" ? "x" : "y";
  const size = model.component.layoutSize.get(sizeType);
  if (size == null || size === "merged") {
    return [];
  }
  const name = model.getSizeSignalRef(sizeType).signal;
  if (size === "step") {
    const scaleComponent = model.getScaleComponent(channel);
    if (scaleComponent) {
      const type7 = scaleComponent.get("type");
      const range7 = scaleComponent.get("range");
      if (hasDiscreteDomain(type7) && isVgRangeStep(range7)) {
        const scaleName = model.scaleName(channel);
        if (isFacetModel(model.parent)) {
          const parentResolve = model.parent.component.resolve;
          if (parentResolve.scale[channel] === "independent") {
            return [stepSignal(scaleName, range7)];
          }
        }
        return [
          stepSignal(scaleName, range7),
          {
            name,
            update: sizeExpr(scaleName, scaleComponent, `domain('${scaleName}').length`)
          }
        ];
      }
    }
    throw new Error("layout size is step although width/height is not step.");
  } else if (size == "container") {
    const isWidth = name.endsWith("width");
    const expr2 = isWidth ? "containerSize()[0]" : "containerSize()[1]";
    const defaultValue = getViewConfigContinuousSize(model.config.view, isWidth ? "width" : "height");
    const safeExpr = `isFinite(${expr2}) ? ${expr2} : ${defaultValue}`;
    return [{ name, init: safeExpr, on: [{ update: safeExpr, events: "window:resize" }] }];
  } else {
    return [
      {
        name,
        value: size
      }
    ];
  }
}
function stepSignal(scaleName, range7) {
  const name = `${scaleName}_step`;
  if (isSignalRef(range7.step)) {
    return { name, update: range7.step.signal };
  } else {
    return { name, value: range7.step };
  }
}
function sizeExpr(scaleName, scaleComponent, cardinality) {
  const type7 = scaleComponent.get("type");
  const padding3 = scaleComponent.get("padding");
  const paddingOuter2 = getFirstDefined(scaleComponent.get("paddingOuter"), padding3);
  let paddingInner2 = scaleComponent.get("paddingInner");
  paddingInner2 = type7 === "band" ? (
    // only band has real paddingInner
    paddingInner2 !== void 0 ? paddingInner2 : padding3
  ) : (
    // For point, as calculated in https://github.com/vega/vega-scale/blob/master/src/band.js#L128,
    // it's equivalent to have paddingInner = 1 since there is only n-1 steps between n points.
    1
  );
  return `bandspace(${cardinality}, ${signalOrStringValue(paddingInner2)}, ${signalOrStringValue(paddingOuter2)}) * ${scaleName}_step`;
}
function getSizeTypeFromLayoutSizeType(layoutSizeType) {
  return layoutSizeType === "childWidth" ? "width" : layoutSizeType === "childHeight" ? "height" : layoutSizeType;
}
function guideEncodeEntry(encoding, model) {
  return keys4(encoding).reduce((encode2, channel) => {
    return {
      ...encode2,
      ...wrapCondition({
        model,
        channelDef: encoding[channel],
        vgChannel: channel,
        mainRefFn: (def6) => signalOrValueRef(def6.value),
        invalidValueRef: void 0
        // guide encoding won't show invalid values for the scale
      })
    };
  }, {});
}
function defaultScaleResolve(channel, model) {
  if (isFacetModel(model)) {
    return channel === "theta" ? "independent" : "shared";
  } else if (isLayerModel(model)) {
    return "shared";
  } else if (isConcatModel(model)) {
    return isXorY(channel) || channel === "theta" || channel === "radius" ? "independent" : "shared";
  }
  throw new Error("invalid model type for resolve");
}
function parseGuideResolve(resolve2, channel) {
  const channelScaleResolve = resolve2.scale[channel];
  const guide = isXorY(channel) ? "axis" : "legend";
  if (channelScaleResolve === "independent") {
    if (resolve2[guide][channel] === "shared") {
      warn2(independentScaleMeansIndependentGuide(channel));
    }
    return "independent";
  }
  return resolve2[guide][channel] || "shared";
}
var LEGEND_COMPONENT_PROPERTY_INDEX = {
  ...COMMON_LEGEND_PROPERTY_INDEX,
  disable: 1,
  labelExpr: 1,
  selections: 1,
  // channel scales
  opacity: 1,
  shape: 1,
  stroke: 1,
  fill: 1,
  size: 1,
  strokeWidth: 1,
  strokeDash: 1,
  // encode
  encode: 1
};
var LEGEND_COMPONENT_PROPERTIES = keys4(LEGEND_COMPONENT_PROPERTY_INDEX);
var LegendComponent = class extends Split {
};
var legendEncodeRules = {
  symbols: symbols15,
  gradient: gradient7,
  labels: labels$1,
  entries
};
function symbols15(symbolsSpec, { fieldOrDatumDef, model, channel, legendCmpt, legendType: legendType2 }) {
  if (legendType2 !== "symbol") {
    return void 0;
  }
  const { markDef, encoding, config, mark } = model;
  const filled = markDef.filled && mark !== "trail";
  let out = {
    ...applyMarkConfig({}, model, FILL_STROKE_CONFIG),
    ...color8(model, { filled })
  };
  const symbolOpacity = legendCmpt.get("symbolOpacity") ?? config.legend.symbolOpacity;
  const symbolFillColor = legendCmpt.get("symbolFillColor") ?? config.legend.symbolFillColor;
  const symbolStrokeColor = legendCmpt.get("symbolStrokeColor") ?? config.legend.symbolStrokeColor;
  const opacity2 = symbolOpacity === void 0 ? getMaxValue(encoding.opacity) ?? markDef.opacity : void 0;
  if (out.fill) {
    if (channel === "fill" || filled && channel === COLOR) {
      delete out.fill;
    } else if (hasProperty(out.fill, "field")) {
      if (symbolFillColor) {
        delete out.fill;
      } else {
        out.fill = signalOrValueRef(config.legend.symbolBaseFillColor ?? "black");
        out.fillOpacity = signalOrValueRef(opacity2 ?? 1);
      }
    } else if (isArray22(out.fill)) {
      const fill6 = getFirstConditionValue(encoding.fill ?? encoding.color) ?? markDef.fill ?? (filled && markDef.color);
      if (fill6) {
        out.fill = signalOrValueRef(fill6);
      }
    }
  }
  if (out.stroke) {
    if (channel === "stroke" || !filled && channel === COLOR) {
      delete out.stroke;
    } else if (hasProperty(out.stroke, "field") || symbolStrokeColor) {
      delete out.stroke;
    } else if (isArray22(out.stroke)) {
      const stroke6 = getFirstDefined(getFirstConditionValue(encoding.stroke || encoding.color), markDef.stroke, filled ? markDef.color : void 0);
      if (stroke6) {
        out.stroke = { value: stroke6 };
      }
    }
  }
  if (channel !== OPACITY) {
    const condition = isFieldDef(fieldOrDatumDef) && selectedCondition(model, legendCmpt, fieldOrDatumDef);
    if (condition) {
      out.opacity = [
        { test: condition, ...signalOrValueRef(opacity2 ?? 1) },
        signalOrValueRef(config.legend.unselectedOpacity)
      ];
    } else if (opacity2) {
      out.opacity = signalOrValueRef(opacity2);
    }
  }
  out = { ...out, ...symbolsSpec };
  return isEmpty(out) ? void 0 : out;
}
function gradient7(gradientSpec, { model, legendType: legendType2, legendCmpt }) {
  if (legendType2 !== "gradient") {
    return void 0;
  }
  const { config, markDef, encoding } = model;
  let out = {};
  const gradientOpacity = legendCmpt.get("gradientOpacity") ?? config.legend.gradientOpacity;
  const opacity2 = gradientOpacity === void 0 ? getMaxValue(encoding.opacity) || markDef.opacity : void 0;
  if (opacity2) {
    out.opacity = signalOrValueRef(opacity2);
  }
  out = { ...out, ...gradientSpec };
  return isEmpty(out) ? void 0 : out;
}
function labels$1(specifiedlabelsSpec, { fieldOrDatumDef, model, channel, legendCmpt }) {
  const legend = model.legend(channel) || {};
  const config = model.config;
  const condition = isFieldDef(fieldOrDatumDef) ? selectedCondition(model, legendCmpt, fieldOrDatumDef) : void 0;
  const opacity2 = condition ? [{ test: condition, value: 1 }, { value: config.legend.unselectedOpacity }] : void 0;
  const { format: format14, formatType } = legend;
  let text7 = void 0;
  if (isCustomFormatType(formatType)) {
    text7 = formatCustomType({
      fieldOrDatumDef,
      field: "datum.value",
      format: format14,
      formatType,
      config
    });
  } else if (format14 === void 0 && formatType === void 0 && config.customFormatTypes) {
    if (fieldOrDatumDef.type === "quantitative" && config.numberFormatType) {
      text7 = formatCustomType({
        fieldOrDatumDef,
        field: "datum.value",
        format: config.numberFormat,
        formatType: config.numberFormatType,
        config
      });
    } else if (fieldOrDatumDef.type === "temporal" && config.timeFormatType && isFieldDef(fieldOrDatumDef) && fieldOrDatumDef.timeUnit === void 0) {
      text7 = formatCustomType({
        fieldOrDatumDef,
        field: "datum.value",
        format: config.timeFormat,
        formatType: config.timeFormatType,
        config
      });
    }
  }
  const labelsSpec = {
    ...opacity2 ? { opacity: opacity2 } : {},
    ...text7 ? { text: text7 } : {},
    ...specifiedlabelsSpec
  };
  return isEmpty(labelsSpec) ? void 0 : labelsSpec;
}
function entries(entriesSpec, { legendCmpt }) {
  const selections = legendCmpt.get("selections");
  return (selections == null ? void 0 : selections.length) ? { ...entriesSpec, fill: { value: "transparent" } } : entriesSpec;
}
function getMaxValue(channelDef) {
  return getConditionValue(channelDef, (v2, conditionalDef) => Math.max(v2, conditionalDef.value));
}
function getFirstConditionValue(channelDef) {
  return getConditionValue(channelDef, (v2, conditionalDef) => {
    return getFirstDefined(v2, conditionalDef.value);
  });
}
function getConditionValue(channelDef, reducer) {
  if (hasConditionalValueDef(channelDef)) {
    return array21(channelDef.condition).reduce(reducer, channelDef.value);
  } else if (isValueDef(channelDef)) {
    return channelDef.value;
  }
  return void 0;
}
function selectedCondition(model, legendCmpt, fieldDef) {
  const selections = legendCmpt.get("selections");
  if (!(selections == null ? void 0 : selections.length))
    return void 0;
  const field25 = $10(fieldDef.field);
  return selections.map((name) => {
    const store = $10(varName(name) + STORE);
    return `(!length(data(${store})) || (${name}[${field25}] && indexof(${name}[${field25}], datum.value) >= 0))`;
  }).join(" || ");
}
var legendRules = {
  direction: ({ direction }) => direction,
  format: ({ fieldOrDatumDef, legend, config }) => {
    const { format: format14, formatType } = legend;
    return guideFormat(fieldOrDatumDef, fieldOrDatumDef.type, format14, formatType, config, false);
  },
  formatType: ({ legend, fieldOrDatumDef, scaleType: scaleType2 }) => {
    const { formatType } = legend;
    return guideFormatType(formatType, fieldOrDatumDef, scaleType2);
  },
  gradientLength: (params2) => {
    const { legend, legendConfig } = params2;
    return legend.gradientLength ?? legendConfig.gradientLength ?? defaultGradientLength(params2);
  },
  labelOverlap: ({ legend, legendConfig, scaleType: scaleType2 }) => legend.labelOverlap ?? legendConfig.labelOverlap ?? defaultLabelOverlap(scaleType2),
  symbolType: ({ legend, markDef, channel, encoding }) => legend.symbolType ?? defaultSymbolType(markDef.type, channel, encoding.shape, markDef.shape),
  title: ({ fieldOrDatumDef, config }) => title(fieldOrDatumDef, config, { allowDisabling: true }),
  type: ({ legendType: legendType2, scaleType: scaleType2, channel }) => {
    if (isColorChannel(channel) && isContinuousToContinuous(scaleType2)) {
      if (legendType2 === "gradient") {
        return void 0;
      }
    } else if (legendType2 === "symbol") {
      return void 0;
    }
    return legendType2;
  },
  // depended by other property, let's define upfront
  values: ({ fieldOrDatumDef, legend }) => values6(legend, fieldOrDatumDef)
};
function values6(legend, fieldOrDatumDef) {
  const vals2 = legend.values;
  if (isArray22(vals2)) {
    return valueArray(fieldOrDatumDef, vals2);
  } else if (isSignalRef(vals2)) {
    return vals2;
  }
  return void 0;
}
function defaultSymbolType(mark, channel, shapeChannelDef, markShape) {
  if (channel !== "shape") {
    const shape6 = getFirstConditionValue(shapeChannelDef) ?? markShape;
    if (shape6) {
      return shape6;
    }
  }
  switch (mark) {
    case "bar":
    case "rect":
    case "image":
    case "square":
      return "square";
    case "line":
    case "trail":
    case "rule":
      return "stroke";
    case "arc":
    case "point":
    case "circle":
    case "tick":
    case "geoshape":
    case "area":
    case "text":
      return "circle";
  }
}
function getLegendType(params2) {
  const { legend } = params2;
  return getFirstDefined(legend.type, defaultType$1(params2));
}
function defaultType$1({ channel, timeUnit, scaleType: scaleType2 }) {
  if (isColorChannel(channel)) {
    if (contains2(["quarter", "month", "day"], timeUnit)) {
      return "symbol";
    }
    if (isContinuousToContinuous(scaleType2)) {
      return "gradient";
    }
  }
  return "symbol";
}
function getDirection({ legendConfig, legendType: legendType2, orient: orient2, legend }) {
  return legend.direction ?? legendConfig[legendType2 ? "gradientDirection" : "symbolDirection"] ?? defaultDirection(orient2, legendType2);
}
function defaultDirection(orient2, legendType2) {
  switch (orient2) {
    case "top":
    case "bottom":
      return "horizontal";
    case "left":
    case "right":
    case "none":
    case void 0:
      return void 0;
    default:
      return legendType2 === "gradient" ? "horizontal" : void 0;
  }
}
function defaultGradientLength({ legendConfig, model, direction, orient: orient2, scaleType: scaleType2 }) {
  const { gradientHorizontalMaxLength, gradientHorizontalMinLength, gradientVerticalMaxLength, gradientVerticalMinLength } = legendConfig;
  if (isContinuousToContinuous(scaleType2)) {
    if (direction === "horizontal") {
      if (orient2 === "top" || orient2 === "bottom") {
        return gradientLengthSignal(model, "width", gradientHorizontalMinLength, gradientHorizontalMaxLength);
      } else {
        return gradientHorizontalMinLength;
      }
    } else {
      return gradientLengthSignal(model, "height", gradientVerticalMinLength, gradientVerticalMaxLength);
    }
  }
  return void 0;
}
function gradientLengthSignal(model, sizeType, min5, max5) {
  const sizeSignal = model.getSizeSignalRef(sizeType).signal;
  return { signal: `clamp(${sizeSignal}, ${min5}, ${max5})` };
}
function defaultLabelOverlap(scaleType2) {
  if (contains2(["quantile", "threshold", "log", "symlog"], scaleType2)) {
    return "greedy";
  }
  return void 0;
}
function parseLegend2(model) {
  const legendComponent = isUnitModel(model) ? parseUnitLegend(model) : parseNonUnitLegend(model);
  model.component.legends = legendComponent;
  return legendComponent;
}
function parseUnitLegend(model) {
  const { encoding } = model;
  const legendComponent = {};
  for (const channel of [COLOR, ...LEGEND_SCALE_CHANNELS]) {
    const def6 = getFieldOrDatumDef(encoding[channel]);
    if (!def6 || !model.getScaleComponent(channel)) {
      continue;
    }
    if (channel === SHAPE && isFieldDef(def6) && def6.type === GEOJSON) {
      continue;
    }
    legendComponent[channel] = parseLegendForChannel(model, channel);
  }
  return legendComponent;
}
function getLegendDefWithScale(model, channel) {
  const scale19 = model.scaleName(channel);
  if (model.mark === "trail") {
    if (channel === "color") {
      return { stroke: scale19 };
    } else if (channel === "size") {
      return { strokeWidth: scale19 };
    }
  }
  if (channel === "color") {
    return model.markDef.filled ? { fill: scale19 } : { stroke: scale19 };
  }
  return { [channel]: scale19 };
}
function isExplicit$1(value7, property2, legend, fieldDef) {
  switch (property2) {
    case "disable":
      return legend !== void 0;
    case "values":
      return !!(legend == null ? void 0 : legend.values);
    case "title":
      if (property2 === "title" && value7 === (fieldDef == null ? void 0 : fieldDef.title)) {
        return true;
      }
  }
  return value7 === (legend || {})[property2];
}
function parseLegendForChannel(model, channel) {
  var _a2;
  let legend = model.legend(channel);
  const { markDef, encoding, config } = model;
  const legendConfig = config.legend;
  const legendCmpt = new LegendComponent({}, getLegendDefWithScale(model, channel));
  parseInteractiveLegend(model, channel, legendCmpt);
  const disable = legend !== void 0 ? !legend : legendConfig.disable;
  legendCmpt.set("disable", disable, legend !== void 0);
  if (disable) {
    return legendCmpt;
  }
  legend = legend || {};
  const scaleType2 = model.getScaleComponent(channel).get("type");
  const fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]);
  const timeUnit = isFieldDef(fieldOrDatumDef) ? (_a2 = normalizeTimeUnit(fieldOrDatumDef.timeUnit)) == null ? void 0 : _a2.unit : void 0;
  const orient2 = legend.orient || config.legend.orient || "right";
  const legendType2 = getLegendType({ legend, channel, timeUnit, scaleType: scaleType2 });
  const direction = getDirection({ legend, legendType: legendType2, orient: orient2, legendConfig });
  const ruleParams = {
    legend,
    channel,
    model,
    markDef,
    encoding,
    fieldOrDatumDef,
    legendConfig,
    config,
    scaleType: scaleType2,
    orient: orient2,
    legendType: legendType2,
    direction
  };
  for (const property2 of LEGEND_COMPONENT_PROPERTIES) {
    if (legendType2 === "gradient" && property2.startsWith("symbol") || legendType2 === "symbol" && property2.startsWith("gradient")) {
      continue;
    }
    const value7 = property2 in legendRules ? legendRules[property2](ruleParams) : legend[property2];
    if (value7 !== void 0) {
      const explicit = isExplicit$1(value7, property2, legend, model.fieldDef(channel));
      if (explicit || config.legend[property2] === void 0) {
        legendCmpt.set(property2, value7, explicit);
      }
    }
  }
  const legendEncoding = (legend == null ? void 0 : legend.encoding) ?? {};
  const selections = legendCmpt.get("selections");
  const legendEncode = {};
  const legendEncodeParams = { fieldOrDatumDef, model, channel, legendCmpt, legendType: legendType2 };
  for (const part of ["labels", "legend", "title", "symbols", "gradient", "entries"]) {
    const legendEncodingPart = guideEncodeEntry(legendEncoding[part] ?? {}, model);
    const value7 = part in legendEncodeRules ? legendEncodeRules[part](legendEncodingPart, legendEncodeParams) : legendEncodingPart;
    if (value7 !== void 0 && !isEmpty(value7)) {
      legendEncode[part] = {
        ...(selections == null ? void 0 : selections.length) && isFieldDef(fieldOrDatumDef) ? { name: `${varName(fieldOrDatumDef.field)}_legend_${part}` } : {},
        ...(selections == null ? void 0 : selections.length) ? { interactive: true } : {},
        update: (selections == null ? void 0 : selections.length) ? { ...value7, cursor: { value: "pointer" } } : value7
      };
    }
  }
  if (!isEmpty(legendEncode)) {
    legendCmpt.set("encode", legendEncode, !!(legend == null ? void 0 : legend.encoding));
  }
  return legendCmpt;
}
function parseNonUnitLegend(model) {
  const { legends, resolve: resolve2 } = model.component;
  for (const child of model.children) {
    parseLegend2(child);
    for (const channel of keys4(child.component.legends)) {
      resolve2.legend[channel] = parseGuideResolve(model.component.resolve, channel);
      if (resolve2.legend[channel] === "shared") {
        legends[channel] = mergeLegendComponent(legends[channel], child.component.legends[channel]);
        if (!legends[channel]) {
          resolve2.legend[channel] = "independent";
          delete legends[channel];
        }
      }
    }
  }
  for (const channel of keys4(legends)) {
    for (const child of model.children) {
      if (!child.component.legends[channel]) {
        continue;
      }
      if (resolve2.legend[channel] === "shared") {
        delete child.component.legends[channel];
      }
    }
  }
  return legends;
}
function mergeLegendComponent(mergedLegend, childLegend) {
  var _a2, _b, _c2, _d2;
  if (!mergedLegend) {
    return childLegend.clone();
  }
  const mergedOrient = mergedLegend.getWithExplicit("orient");
  const childOrient = childLegend.getWithExplicit("orient");
  if (mergedOrient.explicit && childOrient.explicit && mergedOrient.value !== childOrient.value) {
    return void 0;
  }
  let typeMerged = false;
  for (const prop of LEGEND_COMPONENT_PROPERTIES) {
    const mergedValueWithExplicit = mergeValuesWithExplicit(
      mergedLegend.getWithExplicit(prop),
      childLegend.getWithExplicit(prop),
      prop,
      "legend",
      // Tie breaker function
      (v1, v2) => {
        switch (prop) {
          case "symbolType":
            return mergeSymbolType(v1, v2);
          case "title":
            return mergeTitleComponent(v1, v2);
          case "type":
            typeMerged = true;
            return makeImplicit("symbol");
        }
        return defaultTieBreaker(v1, v2, prop, "legend");
      }
    );
    mergedLegend.setWithExplicit(prop, mergedValueWithExplicit);
  }
  if (typeMerged) {
    if ((_b = (_a2 = mergedLegend.implicit) == null ? void 0 : _a2.encode) == null ? void 0 : _b.gradient) {
      deleteNestedProperty(mergedLegend.implicit, ["encode", "gradient"]);
    }
    if ((_d2 = (_c2 = mergedLegend.explicit) == null ? void 0 : _c2.encode) == null ? void 0 : _d2.gradient) {
      deleteNestedProperty(mergedLegend.explicit, ["encode", "gradient"]);
    }
  }
  return mergedLegend;
}
function mergeSymbolType(st1, st2) {
  if (st2.value === "circle") {
    return st2;
  }
  return st1;
}
function setLegendEncode(legend, part, vgProp, vgRef) {
  var _a2, _b;
  legend.encode ?? (legend.encode = {});
  (_a2 = legend.encode)[part] ?? (_a2[part] = {});
  (_b = legend.encode[part]).update ?? (_b.update = {});
  legend.encode[part].update[vgProp] = vgRef;
}
function assembleLegends(model) {
  const legendComponentIndex = model.component.legends;
  const legendByDomain = {};
  for (const channel of keys4(legendComponentIndex)) {
    const scaleComponent = model.getScaleComponent(channel);
    const domainHash = stringify2(scaleComponent.get("domains"));
    if (legendByDomain[domainHash]) {
      for (const mergedLegendComponent of legendByDomain[domainHash]) {
        const merged = mergeLegendComponent(mergedLegendComponent, legendComponentIndex[channel]);
        if (!merged) {
          legendByDomain[domainHash].push(legendComponentIndex[channel]);
        }
      }
    } else {
      legendByDomain[domainHash] = [legendComponentIndex[channel].clone()];
    }
  }
  const legends = vals(legendByDomain).flat().map((l) => assembleLegend(l, model.config)).filter((l) => l !== void 0);
  return legends;
}
function assembleLegend(legendCmpt, config) {
  var _a2, _b, _c2;
  const { disable, labelExpr, selections, ...legend } = legendCmpt.combine();
  if (disable) {
    return void 0;
  }
  if (config.aria === false && legend.aria == void 0) {
    legend.aria = false;
  }
  if ((_a2 = legend.encode) == null ? void 0 : _a2.symbols) {
    const out = legend.encode.symbols.update;
    if (out.fill && out.fill["value"] !== "transparent" && !out.stroke && !legend.stroke) {
      out.stroke = { value: "transparent" };
    }
    for (const property2 of LEGEND_SCALE_CHANNELS) {
      if (legend[property2]) {
        delete out[property2];
      }
    }
  }
  if (!legend.title) {
    delete legend.title;
  }
  if (labelExpr !== void 0) {
    let expr2 = labelExpr;
    if (((_c2 = (_b = legend.encode) == null ? void 0 : _b.labels) == null ? void 0 : _c2.update) && isSignalRef(legend.encode.labels.update.text)) {
      expr2 = replaceAll(labelExpr, "datum.label", legend.encode.labels.update.text.signal);
    }
    setLegendEncode(legend, "labels", "text", { signal: expr2 });
  }
  return legend;
}
function assembleProjections(model) {
  if (isLayerModel(model) || isConcatModel(model)) {
    return assembleProjectionsForModelAndChildren(model);
  } else {
    return assembleProjectionForModel(model);
  }
}
function assembleProjectionsForModelAndChildren(model) {
  return model.children.reduce((projections2, child) => {
    return projections2.concat(child.assembleProjections());
  }, assembleProjectionForModel(model));
}
function assembleProjectionForModel(model) {
  const component = model.component.projection;
  if (!component || component.merged) {
    return [];
  }
  const projection3 = component.combine();
  const { name } = projection3;
  if (!component.data) {
    return [
      {
        name,
        // translate to center by default
        translate: { signal: "[width / 2, height / 2]" },
        // parameters, overwrite default translate if specified
        ...projection3
      }
    ];
  } else {
    const size = {
      signal: `[${component.size.map((ref2) => ref2.signal).join(", ")}]`
    };
    const fits = component.data.reduce((sources, data3) => {
      const source3 = isSignalRef(data3) ? data3.signal : `data('${model.lookupDataSource(data3)}')`;
      if (!contains2(sources, source3)) {
        sources.push(source3);
      }
      return sources;
    }, []);
    if (fits.length <= 0) {
      throw new Error("Projection's fit didn't find any data sources");
    }
    return [
      {
        name,
        size,
        fit: {
          signal: fits.length > 1 ? `[${fits.join(", ")}]` : fits[0]
        },
        ...projection3
      }
    ];
  }
}
var PROJECTION_PROPERTIES = [
  "type",
  "clipAngle",
  "clipExtent",
  "center",
  "rotate",
  "precision",
  "reflectX",
  "reflectY",
  "coefficient",
  "distance",
  "fraction",
  "lobes",
  "parallel",
  "radius",
  "ratio",
  "spacing",
  "tilt"
];
var ProjectionComponent = class extends Split {
  constructor(name, specifiedProjection, size, data3) {
    super(
      { ...specifiedProjection },
      // all explicit properties of projection
      { name }
    );
    __publicField(this, "specifiedProjection");
    __publicField(this, "size");
    __publicField(this, "data");
    __publicField(this, "merged", false);
    this.specifiedProjection = specifiedProjection;
    this.size = size;
    this.data = data3;
  }
  /**
   * Whether the projection parameters should fit provided data.
   */
  get isFit() {
    return !!this.data;
  }
};
function parseProjection2(model) {
  model.component.projection = isUnitModel(model) ? parseUnitProjection(model) : parseNonUnitProjections(model);
}
function parseUnitProjection(model) {
  if (model.hasProjection) {
    const proj = replaceExprRef(model.specifiedProjection);
    const fit3 = !(proj && (proj.scale != null || proj.translate != null));
    const size = fit3 ? [model.getSizeSignalRef("width"), model.getSizeSignalRef("height")] : void 0;
    const data3 = fit3 ? gatherFitData(model) : void 0;
    const projComp = new ProjectionComponent(model.projectionName(true), {
      ...replaceExprRef(model.config.projection),
      ...proj
    }, size, data3);
    if (!projComp.get("type")) {
      projComp.set("type", "equalEarth", false);
    }
    return projComp;
  }
  return void 0;
}
function gatherFitData(model) {
  const data3 = [];
  const { encoding } = model;
  for (const posssiblePair of [
    [LONGITUDE, LATITUDE],
    [LONGITUDE2, LATITUDE2]
  ]) {
    if (getFieldOrDatumDef(encoding[posssiblePair[0]]) || getFieldOrDatumDef(encoding[posssiblePair[1]])) {
      data3.push({
        signal: model.getName(`geojson_${data3.length}`)
      });
    }
  }
  if (model.channelHasField(SHAPE) && model.typedFieldDef(SHAPE).type === GEOJSON) {
    data3.push({
      signal: model.getName(`geojson_${data3.length}`)
    });
  }
  if (data3.length === 0) {
    data3.push(model.requestDataName(DataSourceType.Main));
  }
  return data3;
}
function mergeIfNoConflict(first, second2) {
  const allPropertiesShared = every2(PROJECTION_PROPERTIES, (prop) => {
    if (!has19(first.explicit, prop) && !has19(second2.explicit, prop)) {
      return true;
    }
    if (has19(first.explicit, prop) && has19(second2.explicit, prop) && // some properties might be signals or objects and require hashing for comparison
    deepEqual(first.get(prop), second2.get(prop))) {
      return true;
    }
    return false;
  });
  const size = deepEqual(first.size, second2.size);
  if (size) {
    if (allPropertiesShared) {
      return first;
    } else if (deepEqual(first.explicit, {})) {
      return second2;
    } else if (deepEqual(second2.explicit, {})) {
      return first;
    }
  }
  return null;
}
function parseNonUnitProjections(model) {
  if (model.children.length === 0) {
    return void 0;
  }
  let nonUnitProjection;
  for (const child of model.children) {
    parseProjection2(child);
  }
  const mergable = every2(model.children, (child) => {
    const projection3 = child.component.projection;
    if (!projection3) {
      return true;
    } else if (!nonUnitProjection) {
      nonUnitProjection = projection3;
      return true;
    } else {
      const merge6 = mergeIfNoConflict(nonUnitProjection, projection3);
      if (merge6) {
        nonUnitProjection = merge6;
      }
      return !!merge6;
    }
  });
  if (nonUnitProjection && mergable) {
    const name = model.projectionName(true);
    const modelProjection = new ProjectionComponent(name, nonUnitProjection.specifiedProjection, nonUnitProjection.size, duplicate(nonUnitProjection.data));
    for (const child of model.children) {
      const projection3 = child.component.projection;
      if (projection3) {
        if (projection3.isFit) {
          modelProjection.data.push(...child.component.projection.data);
        }
        child.renameProjection(projection3.get("name"), name);
        projection3.merged = true;
      }
    }
    return modelProjection;
  }
  return void 0;
}
function rangeFormula(model, fieldDef, channel, config) {
  if (binRequiresRange(fieldDef, channel)) {
    const guide = isUnitModel(model) ? model.axis(channel) ?? model.legend(channel) ?? {} : {};
    const startField = vgField(fieldDef, { expr: "datum" });
    const endField = vgField(fieldDef, { expr: "datum", binSuffix: "end" });
    return {
      formulaAs: vgField(fieldDef, { binSuffix: "range", forAs: true }),
      formula: binFormatExpression(startField, endField, guide.format, guide.formatType, config)
    };
  }
  return {};
}
function binKey(bin5, field25) {
  return `${binToString(bin5)}_${field25}`;
}
function getSignalsFromModel(model, key4) {
  return {
    signal: model.getName(`${key4}_bins`),
    extentSignal: model.getName(`${key4}_extent`)
  };
}
function getBinSignalName(model, field25, bin5) {
  const normalizedBin = normalizeBin(bin5, void 0) ?? {};
  const key4 = binKey(normalizedBin, field25);
  return model.getName(`${key4}_bins`);
}
function isBinTransform(t) {
  return "as" in t;
}
function createBinComponent(t, bin5, model) {
  let as;
  let span12;
  if (isBinTransform(t)) {
    as = isString14(t.as) ? [t.as, `${t.as}_end`] : [t.as[0], t.as[1]];
  } else {
    as = [vgField(t, { forAs: true }), vgField(t, { binSuffix: "end", forAs: true })];
  }
  const normalizedBin = { ...normalizeBin(bin5, void 0) };
  const key4 = binKey(normalizedBin, t.field);
  const { signal, extentSignal } = getSignalsFromModel(model, key4);
  if (isParameterExtent(normalizedBin.extent)) {
    const ext = normalizedBin.extent;
    span12 = parseSelectionExtent(model, ext.param, ext);
    delete normalizedBin.extent;
  }
  const binComponent = {
    bin: normalizedBin,
    field: t.field,
    as: [as],
    ...signal ? { signal } : {},
    ...extentSignal ? { extentSignal } : {},
    ...span12 ? { span: span12 } : {}
  };
  return { key: key4, binComponent };
}
var BinNode = class _BinNode extends DataFlowNode {
  constructor(parent, bins2) {
    super(parent);
    __publicField(this, "bins");
    this.bins = bins2;
  }
  clone() {
    return new _BinNode(null, duplicate(this.bins));
  }
  static makeFromEncoding(parent, model) {
    const bins2 = model.reduceFieldDef((binComponentIndex, fieldDef, channel) => {
      if (isTypedFieldDef(fieldDef) && isBinning(fieldDef.bin)) {
        const { key: key4, binComponent } = createBinComponent(fieldDef, fieldDef.bin, model);
        binComponentIndex[key4] = {
          ...binComponent,
          ...binComponentIndex[key4],
          ...rangeFormula(model, fieldDef, channel, model.config)
        };
      }
      return binComponentIndex;
    }, {});
    if (isEmpty(bins2)) {
      return null;
    }
    return new _BinNode(parent, bins2);
  }
  /**
   * Creates a bin node from BinTransform.
   * The optional parameter should provide
   */
  static makeFromTransform(parent, t, model) {
    const { key: key4, binComponent } = createBinComponent(t, t.bin, model);
    return new _BinNode(parent, {
      [key4]: binComponent
    });
  }
  /**
   * Merge bin nodes. This method either integrates the bin config from the other node
   * or if this node already has a bin config, renames the corresponding signal in the model.
   */
  merge(other, renameSignal) {
    for (const key4 of keys4(other.bins)) {
      if (key4 in this.bins) {
        renameSignal(other.bins[key4].signal, this.bins[key4].signal);
        this.bins[key4].as = unique([...this.bins[key4].as, ...other.bins[key4].as], hash);
      } else {
        this.bins[key4] = other.bins[key4];
      }
    }
    for (const child of other.children) {
      other.removeChild(child);
      child.parent = this;
    }
    other.remove();
  }
  producedFields() {
    return new Set(vals(this.bins).map((c5) => c5.as).flat(2));
  }
  dependentFields() {
    return new Set(vals(this.bins).map((c5) => c5.field));
  }
  hash() {
    return `Bin ${hash(this.bins)}`;
  }
  assemble() {
    return vals(this.bins).flatMap((bin5) => {
      const transform4 = [];
      const [binAs, ...remainingAs] = bin5.as;
      const { extent: extent8, ...params2 } = bin5.bin;
      const binTrans = {
        type: "bin",
        field: replacePathInField(bin5.field),
        as: binAs,
        signal: bin5.signal,
        ...!isParameterExtent(extent8) ? { extent: extent8 } : { extent: null },
        ...bin5.span ? { span: { signal: `span(${bin5.span})` } } : {},
        ...params2
      };
      if (!extent8 && bin5.extentSignal) {
        transform4.push({
          type: "extent",
          field: replacePathInField(bin5.field),
          signal: bin5.extentSignal
        });
        binTrans.extent = { signal: bin5.extentSignal };
      }
      transform4.push(binTrans);
      for (const as of remainingAs) {
        for (let i = 0; i < 2; i++) {
          transform4.push({
            type: "formula",
            expr: vgField({ field: binAs[i] }, { expr: "datum" }),
            as: as[i]
          });
        }
      }
      if (bin5.formula) {
        transform4.push({
          type: "formula",
          expr: bin5.formula,
          as: bin5.formulaAs
        });
      }
      return transform4;
    });
  }
};
function addDimension(dims, channel, fieldDef, model) {
  var _a2;
  const channelDef2 = isUnitModel(model) ? model.encoding[getSecondaryRangeChannel(channel)] : void 0;
  if (isTypedFieldDef(fieldDef) && isUnitModel(model) && hasBandEnd(fieldDef, channelDef2, model.markDef, model.config)) {
    dims.add(vgField(fieldDef, {}));
    dims.add(vgField(fieldDef, { suffix: "end" }));
    const { mark, markDef, config } = model;
    const bandPosition = getBandPosition({ fieldDef, markDef, config });
    if (isRectBasedMark(mark) && bandPosition !== 0.5 && isXorY(channel)) {
      dims.add(vgField(fieldDef, { suffix: OFFSETTED_RECT_START_SUFFIX }));
      dims.add(vgField(fieldDef, { suffix: OFFSETTED_RECT_END_SUFFIX }));
    }
    if (fieldDef.bin && binRequiresRange(fieldDef, channel)) {
      dims.add(vgField(fieldDef, { binSuffix: "range" }));
    }
  } else if (isGeoPositionChannel(channel)) {
    const posChannel = getPositionChannelFromLatLong(channel);
    dims.add(model.getName(posChannel));
  } else {
    dims.add(vgField(fieldDef));
  }
  if (isScaleFieldDef(fieldDef) && isFieldRange((_a2 = fieldDef.scale) == null ? void 0 : _a2.range)) {
    dims.add(fieldDef.scale.range.field);
  }
  return dims;
}
function mergeMeasures(parentMeasures, childMeasures) {
  for (const field25 of keys4(childMeasures)) {
    const ops2 = childMeasures[field25];
    for (const op of keys4(ops2)) {
      if (field25 in parentMeasures) {
        parentMeasures[field25][op] = /* @__PURE__ */ new Set([...parentMeasures[field25][op] ?? [], ...ops2[op]]);
      } else {
        parentMeasures[field25] = { [op]: ops2[op] };
      }
    }
  }
}
var AggregateNode = class _AggregateNode extends DataFlowNode {
  /**
   * @param dimensions string set for dimensions
   * @param measures dictionary mapping field name => dict of aggregation functions and names to use
   */
  constructor(parent, dimensions, measures) {
    super(parent);
    __publicField(this, "dimensions");
    __publicField(this, "measures");
    this.dimensions = dimensions;
    this.measures = measures;
  }
  clone() {
    return new _AggregateNode(null, new Set(this.dimensions), duplicate(this.measures));
  }
  get groupBy() {
    return this.dimensions;
  }
  static makeFromEncoding(parent, model) {
    let isAggregate2 = false;
    model.forEachFieldDef((fd) => {
      if (fd.aggregate) {
        isAggregate2 = true;
      }
    });
    const meas = {};
    const dims = /* @__PURE__ */ new Set();
    if (!isAggregate2) {
      return null;
    }
    model.forEachFieldDef((fieldDef, channel) => {
      const { aggregate, field: field25 } = fieldDef;
      if (aggregate) {
        if (aggregate === "count") {
          meas["*"] ?? (meas["*"] = {});
          meas["*"]["count"] = /* @__PURE__ */ new Set([vgField(fieldDef, { forAs: true })]);
        } else {
          if (isArgminDef(aggregate) || isArgmaxDef(aggregate)) {
            const op = isArgminDef(aggregate) ? "argmin" : "argmax";
            const argField = aggregate[op];
            meas[argField] ?? (meas[argField] = {});
            meas[argField][op] = /* @__PURE__ */ new Set([vgField({ op, field: argField }, { forAs: true })]);
          } else {
            meas[field25] ?? (meas[field25] = {});
            meas[field25][aggregate] = /* @__PURE__ */ new Set([vgField(fieldDef, { forAs: true })]);
          }
          if (isScaleChannel(channel) && model.scaleDomain(channel) === "unaggregated") {
            meas[field25] ?? (meas[field25] = {});
            meas[field25]["min"] = /* @__PURE__ */ new Set([vgField({ field: field25, aggregate: "min" }, { forAs: true })]);
            meas[field25]["max"] = /* @__PURE__ */ new Set([vgField({ field: field25, aggregate: "max" }, { forAs: true })]);
          }
        }
      } else {
        addDimension(dims, channel, fieldDef, model);
      }
    });
    if (dims.size + keys4(meas).length === 0) {
      return null;
    }
    return new _AggregateNode(parent, dims, meas);
  }
  static makeFromTransform(parent, t) {
    var _a2;
    const dims = /* @__PURE__ */ new Set();
    const meas = {};
    for (const s2 of t.aggregate) {
      const { op, field: field25, as } = s2;
      if (op) {
        if (op === "count") {
          meas["*"] ?? (meas["*"] = {});
          meas["*"]["count"] = /* @__PURE__ */ new Set([as ? as : vgField(s2, { forAs: true })]);
        } else {
          meas[field25] ?? (meas[field25] = {});
          (_a2 = meas[field25])[op] ?? (_a2[op] = /* @__PURE__ */ new Set());
          meas[field25][op].add(as ? as : vgField(s2, { forAs: true }));
        }
      }
    }
    for (const s2 of t.groupby ?? []) {
      dims.add(s2);
    }
    if (dims.size + keys4(meas).length === 0) {
      return null;
    }
    return new _AggregateNode(parent, dims, meas);
  }
  merge(other) {
    if (setEqual(this.dimensions, other.dimensions)) {
      mergeMeasures(this.measures, other.measures);
      return true;
    }
    debug2("different dimensions, cannot merge");
    return false;
  }
  addDimensions(fields) {
    fields.forEach(this.dimensions.add, this.dimensions);
  }
  dependentFields() {
    return /* @__PURE__ */ new Set([...this.dimensions, ...keys4(this.measures)]);
  }
  producedFields() {
    const out = /* @__PURE__ */ new Set();
    for (const field25 of keys4(this.measures)) {
      for (const op of keys4(this.measures[field25])) {
        const m3 = this.measures[field25][op];
        if (m3.size === 0) {
          out.add(`${op}_${field25}`);
        } else {
          m3.forEach(out.add, out);
        }
      }
    }
    return out;
  }
  hash() {
    return `Aggregate ${hash({ dimensions: this.dimensions, measures: this.measures })}`;
  }
  assemble() {
    const ops2 = [];
    const fields = [];
    const as = [];
    for (const field25 of keys4(this.measures)) {
      for (const op of keys4(this.measures[field25])) {
        for (const alias of this.measures[field25][op]) {
          as.push(alias);
          ops2.push(op);
          fields.push(field25 === "*" ? null : replacePathInField(field25));
        }
      }
    }
    const result = {
      type: "aggregate",
      groupby: [...this.dimensions].map(replacePathInField),
      ops: ops2,
      fields,
      as
    };
    return result;
  }
};
var FacetNode = class extends DataFlowNode {
  /**
   * @param model The facet model.
   * @param name The name that this facet source will have.
   * @param data The source data for this facet data.
   */
  constructor(parent, model, name, data3) {
    super(parent);
    __publicField(this, "model");
    __publicField(this, "name");
    __publicField(this, "data");
    __publicField(this, "column");
    __publicField(this, "row");
    __publicField(this, "facet");
    __publicField(this, "childModel");
    this.model = model;
    this.name = name;
    this.data = data3;
    for (const channel of FACET_CHANNELS) {
      const fieldDef = model.facet[channel];
      if (fieldDef) {
        const { bin: bin5, sort: sort4 } = fieldDef;
        this[channel] = {
          name: model.getName(`${channel}_domain`),
          fields: [vgField(fieldDef), ...isBinning(bin5) ? [vgField(fieldDef, { binSuffix: "end" })] : []],
          ...isSortField(sort4) ? { sortField: sort4 } : isArray22(sort4) ? { sortIndexField: sortArrayIndexField(fieldDef, channel) } : {}
        };
      }
    }
    this.childModel = model.child;
  }
  hash() {
    let out = `Facet`;
    for (const channel of FACET_CHANNELS) {
      if (this[channel]) {
        out += ` ${channel.charAt(0)}:${hash(this[channel])}`;
      }
    }
    return out;
  }
  get fields() {
    var _a2;
    const f = [];
    for (const channel of FACET_CHANNELS) {
      if ((_a2 = this[channel]) == null ? void 0 : _a2.fields) {
        f.push(...this[channel].fields);
      }
    }
    return f;
  }
  dependentFields() {
    const depFields = new Set(this.fields);
    for (const channel of FACET_CHANNELS) {
      if (this[channel]) {
        if (this[channel].sortField) {
          depFields.add(this[channel].sortField.field);
        }
        if (this[channel].sortIndexField) {
          depFields.add(this[channel].sortIndexField);
        }
      }
    }
    return depFields;
  }
  producedFields() {
    return /* @__PURE__ */ new Set();
  }
  /**
   * The name to reference this source is its name.
   */
  getSource() {
    return this.name;
  }
  getChildIndependentFieldsWithStep() {
    const childIndependentFieldsWithStep = {};
    for (const channel of POSITION_SCALE_CHANNELS) {
      const childScaleComponent = this.childModel.component.scales[channel];
      if (childScaleComponent && !childScaleComponent.merged) {
        const type7 = childScaleComponent.get("type");
        const range7 = childScaleComponent.get("range");
        if (hasDiscreteDomain(type7) && isVgRangeStep(range7)) {
          const domain3 = assembleDomain(this.childModel, channel);
          const field25 = getFieldFromDomain(domain3);
          if (field25) {
            childIndependentFieldsWithStep[channel] = field25;
          } else {
            warn2(unknownField(channel));
          }
        }
      }
    }
    return childIndependentFieldsWithStep;
  }
  assembleRowColumnHeaderData(channel, crossedDataName, childIndependentFieldsWithStep) {
    const childChannel = { row: "y", column: "x", facet: void 0 }[channel];
    const fields = [];
    const ops2 = [];
    const as = [];
    if (childChannel && childIndependentFieldsWithStep && childIndependentFieldsWithStep[childChannel]) {
      if (crossedDataName) {
        fields.push(`distinct_${childIndependentFieldsWithStep[childChannel]}`);
        ops2.push("max");
      } else {
        fields.push(childIndependentFieldsWithStep[childChannel]);
        ops2.push("distinct");
      }
      as.push(`distinct_${childIndependentFieldsWithStep[childChannel]}`);
    }
    const { sortField, sortIndexField } = this[channel];
    if (sortField) {
      const { op = DEFAULT_SORT_OP, field: field25 } = sortField;
      fields.push(field25);
      ops2.push(op);
      as.push(vgField(sortField, { forAs: true }));
    } else if (sortIndexField) {
      fields.push(sortIndexField);
      ops2.push("max");
      as.push(sortIndexField);
    }
    return {
      name: this[channel].name,
      // Use data from the crossed one if it exist
      source: crossedDataName ?? this.data,
      transform: [
        {
          type: "aggregate",
          groupby: this[channel].fields,
          ...fields.length ? {
            fields,
            ops: ops2,
            as
          } : {}
        }
      ]
    };
  }
  assembleFacetHeaderData(childIndependentFieldsWithStep) {
    var _a2, _b;
    const { columns } = this.model.layout;
    const { layoutHeaders: layoutHeaders2 } = this.model.component;
    const data3 = [];
    const hasSharedAxis = {};
    for (const headerChannel of HEADER_CHANNELS) {
      for (const headerType of HEADER_TYPES) {
        const headers = ((_a2 = layoutHeaders2[headerChannel]) == null ? void 0 : _a2[headerType]) ?? [];
        for (const header of headers) {
          if (((_b = header.axes) == null ? void 0 : _b.length) > 0) {
            hasSharedAxis[headerChannel] = true;
            break;
          }
        }
      }
      if (hasSharedAxis[headerChannel]) {
        const cardinality = `length(data("${this.facet.name}"))`;
        const stop2 = headerChannel === "row" ? columns ? { signal: `ceil(${cardinality} / ${columns})` } : 1 : columns ? { signal: `min(${cardinality}, ${columns})` } : { signal: cardinality };
        data3.push({
          name: `${this.facet.name}_${headerChannel}`,
          transform: [
            {
              type: "sequence",
              start: 0,
              stop: stop2
            }
          ]
        });
      }
    }
    const { row, column } = hasSharedAxis;
    if (row || column) {
      data3.unshift(this.assembleRowColumnHeaderData("facet", null, childIndependentFieldsWithStep));
    }
    return data3;
  }
  assemble() {
    const data3 = [];
    let crossedDataName = null;
    const childIndependentFieldsWithStep = this.getChildIndependentFieldsWithStep();
    const { column, row, facet } = this;
    if (column && row && (childIndependentFieldsWithStep.x || childIndependentFieldsWithStep.y)) {
      crossedDataName = `cross_${this.column.name}_${this.row.name}`;
      const fields = [].concat(childIndependentFieldsWithStep.x ?? [], childIndependentFieldsWithStep.y ?? []);
      const ops2 = fields.map(() => "distinct");
      data3.push({
        name: crossedDataName,
        source: this.data,
        transform: [
          {
            type: "aggregate",
            groupby: this.fields,
            fields,
            ops: ops2
          }
        ]
      });
    }
    for (const channel of [COLUMN, ROW]) {
      if (this[channel]) {
        data3.push(this.assembleRowColumnHeaderData(channel, crossedDataName, childIndependentFieldsWithStep));
      }
    }
    if (facet) {
      const facetData = this.assembleFacetHeaderData(childIndependentFieldsWithStep);
      if (facetData) {
        data3.push(...facetData);
      }
    }
    return data3;
  }
};
function unquote(pattern) {
  if (pattern.startsWith("'") && pattern.endsWith("'") || pattern.startsWith('"') && pattern.endsWith('"')) {
    return pattern.slice(1, -1);
  }
  return pattern;
}
function parseExpression2(field25, parse12) {
  const f = accessPathWithDatum(field25);
  if (parse12 === "number") {
    return `toNumber(${f})`;
  } else if (parse12 === "boolean") {
    return `toBoolean(${f})`;
  } else if (parse12 === "string") {
    return `toString(${f})`;
  } else if (parse12 === "date") {
    return `toDate(${f})`;
  } else if (parse12 === "flatten") {
    return f;
  } else if (parse12.startsWith("date:")) {
    const specifier = unquote(parse12.slice(5, parse12.length));
    return `timeParse(${f},'${specifier}')`;
  } else if (parse12.startsWith("utc:")) {
    const specifier = unquote(parse12.slice(4, parse12.length));
    return `utcParse(${f},'${specifier}')`;
  } else {
    warn2(unrecognizedParse(parse12));
    return null;
  }
}
function getImplicitFromFilterTransform(transform4) {
  const implicit2 = {};
  forEachLeaf(transform4.filter, (filter4) => {
    if (isFieldPredicate(filter4)) {
      let val = null;
      if (isFieldEqualPredicate(filter4)) {
        val = signalRefOrValue(filter4.equal);
      } else if (isFieldLTEPredicate(filter4)) {
        val = signalRefOrValue(filter4.lte);
      } else if (isFieldLTPredicate(filter4)) {
        val = signalRefOrValue(filter4.lt);
      } else if (isFieldGTPredicate(filter4)) {
        val = signalRefOrValue(filter4.gt);
      } else if (isFieldGTEPredicate(filter4)) {
        val = signalRefOrValue(filter4.gte);
      } else if (isFieldRangePredicate(filter4)) {
        val = filter4.range[0];
      } else if (isFieldOneOfPredicate(filter4)) {
        val = (filter4.oneOf ?? filter4.in)[0];
      }
      if (val) {
        if (isDateTime(val)) {
          implicit2[filter4.field] = "date";
        } else if (isNumber14(val)) {
          implicit2[filter4.field] = "number";
        } else if (isString14(val)) {
          implicit2[filter4.field] = "string";
        }
      }
      if (filter4.timeUnit) {
        implicit2[filter4.field] = "date";
      }
    }
  });
  return implicit2;
}
function getImplicitFromEncoding(model) {
  const implicit2 = {};
  function add10(fieldDef) {
    if (isFieldOrDatumDefForTimeFormat(fieldDef)) {
      implicit2[fieldDef.field] = "date";
    } else if (fieldDef.type === "quantitative" && isMinMaxOp(fieldDef.aggregate)) {
      implicit2[fieldDef.field] = "number";
    } else if (accessPathDepth(fieldDef.field) > 1) {
      if (!(fieldDef.field in implicit2)) {
        implicit2[fieldDef.field] = "flatten";
      }
    } else if (isScaleFieldDef(fieldDef) && isSortField(fieldDef.sort) && accessPathDepth(fieldDef.sort.field) > 1) {
      if (!(fieldDef.sort.field in implicit2)) {
        implicit2[fieldDef.sort.field] = "flatten";
      }
    }
  }
  if (isUnitModel(model) || isFacetModel(model)) {
    model.forEachFieldDef((fieldDef, channel) => {
      if (isTypedFieldDef(fieldDef)) {
        add10(fieldDef);
      } else {
        const mainChannel = getMainRangeChannel(channel);
        const mainFieldDef = model.fieldDef(mainChannel);
        add10({
          ...fieldDef,
          type: mainFieldDef.type
        });
      }
    });
  }
  if (isUnitModel(model)) {
    const { mark, markDef, encoding } = model;
    if (isPathMark(mark) && // No need to sort by dimension if we have a connected scatterplot (order channel is present)
    !model.encoding.order) {
      const dimensionChannel = markDef.orient === "horizontal" ? "y" : "x";
      const dimensionChannelDef = encoding[dimensionChannel];
      if (isFieldDef(dimensionChannelDef) && dimensionChannelDef.type === "quantitative" && !(dimensionChannelDef.field in implicit2)) {
        implicit2[dimensionChannelDef.field] = "number";
      }
    }
  }
  return implicit2;
}
function getImplicitFromSelection(model) {
  const implicit2 = {};
  if (isUnitModel(model) && model.component.selection) {
    for (const name of keys4(model.component.selection)) {
      const selCmpt = model.component.selection[name];
      for (const proj of selCmpt.project.items) {
        if (!proj.channel && accessPathDepth(proj.field) > 1) {
          implicit2[proj.field] = "flatten";
        }
      }
    }
  }
  return implicit2;
}
var ParseNode = class _ParseNode extends DataFlowNode {
  constructor(parent, parse12) {
    super(parent);
    __publicField(this, "_parse");
    this._parse = parse12;
  }
  clone() {
    return new _ParseNode(null, duplicate(this._parse));
  }
  hash() {
    return `Parse ${hash(this._parse)}`;
  }
  /**
   * Creates a parse node from a data.format.parse and updates ancestorParse.
   */
  static makeExplicit(parent, model, ancestorParse) {
    var _a2;
    let explicit = {};
    const data3 = model.data;
    if (!isGenerator(data3) && ((_a2 = data3 == null ? void 0 : data3.format) == null ? void 0 : _a2.parse)) {
      explicit = data3.format.parse;
    }
    return this.makeWithAncestors(parent, explicit, {}, ancestorParse);
  }
  /**
   * Creates a parse node from "explicit" parse and "implicit" parse and updates ancestorParse.
   */
  static makeWithAncestors(parent, explicit, implicit2, ancestorParse) {
    for (const field25 of keys4(implicit2)) {
      const parsedAs = ancestorParse.getWithExplicit(field25);
      if (parsedAs.value !== void 0) {
        if (parsedAs.explicit || parsedAs.value === implicit2[field25] || parsedAs.value === "derived" || implicit2[field25] === "flatten") {
          delete implicit2[field25];
        } else {
          warn2(differentParse(field25, implicit2[field25], parsedAs.value));
        }
      }
    }
    for (const field25 of keys4(explicit)) {
      const parsedAs = ancestorParse.get(field25);
      if (parsedAs !== void 0) {
        if (parsedAs === explicit[field25]) {
          delete explicit[field25];
        } else {
          warn2(differentParse(field25, explicit[field25], parsedAs));
        }
      }
    }
    const parse12 = new Split(explicit, implicit2);
    ancestorParse.copyAll(parse12);
    const p = {};
    for (const key4 of keys4(parse12.combine())) {
      const val = parse12.get(key4);
      if (val !== null) {
        p[key4] = val;
      }
    }
    if (keys4(p).length === 0 || ancestorParse.parseNothing) {
      return null;
    }
    return new _ParseNode(parent, p);
  }
  get parse() {
    return this._parse;
  }
  merge(other) {
    this._parse = { ...this._parse, ...other.parse };
    other.remove();
  }
  /**
   * Assemble an object for Vega's format.parse property.
   */
  assembleFormatParse() {
    const formatParse = {};
    for (const field25 of keys4(this._parse)) {
      const p = this._parse[field25];
      if (accessPathDepth(field25) === 1) {
        formatParse[field25] = p;
      }
    }
    return formatParse;
  }
  // format parse depends and produces all fields in its parse
  producedFields() {
    return new Set(keys4(this._parse));
  }
  dependentFields() {
    return new Set(keys4(this._parse));
  }
  assembleTransforms(onlyNested = false) {
    return keys4(this._parse).filter((field25) => onlyNested ? accessPathDepth(field25) > 1 : true).map((field25) => {
      const expr2 = parseExpression2(field25, this._parse[field25]);
      if (!expr2) {
        return null;
      }
      const formula = {
        type: "formula",
        expr: expr2,
        as: removePathFromField(field25)
        // Vega output is always flattened
      };
      return formula;
    }).filter((t) => t !== null);
  }
};
var IdentifierNode = class _IdentifierNode extends DataFlowNode {
  clone() {
    return new _IdentifierNode(null);
  }
  constructor(parent) {
    super(parent);
  }
  dependentFields() {
    return /* @__PURE__ */ new Set();
  }
  producedFields() {
    return /* @__PURE__ */ new Set([SELECTION_ID]);
  }
  hash() {
    return "Identifier";
  }
  assemble() {
    return { type: "identifier", as: SELECTION_ID };
  }
};
var GraticuleNode = class _GraticuleNode extends DataFlowNode {
  constructor(parent, params2) {
    super(parent);
    __publicField(this, "params");
    this.params = params2;
  }
  clone() {
    return new _GraticuleNode(null, this.params);
  }
  dependentFields() {
    return /* @__PURE__ */ new Set();
  }
  producedFields() {
    return void 0;
  }
  hash() {
    return `Graticule ${hash(this.params)}`;
  }
  assemble() {
    return {
      type: "graticule",
      ...this.params === true ? {} : this.params
    };
  }
};
var SequenceNode = class _SequenceNode extends DataFlowNode {
  constructor(parent, params2) {
    super(parent);
    __publicField(this, "params");
    this.params = params2;
  }
  clone() {
    return new _SequenceNode(null, this.params);
  }
  dependentFields() {
    return /* @__PURE__ */ new Set();
  }
  producedFields() {
    return /* @__PURE__ */ new Set([this.params.as ?? "data"]);
  }
  hash() {
    return `Hash ${hash(this.params)}`;
  }
  assemble() {
    return {
      type: "sequence",
      ...this.params
    };
  }
};
var SourceNode = class extends DataFlowNode {
  constructor(data3) {
    super(null);
    __publicField(this, "_data");
    __publicField(this, "_name");
    __publicField(this, "_generator");
    data3 ?? (data3 = { name: "source" });
    let format14;
    if (!isGenerator(data3)) {
      format14 = data3.format ? { ...omit(data3.format, ["parse"]) } : {};
    }
    if (isInlineData(data3)) {
      this._data = { values: data3.values };
    } else if (isUrlData(data3)) {
      this._data = { url: data3.url };
      if (!format14.type) {
        let defaultExtension = /(?:\.([^.]+))?$/.exec(data3.url)[1];
        if (!contains2(["json", "csv", "tsv", "dsv", "topojson"], defaultExtension)) {
          defaultExtension = "json";
        }
        format14.type = defaultExtension;
      }
    } else if (isSphereGenerator(data3)) {
      this._data = { values: [{ type: "Sphere" }] };
    } else if (isNamedData(data3) || isGenerator(data3)) {
      this._data = {};
    }
    this._generator = isGenerator(data3);
    if (data3.name) {
      this._name = data3.name;
    }
    if (format14 && !isEmpty(format14)) {
      this._data.format = format14;
    }
  }
  dependentFields() {
    return /* @__PURE__ */ new Set();
  }
  producedFields() {
    return void 0;
  }
  get data() {
    return this._data;
  }
  hasName() {
    return !!this._name;
  }
  get isGenerator() {
    return this._generator;
  }
  get dataName() {
    return this._name;
  }
  set dataName(name) {
    this._name = name;
  }
  set parent(parent) {
    throw new Error("Source nodes have to be roots.");
  }
  remove() {
    throw new Error("Source nodes are roots and cannot be removed.");
  }
  hash() {
    throw new Error("Cannot hash sources");
  }
  assemble() {
    return {
      name: this._name,
      ...this._data,
      transform: []
    };
  }
};
function isDataSourceNode(node) {
  return node instanceof SourceNode || node instanceof GraticuleNode || node instanceof SequenceNode;
}
var _modified;
var Optimizer = class {
  constructor() {
    __privateAdd(this, _modified, void 0);
    __privateSet(this, _modified, false);
  }
  // Once true, #modified is never set to false
  setModified() {
    __privateSet(this, _modified, true);
  }
  get modifiedFlag() {
    return __privateGet(this, _modified);
  }
};
_modified = new WeakMap();
var BottomUpOptimizer = class extends Optimizer {
  /**
   * Compute a map of node depths that we can use to determine a topological sort order.
   */
  getNodeDepths(node, depth, depths) {
    depths.set(node, depth);
    for (const child of node.children) {
      this.getNodeDepths(child, depth + 1, depths);
    }
    return depths;
  }
  /**
   * Run the optimizer on all nodes starting from the leaves.
   */
  optimize(node) {
    const depths = this.getNodeDepths(node, 0, /* @__PURE__ */ new Map());
    const topologicalSort = [...depths.entries()].sort((a4, b6) => b6[1] - a4[1]);
    for (const tuple of topologicalSort) {
      this.run(tuple[0]);
    }
    return this.modifiedFlag;
  }
};
var TopDownOptimizer = class extends Optimizer {
  /**
   * Run the optimizer depth first on all nodes starting from the roots.
   */
  optimize(node) {
    this.run(node);
    for (const child of node.children) {
      this.optimize(child);
    }
    return this.modifiedFlag;
  }
};
var MergeIdenticalNodes = class extends TopDownOptimizer {
  mergeNodes(parent, nodes) {
    const mergedNode = nodes.shift();
    for (const node of nodes) {
      parent.removeChild(node);
      node.parent = mergedNode;
      node.remove();
    }
  }
  run(node) {
    const hashes = node.children.map((x9) => x9.hash());
    const buckets = {};
    for (let i = 0; i < hashes.length; i++) {
      if (buckets[hashes[i]] === void 0) {
        buckets[hashes[i]] = [node.children[i]];
      } else {
        buckets[hashes[i]].push(node.children[i]);
      }
    }
    for (const k3 of keys4(buckets)) {
      if (buckets[k3].length > 1) {
        this.setModified();
        this.mergeNodes(node, buckets[k3]);
      }
    }
  }
};
var RemoveUnnecessaryIdentifierNodes = class extends TopDownOptimizer {
  constructor(model) {
    super();
    __publicField(this, "requiresSelectionId");
    this.requiresSelectionId = model && requiresSelectionId(model);
  }
  run(node) {
    if (node instanceof IdentifierNode) {
      if (!(this.requiresSelectionId && (isDataSourceNode(node.parent) || node.parent instanceof AggregateNode || node.parent instanceof ParseNode))) {
        this.setModified();
        node.remove();
      }
    }
  }
};
var RemoveDuplicateTimeUnits = class extends Optimizer {
  optimize(node) {
    this.run(node, /* @__PURE__ */ new Set());
    return this.modifiedFlag;
  }
  run(node, timeUnitFields) {
    let producedFields = /* @__PURE__ */ new Set();
    if (node instanceof TimeUnitNode) {
      producedFields = node.producedFields();
      if (hasIntersection(producedFields, timeUnitFields)) {
        this.setModified();
        node.removeFormulas(timeUnitFields);
        if (node.producedFields.length === 0) {
          node.remove();
        }
      }
    }
    for (const child of node.children) {
      this.run(child, /* @__PURE__ */ new Set([...timeUnitFields, ...producedFields]));
    }
  }
};
var RemoveUnnecessaryOutputNodes = class extends TopDownOptimizer {
  constructor() {
    super();
  }
  run(node) {
    if (node instanceof OutputNode && !node.isRequired()) {
      this.setModified();
      node.remove();
    }
  }
};
var MoveParseUp = class extends BottomUpOptimizer {
  run(node) {
    if (isDataSourceNode(node)) {
      return;
    }
    if (node.numChildren() > 1) {
      return;
    }
    for (const child of node.children) {
      if (child instanceof ParseNode) {
        if (node instanceof ParseNode) {
          this.setModified();
          node.merge(child);
        } else {
          if (fieldIntersection(node.producedFields(), child.dependentFields())) {
            continue;
          }
          this.setModified();
          child.swapWithParent();
        }
      }
    }
    return;
  }
};
var MergeParse = class extends BottomUpOptimizer {
  run(node) {
    const originalChildren = [...node.children];
    const parseChildren = node.children.filter((child) => child instanceof ParseNode);
    if (node.numChildren() > 1 && parseChildren.length >= 1) {
      const commonParse = {};
      const conflictingParse = /* @__PURE__ */ new Set();
      for (const parseNode of parseChildren) {
        const parse12 = parseNode.parse;
        for (const k3 of keys4(parse12)) {
          if (!(k3 in commonParse)) {
            commonParse[k3] = parse12[k3];
          } else if (commonParse[k3] !== parse12[k3]) {
            conflictingParse.add(k3);
          }
        }
      }
      for (const field25 of conflictingParse) {
        delete commonParse[field25];
      }
      if (!isEmpty(commonParse)) {
        this.setModified();
        const mergedParseNode = new ParseNode(node, commonParse);
        for (const childNode of originalChildren) {
          if (childNode instanceof ParseNode) {
            for (const key4 of keys4(commonParse)) {
              delete childNode.parse[key4];
            }
          }
          node.removeChild(childNode);
          childNode.parent = mergedParseNode;
          if (childNode instanceof ParseNode && keys4(childNode.parse).length === 0) {
            childNode.remove();
          }
        }
      }
    }
  }
};
var RemoveUnusedSubtrees = class extends BottomUpOptimizer {
  run(node) {
    if (node instanceof OutputNode || node.numChildren() > 0 || node instanceof FacetNode)
      ;
    else if (node instanceof SourceNode)
      ;
    else {
      this.setModified();
      node.remove();
    }
  }
};
var MergeTimeUnits = class extends BottomUpOptimizer {
  run(node) {
    const timeUnitChildren = node.children.filter((x9) => x9 instanceof TimeUnitNode);
    const combination = timeUnitChildren.pop();
    for (const timeUnit of timeUnitChildren) {
      this.setModified();
      combination.merge(timeUnit);
    }
  }
};
var MergeAggregates = class extends BottomUpOptimizer {
  run(node) {
    const aggChildren = node.children.filter((child) => child instanceof AggregateNode);
    const groupedAggregates = {};
    for (const agg of aggChildren) {
      const groupBys = hash(agg.groupBy);
      if (!(groupBys in groupedAggregates)) {
        groupedAggregates[groupBys] = [];
      }
      groupedAggregates[groupBys].push(agg);
    }
    for (const group7 of keys4(groupedAggregates)) {
      const mergeableAggs = groupedAggregates[group7];
      if (mergeableAggs.length > 1) {
        const mergedAggs = mergeableAggs.pop();
        for (const agg of mergeableAggs) {
          if (mergedAggs.merge(agg)) {
            node.removeChild(agg);
            agg.parent = mergedAggs;
            agg.remove();
            this.setModified();
          }
        }
      }
    }
  }
};
var MergeBins = class extends BottomUpOptimizer {
  constructor(model) {
    super();
    __publicField(this, "model");
    this.model = model;
  }
  run(node) {
    const moveBinsUp = !(isDataSourceNode(node) || node instanceof FilterNode || node instanceof ParseNode || node instanceof IdentifierNode);
    const promotableBins = [];
    const remainingBins = [];
    for (const child of node.children) {
      if (child instanceof BinNode) {
        if (moveBinsUp && !fieldIntersection(node.producedFields(), child.dependentFields())) {
          promotableBins.push(child);
        } else {
          remainingBins.push(child);
        }
      }
    }
    if (promotableBins.length > 0) {
      const promotedBin = promotableBins.pop();
      for (const bin5 of promotableBins) {
        promotedBin.merge(bin5, this.model.renameSignal.bind(this.model));
      }
      this.setModified();
      if (node instanceof BinNode) {
        node.merge(promotedBin, this.model.renameSignal.bind(this.model));
      } else {
        promotedBin.swapWithParent();
      }
    }
    if (remainingBins.length > 1) {
      const remainingBin = remainingBins.pop();
      for (const bin5 of remainingBins) {
        remainingBin.merge(bin5, this.model.renameSignal.bind(this.model));
      }
      this.setModified();
    }
  }
};
var MergeOutputs = class extends BottomUpOptimizer {
  run(node) {
    const children3 = [...node.children];
    const hasOutputChild = some2(children3, (child) => child instanceof OutputNode);
    if (!hasOutputChild || node.numChildren() <= 1) {
      return;
    }
    const otherChildren = [];
    let mainOutput;
    for (const child of children3) {
      if (child instanceof OutputNode) {
        let lastOutput = child;
        while (lastOutput.numChildren() === 1) {
          const [theChild] = lastOutput.children;
          if (theChild instanceof OutputNode) {
            lastOutput = theChild;
          } else {
            break;
          }
        }
        otherChildren.push(...lastOutput.children);
        if (mainOutput) {
          node.removeChild(child);
          child.parent = mainOutput.parent;
          mainOutput.parent.removeChild(mainOutput);
          mainOutput.parent = lastOutput;
          this.setModified();
        } else {
          mainOutput = lastOutput;
        }
      } else {
        otherChildren.push(child);
      }
    }
    if (otherChildren.length) {
      this.setModified();
      for (const child of otherChildren) {
        child.parent.removeChild(child);
        child.parent = mainOutput;
      }
    }
  }
};
var JoinAggregateTransformNode = class _JoinAggregateTransformNode extends DataFlowNode {
  constructor(parent, transform4) {
    super(parent);
    __publicField(this, "transform");
    this.transform = transform4;
  }
  clone() {
    return new _JoinAggregateTransformNode(null, duplicate(this.transform));
  }
  addDimensions(fields) {
    this.transform.groupby = unique(this.transform.groupby.concat(fields), (d) => d);
  }
  dependentFields() {
    const out = /* @__PURE__ */ new Set();
    if (this.transform.groupby) {
      this.transform.groupby.forEach(out.add, out);
    }
    this.transform.joinaggregate.map((w8) => w8.field).filter((f) => f !== void 0).forEach(out.add, out);
    return out;
  }
  producedFields() {
    return new Set(this.transform.joinaggregate.map(this.getDefaultName));
  }
  getDefaultName(joinAggregateFieldDef) {
    return joinAggregateFieldDef.as ?? vgField(joinAggregateFieldDef);
  }
  hash() {
    return `JoinAggregateTransform ${hash(this.transform)}`;
  }
  assemble() {
    const fields = [];
    const ops2 = [];
    const as = [];
    for (const joinaggregate of this.transform.joinaggregate) {
      ops2.push(joinaggregate.op);
      as.push(this.getDefaultName(joinaggregate));
      fields.push(joinaggregate.field === void 0 ? null : joinaggregate.field);
    }
    const groupby = this.transform.groupby;
    return {
      type: "joinaggregate",
      as,
      ops: ops2,
      fields,
      ...groupby !== void 0 ? { groupby } : {}
    };
  }
};
var FilterInvalidNode = class _FilterInvalidNode extends DataFlowNode {
  constructor(parent, filter4) {
    super(parent);
    __publicField(this, "filter");
    this.filter = filter4;
  }
  clone() {
    return new _FilterInvalidNode(null, { ...this.filter });
  }
  static make(parent, model, dataSourcesForHandlingInvalidValues) {
    const { config, markDef } = model;
    const { marks, scales: scales10 } = dataSourcesForHandlingInvalidValues;
    if (marks === "include-invalid-values" && scales10 === "include-invalid-values") {
      return null;
    }
    const filter4 = model.reduceFieldDef((aggregator, fieldDef, channel) => {
      const scaleComponent = isScaleChannel(channel) && model.getScaleComponent(channel);
      if (scaleComponent) {
        const scaleType2 = scaleComponent.get("type");
        const { aggregate } = fieldDef;
        const invalidDataMode = getScaleInvalidDataMode({
          scaleChannel: channel,
          markDef,
          config,
          scaleType: scaleType2,
          isCountAggregate: isCountingAggregateOp(aggregate)
        });
        if (invalidDataMode !== "show" && invalidDataMode !== "always-valid") {
          aggregator[fieldDef.field] = fieldDef;
        }
      }
      return aggregator;
    }, {});
    if (!keys4(filter4).length) {
      return null;
    }
    return new _FilterInvalidNode(parent, filter4);
  }
  dependentFields() {
    return new Set(keys4(this.filter));
  }
  producedFields() {
    return /* @__PURE__ */ new Set();
  }
  hash() {
    return `FilterInvalid ${hash(this.filter)}`;
  }
  /**
   * Create the VgTransforms for each of the filtered fields.
   */
  assemble() {
    const filters7 = keys4(this.filter).reduce((vegaFilters, field25) => {
      const fieldDef = this.filter[field25];
      const ref2 = vgField(fieldDef, { expr: "datum" });
      if (fieldDef !== null) {
        if (fieldDef.type === "temporal") {
          vegaFilters.push(`(isDate(${ref2}) || (${isValidFiniteNumberExpr(ref2)}))`);
        } else if (fieldDef.type === "quantitative") {
          vegaFilters.push(isValidFiniteNumberExpr(ref2));
        } else
          ;
      }
      return vegaFilters;
    }, []);
    return filters7.length > 0 ? {
      type: "filter",
      expr: filters7.join(" && ")
    } : null;
  }
};
function isValidFiniteNumberExpr(ref2) {
  return `isValid(${ref2}) && isFinite(+${ref2})`;
}
function getStackByFields(model) {
  return model.stack.stackBy.reduce((fields, by) => {
    const fieldDef = by.fieldDef;
    const _field = vgField(fieldDef);
    if (_field) {
      fields.push(_field);
    }
    return fields;
  }, []);
}
function isValidAsArray(as) {
  return isArray22(as) && as.every((s2) => isString14(s2)) && as.length > 1;
}
var StackNode = class _StackNode extends DataFlowNode {
  constructor(parent, stack2) {
    super(parent);
    __publicField(this, "_stack");
    this._stack = stack2;
  }
  clone() {
    return new _StackNode(null, duplicate(this._stack));
  }
  static makeFromTransform(parent, stackTransform) {
    const { stack: stack2, groupby, as, offset: offset9 = "zero" } = stackTransform;
    const sortFields = [];
    const sortOrder = [];
    if (stackTransform.sort !== void 0) {
      for (const sortField of stackTransform.sort) {
        sortFields.push(sortField.field);
        sortOrder.push(getFirstDefined(sortField.order, "ascending"));
      }
    }
    const sort4 = {
      field: sortFields,
      order: sortOrder
    };
    let normalizedAs;
    if (isValidAsArray(as)) {
      normalizedAs = as;
    } else if (isString14(as)) {
      normalizedAs = [as, `${as}_end`];
    } else {
      normalizedAs = [`${stackTransform.stack}_start`, `${stackTransform.stack}_end`];
    }
    return new _StackNode(parent, {
      dimensionFieldDefs: [],
      stackField: stack2,
      groupby,
      offset: offset9,
      sort: sort4,
      facetby: [],
      as: normalizedAs
    });
  }
  static makeFromEncoding(parent, model) {
    const stackProperties = model.stack;
    const { encoding } = model;
    if (!stackProperties) {
      return null;
    }
    const { groupbyChannels, fieldChannel, offset: offset9, impute } = stackProperties;
    const dimensionFieldDefs = groupbyChannels.map((groupbyChannel) => {
      const cDef = encoding[groupbyChannel];
      return getFieldDef(cDef);
    }).filter((def6) => !!def6);
    const stackby = getStackByFields(model);
    const orderDef = model.encoding.order;
    let sort4;
    if (isArray22(orderDef) || isFieldDef(orderDef)) {
      sort4 = sortParams(orderDef);
    } else {
      const sortOrder = isOrderOnlyDef(orderDef) ? orderDef.sort : fieldChannel === "y" ? "descending" : "ascending";
      sort4 = stackby.reduce((s2, field25) => {
        if (!s2.field.includes(field25)) {
          s2.field.push(field25);
          s2.order.push(sortOrder);
        }
        return s2;
      }, { field: [], order: [] });
    }
    return new _StackNode(parent, {
      dimensionFieldDefs,
      stackField: model.vgField(fieldChannel),
      facetby: [],
      stackby,
      sort: sort4,
      offset: offset9,
      impute,
      as: [
        model.vgField(fieldChannel, { suffix: "start", forAs: true }),
        model.vgField(fieldChannel, { suffix: "end", forAs: true })
      ]
    });
  }
  get stack() {
    return this._stack;
  }
  addDimensions(fields) {
    this._stack.facetby.push(...fields);
  }
  dependentFields() {
    const out = /* @__PURE__ */ new Set();
    out.add(this._stack.stackField);
    this.getGroupbyFields().forEach(out.add, out);
    this._stack.facetby.forEach(out.add, out);
    this._stack.sort.field.forEach(out.add, out);
    return out;
  }
  producedFields() {
    return new Set(this._stack.as);
  }
  hash() {
    return `Stack ${hash(this._stack)}`;
  }
  getGroupbyFields() {
    const { dimensionFieldDefs, impute, groupby } = this._stack;
    if (dimensionFieldDefs.length > 0) {
      return dimensionFieldDefs.map((dimensionFieldDef) => {
        if (dimensionFieldDef.bin) {
          if (impute) {
            return [vgField(dimensionFieldDef, { binSuffix: "mid" })];
          }
          return [
            // For binned group by field without impute, we need both bin (start) and bin_end
            vgField(dimensionFieldDef, {}),
            vgField(dimensionFieldDef, { binSuffix: "end" })
          ];
        }
        return [vgField(dimensionFieldDef)];
      }).flat();
    }
    return groupby ?? [];
  }
  assemble() {
    const transform4 = [];
    const { facetby, dimensionFieldDefs, stackField: field25, stackby, sort: sort4, offset: offset9, impute, as } = this._stack;
    if (impute) {
      for (const dimensionFieldDef of dimensionFieldDefs) {
        const { bandPosition = 0.5, bin: bin5 } = dimensionFieldDef;
        if (bin5) {
          const binStart = vgField(dimensionFieldDef, { expr: "datum" });
          const binEnd = vgField(dimensionFieldDef, { expr: "datum", binSuffix: "end" });
          transform4.push({
            type: "formula",
            expr: `${isValidFiniteNumberExpr(binStart)} ? ${bandPosition}*${binStart}+${1 - bandPosition}*${binEnd} : ${binStart}`,
            as: vgField(dimensionFieldDef, { binSuffix: "mid", forAs: true })
          });
        }
        transform4.push({
          type: "impute",
          field: field25,
          groupby: [...stackby, ...facetby],
          key: vgField(dimensionFieldDef, { binSuffix: "mid" }),
          method: "value",
          value: 0
        });
      }
    }
    transform4.push({
      type: "stack",
      groupby: [...this.getGroupbyFields(), ...facetby],
      field: field25,
      sort: sort4,
      as,
      offset: offset9
    });
    return transform4;
  }
};
var WindowTransformNode = class _WindowTransformNode extends DataFlowNode {
  constructor(parent, transform4) {
    super(parent);
    __publicField(this, "transform");
    this.transform = transform4;
  }
  clone() {
    return new _WindowTransformNode(null, duplicate(this.transform));
  }
  addDimensions(fields) {
    this.transform.groupby = unique(this.transform.groupby.concat(fields), (d) => d);
  }
  dependentFields() {
    const out = /* @__PURE__ */ new Set();
    (this.transform.groupby ?? []).forEach(out.add, out);
    (this.transform.sort ?? []).forEach((m3) => out.add(m3.field));
    this.transform.window.map((w8) => w8.field).filter((f) => f !== void 0).forEach(out.add, out);
    return out;
  }
  producedFields() {
    return new Set(this.transform.window.map(this.getDefaultName));
  }
  getDefaultName(windowFieldDef) {
    return windowFieldDef.as ?? vgField(windowFieldDef);
  }
  hash() {
    return `WindowTransform ${hash(this.transform)}`;
  }
  assemble() {
    const fields = [];
    const ops2 = [];
    const as = [];
    const params2 = [];
    for (const window2 of this.transform.window) {
      ops2.push(window2.op);
      as.push(this.getDefaultName(window2));
      params2.push(window2.param === void 0 ? null : window2.param);
      fields.push(window2.field === void 0 ? null : window2.field);
    }
    const frame2 = this.transform.frame;
    const groupby = this.transform.groupby;
    if (frame2 && frame2[0] === null && frame2[1] === null && ops2.every((o) => isAggregateOp(o))) {
      return {
        type: "joinaggregate",
        as,
        ops: ops2,
        fields,
        ...groupby !== void 0 ? { groupby } : {}
      };
    }
    const sortFields = [];
    const sortOrder = [];
    if (this.transform.sort !== void 0) {
      for (const sortField of this.transform.sort) {
        sortFields.push(sortField.field);
        sortOrder.push(sortField.order ?? "ascending");
      }
    }
    const sort4 = {
      field: sortFields,
      order: sortOrder
    };
    const ignorePeers = this.transform.ignorePeers;
    return {
      type: "window",
      params: params2,
      as,
      ops: ops2,
      fields,
      sort: sort4,
      ...ignorePeers !== void 0 ? { ignorePeers } : {},
      ...groupby !== void 0 ? { groupby } : {},
      ...frame2 !== void 0 ? { frame: frame2 } : {}
    };
  }
};
function cloneSubtree(facet) {
  function clone(node) {
    if (!(node instanceof FacetNode)) {
      const copy4 = node.clone();
      if (copy4 instanceof OutputNode) {
        const newName = FACET_SCALE_PREFIX + copy4.getSource();
        copy4.setSource(newName);
        facet.model.component.data.outputNodes[newName] = copy4;
      } else if (copy4 instanceof AggregateNode || copy4 instanceof StackNode || copy4 instanceof WindowTransformNode || copy4 instanceof JoinAggregateTransformNode) {
        copy4.addDimensions(facet.fields);
      }
      for (const n of node.children.flatMap(clone)) {
        n.parent = copy4;
      }
      return [copy4];
    }
    return node.children.flatMap(clone);
  }
  return clone;
}
function moveFacetDown(node) {
  if (node instanceof FacetNode) {
    if (node.numChildren() === 1 && !(node.children[0] instanceof OutputNode)) {
      const child = node.children[0];
      if (child instanceof AggregateNode || child instanceof StackNode || child instanceof WindowTransformNode || child instanceof JoinAggregateTransformNode) {
        child.addDimensions(node.fields);
      }
      child.swapWithParent();
      moveFacetDown(node);
    } else {
      const facetMain = node.model.component.data.main;
      moveMainDownToFacet(facetMain);
      const cloner = cloneSubtree(node);
      const copy4 = node.children.map(cloner).flat();
      for (const c5 of copy4) {
        c5.parent = facetMain;
      }
    }
  } else {
    node.children.map(moveFacetDown);
  }
}
function moveMainDownToFacet(node) {
  if (node instanceof OutputNode && node.type === DataSourceType.Main) {
    if (node.numChildren() === 1) {
      const child = node.children[0];
      if (!(child instanceof FacetNode)) {
        child.swapWithParent();
        moveMainDownToFacet(node);
      }
    }
  }
}
var FACET_SCALE_PREFIX = "scale_";
var MAX_OPTIMIZATION_RUNS = 5;
function checkLinks(nodes) {
  for (const node of nodes) {
    for (const child of node.children) {
      if (child.parent !== node) {
        return false;
      }
    }
    if (!checkLinks(node.children)) {
      return false;
    }
  }
  return true;
}
function runOptimizer(optimizer, nodes) {
  let modified2 = false;
  for (const node of nodes) {
    modified2 = optimizer.optimize(node) || modified2;
  }
  return modified2;
}
function optimizationDataflowHelper(dataComponent, model, firstPass) {
  let roots = dataComponent.sources;
  let modified2 = false;
  modified2 = runOptimizer(new RemoveUnnecessaryOutputNodes(), roots) || modified2;
  modified2 = runOptimizer(new RemoveUnnecessaryIdentifierNodes(model), roots) || modified2;
  roots = roots.filter((r) => r.numChildren() > 0);
  modified2 = runOptimizer(new RemoveUnusedSubtrees(), roots) || modified2;
  roots = roots.filter((r) => r.numChildren() > 0);
  if (!firstPass) {
    modified2 = runOptimizer(new MoveParseUp(), roots) || modified2;
    modified2 = runOptimizer(new MergeBins(model), roots) || modified2;
    modified2 = runOptimizer(new RemoveDuplicateTimeUnits(), roots) || modified2;
    modified2 = runOptimizer(new MergeParse(), roots) || modified2;
    modified2 = runOptimizer(new MergeAggregates(), roots) || modified2;
    modified2 = runOptimizer(new MergeTimeUnits(), roots) || modified2;
    modified2 = runOptimizer(new MergeIdenticalNodes(), roots) || modified2;
    modified2 = runOptimizer(new MergeOutputs(), roots) || modified2;
  }
  dataComponent.sources = roots;
  return modified2;
}
function optimizeDataflow(data3, model) {
  checkLinks(data3.sources);
  let firstPassCounter = 0;
  let secondPassCounter = 0;
  for (let i = 0; i < MAX_OPTIMIZATION_RUNS; i++) {
    if (!optimizationDataflowHelper(data3, model, true)) {
      break;
    }
    firstPassCounter++;
  }
  data3.sources.map(moveFacetDown);
  for (let i = 0; i < MAX_OPTIMIZATION_RUNS; i++) {
    if (!optimizationDataflowHelper(data3, model, false)) {
      break;
    }
    secondPassCounter++;
  }
  checkLinks(data3.sources);
  if (Math.max(firstPassCounter, secondPassCounter) === MAX_OPTIMIZATION_RUNS) {
    warn2(`Maximum optimization runs(${MAX_OPTIMIZATION_RUNS}) reached.`);
  }
}
var SignalRefWrapper = class _SignalRefWrapper {
  constructor(exprGenerator) {
    __publicField(this, "signal");
    Object.defineProperty(this, "signal", {
      enumerable: true,
      get: exprGenerator
    });
  }
  // for ts
  static fromName(rename, signalName) {
    return new _SignalRefWrapper(() => rename(signalName));
  }
};
function parseScaleDomain2(model) {
  if (isUnitModel(model)) {
    parseUnitScaleDomain(model);
  } else {
    parseNonUnitScaleDomain(model);
  }
}
function parseUnitScaleDomain(model) {
  const localScaleComponents = model.component.scales;
  for (const channel of keys4(localScaleComponents)) {
    const domains = parseDomainForChannel(model, channel);
    const localScaleCmpt = localScaleComponents[channel];
    localScaleCmpt.setWithExplicit("domains", domains);
    parseSelectionDomain(model, channel);
    if (model.component.data.isFaceted) {
      let facetParent = model;
      while (!isFacetModel(facetParent) && facetParent.parent) {
        facetParent = facetParent.parent;
      }
      const resolve2 = facetParent.component.resolve.scale[channel];
      if (resolve2 === "shared") {
        for (const domain3 of domains.value) {
          if (isDataRefDomain(domain3)) {
            domain3.data = FACET_SCALE_PREFIX + domain3.data.replace(FACET_SCALE_PREFIX, "");
          }
        }
      }
    }
  }
}
function parseNonUnitScaleDomain(model) {
  for (const child of model.children) {
    parseScaleDomain2(child);
  }
  const localScaleComponents = model.component.scales;
  for (const channel of keys4(localScaleComponents)) {
    let domains;
    let selectionExtent = null;
    for (const child of model.children) {
      const childComponent = child.component.scales[channel];
      if (childComponent) {
        if (domains === void 0) {
          domains = childComponent.getWithExplicit("domains");
        } else {
          domains = mergeValuesWithExplicit(domains, childComponent.getWithExplicit("domains"), "domains", "scale", domainsTieBreaker);
        }
        const se = childComponent.get("selectionExtent");
        if (selectionExtent && se && selectionExtent.param !== se.param) {
          warn2(NEEDS_SAME_SELECTION);
        }
        selectionExtent = se;
      }
    }
    localScaleComponents[channel].setWithExplicit("domains", domains);
    if (selectionExtent) {
      localScaleComponents[channel].set("selectionExtent", selectionExtent, true);
    }
  }
}
function normalizeUnaggregatedDomain(domain3, fieldDef, scaleType2, scaleConfig) {
  if (domain3 === "unaggregated") {
    const { valid, reason } = canUseUnaggregatedDomain(fieldDef, scaleType2);
    if (!valid) {
      warn2(reason);
      return void 0;
    }
  } else if (domain3 === void 0 && scaleConfig.useUnaggregatedDomain) {
    const { valid } = canUseUnaggregatedDomain(fieldDef, scaleType2);
    if (valid) {
      return "unaggregated";
    }
  }
  return domain3;
}
function parseDomainForChannel(model, channel) {
  const scaleType2 = model.getScaleComponent(channel).get("type");
  const { encoding } = model;
  const domain3 = normalizeUnaggregatedDomain(model.scaleDomain(channel), model.typedFieldDef(channel), scaleType2, model.config.scale);
  if (domain3 !== model.scaleDomain(channel)) {
    model.specifiedScales[channel] = {
      ...model.specifiedScales[channel],
      domain: domain3
    };
  }
  if (channel === "x" && getFieldOrDatumDef(encoding.x2)) {
    if (getFieldOrDatumDef(encoding.x)) {
      return mergeValuesWithExplicit(parseSingleChannelDomain(scaleType2, domain3, model, "x"), parseSingleChannelDomain(scaleType2, domain3, model, "x2"), "domain", "scale", domainsTieBreaker);
    } else {
      return parseSingleChannelDomain(scaleType2, domain3, model, "x2");
    }
  } else if (channel === "y" && getFieldOrDatumDef(encoding.y2)) {
    if (getFieldOrDatumDef(encoding.y)) {
      return mergeValuesWithExplicit(parseSingleChannelDomain(scaleType2, domain3, model, "y"), parseSingleChannelDomain(scaleType2, domain3, model, "y2"), "domain", "scale", domainsTieBreaker);
    } else {
      return parseSingleChannelDomain(scaleType2, domain3, model, "y2");
    }
  }
  return parseSingleChannelDomain(scaleType2, domain3, model, channel);
}
function mapDomainToDataSignal(domain3, type7, timeUnit) {
  return domain3.map((v2) => {
    const data3 = valueExpr(v2, { timeUnit, type: type7 });
    return { signal: `{data: ${data3}}` };
  });
}
function convertDomainIfItIsDateTime(domain3, type7, timeUnit) {
  var _a2;
  const normalizedTimeUnit = (_a2 = normalizeTimeUnit(timeUnit)) == null ? void 0 : _a2.unit;
  if (type7 === "temporal" || normalizedTimeUnit) {
    return mapDomainToDataSignal(domain3, type7, normalizedTimeUnit);
  }
  return [domain3];
}
function parseSingleChannelDomain(scaleType2, domain3, model, channel) {
  const { encoding, markDef, mark, config, stack: stack2 } = model;
  const fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]);
  const { type: type7 } = fieldOrDatumDef;
  const timeUnit = fieldOrDatumDef["timeUnit"];
  const dataSourceTypeForScaleDomain = getScaleDataSourceForHandlingInvalidValues({
    invalid: getMarkConfig("invalid", markDef, config),
    isPath: isPathMark(mark)
  });
  if (isDomainUnionWith(domain3)) {
    const defaultDomain = parseSingleChannelDomain(scaleType2, void 0, model, channel);
    const unionWith = convertDomainIfItIsDateTime(domain3.unionWith, type7, timeUnit);
    return makeExplicit([...unionWith, ...defaultDomain.value]);
  } else if (isSignalRef(domain3)) {
    return makeExplicit([domain3]);
  } else if (domain3 && domain3 !== "unaggregated" && !isParameterDomain(domain3)) {
    return makeExplicit(convertDomainIfItIsDateTime(domain3, type7, timeUnit));
  }
  if (stack2 && channel === stack2.fieldChannel) {
    if (stack2.offset === "normalize") {
      return makeImplicit([[0, 1]]);
    }
    const data3 = model.requestDataName(dataSourceTypeForScaleDomain);
    return makeImplicit([
      {
        data: data3,
        field: model.vgField(channel, { suffix: "start" })
      },
      {
        data: data3,
        field: model.vgField(channel, { suffix: "end" })
      }
    ]);
  }
  const sort4 = isScaleChannel(channel) && isFieldDef(fieldOrDatumDef) ? domainSort(model, channel, scaleType2) : void 0;
  if (isDatumDef(fieldOrDatumDef)) {
    const d = convertDomainIfItIsDateTime([fieldOrDatumDef.datum], type7, timeUnit);
    return makeImplicit(d);
  }
  const fieldDef = fieldOrDatumDef;
  if (domain3 === "unaggregated") {
    const { field: field25 } = fieldOrDatumDef;
    return makeImplicit([
      {
        data: model.requestDataName(dataSourceTypeForScaleDomain),
        field: vgField({ field: field25, aggregate: "min" })
      },
      {
        data: model.requestDataName(dataSourceTypeForScaleDomain),
        field: vgField({ field: field25, aggregate: "max" })
      }
    ]);
  } else if (isBinning(fieldDef.bin)) {
    if (hasDiscreteDomain(scaleType2)) {
      if (scaleType2 === "bin-ordinal") {
        return makeImplicit([]);
      }
      return makeImplicit([
        {
          // If sort by aggregation of a specified sort field, we need to use RAW table,
          // so we can aggregate values for the scale independently from the main aggregation.
          data: isBoolean6(sort4) ? model.requestDataName(dataSourceTypeForScaleDomain) : model.requestDataName(DataSourceType.Raw),
          // Use range if we added it and the scale does not support computing a range as a signal.
          field: model.vgField(channel, binRequiresRange(fieldDef, channel) ? { binSuffix: "range" } : {}),
          // we have to use a sort object if sort = true to make the sort correct by bin start
          sort: sort4 === true || !isObject12(sort4) ? {
            field: model.vgField(channel, {}),
            op: "min"
            // min or max doesn't matter since we sort by the start of the bin range
          } : sort4
        }
      ]);
    } else {
      const { bin: bin5 } = fieldDef;
      if (isBinning(bin5)) {
        const binSignal = getBinSignalName(model, fieldDef.field, bin5);
        return makeImplicit([
          new SignalRefWrapper(() => {
            const signal = model.getSignalName(binSignal);
            return `[${signal}.start, ${signal}.stop]`;
          })
        ]);
      } else {
        return makeImplicit([
          {
            data: model.requestDataName(dataSourceTypeForScaleDomain),
            field: model.vgField(channel, {})
          }
        ]);
      }
    }
  } else if (fieldDef.timeUnit && contains2(["time", "utc"], scaleType2)) {
    const fieldDef2 = encoding[getSecondaryRangeChannel(channel)];
    if (hasBandEnd(fieldDef, fieldDef2, markDef, config)) {
      const data3 = model.requestDataName(dataSourceTypeForScaleDomain);
      const bandPosition = getBandPosition({ fieldDef, fieldDef2, markDef, config });
      const isRectWithOffset = isRectBasedMark(mark) && bandPosition !== 0.5 && isXorY(channel);
      return makeImplicit([
        {
          data: data3,
          field: model.vgField(channel, isRectWithOffset ? { suffix: OFFSETTED_RECT_START_SUFFIX } : {})
        },
        {
          data: data3,
          field: model.vgField(channel, { suffix: isRectWithOffset ? OFFSETTED_RECT_END_SUFFIX : "end" })
        }
      ]);
    }
  }
  if (sort4) {
    return makeImplicit([
      {
        // If sort by aggregation of a specified sort field, we need to use RAW table,
        // so we can aggregate values for the scale independently from the main aggregation.
        data: isBoolean6(sort4) ? model.requestDataName(dataSourceTypeForScaleDomain) : model.requestDataName(DataSourceType.Raw),
        field: model.vgField(channel),
        sort: sort4
      }
    ]);
  } else {
    return makeImplicit([
      {
        data: model.requestDataName(dataSourceTypeForScaleDomain),
        field: model.vgField(channel)
      }
    ]);
  }
}
function normalizeSortField(sort4, isStackedMeasure) {
  const { op, field: field25, order } = sort4;
  return {
    // Apply default op
    op: op ?? (isStackedMeasure ? "sum" : DEFAULT_SORT_OP),
    // flatten nested fields
    ...field25 ? { field: replacePathInField(field25) } : {},
    ...order ? { order } : {}
  };
}
function parseSelectionDomain(model, channel) {
  var _a2;
  const scale19 = model.component.scales[channel];
  const spec = model.specifiedScales[channel].domain;
  const bin5 = (_a2 = model.fieldDef(channel)) == null ? void 0 : _a2.bin;
  const domain3 = isParameterDomain(spec) ? spec : void 0;
  const extent8 = isBinParams(bin5) && isParameterExtent(bin5.extent) ? bin5.extent : void 0;
  if (domain3 || extent8) {
    scale19.set("selectionExtent", domain3 ?? extent8, true);
  }
}
function domainSort(model, channel, scaleType2) {
  if (!hasDiscreteDomain(scaleType2)) {
    return void 0;
  }
  const fieldDef = model.fieldDef(channel);
  const sort4 = fieldDef.sort;
  if (isSortArray(sort4)) {
    return {
      op: "min",
      field: sortArrayIndexField(fieldDef, channel),
      order: "ascending"
    };
  }
  const { stack: stack2 } = model;
  const stackDimensions = stack2 ? /* @__PURE__ */ new Set([...stack2.groupbyFields, ...stack2.stackBy.map((s2) => s2.fieldDef.field)]) : void 0;
  if (isSortField(sort4)) {
    const isStackedMeasure = stack2 && !stackDimensions.has(sort4.field);
    return normalizeSortField(sort4, isStackedMeasure);
  } else if (isSortByEncoding(sort4)) {
    const { encoding, order } = sort4;
    const fieldDefToSortBy = model.fieldDef(encoding);
    const { aggregate, field: field25 } = fieldDefToSortBy;
    const isStackedMeasure = stack2 && !stackDimensions.has(field25);
    if (isArgminDef(aggregate) || isArgmaxDef(aggregate)) {
      return normalizeSortField({
        field: vgField(fieldDefToSortBy),
        order
      }, isStackedMeasure);
    } else if (isAggregateOp(aggregate) || !aggregate) {
      return normalizeSortField({
        op: aggregate,
        // can't be argmin/argmax since we don't support them in encoding field def
        field: field25,
        order
      }, isStackedMeasure);
    }
  } else if (sort4 === "descending") {
    return {
      op: "min",
      field: model.vgField(channel),
      order: "descending"
    };
  } else if (contains2([
    "ascending",
    void 0
    /* default =ascending*/
  ], sort4)) {
    return true;
  }
  return void 0;
}
function canUseUnaggregatedDomain(fieldDef, scaleType2) {
  const { aggregate, type: type7 } = fieldDef;
  if (!aggregate) {
    return {
      valid: false,
      reason: unaggregateDomainHasNoEffectForRawField(fieldDef)
    };
  }
  if (isString14(aggregate) && !SHARED_DOMAIN_OPS.has(aggregate)) {
    return {
      valid: false,
      reason: unaggregateDomainWithNonSharedDomainOp(aggregate)
    };
  }
  if (type7 === "quantitative") {
    if (scaleType2 === "log") {
      return {
        valid: false,
        reason: unaggregatedDomainWithLogScale(fieldDef)
      };
    }
  }
  return { valid: true };
}
function domainsTieBreaker(v1, v2, property2, propertyOf) {
  if (v1.explicit && v2.explicit) {
    warn2(mergeConflictingDomainProperty(property2, propertyOf, v1.value, v2.value));
  }
  return { explicit: v1.explicit, value: [...v1.value, ...v2.value] };
}
function mergeDomains(domains) {
  const uniqueDomains = unique(domains.map((domain3) => {
    if (isDataRefDomain(domain3)) {
      const { sort: _s, ...domainWithoutSort } = domain3;
      return domainWithoutSort;
    }
    return domain3;
  }), hash);
  const sorts = unique(domains.map((d) => {
    if (isDataRefDomain(d)) {
      const s2 = d.sort;
      if (s2 !== void 0 && !isBoolean6(s2)) {
        if ("op" in s2 && s2.op === "count") {
          delete s2.field;
        }
        if (s2.order === "ascending") {
          delete s2.order;
        }
      }
      return s2;
    }
    return void 0;
  }).filter((s2) => s2 !== void 0), hash);
  if (uniqueDomains.length === 0) {
    return void 0;
  } else if (uniqueDomains.length === 1) {
    const domain3 = domains[0];
    if (isDataRefDomain(domain3) && sorts.length > 0) {
      let sort5 = sorts[0];
      if (sorts.length > 1) {
        warn2(MORE_THAN_ONE_SORT);
        const filteredSorts = sorts.filter((s2) => isObject12(s2) && "op" in s2 && s2.op !== "min");
        if (sorts.every((s2) => isObject12(s2) && "op" in s2) && filteredSorts.length === 1) {
          sort5 = filteredSorts[0];
        } else {
          sort5 = true;
        }
      } else {
        if (isObject12(sort5) && "field" in sort5) {
          const sortField = sort5.field;
          if (domain3.field === sortField) {
            sort5 = sort5.order ? { order: sort5.order } : true;
          }
        }
      }
      return {
        ...domain3,
        sort: sort5
      };
    }
    return domain3;
  }
  const unionDomainSorts = unique(sorts.map((s2) => {
    if (isBoolean6(s2) || !("op" in s2) || isString14(s2.op) && has19(MULTIDOMAIN_SORT_OP_INDEX, s2.op)) {
      return s2;
    }
    warn2(domainSortDropped(s2));
    return true;
  }), hash);
  let sort4;
  if (unionDomainSorts.length === 1) {
    sort4 = unionDomainSorts[0];
  } else if (unionDomainSorts.length > 1) {
    warn2(MORE_THAN_ONE_SORT);
    sort4 = true;
  }
  const allData = unique(domains.map((d) => {
    if (isDataRefDomain(d)) {
      return d.data;
    }
    return null;
  }), (x9) => x9);
  if (allData.length === 1 && allData[0] !== null) {
    const domain3 = {
      data: allData[0],
      fields: uniqueDomains.map((d) => d.field),
      ...sort4 ? { sort: sort4 } : {}
    };
    return domain3;
  }
  return { fields: uniqueDomains, ...sort4 ? { sort: sort4 } : {} };
}
function getFieldFromDomain(domain3) {
  if (isDataRefDomain(domain3) && isString14(domain3.field)) {
    return domain3.field;
  } else if (isDataRefUnionedDomain(domain3)) {
    let field25;
    for (const nonUnionDomain of domain3.fields) {
      if (isDataRefDomain(nonUnionDomain) && isString14(nonUnionDomain.field)) {
        if (!field25) {
          field25 = nonUnionDomain.field;
        } else if (field25 !== nonUnionDomain.field) {
          warn2(FACETED_INDEPENDENT_DIFFERENT_SOURCES);
          return field25;
        }
      }
    }
    warn2(FACETED_INDEPENDENT_SAME_FIELDS_DIFFERENT_SOURCES);
    return field25;
  } else if (isFieldRefUnionDomain(domain3)) {
    warn2(FACETED_INDEPENDENT_SAME_SOURCE);
    const field25 = domain3.fields[0];
    return isString14(field25) ? field25 : void 0;
  }
  return void 0;
}
function assembleDomain(model, channel) {
  const scaleComponent = model.component.scales[channel];
  const domains = scaleComponent.get("domains").map((domain3) => {
    if (isDataRefDomain(domain3)) {
      domain3.data = model.lookupDataSource(domain3.data);
    }
    return domain3;
  });
  return mergeDomains(domains);
}
function assembleScales(model) {
  if (isLayerModel(model) || isConcatModel(model)) {
    return model.children.reduce((scales10, child) => {
      return scales10.concat(assembleScales(child));
    }, assembleScalesForModel(model));
  } else {
    return assembleScalesForModel(model);
  }
}
function assembleScalesForModel(model) {
  return keys4(model.component.scales).reduce((scales10, channel) => {
    const scaleComponent = model.component.scales[channel];
    if (scaleComponent.merged) {
      return scales10;
    }
    const scale19 = scaleComponent.combine();
    const { name, type: type7, selectionExtent, domains: _d2, range: _r2, reverse: reverse4, ...otherScaleProps } = scale19;
    const range7 = assembleScaleRange(scale19.range, name, channel, model);
    const domain3 = assembleDomain(model, channel);
    const domainRaw = selectionExtent ? assembleSelectionScaleDomain(model, selectionExtent, scaleComponent, domain3) : null;
    scales10.push({
      name,
      type: type7,
      ...domain3 ? { domain: domain3 } : {},
      ...domainRaw ? { domainRaw } : {},
      range: range7,
      ...reverse4 !== void 0 ? { reverse: reverse4 } : {},
      ...otherScaleProps
    });
    return scales10;
  }, []);
}
function assembleScaleRange(scaleRange, scaleName, channel, model) {
  if (isXorY(channel)) {
    if (isVgRangeStep(scaleRange)) {
      return {
        step: { signal: `${scaleName}_step` }
      };
    }
  } else if (isObject12(scaleRange) && isDataRefDomain(scaleRange)) {
    return {
      ...scaleRange,
      data: model.lookupDataSource(scaleRange.data)
    };
  }
  return scaleRange;
}
var ScaleComponent = class extends Split {
  constructor(name, typeWithExplicit) {
    super(
      {},
      // no initial explicit property
      { name }
    );
    __publicField(this, "merged", false);
    this.setWithExplicit("type", typeWithExplicit);
  }
  /**
   * Whether the scale definitely includes or not include zero in the domain
   */
  domainHasZero() {
    const scaleType2 = this.get("type");
    if (contains2([ScaleType.LOG, ScaleType.TIME, ScaleType.UTC], scaleType2)) {
      return "definitely-not";
    }
    const scaleZero = this.get("zero");
    if (scaleZero === true || // If zero is undefined, linear/sqrt/pow scales have zero by default.
    scaleZero === void 0 && contains2([ScaleType.LINEAR, ScaleType.SQRT, ScaleType.POW], scaleType2)) {
      return "definitely";
    }
    const domains = this.get("domains");
    if (domains.length > 0) {
      let hasExplicitDomainWithZero = false;
      let hasExplicitDomainWithoutZero = false;
      let hasDomainBasedOnField = false;
      for (const d of domains) {
        if (isArray22(d)) {
          const first = d[0];
          const last = d[d.length - 1];
          if (isNumber14(first) && isNumber14(last)) {
            if (first <= 0 && last >= 0) {
              hasExplicitDomainWithZero = true;
              continue;
            } else {
              hasExplicitDomainWithoutZero = true;
              continue;
            }
          }
        }
        hasDomainBasedOnField = true;
      }
      if (hasExplicitDomainWithZero) {
        return "definitely";
      } else if (hasExplicitDomainWithoutZero && !hasDomainBasedOnField) {
        return "definitely-not";
      }
    }
    return "maybe";
  }
};
var RANGE_PROPERTIES = ["range", "scheme"];
function parseUnitScaleRange(model) {
  const localScaleComponents = model.component.scales;
  for (const channel of SCALE_CHANNELS) {
    const localScaleCmpt = localScaleComponents[channel];
    if (!localScaleCmpt) {
      continue;
    }
    const rangeWithExplicit = parseRangeForChannel(channel, model);
    localScaleCmpt.setWithExplicit("range", rangeWithExplicit);
  }
}
function getBinStepSignal(model, channel) {
  const fieldDef = model.fieldDef(channel);
  if (fieldDef == null ? void 0 : fieldDef.bin) {
    const { bin: bin5, field: field25 } = fieldDef;
    const sizeType = getSizeChannel(channel);
    const sizeSignal = model.getName(sizeType);
    if (isObject12(bin5) && bin5.binned && bin5.step !== void 0) {
      return new SignalRefWrapper(() => {
        const scaleName = model.scaleName(channel);
        const binCount = `(domain("${scaleName}")[1] - domain("${scaleName}")[0]) / ${bin5.step}`;
        return `${model.getSignalName(sizeSignal)} / (${binCount})`;
      });
    } else if (isBinning(bin5)) {
      const binSignal = getBinSignalName(model, field25, bin5);
      return new SignalRefWrapper(() => {
        const updatedName = model.getSignalName(binSignal);
        const binCount = `(${updatedName}.stop - ${updatedName}.start) / ${updatedName}.step`;
        return `${model.getSignalName(sizeSignal)} / (${binCount})`;
      });
    }
  }
  return void 0;
}
function parseRangeForChannel(channel, model) {
  const specifiedScale = model.specifiedScales[channel];
  const { size } = model;
  const mergedScaleCmpt = model.getScaleComponent(channel);
  const scaleType2 = mergedScaleCmpt.get("type");
  for (const property2 of RANGE_PROPERTIES) {
    if (specifiedScale[property2] !== void 0) {
      const supportedByScaleType = scaleTypeSupportProperty(scaleType2, property2);
      const channelIncompatability = channelScalePropertyIncompatability(channel, property2);
      if (!supportedByScaleType) {
        warn2(scalePropertyNotWorkWithScaleType(scaleType2, property2, channel));
      } else if (channelIncompatability) {
        warn2(channelIncompatability);
      } else {
        switch (property2) {
          case "range": {
            const range7 = specifiedScale.range;
            if (isArray22(range7)) {
              if (isXorY(channel)) {
                return makeExplicit(range7.map((v2) => {
                  if (v2 === "width" || v2 === "height") {
                    const sizeSignal = model.getName(v2);
                    const getSignalName = model.getSignalName.bind(model);
                    return SignalRefWrapper.fromName(getSignalName, sizeSignal);
                  }
                  return v2;
                }));
              }
            } else if (isObject12(range7)) {
              return makeExplicit({
                data: model.requestDataName(DataSourceType.Main),
                field: range7.field,
                sort: { op: "min", field: model.vgField(channel) }
              });
            }
            return makeExplicit(range7);
          }
          case "scheme":
            return makeExplicit(parseScheme(specifiedScale[property2]));
        }
      }
    }
  }
  const sizeChannel = channel === X3 || channel === "xOffset" ? "width" : "height";
  const sizeValue = size[sizeChannel];
  if (isStep(sizeValue)) {
    if (isXorY(channel)) {
      if (hasDiscreteDomain(scaleType2)) {
        const step = getPositionStep(sizeValue, model, channel);
        if (step) {
          return makeExplicit({ step });
        }
      } else {
        warn2(stepDropped(sizeChannel));
      }
    } else if (isXorYOffset(channel)) {
      const positionChannel = channel === XOFFSET ? "x" : "y";
      const positionScaleCmpt = model.getScaleComponent(positionChannel);
      const positionScaleType = positionScaleCmpt.get("type");
      if (positionScaleType === "band") {
        const step = getOffsetStep(sizeValue, scaleType2);
        if (step) {
          return makeExplicit(step);
        }
      }
    }
  }
  const { rangeMin: rangeMin2, rangeMax: rangeMax2 } = specifiedScale;
  const d = defaultRange(channel, model);
  if ((rangeMin2 !== void 0 || rangeMax2 !== void 0) && // it's ok to check just rangeMin's compatibility since rangeMin/rangeMax are the same
  scaleTypeSupportProperty(scaleType2, "rangeMin") && isArray22(d) && d.length === 2) {
    return makeExplicit([rangeMin2 ?? d[0], rangeMax2 ?? d[1]]);
  }
  return makeImplicit(d);
}
function parseScheme(scheme38) {
  if (isExtendedScheme(scheme38)) {
    return {
      scheme: scheme38.name,
      ...omit(scheme38, ["name"])
    };
  }
  return { scheme: scheme38 };
}
function fullWidthOrHeightRange(channel, model, scaleType2, { center } = {}) {
  const sizeType = getSizeChannel(channel);
  const sizeSignal = model.getName(sizeType);
  const getSignalName = model.getSignalName.bind(model);
  if (channel === Y3 && hasContinuousDomain(scaleType2)) {
    return center ? [
      SignalRefWrapper.fromName((name) => `${getSignalName(name)}/2`, sizeSignal),
      SignalRefWrapper.fromName((name) => `-${getSignalName(name)}/2`, sizeSignal)
    ] : [SignalRefWrapper.fromName(getSignalName, sizeSignal), 0];
  } else {
    return center ? [
      SignalRefWrapper.fromName((name) => `-${getSignalName(name)}/2`, sizeSignal),
      SignalRefWrapper.fromName((name) => `${getSignalName(name)}/2`, sizeSignal)
    ] : [0, SignalRefWrapper.fromName(getSignalName, sizeSignal)];
  }
}
function defaultRange(channel, model) {
  const { size, config, mark, encoding } = model;
  const { type: type7 } = getFieldOrDatumDef(encoding[channel]);
  const mergedScaleCmpt = model.getScaleComponent(channel);
  const scaleType2 = mergedScaleCmpt.get("type");
  const { domain: domain3, domainMid } = model.specifiedScales[channel];
  switch (channel) {
    case X3:
    case Y3: {
      if (contains2(["point", "band"], scaleType2)) {
        const positionSize = getDiscretePositionSize(channel, size, config.view);
        if (isStep(positionSize)) {
          const step = getPositionStep(positionSize, model, channel);
          return { step };
        }
      }
      return fullWidthOrHeightRange(channel, model, scaleType2);
    }
    case XOFFSET:
    case YOFFSET:
      return getOffsetRange(channel, model, scaleType2);
    case SIZE2: {
      const rangeMin2 = sizeRangeMin(mark, config);
      const rangeMax2 = sizeRangeMax(mark, size, model, config);
      if (isContinuousToDiscrete(scaleType2)) {
        return interpolateRange3(rangeMin2, rangeMax2, defaultContinuousToDiscreteCount(scaleType2, config, domain3, channel));
      } else {
        return [rangeMin2, rangeMax2];
      }
    }
    case THETA:
      return [0, Math.PI * 2];
    case ANGLE:
      return [0, 360];
    case RADIUS: {
      return [
        0,
        new SignalRefWrapper(() => {
          const w8 = model.getSignalName(isFacetModel(model.parent) ? "child_width" : "width");
          const h6 = model.getSignalName(isFacetModel(model.parent) ? "child_height" : "height");
          return `min(${w8},${h6})/2`;
        })
      ];
    }
    case TIME: {
      return { step: 1e3 / config.scale.framesPerSecond };
    }
    case STROKEWIDTH:
      return [config.scale.minStrokeWidth, config.scale.maxStrokeWidth];
    case STROKEDASH:
      return [
        // TODO: add this to Vega's config.range?
        [1, 0],
        [4, 2],
        [2, 1],
        [1, 1],
        [1, 2, 4, 2]
      ];
    case SHAPE:
      return "symbol";
    case COLOR:
    case FILL:
    case STROKE:
      if (scaleType2 === "ordinal") {
        return type7 === "nominal" ? "category" : "ordinal";
      } else {
        if (domainMid !== void 0) {
          return "diverging";
        } else {
          return mark === "rect" || mark === "geoshape" ? "heatmap" : "ramp";
        }
      }
    case OPACITY:
    case FILLOPACITY:
    case STROKEOPACITY:
      return [config.scale.minOpacity, config.scale.maxOpacity];
  }
}
function getPositionStep(step, model, channel) {
  const { encoding } = model;
  const mergedScaleCmpt = model.getScaleComponent(channel);
  const offsetChannel = getOffsetScaleChannel(channel);
  const offsetDef = encoding[offsetChannel];
  const stepFor = getStepFor({ step, offsetIsDiscrete: isFieldOrDatumDef(offsetDef) && isDiscrete$1(offsetDef.type) });
  if (stepFor === "offset" && channelHasFieldOrDatum(encoding, offsetChannel)) {
    const offsetScaleCmpt = model.getScaleComponent(offsetChannel);
    const offsetScaleName = model.scaleName(offsetChannel);
    let stepCount = `domain('${offsetScaleName}').length`;
    if (offsetScaleCmpt.get("type") === "band") {
      const offsetPaddingInner = offsetScaleCmpt.get("paddingInner") ?? offsetScaleCmpt.get("padding") ?? 0;
      const offsetPaddingOuter = offsetScaleCmpt.get("paddingOuter") ?? offsetScaleCmpt.get("padding") ?? 0;
      stepCount = `bandspace(${stepCount}, ${offsetPaddingInner}, ${offsetPaddingOuter})`;
    }
    const paddingInner2 = mergedScaleCmpt.get("paddingInner") ?? mergedScaleCmpt.get("padding");
    return {
      signal: `${step.step} * ${stepCount} / (1-${exprFromSignalRefOrValue(paddingInner2)})`
    };
  } else {
    return step.step;
  }
}
function getOffsetStep(step, offsetScaleType) {
  const stepFor = getStepFor({ step, offsetIsDiscrete: hasDiscreteDomain(offsetScaleType) });
  if (stepFor === "offset") {
    return { step: step.step };
  }
  return void 0;
}
function getOffsetRange(channel, model, offsetScaleType) {
  const positionChannel = channel === XOFFSET ? "x" : "y";
  const positionScaleCmpt = model.getScaleComponent(positionChannel);
  if (!positionScaleCmpt) {
    return fullWidthOrHeightRange(positionChannel, model, offsetScaleType, { center: true });
  }
  const positionScaleType = positionScaleCmpt.get("type");
  const positionScaleName = model.scaleName(positionChannel);
  const { markDef, config } = model;
  if (positionScaleType === "band") {
    const size = getDiscretePositionSize(positionChannel, model.size, model.config.view);
    if (isStep(size)) {
      const step = getOffsetStep(size, offsetScaleType);
      if (step) {
        return step;
      }
    }
    return [0, { signal: `bandwidth('${positionScaleName}')` }];
  } else {
    const positionDef = model.encoding[positionChannel];
    if (isFieldDef(positionDef) && positionDef.timeUnit) {
      const duration = durationExpr(positionDef.timeUnit, (expr2) => `scale('${positionScaleName}', ${expr2})`);
      const padding3 = model.config.scale.bandWithNestedOffsetPaddingInner;
      const bandPositionOffset = getBandPosition({
        fieldDef: positionDef,
        markDef,
        config
      }) - 0.5;
      const bandPositionOffsetExpr = bandPositionOffset !== 0 ? ` + ${bandPositionOffset}` : "";
      if (padding3) {
        const startRatio = isSignalRef(padding3) ? `${padding3.signal}/2${bandPositionOffsetExpr}` : `${padding3 / 2 + bandPositionOffset}`;
        const endRatio = isSignalRef(padding3) ? `(1 - ${padding3.signal}/2)${bandPositionOffsetExpr}` : `${1 - padding3 / 2 + bandPositionOffset}`;
        return [{ signal: `${startRatio} * (${duration})` }, { signal: `${endRatio} * (${duration})` }];
      }
      return [0, { signal: duration }];
    }
    return never(`Cannot use ${channel} scale if ${positionChannel} scale is not discrete.`);
  }
}
function getDiscretePositionSize(channel, size, viewConfig) {
  const sizeChannel = channel === X3 ? "width" : "height";
  const sizeValue = size[sizeChannel];
  if (sizeValue !== void 0) {
    return sizeValue;
  }
  return getViewConfigDiscreteSize(viewConfig, sizeChannel);
}
function defaultContinuousToDiscreteCount(scaleType2, config, domain3, channel) {
  switch (scaleType2) {
    case "quantile":
      return config.scale.quantileCount;
    case "quantize":
      return config.scale.quantizeCount;
    case "threshold":
      if (domain3 !== void 0 && isArray22(domain3)) {
        return domain3.length + 1;
      } else {
        warn2(domainRequiredForThresholdScale(channel));
        return 3;
      }
  }
}
function interpolateRange3(rangeMin2, rangeMax2, cardinality) {
  const f = () => {
    const rMax = signalOrStringValue(rangeMax2);
    const rMin = signalOrStringValue(rangeMin2);
    const step = `(${rMax} - ${rMin}) / (${cardinality} - 1)`;
    return `sequence(${rMin}, ${rMax} + ${step}, ${step})`;
  };
  if (isSignalRef(rangeMax2)) {
    return new SignalRefWrapper(f);
  } else {
    return { signal: f() };
  }
}
function sizeRangeMin(mark, config) {
  switch (mark) {
    case "bar":
    case "tick":
      return config.scale.minBandSize;
    case "line":
    case "trail":
    case "rule":
      return config.scale.minStrokeWidth;
    case "text":
      return config.scale.minFontSize;
    case "point":
    case "square":
    case "circle":
      return config.scale.minSize;
  }
  throw new Error(incompatibleChannel("size", mark));
}
var MAX_SIZE_RANGE_STEP_RATIO = 0.95;
function sizeRangeMax(mark, size, model, config) {
  const xyStepSignals = {
    x: getBinStepSignal(model, "x"),
    y: getBinStepSignal(model, "y")
  };
  switch (mark) {
    case "bar":
    case "tick": {
      if (config.scale.maxBandSize !== void 0) {
        return config.scale.maxBandSize;
      }
      const min5 = minXYStep(size, xyStepSignals, config.view);
      if (isNumber14(min5)) {
        return min5 - 1;
      } else {
        return new SignalRefWrapper(() => `${min5.signal} - 1`);
      }
    }
    case "line":
    case "trail":
    case "rule":
      return config.scale.maxStrokeWidth;
    case "text":
      return config.scale.maxFontSize;
    case "point":
    case "square":
    case "circle": {
      if (config.scale.maxSize) {
        return config.scale.maxSize;
      }
      const pointStep = minXYStep(size, xyStepSignals, config.view);
      if (isNumber14(pointStep)) {
        return Math.pow(MAX_SIZE_RANGE_STEP_RATIO * pointStep, 2);
      } else {
        return new SignalRefWrapper(() => `pow(${MAX_SIZE_RANGE_STEP_RATIO} * ${pointStep.signal}, 2)`);
      }
    }
  }
  throw new Error(incompatibleChannel("size", mark));
}
function minXYStep(size, xyStepSignals, viewConfig) {
  const widthStep = isStep(size.width) ? size.width.step : getViewConfigDiscreteStep(viewConfig, "width");
  const heightStep = isStep(size.height) ? size.height.step : getViewConfigDiscreteStep(viewConfig, "height");
  if (xyStepSignals.x || xyStepSignals.y) {
    return new SignalRefWrapper(() => {
      const exprs = [
        xyStepSignals.x ? xyStepSignals.x.signal : widthStep,
        xyStepSignals.y ? xyStepSignals.y.signal : heightStep
      ];
      return `min(${exprs.join(", ")})`;
    });
  }
  return Math.min(widthStep, heightStep);
}
function parseScaleProperty(model, property2) {
  if (isUnitModel(model)) {
    parseUnitScaleProperty(model, property2);
  } else {
    parseNonUnitScaleProperty(model, property2);
  }
}
function parseUnitScaleProperty(model, property2) {
  const localScaleComponents = model.component.scales;
  const { config, encoding, markDef, specifiedScales } = model;
  for (const channel of keys4(localScaleComponents)) {
    const specifiedScale = specifiedScales[channel];
    const localScaleCmpt = localScaleComponents[channel];
    const mergedScaleCmpt = model.getScaleComponent(channel);
    const fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]);
    const specifiedValue = specifiedScale[property2];
    const scaleType2 = mergedScaleCmpt.get("type");
    const scalePadding = mergedScaleCmpt.get("padding");
    const scalePaddingInner = mergedScaleCmpt.get("paddingInner");
    const supportedByScaleType = scaleTypeSupportProperty(scaleType2, property2);
    const channelIncompatability = channelScalePropertyIncompatability(channel, property2);
    if (specifiedValue !== void 0) {
      if (!supportedByScaleType) {
        warn2(scalePropertyNotWorkWithScaleType(scaleType2, property2, channel));
      } else if (channelIncompatability) {
        warn2(channelIncompatability);
      }
    }
    if (supportedByScaleType && channelIncompatability === void 0) {
      if (specifiedValue !== void 0) {
        const timeUnit = fieldOrDatumDef.timeUnit;
        const type7 = fieldOrDatumDef.type;
        switch (property2) {
          case "domainMax":
          case "domainMin":
            if (isDateTime(specifiedScale[property2]) || type7 === "temporal" || timeUnit) {
              localScaleCmpt.set(property2, { signal: valueExpr(specifiedScale[property2], { type: type7, timeUnit }) }, true);
            } else {
              localScaleCmpt.set(property2, specifiedScale[property2], true);
            }
            break;
          default:
            localScaleCmpt.copyKeyFromObject(property2, specifiedScale);
        }
      } else {
        const value7 = hasProperty(scaleRules, property2) ? scaleRules[property2]({
          model,
          channel,
          fieldOrDatumDef,
          scaleType: scaleType2,
          scalePadding,
          scalePaddingInner,
          domain: specifiedScale.domain,
          domainMin: specifiedScale.domainMin,
          domainMax: specifiedScale.domainMax,
          markDef,
          config,
          hasNestedOffsetScale: channelHasNestedOffsetScale(encoding, channel),
          hasSecondaryRangeChannel: !!encoding[getSecondaryRangeChannel(channel)]
        }) : config.scale[property2];
        if (value7 !== void 0) {
          localScaleCmpt.set(property2, value7, false);
        }
      }
    }
  }
}
var scaleRules = {
  bins: ({ model, fieldOrDatumDef }) => isFieldDef(fieldOrDatumDef) ? bins(model, fieldOrDatumDef) : void 0,
  interpolate: ({ channel, fieldOrDatumDef }) => interpolate10(channel, fieldOrDatumDef.type),
  nice: ({ scaleType: scaleType2, channel, domain: domain3, domainMin, domainMax, fieldOrDatumDef }) => nice3(scaleType2, channel, domain3, domainMin, domainMax, fieldOrDatumDef),
  padding: ({ channel, scaleType: scaleType2, fieldOrDatumDef, markDef, config }) => padding2(channel, scaleType2, config.scale, fieldOrDatumDef, markDef, config.bar),
  paddingInner: ({ scalePadding, channel, markDef, scaleType: scaleType2, config, hasNestedOffsetScale }) => paddingInner(scalePadding, channel, markDef.type, scaleType2, config.scale, hasNestedOffsetScale),
  paddingOuter: ({ scalePadding, channel, scaleType: scaleType2, scalePaddingInner, config, hasNestedOffsetScale }) => paddingOuter(scalePadding, channel, scaleType2, scalePaddingInner, config.scale, hasNestedOffsetScale),
  reverse: ({ fieldOrDatumDef, scaleType: scaleType2, channel, config }) => {
    const sort4 = isFieldDef(fieldOrDatumDef) ? fieldOrDatumDef.sort : void 0;
    return reverse3(scaleType2, sort4, channel, config.scale);
  },
  zero: ({ channel, fieldOrDatumDef, domain: domain3, markDef, scaleType: scaleType2, config, hasSecondaryRangeChannel }) => zero26(channel, fieldOrDatumDef, domain3, markDef, scaleType2, config.scale, hasSecondaryRangeChannel)
};
function parseScaleRange2(model) {
  if (isUnitModel(model)) {
    parseUnitScaleRange(model);
  } else {
    parseNonUnitScaleProperty(model, "range");
  }
}
function parseNonUnitScaleProperty(model, property2) {
  const localScaleComponents = model.component.scales;
  for (const child of model.children) {
    if (property2 === "range") {
      parseScaleRange2(child);
    } else {
      parseScaleProperty(child, property2);
    }
  }
  for (const channel of keys4(localScaleComponents)) {
    let valueWithExplicit;
    for (const child of model.children) {
      const childComponent = child.component.scales[channel];
      if (childComponent) {
        const childValueWithExplicit = childComponent.getWithExplicit(property2);
        valueWithExplicit = mergeValuesWithExplicit(valueWithExplicit, childValueWithExplicit, property2, "scale", tieBreakByComparing((v1, v2) => {
          switch (property2) {
            case "range":
              if (v1.step && v2.step) {
                return v1.step - v2.step;
              }
              return 0;
          }
          return 0;
        }));
      }
    }
    localScaleComponents[channel].setWithExplicit(property2, valueWithExplicit);
  }
}
function bins(model, fieldDef) {
  const bin5 = fieldDef.bin;
  if (isBinning(bin5)) {
    const binSignal = getBinSignalName(model, fieldDef.field, bin5);
    return new SignalRefWrapper(() => {
      return model.getSignalName(binSignal);
    });
  } else if (isBinned(bin5) && isBinParams(bin5) && bin5.step !== void 0) {
    return {
      step: bin5.step
    };
  }
  return void 0;
}
function interpolate10(channel, type7) {
  if (contains2([COLOR, FILL, STROKE], channel) && type7 !== "nominal") {
    return "hcl";
  }
  return void 0;
}
function nice3(scaleType2, channel, specifiedDomain, domainMin, domainMax, fieldOrDatumDef) {
  var _a2;
  if (((_a2 = getFieldDef(fieldOrDatumDef)) == null ? void 0 : _a2.bin) || isArray22(specifiedDomain) || domainMax != null || domainMin != null || contains2([ScaleType.TIME, ScaleType.UTC], scaleType2)) {
    return void 0;
  }
  return isXorY(channel) ? true : void 0;
}
function padding2(channel, scaleType2, scaleConfig, fieldOrDatumDef, markDef, barConfig) {
  if (isXorY(channel)) {
    if (isContinuousToContinuous(scaleType2)) {
      if (scaleConfig.continuousPadding !== void 0) {
        return scaleConfig.continuousPadding;
      }
      const { type: type7, orient: orient2 } = markDef;
      if (type7 === "bar" && !(isFieldDef(fieldOrDatumDef) && (fieldOrDatumDef.bin || fieldOrDatumDef.timeUnit))) {
        if (orient2 === "vertical" && channel === "x" || orient2 === "horizontal" && channel === "y") {
          return barConfig.continuousBandSize;
        }
      }
    }
    if (scaleType2 === ScaleType.POINT) {
      return scaleConfig.pointPadding;
    }
  }
  return void 0;
}
function paddingInner(paddingValue, channel, mark, scaleType2, scaleConfig, hasNestedOffsetScale = false) {
  if (paddingValue !== void 0) {
    return void 0;
  }
  if (isXorY(channel)) {
    const { bandPaddingInner, barBandPaddingInner, rectBandPaddingInner, tickBandPaddingInner, bandWithNestedOffsetPaddingInner } = scaleConfig;
    if (hasNestedOffsetScale) {
      return bandWithNestedOffsetPaddingInner;
    }
    return getFirstDefined(bandPaddingInner, mark === "bar" ? barBandPaddingInner : mark === "tick" ? tickBandPaddingInner : rectBandPaddingInner);
  } else if (isXorYOffset(channel)) {
    if (scaleType2 === ScaleType.BAND) {
      return scaleConfig.offsetBandPaddingInner;
    }
  }
  return void 0;
}
function paddingOuter(paddingValue, channel, scaleType2, paddingInnerValue, scaleConfig, hasNestedOffsetScale = false) {
  if (paddingValue !== void 0) {
    return void 0;
  }
  if (isXorY(channel)) {
    const { bandPaddingOuter, bandWithNestedOffsetPaddingOuter } = scaleConfig;
    if (hasNestedOffsetScale) {
      return bandWithNestedOffsetPaddingOuter;
    }
    if (scaleType2 === ScaleType.BAND) {
      return getFirstDefined(
        bandPaddingOuter,
        /* By default, paddingOuter is paddingInner / 2. The reason is that
          size (width/height) = step * (cardinality - paddingInner + 2 * paddingOuter).
          and we want the width/height to be integer by default.
          Note that step (by default) and cardinality are integers.) */
        isSignalRef(paddingInnerValue) ? { signal: `${paddingInnerValue.signal}/2` } : paddingInnerValue / 2
      );
    }
  } else if (isXorYOffset(channel)) {
    if (scaleType2 === ScaleType.POINT) {
      return 0.5;
    } else if (scaleType2 === ScaleType.BAND) {
      return scaleConfig.offsetBandPaddingOuter;
    }
  }
  return void 0;
}
function reverse3(scaleType2, sort4, channel, scaleConfig) {
  if (channel === "x" && scaleConfig.xReverse !== void 0) {
    if (hasContinuousDomain(scaleType2) && sort4 === "descending") {
      if (isSignalRef(scaleConfig.xReverse)) {
        return { signal: `!${scaleConfig.xReverse.signal}` };
      } else {
        return !scaleConfig.xReverse;
      }
    }
    return scaleConfig.xReverse;
  }
  if (hasContinuousDomain(scaleType2) && sort4 === "descending") {
    return true;
  }
  return void 0;
}
function zero26(channel, fieldDef, specifiedDomain, markDef, scaleType2, scaleConfig, hasSecondaryRangeChannel) {
  const hasCustomDomain = !!specifiedDomain && specifiedDomain !== "unaggregated";
  if (hasCustomDomain) {
    if (hasContinuousDomain(scaleType2)) {
      if (isArray22(specifiedDomain)) {
        const first = specifiedDomain[0];
        const last = specifiedDomain[specifiedDomain.length - 1];
        if (isNumber14(first) && first <= 0 && isNumber14(last) && last >= 0) {
          return true;
        }
      }
      return false;
    }
  }
  if (channel === "size" && fieldDef.type === "quantitative" && !isContinuousToDiscrete(scaleType2)) {
    return true;
  }
  if (!(isFieldDef(fieldDef) && fieldDef.bin) && contains2([...POSITION_SCALE_CHANNELS, ...POLAR_POSITION_SCALE_CHANNELS], channel)) {
    const { orient: orient2, type: type7 } = markDef;
    if (contains2(["bar", "area", "line", "trail"], type7)) {
      if (orient2 === "horizontal" && channel === "y" || orient2 === "vertical" && channel === "x") {
        return false;
      }
    }
    if (contains2(["bar", "area"], type7) && !hasSecondaryRangeChannel) {
      return true;
    }
    return scaleConfig == null ? void 0 : scaleConfig.zero;
  }
  return false;
}
function scaleType(specifiedScale, channel, fieldDef, mark, hasNestedOffsetScale = false) {
  const defaultScaleType = defaultType(channel, fieldDef, mark, hasNestedOffsetScale);
  const { type: type7 } = specifiedScale;
  if (!isScaleChannel(channel)) {
    return null;
  }
  if (type7 !== void 0) {
    if (!channelSupportScaleType(channel, type7)) {
      warn2(scaleTypeNotWorkWithChannel(channel, type7, defaultScaleType));
      return defaultScaleType;
    }
    if (isFieldDef(fieldDef) && !scaleTypeSupportDataType(type7, fieldDef.type)) {
      warn2(scaleTypeNotWorkWithFieldDef(type7, defaultScaleType));
      return defaultScaleType;
    }
    return type7;
  }
  return defaultScaleType;
}
function defaultType(channel, fieldDef, mark, hasNestedOffsetScale) {
  var _a2;
  switch (fieldDef.type) {
    case "nominal":
    case "ordinal": {
      if (isColorChannel(channel) || rangeType(channel) === "discrete") {
        if (channel === "shape" && fieldDef.type === "ordinal") {
          warn2(discreteChannelCannotEncode(channel, "ordinal"));
        }
        return "ordinal";
      }
      if (isTime(channel)) {
        return "band";
      }
      if (isXorY(channel) || isXorYOffset(channel)) {
        if (contains2(["rect", "bar", "image", "rule", "tick"], mark.type)) {
          return "band";
        }
        if (hasNestedOffsetScale) {
          return "band";
        }
      } else if (mark.type === "arc" && channel in POLAR_POSITION_SCALE_CHANNEL_INDEX) {
        return "band";
      }
      const dimensionSize = mark[getSizeChannel(channel)];
      if (isRelativeBandSize(dimensionSize)) {
        return "band";
      }
      if (isPositionFieldOrDatumDef(fieldDef) && ((_a2 = fieldDef.axis) == null ? void 0 : _a2.tickBand)) {
        return "band";
      }
      return "point";
    }
    case "temporal":
      if (isColorChannel(channel)) {
        return "time";
      } else if (rangeType(channel) === "discrete") {
        warn2(discreteChannelCannotEncode(channel, "temporal"));
        return "ordinal";
      } else if (isFieldDef(fieldDef) && fieldDef.timeUnit && normalizeTimeUnit(fieldDef.timeUnit).utc) {
        return "utc";
      } else if (isTime(channel)) {
        return "band";
      }
      return "time";
    case "quantitative":
      if (isColorChannel(channel)) {
        if (isFieldDef(fieldDef) && isBinning(fieldDef.bin)) {
          return "bin-ordinal";
        }
        return "linear";
      } else if (rangeType(channel) === "discrete") {
        warn2(discreteChannelCannotEncode(channel, "quantitative"));
        return "ordinal";
      } else if (isTime(channel)) {
        return "band";
      }
      return "linear";
    case "geojson":
      return void 0;
  }
  throw new Error(invalidFieldType(fieldDef.type));
}
function parseScales(model, { ignoreRange } = {}) {
  parseScaleCore(model);
  parseScaleDomain2(model);
  for (const prop of NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTIES) {
    parseScaleProperty(model, prop);
  }
  if (!ignoreRange) {
    parseScaleRange2(model);
  }
}
function parseScaleCore(model) {
  if (isUnitModel(model)) {
    model.component.scales = parseUnitScaleCore(model);
  } else {
    model.component.scales = parseNonUnitScaleCore(model);
  }
}
function parseUnitScaleCore(model) {
  const { encoding, mark, markDef } = model;
  const scaleComponents = {};
  for (const channel of SCALE_CHANNELS) {
    const fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]);
    if (fieldOrDatumDef && mark === GEOSHAPE && channel === SHAPE && fieldOrDatumDef.type === GEOJSON) {
      continue;
    }
    let specifiedScale = fieldOrDatumDef && fieldOrDatumDef.scale;
    if (fieldOrDatumDef && specifiedScale !== null && specifiedScale !== false) {
      specifiedScale ?? (specifiedScale = {});
      const hasNestedOffsetScale = channelHasNestedOffsetScale(encoding, channel);
      const sType = scaleType(specifiedScale, channel, fieldOrDatumDef, markDef, hasNestedOffsetScale);
      scaleComponents[channel] = new ScaleComponent(model.scaleName(`${channel}`, true), {
        value: sType,
        explicit: specifiedScale.type === sType
      });
    }
  }
  return scaleComponents;
}
var scaleTypeTieBreaker = tieBreakByComparing((st1, st2) => scaleTypePrecedence(st1) - scaleTypePrecedence(st2));
function parseNonUnitScaleCore(model) {
  var _a2;
  const scaleComponents = model.component.scales = {};
  const scaleTypeWithExplicitIndex = {};
  const resolve2 = model.component.resolve;
  for (const child of model.children) {
    parseScaleCore(child);
    for (const channel of keys4(child.component.scales)) {
      (_a2 = resolve2.scale)[channel] ?? (_a2[channel] = defaultScaleResolve(channel, model));
      if (resolve2.scale[channel] === "shared") {
        const explicitScaleType = scaleTypeWithExplicitIndex[channel];
        const childScaleType = child.component.scales[channel].getWithExplicit("type");
        if (explicitScaleType) {
          if (scaleCompatible(explicitScaleType.value, childScaleType.value)) {
            scaleTypeWithExplicitIndex[channel] = mergeValuesWithExplicit(explicitScaleType, childScaleType, "type", "scale", scaleTypeTieBreaker);
          } else {
            resolve2.scale[channel] = "independent";
            delete scaleTypeWithExplicitIndex[channel];
          }
        } else {
          scaleTypeWithExplicitIndex[channel] = childScaleType;
        }
      }
    }
  }
  for (const channel of keys4(scaleTypeWithExplicitIndex)) {
    const name = model.scaleName(channel, true);
    const typeWithExplicit = scaleTypeWithExplicitIndex[channel];
    scaleComponents[channel] = new ScaleComponent(name, typeWithExplicit);
    for (const child of model.children) {
      const childScale = child.component.scales[channel];
      if (childScale) {
        child.renameScale(childScale.get("name"), name);
        childScale.merged = true;
      }
    }
  }
  return scaleComponents;
}
var NameMap = class {
  constructor() {
    __publicField(this, "nameMap");
    this.nameMap = {};
  }
  rename(oldName, newName) {
    this.nameMap[oldName] = newName;
  }
  has(name) {
    return this.nameMap[name] !== void 0;
  }
  get(name) {
    while (this.nameMap[name] && name !== this.nameMap[name]) {
      name = this.nameMap[name];
    }
    return name;
  }
};
function isUnitModel(model) {
  return (model == null ? void 0 : model.type) === "unit";
}
function isFacetModel(model) {
  return (model == null ? void 0 : model.type) === "facet";
}
function isConcatModel(model) {
  return (model == null ? void 0 : model.type) === "concat";
}
function isLayerModel(model) {
  return (model == null ? void 0 : model.type) === "layer";
}
var Model = class {
  constructor(spec, type7, parent, parentGivenName, config, resolve2, view) {
    __publicField(this, "type");
    __publicField(this, "parent");
    __publicField(this, "config");
    __publicField(this, "name");
    __publicField(this, "size");
    __publicField(this, "title");
    __publicField(this, "description");
    __publicField(this, "data");
    __publicField(this, "transforms");
    __publicField(this, "layout");
    /** Name map for scales, which can be renamed by a model's parent. */
    __publicField(this, "scaleNameMap");
    /** Name map for projections, which can be renamed by a model's parent. */
    __publicField(this, "projectionNameMap");
    /** Name map for signals, which can be renamed by a model's parent. */
    __publicField(this, "signalNameMap");
    __publicField(this, "component");
    __publicField(this, "view");
    this.type = type7;
    this.parent = parent;
    this.config = config;
    this.parent = parent;
    this.config = config;
    this.view = replaceExprRef(view);
    this.name = spec.name ?? parentGivenName;
    this.title = isText(spec.title) ? { text: spec.title } : spec.title ? replaceExprRef(spec.title) : void 0;
    this.scaleNameMap = parent ? parent.scaleNameMap : new NameMap();
    this.projectionNameMap = parent ? parent.projectionNameMap : new NameMap();
    this.signalNameMap = parent ? parent.signalNameMap : new NameMap();
    this.data = spec.data;
    this.description = spec.description;
    this.transforms = normalizeTransform(spec.transform ?? []);
    this.layout = type7 === "layer" || type7 === "unit" ? {} : extractCompositionLayout(spec, type7, config);
    this.component = {
      data: {
        sources: parent ? parent.component.data.sources : [],
        outputNodes: parent ? parent.component.data.outputNodes : {},
        outputNodeRefCounts: parent ? parent.component.data.outputNodeRefCounts : {},
        // data is faceted if the spec is a facet spec or the parent has faceted data and data is undefined
        isFaceted: isFacetSpec(spec) || (parent == null ? void 0 : parent.component.data.isFaceted) && spec.data === void 0
      },
      layoutSize: new Split(),
      layoutHeaders: { row: {}, column: {}, facet: {} },
      mark: null,
      resolve: {
        scale: {},
        axis: {},
        legend: {},
        ...resolve2 ? duplicate(resolve2) : {}
      },
      selection: null,
      scales: null,
      projection: null,
      axes: {},
      legends: {}
    };
  }
  get width() {
    return this.getSizeSignalRef("width");
  }
  get height() {
    return this.getSizeSignalRef("height");
  }
  parse() {
    this.parseScale();
    this.parseLayoutSize();
    this.renameTopLevelLayoutSizeSignal();
    this.parseSelections();
    this.parseProjection();
    this.parseData();
    this.parseAxesAndHeaders();
    this.parseLegends();
    this.parseMarkGroup();
  }
  parseScale() {
    parseScales(this);
  }
  parseProjection() {
    parseProjection2(this);
  }
  /**
   * Rename top-level spec's size to be just width / height, ignoring model name.
   * This essentially merges the top-level spec's width/height signals with the width/height signals
   * to help us reduce redundant signals declaration.
   */
  renameTopLevelLayoutSizeSignal() {
    if (this.getName("width") !== "width") {
      this.renameSignal(this.getName("width"), "width");
    }
    if (this.getName("height") !== "height") {
      this.renameSignal(this.getName("height"), "height");
    }
  }
  parseLegends() {
    parseLegend2(this);
  }
  assembleEncodeFromView(view) {
    const { style: _, ...baseView } = view;
    const e3 = {};
    for (const property2 of keys4(baseView)) {
      const value7 = baseView[property2];
      if (value7 !== void 0) {
        e3[property2] = signalOrValueRef(value7);
      }
    }
    return e3;
  }
  assembleGroupEncodeEntry(isTopLevel) {
    let encodeEntry2 = {};
    if (this.view) {
      encodeEntry2 = this.assembleEncodeFromView(this.view);
    }
    if (!isTopLevel) {
      if (this.description) {
        encodeEntry2["description"] = signalOrValueRef(this.description);
      }
      if (this.type === "unit" || this.type === "layer") {
        return {
          width: this.getSizeSignalRef("width"),
          height: this.getSizeSignalRef("height"),
          ...encodeEntry2
        };
      }
    }
    return isEmpty(encodeEntry2) ? void 0 : encodeEntry2;
  }
  assembleLayout() {
    if (!this.layout) {
      return void 0;
    }
    const { spacing, ...layout } = this.layout;
    const { component, config } = this;
    const titleBand = assembleLayoutTitleBand(component.layoutHeaders, config);
    return {
      padding: spacing,
      ...this.assembleDefaultLayout(),
      ...layout,
      ...titleBand ? { titleBand } : {}
    };
  }
  assembleDefaultLayout() {
    return {};
  }
  assembleHeaderMarks() {
    const { layoutHeaders: layoutHeaders2 } = this.component;
    let headerMarks = [];
    for (const channel of FACET_CHANNELS) {
      if (layoutHeaders2[channel].title) {
        headerMarks.push(assembleTitleGroup(this, channel));
      }
    }
    for (const channel of HEADER_CHANNELS) {
      headerMarks = headerMarks.concat(assembleHeaderGroups(this, channel));
    }
    return headerMarks;
  }
  assembleAxes() {
    return assembleAxes(this.component.axes, this.config);
  }
  assembleLegends() {
    return assembleLegends(this);
  }
  assembleProjections() {
    return assembleProjections(this);
  }
  assembleTitle() {
    const { encoding, ...titleNoEncoding } = this.title ?? {};
    const title2 = {
      ...extractTitleConfig(this.config.title).nonMarkTitleProperties,
      ...titleNoEncoding,
      ...encoding ? { encode: { update: encoding } } : {}
    };
    if (title2.text) {
      if (contains2(["unit", "layer"], this.type)) {
        if (contains2(["middle", void 0], title2.anchor)) {
          title2.frame ?? (title2.frame = "group");
        }
      } else {
        title2.anchor ?? (title2.anchor = "start");
      }
      return isEmpty(title2) ? void 0 : title2;
    }
    return void 0;
  }
  /**
   * Assemble the mark group for this model. We accept optional `signals` so that we can include concat top-level signals with the top-level model's local signals.
   */
  assembleGroup(signals = []) {
    const group7 = {};
    signals = signals.concat(this.assembleSignals());
    if (signals.length > 0) {
      group7.signals = signals;
    }
    const layout = this.assembleLayout();
    if (layout) {
      group7.layout = layout;
    }
    group7.marks = [].concat(this.assembleHeaderMarks(), this.assembleMarks());
    const scales10 = !this.parent || isFacetModel(this.parent) ? assembleScales(this) : [];
    if (scales10.length > 0) {
      group7.scales = scales10;
    }
    const axes = this.assembleAxes();
    if (axes.length > 0) {
      group7.axes = axes;
    }
    const legends = this.assembleLegends();
    if (legends.length > 0) {
      group7.legends = legends;
    }
    return group7;
  }
  getName(text7) {
    return varName((this.name ? `${this.name}_` : "") + text7);
  }
  getDataName(type7) {
    return this.getName(DataSourceType[type7].toLowerCase());
  }
  /**
   * Request a data source name for the given data source type and mark that data source as required.
   * This method should be called in parse, so that all used data source can be correctly instantiated in assembleData().
   * You can lookup the correct dataset name in assemble with `lookupDataSource`.
   */
  requestDataName(name) {
    const fullName = this.getDataName(name);
    const refCounts = this.component.data.outputNodeRefCounts;
    refCounts[fullName] = (refCounts[fullName] || 0) + 1;
    return fullName;
  }
  getSizeSignalRef(layoutSizeType) {
    if (isFacetModel(this.parent)) {
      const sizeType = getSizeTypeFromLayoutSizeType(layoutSizeType);
      const channel = getPositionScaleChannel(sizeType);
      const scaleComponent = this.component.scales[channel];
      if (scaleComponent && !scaleComponent.merged) {
        const type7 = scaleComponent.get("type");
        const range7 = scaleComponent.get("range");
        if (hasDiscreteDomain(type7) && isVgRangeStep(range7)) {
          const scaleName = scaleComponent.get("name");
          const domain3 = assembleDomain(this, channel);
          const field25 = getFieldFromDomain(domain3);
          if (field25) {
            const fieldRef2 = vgField({ aggregate: "distinct", field: field25 }, { expr: "datum" });
            return {
              signal: sizeExpr(scaleName, scaleComponent, fieldRef2)
            };
          } else {
            warn2(unknownField(channel));
            return null;
          }
        }
      }
    }
    return {
      signal: this.signalNameMap.get(this.getName(layoutSizeType))
    };
  }
  /**
   * Lookup the name of the datasource for an output node. You probably want to call this in assemble.
   */
  lookupDataSource(name) {
    const node = this.component.data.outputNodes[name];
    if (!node) {
      return name;
    }
    return node.getSource();
  }
  getSignalName(oldSignalName) {
    return this.signalNameMap.get(oldSignalName);
  }
  renameSignal(oldName, newName) {
    this.signalNameMap.rename(oldName, newName);
  }
  renameScale(oldName, newName) {
    this.scaleNameMap.rename(oldName, newName);
  }
  renameProjection(oldName, newName) {
    this.projectionNameMap.rename(oldName, newName);
  }
  /**
   * @return scale name for a given channel after the scale has been parsed and named.
   */
  scaleName(originalScaleName, parse12) {
    if (parse12) {
      return this.getName(originalScaleName);
    }
    if (
      // If there is a scale for the channel, there should be a local scale component for it
      isChannel(originalScaleName) && isScaleChannel(originalScaleName) && this.component.scales[originalScaleName] || // in the scale name map (the scale get merged by its parent)
      this.scaleNameMap.has(this.getName(originalScaleName))
    ) {
      return this.scaleNameMap.get(this.getName(originalScaleName));
    }
    return void 0;
  }
  /**
   * @return projection name after the projection has been parsed and named.
   */
  projectionName(parse12) {
    if (parse12) {
      return this.getName("projection");
    }
    if (this.component.projection && !this.component.projection.merged || this.projectionNameMap.has(this.getName("projection"))) {
      return this.projectionNameMap.get(this.getName("projection"));
    }
    return void 0;
  }
  /**
   * Traverse a model's hierarchy to get the scale component for a particular channel.
   */
  getScaleComponent(channel) {
    if (!this.component.scales) {
      throw new Error("getScaleComponent cannot be called before parseScale(). Make sure you have called parseScale or use parseUnitModelWithScale().");
    }
    const localScaleComponent = this.component.scales[channel];
    if (localScaleComponent && !localScaleComponent.merged) {
      return localScaleComponent;
    }
    return this.parent ? this.parent.getScaleComponent(channel) : void 0;
  }
  getScaleType(channel) {
    const scaleComponent = this.getScaleComponent(channel);
    return scaleComponent ? scaleComponent.get("type") : void 0;
  }
  /**
   * Traverse a model's hierarchy to get a particular selection component.
   */
  getSelectionComponent(variableName, origName) {
    let sel = this.component.selection[variableName];
    if (!sel && this.parent) {
      sel = this.parent.getSelectionComponent(variableName, origName);
    }
    if (!sel) {
      throw new Error(selectionNotFound(origName));
    }
    return sel;
  }
  /**
   * Returns true if the model has a signalRef for an axis orient.
   */
  hasAxisOrientSignalRef() {
    var _a2, _b;
    return ((_a2 = this.component.axes.x) == null ? void 0 : _a2.some((a4) => a4.hasOrientSignalRef())) || ((_b = this.component.axes.y) == null ? void 0 : _b.some((a4) => a4.hasOrientSignalRef()));
  }
};
var ModelWithField = class extends Model {
  /** Get "field" reference for Vega */
  vgField(channel, opt = {}) {
    const fieldDef = this.fieldDef(channel);
    if (!fieldDef) {
      return void 0;
    }
    return vgField(fieldDef, opt);
  }
  reduceFieldDef(f, init2) {
    return reduce2(this.getMapping(), (acc, cd2, c5) => {
      const fieldDef = getFieldDef(cd2);
      if (fieldDef) {
        return f(acc, fieldDef, c5);
      }
      return acc;
    }, init2);
  }
  forEachFieldDef(f, t) {
    forEach(this.getMapping(), (cd2, c5) => {
      const fieldDef = getFieldDef(cd2);
      if (fieldDef) {
        f(fieldDef, c5);
      }
    }, t);
  }
};
var DensityTransformNode = class _DensityTransformNode extends DataFlowNode {
  constructor(parent, transform4) {
    super(parent);
    __publicField(this, "transform");
    this.transform = transform4;
    this.transform = duplicate(transform4);
    const specifiedAs = this.transform.as ?? [void 0, void 0];
    this.transform.as = [specifiedAs[0] ?? "value", specifiedAs[1] ?? "density"];
    const resolve2 = this.transform.resolve ?? "shared";
    this.transform.resolve = resolve2;
  }
  clone() {
    return new _DensityTransformNode(null, duplicate(this.transform));
  }
  dependentFields() {
    return /* @__PURE__ */ new Set([this.transform.density, ...this.transform.groupby ?? []]);
  }
  producedFields() {
    return new Set(this.transform.as);
  }
  hash() {
    return `DensityTransform ${hash(this.transform)}`;
  }
  assemble() {
    const { density, ...rest } = this.transform;
    const result = {
      type: "kde",
      field: density,
      ...rest
    };
    result.resolve = this.transform.resolve;
    return result;
  }
};
var ExtentTransformNode = class _ExtentTransformNode extends DataFlowNode {
  constructor(parent, transform4) {
    super(parent);
    __publicField(this, "transform");
    this.transform = transform4;
    this.transform = duplicate(transform4);
  }
  clone() {
    return new _ExtentTransformNode(null, duplicate(this.transform));
  }
  dependentFields() {
    return /* @__PURE__ */ new Set([this.transform.extent]);
  }
  producedFields() {
    return /* @__PURE__ */ new Set([]);
  }
  hash() {
    return `ExtentTransform ${hash(this.transform)}`;
  }
  assemble() {
    const { extent: extent8, param: param2 } = this.transform;
    const result = {
      type: "extent",
      field: extent8,
      signal: param2
    };
    return result;
  }
};
var FlattenTransformNode = class _FlattenTransformNode extends DataFlowNode {
  constructor(parent, transform4) {
    super(parent);
    __publicField(this, "transform");
    this.transform = transform4;
    this.transform = duplicate(transform4);
    const { flatten: flatten2, as = [] } = this.transform;
    this.transform.as = flatten2.map((f, i) => as[i] ?? f);
  }
  clone() {
    return new _FlattenTransformNode(this.parent, duplicate(this.transform));
  }
  dependentFields() {
    return new Set(this.transform.flatten);
  }
  producedFields() {
    return new Set(this.transform.as);
  }
  hash() {
    return `FlattenTransform ${hash(this.transform)}`;
  }
  assemble() {
    const { flatten: fields, as } = this.transform;
    const result = {
      type: "flatten",
      fields,
      as
    };
    return result;
  }
};
var FoldTransformNode = class _FoldTransformNode extends DataFlowNode {
  constructor(parent, transform4) {
    super(parent);
    __publicField(this, "transform");
    this.transform = transform4;
    this.transform = duplicate(transform4);
    const specifiedAs = this.transform.as ?? [void 0, void 0];
    this.transform.as = [specifiedAs[0] ?? "key", specifiedAs[1] ?? "value"];
  }
  clone() {
    return new _FoldTransformNode(null, duplicate(this.transform));
  }
  dependentFields() {
    return new Set(this.transform.fold);
  }
  producedFields() {
    return new Set(this.transform.as);
  }
  hash() {
    return `FoldTransform ${hash(this.transform)}`;
  }
  assemble() {
    const { fold, as } = this.transform;
    const result = {
      type: "fold",
      fields: fold,
      as
    };
    return result;
  }
};
var GeoJSONNode = class _GeoJSONNode extends DataFlowNode {
  constructor(parent, fields, geojson, signal) {
    super(parent);
    __publicField(this, "fields");
    __publicField(this, "geojson");
    __publicField(this, "signal");
    this.fields = fields;
    this.geojson = geojson;
    this.signal = signal;
  }
  clone() {
    return new _GeoJSONNode(null, duplicate(this.fields), this.geojson, this.signal);
  }
  static parseAll(parent, model) {
    if (model.component.projection && !model.component.projection.isFit) {
      return parent;
    }
    let geoJsonCounter = 0;
    for (const coordinates of [
      [LONGITUDE, LATITUDE],
      [LONGITUDE2, LATITUDE2]
    ]) {
      const pair = coordinates.map((channel) => {
        const def6 = getFieldOrDatumDef(model.encoding[channel]);
        return isFieldDef(def6) ? def6.field : isDatumDef(def6) ? { expr: `${def6.datum}` } : isValueDef(def6) ? { expr: `${def6["value"]}` } : void 0;
      });
      if (pair[0] || pair[1]) {
        parent = new _GeoJSONNode(parent, pair, null, model.getName(`geojson_${geoJsonCounter++}`));
      }
    }
    if (model.channelHasField(SHAPE)) {
      const fieldDef = model.typedFieldDef(SHAPE);
      if (fieldDef.type === GEOJSON) {
        parent = new _GeoJSONNode(parent, null, fieldDef.field, model.getName(`geojson_${geoJsonCounter++}`));
      }
    }
    return parent;
  }
  dependentFields() {
    const fields = (this.fields ?? []).filter(isString14);
    return /* @__PURE__ */ new Set([...this.geojson ? [this.geojson] : [], ...fields]);
  }
  producedFields() {
    return /* @__PURE__ */ new Set();
  }
  hash() {
    return `GeoJSON ${this.geojson} ${this.signal} ${hash(this.fields)}`;
  }
  assemble() {
    return [
      ...this.geojson ? [
        {
          type: "filter",
          expr: `isValid(datum["${this.geojson}"])`
        }
      ] : [],
      {
        type: "geojson",
        ...this.fields ? { fields: this.fields } : {},
        ...this.geojson ? { geojson: this.geojson } : {},
        signal: this.signal
      }
    ];
  }
};
var GeoPointNode = class _GeoPointNode extends DataFlowNode {
  constructor(parent, projection3, fields, as) {
    super(parent);
    __publicField(this, "projection");
    __publicField(this, "fields");
    __publicField(this, "as");
    this.projection = projection3;
    this.fields = fields;
    this.as = as;
  }
  clone() {
    return new _GeoPointNode(null, this.projection, duplicate(this.fields), duplicate(this.as));
  }
  static parseAll(parent, model) {
    if (!model.projectionName()) {
      return parent;
    }
    for (const coordinates of [
      [LONGITUDE, LATITUDE],
      [LONGITUDE2, LATITUDE2]
    ]) {
      const pair = coordinates.map((channel) => {
        const def6 = getFieldOrDatumDef(model.encoding[channel]);
        return isFieldDef(def6) ? def6.field : isDatumDef(def6) ? { expr: `${def6.datum}` } : isValueDef(def6) ? { expr: `${def6["value"]}` } : void 0;
      });
      const suffix = coordinates[0] === LONGITUDE2 ? "2" : "";
      if (pair[0] || pair[1]) {
        parent = new _GeoPointNode(parent, model.projectionName(), pair, [
          model.getName(`x${suffix}`),
          model.getName(`y${suffix}`)
        ]);
      }
    }
    return parent;
  }
  dependentFields() {
    return new Set(this.fields.filter(isString14));
  }
  producedFields() {
    return new Set(this.as);
  }
  hash() {
    return `Geopoint ${this.projection} ${hash(this.fields)} ${hash(this.as)}`;
  }
  assemble() {
    return {
      type: "geopoint",
      projection: this.projection,
      fields: this.fields,
      as: this.as
    };
  }
};
var ImputeNode = class _ImputeNode extends DataFlowNode {
  constructor(parent, transform4) {
    super(parent);
    __publicField(this, "transform");
    this.transform = transform4;
  }
  clone() {
    return new _ImputeNode(null, duplicate(this.transform));
  }
  dependentFields() {
    return /* @__PURE__ */ new Set([this.transform.impute, this.transform.key, ...this.transform.groupby ?? []]);
  }
  producedFields() {
    return /* @__PURE__ */ new Set([this.transform.impute]);
  }
  processSequence(keyvals) {
    const { start = 0, stop: stop2, step } = keyvals;
    const result = [start, stop2, ...step ? [step] : []].join(",");
    return { signal: `sequence(${result})` };
  }
  static makeFromTransform(parent, imputeTransform) {
    return new _ImputeNode(parent, imputeTransform);
  }
  static makeFromEncoding(parent, model) {
    const encoding = model.encoding;
    const xDef = encoding.x;
    const yDef = encoding.y;
    if (isFieldDef(xDef) && isFieldDef(yDef)) {
      const imputedChannel = xDef.impute ? xDef : yDef.impute ? yDef : void 0;
      if (imputedChannel === void 0) {
        return void 0;
      }
      const keyChannel = xDef.impute ? yDef : yDef.impute ? xDef : void 0;
      const { method: method10, value: value7, frame: frame2, keyvals } = imputedChannel.impute;
      const groupbyFields = pathGroupingFields(model.mark, encoding);
      return new _ImputeNode(parent, {
        impute: imputedChannel.field,
        key: keyChannel.field,
        ...method10 ? { method: method10 } : {},
        ...value7 !== void 0 ? { value: value7 } : {},
        ...frame2 ? { frame: frame2 } : {},
        ...keyvals !== void 0 ? { keyvals } : {},
        ...groupbyFields.length ? { groupby: groupbyFields } : {}
      });
    }
    return null;
  }
  hash() {
    return `Impute ${hash(this.transform)}`;
  }
  assemble() {
    const { impute, key: key4, keyvals, method: method10, groupby, value: value7, frame: frame2 = [null, null] } = this.transform;
    const imputeTransform = {
      type: "impute",
      field: impute,
      key: key4,
      ...keyvals ? { keyvals: isImputeSequence(keyvals) ? this.processSequence(keyvals) : keyvals } : {},
      method: "value",
      ...groupby ? { groupby } : {},
      value: !method10 || method10 === "value" ? value7 : null
    };
    if (method10 && method10 !== "value") {
      const deriveNewField = {
        type: "window",
        as: [`imputed_${impute}_value`],
        ops: [method10],
        fields: [impute],
        frame: frame2,
        ignorePeers: false,
        ...groupby ? { groupby } : {}
      };
      const replaceOriginal = {
        type: "formula",
        expr: `datum.${impute} === null ? datum.imputed_${impute}_value : datum.${impute}`,
        as: impute
      };
      return [imputeTransform, deriveNewField, replaceOriginal];
    } else {
      return [imputeTransform];
    }
  }
};
var LoessTransformNode = class _LoessTransformNode extends DataFlowNode {
  constructor(parent, transform4) {
    super(parent);
    __publicField(this, "transform");
    this.transform = transform4;
    this.transform = duplicate(transform4);
    const specifiedAs = this.transform.as ?? [void 0, void 0];
    this.transform.as = [specifiedAs[0] ?? transform4.on, specifiedAs[1] ?? transform4.loess];
  }
  clone() {
    return new _LoessTransformNode(null, duplicate(this.transform));
  }
  dependentFields() {
    return /* @__PURE__ */ new Set([this.transform.loess, this.transform.on, ...this.transform.groupby ?? []]);
  }
  producedFields() {
    return new Set(this.transform.as);
  }
  hash() {
    return `LoessTransform ${hash(this.transform)}`;
  }
  assemble() {
    const { loess: loess2, on: on2, ...rest } = this.transform;
    const result = {
      type: "loess",
      x: on2,
      y: loess2,
      ...rest
    };
    return result;
  }
};
var LookupNode = class _LookupNode extends DataFlowNode {
  constructor(parent, transform4, secondary) {
    super(parent);
    __publicField(this, "transform");
    __publicField(this, "secondary");
    this.transform = transform4;
    this.secondary = secondary;
  }
  clone() {
    return new _LookupNode(null, duplicate(this.transform), this.secondary);
  }
  static make(parent, model, transform4, counter) {
    const sources = model.component.data.sources;
    const { from } = transform4;
    let fromOutputNode = null;
    if (isLookupData(from)) {
      let fromSource = findSource(from.data, sources);
      if (!fromSource) {
        fromSource = new SourceNode(from.data);
        sources.push(fromSource);
      }
      const fromOutputName = model.getName(`lookup_${counter}`);
      fromOutputNode = new OutputNode(fromSource, fromOutputName, DataSourceType.Lookup, model.component.data.outputNodeRefCounts);
      model.component.data.outputNodes[fromOutputName] = fromOutputNode;
    } else if (isLookupSelection(from)) {
      const selName = from.param;
      transform4 = { as: selName, ...transform4 };
      let selCmpt;
      try {
        selCmpt = model.getSelectionComponent(varName(selName), selName);
      } catch {
        throw new Error(cannotLookupVariableParameter(selName));
      }
      fromOutputNode = selCmpt.materialized;
      if (!fromOutputNode) {
        throw new Error(noSameUnitLookup(selName));
      }
    }
    return new _LookupNode(parent, transform4, fromOutputNode.getSource());
  }
  dependentFields() {
    return /* @__PURE__ */ new Set([this.transform.lookup]);
  }
  producedFields() {
    return new Set(this.transform.as ? array21(this.transform.as) : this.transform.from.fields);
  }
  hash() {
    return `Lookup ${hash({ transform: this.transform, secondary: this.secondary })}`;
  }
  assemble() {
    let foreign;
    if (this.transform.from.fields) {
      foreign = {
        values: this.transform.from.fields,
        ...this.transform.as ? { as: array21(this.transform.as) } : {}
      };
    } else {
      let asName = this.transform.as;
      if (!isString14(asName)) {
        warn2(NO_FIELDS_NEEDS_AS);
        asName = "_lookup";
      }
      foreign = {
        as: [asName]
      };
    }
    return {
      type: "lookup",
      from: this.secondary,
      key: this.transform.from.key,
      fields: [this.transform.lookup],
      ...foreign,
      ...this.transform.default ? { default: this.transform.default } : {}
    };
  }
};
var QuantileTransformNode = class _QuantileTransformNode extends DataFlowNode {
  constructor(parent, transform4) {
    super(parent);
    __publicField(this, "transform");
    this.transform = transform4;
    this.transform = duplicate(transform4);
    const specifiedAs = this.transform.as ?? [void 0, void 0];
    this.transform.as = [specifiedAs[0] ?? "prob", specifiedAs[1] ?? "value"];
  }
  clone() {
    return new _QuantileTransformNode(null, duplicate(this.transform));
  }
  dependentFields() {
    return /* @__PURE__ */ new Set([this.transform.quantile, ...this.transform.groupby ?? []]);
  }
  producedFields() {
    return new Set(this.transform.as);
  }
  hash() {
    return `QuantileTransform ${hash(this.transform)}`;
  }
  assemble() {
    const { quantile: quantile3, ...rest } = this.transform;
    const result = {
      type: "quantile",
      field: quantile3,
      ...rest
    };
    return result;
  }
};
var RegressionTransformNode = class _RegressionTransformNode extends DataFlowNode {
  constructor(parent, transform4) {
    super(parent);
    __publicField(this, "transform");
    this.transform = transform4;
    this.transform = duplicate(transform4);
    const specifiedAs = this.transform.as ?? [void 0, void 0];
    this.transform.as = [specifiedAs[0] ?? transform4.on, specifiedAs[1] ?? transform4.regression];
  }
  clone() {
    return new _RegressionTransformNode(null, duplicate(this.transform));
  }
  dependentFields() {
    return /* @__PURE__ */ new Set([this.transform.regression, this.transform.on, ...this.transform.groupby ?? []]);
  }
  producedFields() {
    return new Set(this.transform.as);
  }
  hash() {
    return `RegressionTransform ${hash(this.transform)}`;
  }
  assemble() {
    const { regression, on: on2, ...rest } = this.transform;
    const result = {
      type: "regression",
      x: on2,
      y: regression,
      ...rest
    };
    return result;
  }
};
var PivotTransformNode = class _PivotTransformNode extends DataFlowNode {
  constructor(parent, transform4) {
    super(parent);
    __publicField(this, "transform");
    this.transform = transform4;
  }
  clone() {
    return new _PivotTransformNode(null, duplicate(this.transform));
  }
  addDimensions(fields) {
    this.transform.groupby = unique((this.transform.groupby ?? []).concat(fields), (d) => d);
  }
  producedFields() {
    return void 0;
  }
  dependentFields() {
    return /* @__PURE__ */ new Set([this.transform.pivot, this.transform.value, ...this.transform.groupby ?? []]);
  }
  hash() {
    return `PivotTransform ${hash(this.transform)}`;
  }
  assemble() {
    const { pivot, value: value7, groupby, limit, op } = this.transform;
    return {
      type: "pivot",
      field: pivot,
      value: value7,
      ...limit !== void 0 ? { limit } : {},
      ...op !== void 0 ? { op } : {},
      ...groupby !== void 0 ? { groupby } : {}
    };
  }
};
var SampleTransformNode = class _SampleTransformNode extends DataFlowNode {
  constructor(parent, transform4) {
    super(parent);
    __publicField(this, "transform");
    this.transform = transform4;
  }
  clone() {
    return new _SampleTransformNode(null, duplicate(this.transform));
  }
  dependentFields() {
    return /* @__PURE__ */ new Set();
  }
  producedFields() {
    return /* @__PURE__ */ new Set();
  }
  hash() {
    return `SampleTransform ${hash(this.transform)}`;
  }
  assemble() {
    return {
      type: "sample",
      size: this.transform.sample
    };
  }
};
function makeWalkTree(data3) {
  let datasetIndex = 0;
  function walkTree(node, dataSource) {
    if (node instanceof SourceNode) {
      if (!node.isGenerator && !isUrlData(node.data)) {
        data3.push(dataSource);
        const newData = {
          name: null,
          source: dataSource.name,
          transform: []
        };
        dataSource = newData;
      }
    }
    if (node instanceof ParseNode) {
      if (node.parent instanceof SourceNode && !dataSource.source) {
        dataSource.format = {
          ...dataSource.format,
          parse: node.assembleFormatParse()
        };
        dataSource.transform.push(...node.assembleTransforms(true));
      } else {
        dataSource.transform.push(...node.assembleTransforms());
      }
    }
    if (node instanceof FacetNode) {
      if (!dataSource.name) {
        dataSource.name = `data_${datasetIndex++}`;
      }
      if (!dataSource.source || dataSource.transform.length > 0) {
        data3.push(dataSource);
        node.data = dataSource.name;
      } else {
        node.data = dataSource.source;
      }
      data3.push(...node.assemble());
      return;
    }
    if (node instanceof GraticuleNode || node instanceof SequenceNode || node instanceof FilterInvalidNode || node instanceof FilterNode || node instanceof CalculateNode || node instanceof GeoPointNode || node instanceof AggregateNode || node instanceof LookupNode || node instanceof WindowTransformNode || node instanceof JoinAggregateTransformNode || node instanceof FoldTransformNode || node instanceof FlattenTransformNode || node instanceof DensityTransformNode || node instanceof LoessTransformNode || node instanceof QuantileTransformNode || node instanceof RegressionTransformNode || node instanceof IdentifierNode || node instanceof SampleTransformNode || node instanceof PivotTransformNode || node instanceof ExtentTransformNode) {
      dataSource.transform.push(node.assemble());
    }
    if (node instanceof BinNode || node instanceof TimeUnitNode || node instanceof ImputeNode || node instanceof StackNode || node instanceof GeoJSONNode) {
      dataSource.transform.push(...node.assemble());
    }
    if (node instanceof OutputNode) {
      if (dataSource.source && dataSource.transform.length === 0) {
        node.setSource(dataSource.source);
      } else if (node.parent instanceof OutputNode) {
        node.setSource(dataSource.name);
      } else {
        if (!dataSource.name) {
          dataSource.name = `data_${datasetIndex++}`;
        }
        node.setSource(dataSource.name);
        if (node.numChildren() === 1) {
          data3.push(dataSource);
          const newData = {
            name: null,
            source: dataSource.name,
            transform: []
          };
          dataSource = newData;
        }
      }
    }
    switch (node.numChildren()) {
      case 0:
        if (node instanceof OutputNode && (!dataSource.source || dataSource.transform.length > 0)) {
          data3.push(dataSource);
        }
        break;
      case 1:
        walkTree(node.children[0], dataSource);
        break;
      default: {
        if (!dataSource.name) {
          dataSource.name = `data_${datasetIndex++}`;
        }
        let source3 = dataSource.name;
        if (!dataSource.source || dataSource.transform.length > 0) {
          data3.push(dataSource);
        } else {
          source3 = dataSource.source;
        }
        for (const child of node.children) {
          const newData = {
            name: null,
            source: source3,
            transform: []
          };
          walkTree(child, newData);
        }
        break;
      }
    }
  }
  return walkTree;
}
function assembleFacetData(root) {
  const data3 = [];
  const walkTree = makeWalkTree(data3);
  for (const child of root.children) {
    walkTree(child, {
      source: root.name,
      name: null,
      transform: []
    });
  }
  return data3;
}
function assembleRootData(dataComponent, datasets) {
  const data3 = [];
  const walkTree = makeWalkTree(data3);
  let sourceIndex = 0;
  for (const root of dataComponent.sources) {
    if (!root.hasName()) {
      root.dataName = `source_${sourceIndex++}`;
    }
    const newData = root.assemble();
    walkTree(root, newData);
  }
  for (const d of data3) {
    if (d.transform.length === 0) {
      delete d.transform;
    }
  }
  let whereTo = 0;
  for (const [i, d] of data3.entries()) {
    if ((d.transform ?? []).length === 0 && !d.source) {
      data3.splice(whereTo++, 0, data3.splice(i, 1)[0]);
    }
  }
  for (const d of data3) {
    for (const t of d.transform ?? []) {
      if (t.type === "lookup") {
        t.from = dataComponent.outputNodes[t.from].getSource();
      }
    }
  }
  for (const d of data3) {
    if (d.name in datasets) {
      d.values = datasets[d.name];
    }
  }
  return data3;
}
function getHeaderType(orient2) {
  if (orient2 === "top" || orient2 === "left" || isSignalRef(orient2)) {
    return "header";
  }
  return "footer";
}
function parseFacetHeaders(model) {
  for (const channel of FACET_CHANNELS) {
    parseFacetHeader(model, channel);
  }
  mergeChildAxis(model, "x");
  mergeChildAxis(model, "y");
}
function parseFacetHeader(model, channel) {
  var _a2;
  const { facet, config, child, component } = model;
  if (model.channelHasField(channel)) {
    const fieldDef = facet[channel];
    const titleConfig = getHeaderProperty("title", null, config, channel);
    let title$1 = title(fieldDef, config, {
      allowDisabling: true,
      includeDefault: titleConfig === void 0 || !!titleConfig
    });
    if (child.component.layoutHeaders[channel].title) {
      title$1 = isArray22(title$1) ? title$1.join(", ") : title$1;
      title$1 += ` / ${child.component.layoutHeaders[channel].title}`;
      child.component.layoutHeaders[channel].title = null;
    }
    const labelOrient = getHeaderProperty("labelOrient", fieldDef.header, config, channel);
    const labels2 = fieldDef.header !== null ? getFirstDefined((_a2 = fieldDef.header) == null ? void 0 : _a2.labels, config.header.labels, true) : false;
    const headerType = contains2(["bottom", "right"], labelOrient) ? "footer" : "header";
    component.layoutHeaders[channel] = {
      title: fieldDef.header !== null ? title$1 : null,
      facetFieldDef: fieldDef,
      [headerType]: channel === "facet" ? [] : [makeHeaderComponent(model, channel, labels2)]
    };
  }
}
function makeHeaderComponent(model, channel, labels2) {
  const sizeType = channel === "row" ? "height" : "width";
  return {
    labels: labels2,
    sizeSignal: model.child.component.layoutSize.get(sizeType) ? model.child.getSizeSignalRef(sizeType) : void 0,
    axes: []
  };
}
function mergeChildAxis(model, channel) {
  const { child } = model;
  if (child.component.axes[channel]) {
    const { layoutHeaders: layoutHeaders2, resolve: resolve2 } = model.component;
    resolve2.axis[channel] = parseGuideResolve(resolve2, channel);
    if (resolve2.axis[channel] === "shared") {
      const headerChannel = channel === "x" ? "column" : "row";
      const layoutHeader = layoutHeaders2[headerChannel];
      for (const axisComponent of child.component.axes[channel]) {
        const headerType = getHeaderType(axisComponent.get("orient"));
        layoutHeader[headerType] ?? (layoutHeader[headerType] = [makeHeaderComponent(model, headerChannel, false)]);
        const mainAxis = assembleAxis(axisComponent, "main", model.config, { header: true });
        if (mainAxis) {
          layoutHeader[headerType][0].axes.push(mainAxis);
        }
        axisComponent.mainExtracted = true;
      }
    }
  }
}
function parseLayerLayoutSize(model) {
  parseChildrenLayoutSize(model);
  parseNonUnitLayoutSizeForChannel(model, "width");
  parseNonUnitLayoutSizeForChannel(model, "height");
}
function parseConcatLayoutSize(model) {
  parseChildrenLayoutSize(model);
  const widthType = model.layout.columns === 1 ? "width" : "childWidth";
  const heightType = model.layout.columns === void 0 ? "height" : "childHeight";
  parseNonUnitLayoutSizeForChannel(model, widthType);
  parseNonUnitLayoutSizeForChannel(model, heightType);
}
function parseChildrenLayoutSize(model) {
  for (const child of model.children) {
    child.parseLayoutSize();
  }
}
function parseNonUnitLayoutSizeForChannel(model, layoutSizeType) {
  const sizeType = getSizeTypeFromLayoutSizeType(layoutSizeType);
  const channel = getPositionScaleChannel(sizeType);
  const resolve2 = model.component.resolve;
  const layoutSizeCmpt = model.component.layoutSize;
  let mergedSize;
  for (const child of model.children) {
    const childSize = child.component.layoutSize.getWithExplicit(sizeType);
    const scaleResolve = resolve2.scale[channel] ?? defaultScaleResolve(channel, model);
    if (scaleResolve === "independent" && childSize.value === "step") {
      mergedSize = void 0;
      break;
    }
    if (mergedSize) {
      if (scaleResolve === "independent" && mergedSize.value !== childSize.value) {
        mergedSize = void 0;
        break;
      }
      mergedSize = mergeValuesWithExplicit(mergedSize, childSize, sizeType, "");
    } else {
      mergedSize = childSize;
    }
  }
  if (mergedSize) {
    for (const child of model.children) {
      model.renameSignal(child.getName(sizeType), model.getName(layoutSizeType));
      child.component.layoutSize.set(sizeType, "merged", false);
    }
    layoutSizeCmpt.setWithExplicit(layoutSizeType, mergedSize);
  } else {
    layoutSizeCmpt.setWithExplicit(layoutSizeType, {
      explicit: false,
      value: void 0
    });
  }
}
function parseUnitLayoutSize(model) {
  const { size, component } = model;
  for (const channel of POSITION_SCALE_CHANNELS) {
    const sizeType = getSizeChannel(channel);
    if (size[sizeType] != void 0 && size[sizeType] != null) {
      const specifiedSize = size[sizeType];
      component.layoutSize.set(sizeType, isStep(specifiedSize) ? "step" : specifiedSize, true);
    } else {
      const defaultSize = defaultUnitSize(model, sizeType);
      component.layoutSize.set(sizeType, defaultSize, false);
    }
  }
}
function defaultUnitSize(model, sizeType) {
  const channel = sizeType === "width" ? "x" : "y";
  const config = model.config;
  const scaleComponent = model.getScaleComponent(channel);
  if (scaleComponent) {
    const scaleType2 = scaleComponent.get("type");
    const range7 = scaleComponent.get("range");
    if (hasDiscreteDomain(scaleType2)) {
      const size = getViewConfigDiscreteSize(config.view, sizeType);
      if (isVgRangeStep(range7) || isStep(size)) {
        return "step";
      } else {
        return size;
      }
    } else {
      return getViewConfigContinuousSize(config.view, sizeType);
    }
  } else if (model.hasProjection || model.mark === "arc") {
    return getViewConfigContinuousSize(config.view, sizeType);
  } else {
    const size = getViewConfigDiscreteSize(config.view, sizeType);
    return isStep(size) ? size.step : size;
  }
}
function facetSortFieldName(fieldDef, sort4, opt) {
  return vgField(sort4, { suffix: `by_${vgField(fieldDef)}`, ...opt });
}
var FacetModel = class _FacetModel extends ModelWithField {
  constructor(spec, parent, parentGivenName, config) {
    super(spec, "facet", parent, parentGivenName, config, spec.resolve);
    __publicField(this, "facet");
    __publicField(this, "child");
    __publicField(this, "children");
    this.child = buildModel(spec.spec, this, this.getName("child"), void 0, config);
    this.children = [this.child];
    this.facet = this.initFacet(spec.facet);
  }
  initFacet(facet) {
    if (!isFacetMapping(facet)) {
      return { facet: this.initFacetFieldDef(facet, "facet") };
    }
    const channels = keys4(facet);
    const normalizedFacet = {};
    for (const channel of channels) {
      if (![ROW, COLUMN].includes(channel)) {
        warn2(incompatibleChannel(channel, "facet"));
        break;
      }
      const fieldDef = facet[channel];
      if (fieldDef.field === void 0) {
        warn2(emptyFieldDef(fieldDef, channel));
        break;
      }
      normalizedFacet[channel] = this.initFacetFieldDef(fieldDef, channel);
    }
    return normalizedFacet;
  }
  initFacetFieldDef(fieldDef, channel) {
    const facetFieldDef = initFieldDef(fieldDef, channel);
    if (facetFieldDef.header) {
      facetFieldDef.header = replaceExprRef(facetFieldDef.header);
    } else if (facetFieldDef.header === null) {
      facetFieldDef.header = null;
    }
    return facetFieldDef;
  }
  channelHasField(channel) {
    return hasProperty(this.facet, channel);
  }
  fieldDef(channel) {
    return this.facet[channel];
  }
  parseData() {
    this.component.data = parseData2(this);
    this.child.parseData();
  }
  parseLayoutSize() {
    parseChildrenLayoutSize(this);
  }
  parseSelections() {
    this.child.parseSelections();
    this.component.selection = this.child.component.selection;
    if (vals(this.component.selection).some((selCmpt) => isTimerSelection(selCmpt))) {
      error23(MULTI_VIEW_ANIMATION_UNSUPPORTED);
    }
  }
  parseMarkGroup() {
    this.child.parseMarkGroup();
  }
  parseAxesAndHeaders() {
    this.child.parseAxesAndHeaders();
    parseFacetHeaders(this);
  }
  assembleSelectionTopLevelSignals(signals) {
    return this.child.assembleSelectionTopLevelSignals(signals);
  }
  assembleSignals() {
    this.child.assembleSignals();
    return [];
  }
  assembleSelectionData(data3) {
    return this.child.assembleSelectionData(data3);
  }
  getHeaderLayoutMixins() {
    const layoutMixins = {};
    for (const channel of FACET_CHANNELS) {
      for (const headerType of HEADER_TYPES) {
        const layoutHeaderComponent = this.component.layoutHeaders[channel];
        const headerComponent = layoutHeaderComponent[headerType];
        const { facetFieldDef } = layoutHeaderComponent;
        if (facetFieldDef) {
          const titleOrient = getHeaderProperty("titleOrient", facetFieldDef.header, this.config, channel);
          if (["right", "bottom"].includes(titleOrient)) {
            const headerChannel = getHeaderChannel(channel, titleOrient);
            layoutMixins.titleAnchor ?? (layoutMixins.titleAnchor = {});
            layoutMixins.titleAnchor[headerChannel] = "end";
          }
        }
        if (headerComponent == null ? void 0 : headerComponent[0]) {
          const sizeType = channel === "row" ? "height" : "width";
          const bandType = headerType === "header" ? "headerBand" : "footerBand";
          if (channel !== "facet" && !this.child.component.layoutSize.get(sizeType)) {
            layoutMixins[bandType] ?? (layoutMixins[bandType] = {});
            layoutMixins[bandType][channel] = 0.5;
          }
          if (layoutHeaderComponent.title) {
            layoutMixins.offset ?? (layoutMixins.offset = {});
            layoutMixins.offset[channel === "row" ? "rowTitle" : "columnTitle"] = 10;
          }
        }
      }
    }
    return layoutMixins;
  }
  assembleDefaultLayout() {
    const { column, row } = this.facet;
    const columns = column ? this.columnDistinctSignal() : row ? 1 : void 0;
    let align2 = "all";
    if (!row && this.component.resolve.scale.x === "independent") {
      align2 = "none";
    } else if (!column && this.component.resolve.scale.y === "independent") {
      align2 = "none";
    }
    return {
      ...this.getHeaderLayoutMixins(),
      ...columns ? { columns } : {},
      bounds: "full",
      align: align2
    };
  }
  assembleLayoutSignals() {
    return this.child.assembleLayoutSignals();
  }
  columnDistinctSignal() {
    if (this.parent && this.parent instanceof _FacetModel) {
      return void 0;
    } else {
      const facetLayoutDataName = this.getName("column_domain");
      return { signal: `length(data('${facetLayoutDataName}'))` };
    }
  }
  assembleGroupStyle() {
    return void 0;
  }
  assembleGroup(signals) {
    if (this.parent && this.parent instanceof _FacetModel) {
      return {
        ...this.channelHasField("column") ? {
          encode: {
            update: {
              // TODO(https://github.com/vega/vega-lite/issues/2759):
              // Correct the signal for facet of concat of facet_column
              columns: { field: vgField(this.facet.column, { prefix: "distinct" }) }
            }
          }
        } : {},
        ...super.assembleGroup(signals)
      };
    }
    return super.assembleGroup(signals);
  }
  /**
   * Aggregate cardinality for calculating size
   */
  getCardinalityAggregateForChild() {
    const fields = [];
    const ops2 = [];
    const as = [];
    if (this.child instanceof _FacetModel) {
      if (this.child.channelHasField("column")) {
        const field25 = vgField(this.child.facet.column);
        fields.push(field25);
        ops2.push("distinct");
        as.push(`distinct_${field25}`);
      }
    } else {
      for (const channel of POSITION_SCALE_CHANNELS) {
        const childScaleComponent = this.child.component.scales[channel];
        if (childScaleComponent && !childScaleComponent.merged) {
          const type7 = childScaleComponent.get("type");
          const range7 = childScaleComponent.get("range");
          if (hasDiscreteDomain(type7) && isVgRangeStep(range7)) {
            const domain3 = assembleDomain(this.child, channel);
            const field25 = getFieldFromDomain(domain3);
            if (field25) {
              fields.push(field25);
              ops2.push("distinct");
              as.push(`distinct_${field25}`);
            } else {
              warn2(unknownField(channel));
            }
          }
        }
      }
    }
    return { fields, ops: ops2, as };
  }
  assembleFacet() {
    const { name, data: data3 } = this.component.data.facetRoot;
    const { row, column } = this.facet;
    const { fields, ops: ops2, as } = this.getCardinalityAggregateForChild();
    const groupby = [];
    for (const channel of FACET_CHANNELS) {
      const fieldDef = this.facet[channel];
      if (fieldDef) {
        groupby.push(vgField(fieldDef));
        const { bin: bin5, sort: sort4 } = fieldDef;
        if (isBinning(bin5)) {
          groupby.push(vgField(fieldDef, { binSuffix: "end" }));
        }
        if (isSortField(sort4)) {
          const { field: field25, op = DEFAULT_SORT_OP } = sort4;
          const outputName = facetSortFieldName(fieldDef, sort4);
          if (row && column) {
            fields.push(outputName);
            ops2.push("max");
            as.push(outputName);
          } else {
            fields.push(field25);
            ops2.push(op);
            as.push(outputName);
          }
        } else if (isArray22(sort4)) {
          const outputName = sortArrayIndexField(fieldDef, channel);
          fields.push(outputName);
          ops2.push("max");
          as.push(outputName);
        }
      }
    }
    const cross3 = !!row && !!column;
    return {
      name,
      data: data3,
      groupby,
      ...cross3 || fields.length > 0 ? {
        aggregate: {
          ...cross3 ? { cross: cross3 } : {},
          ...fields.length ? { fields, ops: ops2, as } : {}
        }
      } : {}
    };
  }
  facetSortFields(channel) {
    const { facet } = this;
    const fieldDef = facet[channel];
    if (fieldDef) {
      if (isSortField(fieldDef.sort)) {
        return [facetSortFieldName(fieldDef, fieldDef.sort, { expr: "datum" })];
      } else if (isArray22(fieldDef.sort)) {
        return [sortArrayIndexField(fieldDef, channel, { expr: "datum" })];
      }
      return [vgField(fieldDef, { expr: "datum" })];
    }
    return [];
  }
  facetSortOrder(channel) {
    const { facet } = this;
    const fieldDef = facet[channel];
    if (fieldDef) {
      const { sort: sort4 } = fieldDef;
      const order = (isSortField(sort4) ? sort4.order : !isArray22(sort4) && sort4) || "ascending";
      return [order];
    }
    return [];
  }
  assembleLabelTitle() {
    var _a2;
    const { facet, config } = this;
    if (facet.facet) {
      return assembleLabelTitle(facet.facet, "facet", config);
    }
    const ORTHOGONAL_ORIENT = {
      row: ["top", "bottom"],
      column: ["left", "right"]
    };
    for (const channel of HEADER_CHANNELS) {
      if (facet[channel]) {
        const labelOrient = getHeaderProperty("labelOrient", (_a2 = facet[channel]) == null ? void 0 : _a2.header, config, channel);
        if (ORTHOGONAL_ORIENT[channel].includes(labelOrient)) {
          return assembleLabelTitle(facet[channel], channel, config);
        }
      }
    }
    return void 0;
  }
  assembleMarks() {
    const { child } = this;
    const facetRoot = this.component.data.facetRoot;
    const data3 = assembleFacetData(facetRoot);
    const encodeEntry2 = child.assembleGroupEncodeEntry(false);
    const title2 = this.assembleLabelTitle() || child.assembleTitle();
    const style6 = child.assembleGroupStyle();
    const markGroup = {
      name: this.getName("cell"),
      type: "group",
      ...title2 ? { title: title2 } : {},
      ...style6 ? { style: style6 } : {},
      from: {
        facet: this.assembleFacet()
      },
      // TODO: move this to after data
      sort: {
        field: FACET_CHANNELS.map((c5) => this.facetSortFields(c5)).flat(),
        order: FACET_CHANNELS.map((c5) => this.facetSortOrder(c5)).flat()
      },
      ...data3.length > 0 ? { data: data3 } : {},
      ...encodeEntry2 ? { encode: { update: encodeEntry2 } } : {},
      ...child.assembleGroup(assembleFacetSignals(this, []))
    };
    return [markGroup];
  }
  getMapping() {
    return this.facet;
  }
};
function makeJoinAggregateFromFacet(parent, facet) {
  const { row, column } = facet;
  if (row && column) {
    let newParent = null;
    for (const fieldDef of [row, column]) {
      if (isSortField(fieldDef.sort)) {
        const { field: field25, op = DEFAULT_SORT_OP } = fieldDef.sort;
        parent = newParent = new JoinAggregateTransformNode(parent, {
          joinaggregate: [
            {
              op,
              field: field25,
              as: facetSortFieldName(fieldDef, fieldDef.sort, { forAs: true })
            }
          ],
          groupby: [vgField(fieldDef)]
        });
      }
    }
    return newParent;
  }
  return null;
}
function findSource(data3, sources) {
  var _a2, _b, _c2, _d2;
  for (const other of sources) {
    const otherData = other.data;
    if (data3.name && other.hasName() && data3.name !== other.dataName) {
      continue;
    }
    const formatMesh = (_a2 = data3.format) == null ? void 0 : _a2.mesh;
    const otherFeature = (_b = otherData.format) == null ? void 0 : _b.feature;
    if (formatMesh && otherFeature) {
      continue;
    }
    const formatFeature = (_c2 = data3.format) == null ? void 0 : _c2.feature;
    if ((formatFeature || otherFeature) && formatFeature !== otherFeature) {
      continue;
    }
    const otherMesh = (_d2 = otherData.format) == null ? void 0 : _d2.mesh;
    if ((formatMesh || otherMesh) && formatMesh !== otherMesh) {
      continue;
    }
    if (isInlineData(data3) && isInlineData(otherData)) {
      if (deepEqual(data3.values, otherData.values)) {
        return other;
      }
    } else if (isUrlData(data3) && isUrlData(otherData)) {
      if (data3.url === otherData.url) {
        return other;
      }
    } else if (isNamedData(data3)) {
      if (data3.name === other.dataName) {
        return other;
      }
    }
  }
  return null;
}
function parseRoot(model, sources) {
  if (model.data || !model.parent) {
    if (model.data === null) {
      const source3 = new SourceNode({ values: [] });
      sources.push(source3);
      return source3;
    }
    const existingSource = findSource(model.data, sources);
    if (existingSource) {
      if (!isGenerator(model.data)) {
        existingSource.data.format = mergeDeep({}, model.data.format, existingSource.data.format);
      }
      if (!existingSource.hasName() && model.data.name) {
        existingSource.dataName = model.data.name;
      }
      return existingSource;
    } else {
      const source3 = new SourceNode(model.data);
      sources.push(source3);
      return source3;
    }
  } else {
    return model.parent.component.data.facetRoot ? model.parent.component.data.facetRoot : model.parent.component.data.main;
  }
}
function parseTransformArray(head, model, ancestorParse) {
  let lookupCounter = 0;
  for (const t of model.transforms) {
    let derivedType = void 0;
    let transformNode;
    if (isCalculate(t)) {
      transformNode = head = new CalculateNode(head, t);
      derivedType = "derived";
    } else if (isFilter(t)) {
      const implicit2 = getImplicitFromFilterTransform(t);
      transformNode = head = ParseNode.makeWithAncestors(head, {}, implicit2, ancestorParse) ?? head;
      head = new FilterNode(head, model, t.filter);
    } else if (isBin(t)) {
      transformNode = head = BinNode.makeFromTransform(head, t, model);
      derivedType = "number";
    } else if (isTimeUnit(t)) {
      derivedType = "date";
      const parsedAs = ancestorParse.getWithExplicit(t.field);
      if (parsedAs.value === void 0) {
        head = new ParseNode(head, { [t.field]: derivedType });
        ancestorParse.set(t.field, derivedType, false);
      }
      transformNode = head = TimeUnitNode.makeFromTransform(head, t);
    } else if (isAggregate(t)) {
      transformNode = head = AggregateNode.makeFromTransform(head, t);
      derivedType = "number";
      if (requiresSelectionId(model)) {
        head = new IdentifierNode(head);
      }
    } else if (isLookup(t)) {
      transformNode = head = LookupNode.make(head, model, t, lookupCounter++);
      derivedType = "derived";
    } else if (isWindow(t)) {
      transformNode = head = new WindowTransformNode(head, t);
      derivedType = "number";
    } else if (isJoinAggregate(t)) {
      transformNode = head = new JoinAggregateTransformNode(head, t);
      derivedType = "number";
    } else if (isStack(t)) {
      transformNode = head = StackNode.makeFromTransform(head, t);
      derivedType = "derived";
    } else if (isFold(t)) {
      transformNode = head = new FoldTransformNode(head, t);
      derivedType = "derived";
    } else if (isExtent(t)) {
      transformNode = head = new ExtentTransformNode(head, t);
      derivedType = "derived";
    } else if (isFlatten(t)) {
      transformNode = head = new FlattenTransformNode(head, t);
      derivedType = "derived";
    } else if (isPivot(t)) {
      transformNode = head = new PivotTransformNode(head, t);
      derivedType = "derived";
    } else if (isSample(t)) {
      head = new SampleTransformNode(head, t);
    } else if (isImpute(t)) {
      transformNode = head = ImputeNode.makeFromTransform(head, t);
      derivedType = "derived";
    } else if (isDensity(t)) {
      transformNode = head = new DensityTransformNode(head, t);
      derivedType = "derived";
    } else if (isQuantile2(t)) {
      transformNode = head = new QuantileTransformNode(head, t);
      derivedType = "derived";
    } else if (isRegression(t)) {
      transformNode = head = new RegressionTransformNode(head, t);
      derivedType = "derived";
    } else if (isLoess(t)) {
      transformNode = head = new LoessTransformNode(head, t);
      derivedType = "derived";
    } else {
      warn2(invalidTransformIgnored(t));
      continue;
    }
    if (transformNode && derivedType !== void 0) {
      for (const field25 of transformNode.producedFields() ?? []) {
        ancestorParse.set(field25, derivedType, false);
      }
    }
  }
  return head;
}
function parseData2(model) {
  var _a2;
  let head = parseRoot(model, model.component.data.sources);
  const { outputNodes, outputNodeRefCounts } = model.component.data;
  const data3 = model.data;
  const newData = data3 && (isGenerator(data3) || isUrlData(data3) || isInlineData(data3));
  const ancestorParse = !newData && model.parent ? model.parent.component.data.ancestorParse.clone() : new AncestorParse();
  if (isGenerator(data3)) {
    if (isSequenceGenerator(data3)) {
      head = new SequenceNode(head, data3.sequence);
    } else if (isGraticuleGenerator(data3)) {
      head = new GraticuleNode(head, data3.graticule);
    }
    ancestorParse.parseNothing = true;
  } else if (((_a2 = data3 == null ? void 0 : data3.format) == null ? void 0 : _a2.parse) === null) {
    ancestorParse.parseNothing = true;
  }
  head = ParseNode.makeExplicit(head, model, ancestorParse) ?? head;
  head = new IdentifierNode(head);
  const parentIsLayer = model.parent && isLayerModel(model.parent);
  if (isUnitModel(model) || isFacetModel(model)) {
    if (parentIsLayer) {
      head = BinNode.makeFromEncoding(head, model) ?? head;
    }
  }
  if (model.transforms.length > 0) {
    head = parseTransformArray(head, model, ancestorParse);
  }
  const implicitSelection = getImplicitFromSelection(model);
  const implicitEncoding = getImplicitFromEncoding(model);
  head = ParseNode.makeWithAncestors(head, {}, { ...implicitSelection, ...implicitEncoding }, ancestorParse) ?? head;
  if (isUnitModel(model)) {
    head = GeoJSONNode.parseAll(head, model);
    head = GeoPointNode.parseAll(head, model);
  }
  if (isUnitModel(model) || isFacetModel(model)) {
    if (!parentIsLayer) {
      head = BinNode.makeFromEncoding(head, model) ?? head;
    }
    head = TimeUnitNode.makeFromEncoding(head, model) ?? head;
    head = CalculateNode.parseAllForSortIndex(head, model);
  }
  const raw = head = makeOutputNode(DataSourceType.Raw, model, head);
  if (isUnitModel(model)) {
    const agg = AggregateNode.makeFromEncoding(head, model);
    if (agg) {
      head = agg;
      if (requiresSelectionId(model)) {
        head = new IdentifierNode(head);
      }
    }
    head = ImputeNode.makeFromEncoding(head, model) ?? head;
    head = StackNode.makeFromEncoding(head, model) ?? head;
  }
  let preFilterInvalid;
  let dataSourcesForHandlingInvalidValues;
  if (isUnitModel(model)) {
    const { markDef, mark, config } = model;
    const invalid = getMarkPropOrConfig("invalid", markDef, config);
    const { marks, scales: scales10 } = dataSourcesForHandlingInvalidValues = getDataSourcesForHandlingInvalidValues({
      invalid,
      isPath: isPathMark(mark)
    });
    if (marks !== scales10 && scales10 === "include-invalid-values") {
      preFilterInvalid = head = makeOutputNode(DataSourceType.PreFilterInvalid, model, head);
    }
    if (marks === "exclude-invalid-values") {
      head = FilterInvalidNode.make(head, model, dataSourcesForHandlingInvalidValues) ?? head;
    }
  }
  const main2 = head = makeOutputNode(DataSourceType.Main, model, head);
  let postFilterInvalid;
  if (isUnitModel(model) && dataSourcesForHandlingInvalidValues) {
    const { marks, scales: scales10 } = dataSourcesForHandlingInvalidValues;
    if (marks === "include-invalid-values" && scales10 === "exclude-invalid-values") {
      head = FilterInvalidNode.make(head, model, dataSourcesForHandlingInvalidValues) ?? head;
      postFilterInvalid = head = makeOutputNode(DataSourceType.PostFilterInvalid, model, head);
    }
  }
  if (isUnitModel(model)) {
    materializeSelections(model, main2);
  }
  let facetRoot = null;
  if (isFacetModel(model)) {
    const facetName = model.getName("facet");
    head = makeJoinAggregateFromFacet(head, model.facet) ?? head;
    facetRoot = new FacetNode(head, model, facetName, main2.getSource());
    outputNodes[facetName] = facetRoot;
  }
  return {
    ...model.component.data,
    outputNodes,
    outputNodeRefCounts,
    raw,
    main: main2,
    facetRoot,
    ancestorParse,
    preFilterInvalid,
    postFilterInvalid
  };
}
function makeOutputNode(dataSourceType, model, head) {
  const { outputNodes, outputNodeRefCounts } = model.component.data;
  const name = model.getDataName(dataSourceType);
  const node = new OutputNode(head, name, dataSourceType, outputNodeRefCounts);
  outputNodes[name] = node;
  return node;
}
var ConcatModel = class extends Model {
  constructor(spec, parent, parentGivenName, config) {
    var _a2, _b, _c2, _d2;
    super(spec, "concat", parent, parentGivenName, config, spec.resolve);
    __publicField(this, "children");
    if (((_b = (_a2 = spec.resolve) == null ? void 0 : _a2.axis) == null ? void 0 : _b.x) === "shared" || ((_d2 = (_c2 = spec.resolve) == null ? void 0 : _c2.axis) == null ? void 0 : _d2.y) === "shared") {
      warn2(CONCAT_CANNOT_SHARE_AXIS);
    }
    this.children = this.getChildren(spec).map((child, i) => {
      return buildModel(child, this, this.getName(`concat_${i}`), void 0, config);
    });
  }
  parseData() {
    this.component.data = parseData2(this);
    for (const child of this.children) {
      child.parseData();
    }
  }
  parseSelections() {
    this.component.selection = {};
    for (const child of this.children) {
      child.parseSelections();
      for (const key4 of keys4(child.component.selection)) {
        this.component.selection[key4] = child.component.selection[key4];
      }
    }
    if (vals(this.component.selection).some((selCmpt) => isTimerSelection(selCmpt))) {
      error23(MULTI_VIEW_ANIMATION_UNSUPPORTED);
    }
  }
  parseMarkGroup() {
    for (const child of this.children) {
      child.parseMarkGroup();
    }
  }
  parseAxesAndHeaders() {
    for (const child of this.children) {
      child.parseAxesAndHeaders();
    }
  }
  getChildren(spec) {
    if (isVConcatSpec(spec)) {
      return spec.vconcat;
    } else if (isHConcatSpec(spec)) {
      return spec.hconcat;
    }
    return spec.concat;
  }
  parseLayoutSize() {
    parseConcatLayoutSize(this);
  }
  parseAxisGroup() {
    return null;
  }
  assembleSelectionTopLevelSignals(signals) {
    return this.children.reduce((sg, child) => child.assembleSelectionTopLevelSignals(sg), signals);
  }
  assembleSignals() {
    this.children.forEach((child) => child.assembleSignals());
    return [];
  }
  assembleLayoutSignals() {
    const layoutSignals = assembleLayoutSignals(this);
    for (const child of this.children) {
      layoutSignals.push(...child.assembleLayoutSignals());
    }
    return layoutSignals;
  }
  assembleSelectionData(data3) {
    return this.children.reduce((db, child) => child.assembleSelectionData(db), data3);
  }
  assembleMarks() {
    return this.children.map((child) => {
      const title2 = child.assembleTitle();
      const style6 = child.assembleGroupStyle();
      const encodeEntry2 = child.assembleGroupEncodeEntry(false);
      return {
        type: "group",
        name: child.getName("group"),
        ...title2 ? { title: title2 } : {},
        ...style6 ? { style: style6 } : {},
        ...encodeEntry2 ? { encode: { update: encodeEntry2 } } : {},
        ...child.assembleGroup()
      };
    });
  }
  assembleGroupStyle() {
    return void 0;
  }
  assembleDefaultLayout() {
    const columns = this.layout.columns;
    return {
      ...columns != null ? { columns } : {},
      bounds: "full",
      // Use align each so it can work with multiple plots with different size
      align: "each"
    };
  }
};
function isFalseOrNull(v2) {
  return v2 === false || v2 === null;
}
var AXIS_COMPONENT_PROPERTIES_INDEX = {
  disable: 1,
  gridScale: 1,
  scale: 1,
  ...COMMON_AXIS_PROPERTIES_INDEX,
  labelExpr: 1,
  encode: 1
};
var AXIS_COMPONENT_PROPERTIES = keys4(AXIS_COMPONENT_PROPERTIES_INDEX);
var AxisComponent = class _AxisComponent extends Split {
  constructor(explicit = {}, implicit2 = {}, mainExtracted = false) {
    super();
    __publicField(this, "explicit");
    __publicField(this, "implicit");
    __publicField(this, "mainExtracted");
    this.explicit = explicit;
    this.implicit = implicit2;
    this.mainExtracted = mainExtracted;
  }
  clone() {
    return new _AxisComponent(duplicate(this.explicit), duplicate(this.implicit), this.mainExtracted);
  }
  hasAxisPart(part) {
    if (part === "axis") {
      return true;
    }
    if (part === "grid" || part === "title") {
      return !!this.get(part);
    }
    return !isFalseOrNull(this.get(part));
  }
  hasOrientSignalRef() {
    return isSignalRef(this.explicit.orient);
  }
};
function labels(model, channel, specifiedLabelsSpec) {
  const { encoding, config } = model;
  const fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]) ?? getFieldOrDatumDef(encoding[getSecondaryRangeChannel(channel)]);
  const axis = model.axis(channel) || {};
  const { format: format14, formatType } = axis;
  if (isCustomFormatType(formatType)) {
    return {
      text: formatCustomType({
        fieldOrDatumDef,
        field: "datum.value",
        format: format14,
        formatType,
        config
      }),
      ...specifiedLabelsSpec
    };
  } else if (format14 === void 0 && formatType === void 0 && config.customFormatTypes) {
    if (channelDefType(fieldOrDatumDef) === "quantitative") {
      if (isPositionFieldOrDatumDef(fieldOrDatumDef) && fieldOrDatumDef.stack === "normalize" && config.normalizedNumberFormatType) {
        return {
          text: formatCustomType({
            fieldOrDatumDef,
            field: "datum.value",
            format: config.normalizedNumberFormat,
            formatType: config.normalizedNumberFormatType,
            config
          }),
          ...specifiedLabelsSpec
        };
      } else if (config.numberFormatType) {
        return {
          text: formatCustomType({
            fieldOrDatumDef,
            field: "datum.value",
            format: config.numberFormat,
            formatType: config.numberFormatType,
            config
          }),
          ...specifiedLabelsSpec
        };
      }
    }
    if (channelDefType(fieldOrDatumDef) === "temporal" && config.timeFormatType && isFieldDef(fieldOrDatumDef) && !fieldOrDatumDef.timeUnit) {
      return {
        text: formatCustomType({
          fieldOrDatumDef,
          field: "datum.value",
          format: config.timeFormat,
          formatType: config.timeFormatType,
          config
        }),
        ...specifiedLabelsSpec
      };
    }
  }
  return specifiedLabelsSpec;
}
function parseUnitAxes(model) {
  return POSITION_SCALE_CHANNELS.reduce((axis, channel) => {
    if (model.component.scales[channel]) {
      axis[channel] = [parseAxis2(channel, model)];
    }
    return axis;
  }, {});
}
var OPPOSITE_ORIENT = {
  bottom: "top",
  top: "bottom",
  left: "right",
  right: "left"
};
function parseLayerAxes(model) {
  const { axes, resolve: resolve2 } = model.component;
  const axisCount = { top: 0, bottom: 0, right: 0, left: 0 };
  for (const child of model.children) {
    child.parseAxesAndHeaders();
    for (const channel of keys4(child.component.axes)) {
      resolve2.axis[channel] = parseGuideResolve(model.component.resolve, channel);
      if (resolve2.axis[channel] === "shared") {
        axes[channel] = mergeAxisComponents(axes[channel], child.component.axes[channel]);
        if (!axes[channel]) {
          resolve2.axis[channel] = "independent";
          delete axes[channel];
        }
      }
    }
  }
  for (const channel of POSITION_SCALE_CHANNELS) {
    for (const child of model.children) {
      if (!child.component.axes[channel]) {
        continue;
      }
      if (resolve2.axis[channel] === "independent") {
        axes[channel] = (axes[channel] ?? []).concat(child.component.axes[channel]);
        for (const axisComponent of child.component.axes[channel]) {
          const { value: orient2, explicit } = axisComponent.getWithExplicit("orient");
          if (isSignalRef(orient2)) {
            continue;
          }
          if (axisCount[orient2] > 0 && !explicit) {
            const oppositeOrient = OPPOSITE_ORIENT[orient2];
            if (axisCount[orient2] > axisCount[oppositeOrient]) {
              axisComponent.set("orient", oppositeOrient, false);
            }
          }
          axisCount[orient2]++;
        }
      }
      delete child.component.axes[channel];
    }
    if (resolve2.axis[channel] === "independent" && axes[channel] && axes[channel].length > 1) {
      for (const [index4, axisCmpt] of (axes[channel] || []).entries()) {
        if (index4 > 0 && !!axisCmpt.get("grid") && !axisCmpt.explicit.grid) {
          axisCmpt.implicit.grid = false;
        }
      }
    }
  }
}
function mergeAxisComponents(mergedAxisCmpts, childAxisCmpts) {
  if (mergedAxisCmpts) {
    if (mergedAxisCmpts.length !== childAxisCmpts.length) {
      return void 0;
    }
    const length2 = mergedAxisCmpts.length;
    for (let i = 0; i < length2; i++) {
      const merged = mergedAxisCmpts[i];
      const child = childAxisCmpts[i];
      if (!!merged !== !!child) {
        return void 0;
      } else if (merged && child) {
        const mergedOrient = merged.getWithExplicit("orient");
        const childOrient = child.getWithExplicit("orient");
        if (mergedOrient.explicit && childOrient.explicit && mergedOrient.value !== childOrient.value) {
          return void 0;
        } else {
          mergedAxisCmpts[i] = mergeAxisComponent(merged, child);
        }
      }
    }
  } else {
    return childAxisCmpts.map((axisComponent) => axisComponent.clone());
  }
  return mergedAxisCmpts;
}
function mergeAxisComponent(merged, child) {
  for (const prop of AXIS_COMPONENT_PROPERTIES) {
    const mergedValueWithExplicit = mergeValuesWithExplicit(
      merged.getWithExplicit(prop),
      child.getWithExplicit(prop),
      prop,
      "axis",
      // Tie breaker function
      (v1, v2) => {
        switch (prop) {
          case "title":
            return mergeTitleComponent(v1, v2);
          case "gridScale":
            return {
              explicit: v1.explicit,
              // keep the old explicit
              value: getFirstDefined(v1.value, v2.value)
            };
        }
        return defaultTieBreaker(v1, v2, prop, "axis");
      }
    );
    merged.setWithExplicit(prop, mergedValueWithExplicit);
  }
  return merged;
}
function isExplicit(value7, property2, axis, model, channel) {
  if (property2 === "disable") {
    return axis !== void 0;
  }
  axis = axis || {};
  switch (property2) {
    case "titleAngle":
    case "labelAngle":
      return value7 === (isSignalRef(axis.labelAngle) ? axis.labelAngle : normalizeAngle(axis.labelAngle));
    case "values":
      return !!axis.values;
    case "encode":
      return !!axis.encoding || !!axis.labelAngle;
    case "title":
      if (value7 === getFieldDefTitle(model, channel)) {
        return true;
      }
  }
  return value7 === axis[property2];
}
var propsToAlwaysIncludeConfig = /* @__PURE__ */ new Set([
  "grid",
  // Grid is an exception because we need to set grid = true to generate another grid axis
  "translate",
  // translate has dependent logic for bar's bin position and it's 0.5 by default in Vega. If a config overrides this value, we need to know.
  // the rest are not axis configs in Vega, but are in VL, so we need to set too.
  "format",
  "formatType",
  "orient",
  "labelExpr",
  "tickCount",
  "position",
  "tickMinStep"
]);
function parseAxis2(channel, model) {
  var _a2, _b;
  let axis = model.axis(channel);
  const axisComponent = new AxisComponent();
  const fieldOrDatumDef = getFieldOrDatumDef(model.encoding[channel]);
  const { mark, config } = model;
  const orient2 = (axis == null ? void 0 : axis.orient) || ((_a2 = config[channel === "x" ? "axisX" : "axisY"]) == null ? void 0 : _a2.orient) || ((_b = config.axis) == null ? void 0 : _b.orient) || defaultOrient(channel);
  const scaleType2 = model.getScaleComponent(channel).get("type");
  const axisConfigs = getAxisConfigs(channel, scaleType2, orient2, model.config);
  const disable = axis !== void 0 ? !axis : getAxisConfig("disable", config.style, axis == null ? void 0 : axis.style, axisConfigs).configValue;
  axisComponent.set("disable", disable, axis !== void 0);
  if (disable) {
    return axisComponent;
  }
  axis = axis || {};
  const labelAngle = getLabelAngle(fieldOrDatumDef, axis, channel, config.style, axisConfigs);
  const formatType = guideFormatType(axis.formatType, fieldOrDatumDef, scaleType2);
  const format14 = guideFormat(fieldOrDatumDef, fieldOrDatumDef.type, axis.format, axis.formatType, config, true);
  const ruleParams = {
    fieldOrDatumDef,
    axis,
    channel,
    model,
    scaleType: scaleType2,
    orient: orient2,
    labelAngle,
    format: format14,
    formatType,
    mark,
    config
  };
  for (const property2 of AXIS_COMPONENT_PROPERTIES) {
    const value7 = property2 in axisRules ? axisRules[property2](ruleParams) : isAxisProperty(property2) ? axis[property2] : void 0;
    const hasValue = value7 !== void 0;
    const explicit = isExplicit(value7, property2, axis, model, channel);
    if (hasValue && explicit) {
      axisComponent.set(property2, value7, explicit);
    } else {
      const { configValue = void 0, configFrom = void 0 } = isAxisProperty(property2) && property2 !== "values" ? getAxisConfig(property2, config.style, axis.style, axisConfigs) : {};
      const hasConfigValue = configValue !== void 0;
      if (hasValue && !hasConfigValue) {
        axisComponent.set(property2, value7, explicit);
      } else if (
        // Cases need implicit values
        // 1. Axis config that aren't available in Vega
        !(configFrom === "vgAxisConfig") || // 2. Certain properties are always included (see `propsToAlwaysIncludeConfig`'s declaration for more details)
        propsToAlwaysIncludeConfig.has(property2) && hasConfigValue || // 3. Conditional axis values and signals
        isConditionalAxisValue(configValue) || isSignalRef(configValue)
      ) {
        axisComponent.set(property2, configValue, false);
      }
    }
  }
  const axisEncoding = axis.encoding ?? {};
  const axisEncode = AXIS_PARTS.reduce((e3, part) => {
    if (!axisComponent.hasAxisPart(part)) {
      return e3;
    }
    const axisEncodingPart = guideEncodeEntry(axisEncoding[part] ?? {}, model);
    const value7 = part === "labels" ? labels(model, channel, axisEncodingPart) : axisEncodingPart;
    if (value7 !== void 0 && !isEmpty(value7)) {
      e3[part] = { update: value7 };
    }
    return e3;
  }, {});
  if (!isEmpty(axisEncode)) {
    axisComponent.set("encode", axisEncode, !!axis.encoding || axis.labelAngle !== void 0);
  }
  return axisComponent;
}
function initLayoutSize({ encoding, size }) {
  for (const channel of POSITION_SCALE_CHANNELS) {
    const sizeType = getSizeChannel(channel);
    if (isStep(size[sizeType])) {
      if (isContinuousFieldOrDatumDef(encoding[channel])) {
        delete size[sizeType];
        warn2(stepDropped(sizeType));
      }
    }
  }
  return size;
}
var arc7 = {
  vgMark: "arc",
  encodeEntry: (model) => {
    return {
      ...baseEncodeEntry(model, {
        align: "ignore",
        baseline: "ignore",
        color: "include",
        size: "ignore",
        orient: "ignore",
        theta: "ignore"
      }),
      ...pointPosition("x", model, { defaultPos: "mid" }),
      ...pointPosition("y", model, { defaultPos: "mid" }),
      // arcs are rectangles in polar coordinates
      ...rectPosition(model, "radius"),
      ...rectPosition(model, "theta")
    };
  }
};
var area7 = {
  vgMark: "area",
  encodeEntry: (model) => {
    return {
      ...baseEncodeEntry(model, {
        align: "ignore",
        baseline: "ignore",
        color: "include",
        orient: "include",
        size: "ignore",
        theta: "ignore"
      }),
      ...pointOrRangePosition("x", model, {
        defaultPos: "zeroOrMin",
        defaultPos2: "zeroOrMin",
        range: model.markDef.orient === "horizontal"
      }),
      ...pointOrRangePosition("y", model, {
        defaultPos: "zeroOrMin",
        defaultPos2: "zeroOrMin",
        range: model.markDef.orient === "vertical"
      }),
      ...defined(model)
    };
  }
};
var bar = {
  vgMark: "rect",
  encodeEntry: (model) => {
    return {
      ...baseEncodeEntry(model, {
        align: "ignore",
        baseline: "ignore",
        color: "include",
        orient: "ignore",
        size: "ignore",
        theta: "ignore"
      }),
      ...rectPosition(model, "x"),
      ...rectPosition(model, "y")
    };
  }
};
var geoshape = {
  vgMark: "shape",
  encodeEntry: (model) => {
    return {
      ...baseEncodeEntry(model, {
        align: "ignore",
        baseline: "ignore",
        color: "include",
        size: "ignore",
        orient: "ignore",
        theta: "ignore"
      })
    };
  },
  postEncodingTransform: (model) => {
    const { encoding } = model;
    const shapeDef = encoding.shape;
    const transform4 = {
      type: "geoshape",
      projection: model.projectionName(),
      // as: 'shape',
      ...shapeDef && isFieldDef(shapeDef) && shapeDef.type === GEOJSON ? { field: vgField(shapeDef, { expr: "datum" }) } : {}
    };
    return [transform4];
  }
};
var image6 = {
  vgMark: "image",
  encodeEntry: (model) => {
    return {
      ...baseEncodeEntry(model, {
        align: "ignore",
        baseline: "ignore",
        color: "ignore",
        orient: "ignore",
        size: "ignore",
        theta: "ignore"
      }),
      ...rectPosition(model, "x"),
      ...rectPosition(model, "y"),
      ...text$1(model, "url")
    };
  }
};
var line7 = {
  vgMark: "line",
  encodeEntry: (model) => {
    return {
      ...baseEncodeEntry(model, {
        align: "ignore",
        baseline: "ignore",
        color: "include",
        size: "ignore",
        orient: "ignore",
        theta: "ignore"
      }),
      ...pointPosition("x", model, { defaultPos: "mid" }),
      ...pointPosition("y", model, { defaultPos: "mid" }),
      ...nonPosition("size", model, {
        vgChannel: "strokeWidth"
        // VL's line size is strokeWidth
      }),
      ...defined(model)
    };
  }
};
var trail6 = {
  vgMark: "trail",
  encodeEntry: (model) => {
    return {
      ...baseEncodeEntry(model, {
        align: "ignore",
        baseline: "ignore",
        color: "include",
        size: "include",
        orient: "ignore",
        theta: "ignore"
      }),
      ...pointPosition("x", model, { defaultPos: "mid" }),
      ...pointPosition("y", model, { defaultPos: "mid" }),
      ...nonPosition("size", model),
      ...defined(model)
    };
  }
};
function encodeEntry(model, fixedShape) {
  const { config } = model;
  return {
    ...baseEncodeEntry(model, {
      align: "ignore",
      baseline: "ignore",
      color: "include",
      size: "include",
      orient: "ignore",
      theta: "ignore"
    }),
    ...pointPosition("x", model, { defaultPos: "mid" }),
    ...pointPosition("y", model, { defaultPos: "mid" }),
    ...nonPosition("size", model),
    ...nonPosition("angle", model),
    ...shapeMixins(model, config, fixedShape)
  };
}
function shapeMixins(model, config, fixedShape) {
  if (fixedShape) {
    return { shape: { value: fixedShape } };
  }
  return nonPosition("shape", model);
}
var point20 = {
  vgMark: "symbol",
  encodeEntry: (model) => {
    return encodeEntry(model);
  }
};
var circle = {
  vgMark: "symbol",
  encodeEntry: (model) => {
    return encodeEntry(model, "circle");
  }
};
var square = {
  vgMark: "symbol",
  encodeEntry: (model) => {
    return encodeEntry(model, "square");
  }
};
var rect6 = {
  vgMark: "rect",
  encodeEntry: (model) => {
    return {
      ...baseEncodeEntry(model, {
        align: "ignore",
        baseline: "ignore",
        color: "include",
        orient: "ignore",
        size: "ignore",
        theta: "ignore"
      }),
      ...rectPosition(model, "x"),
      ...rectPosition(model, "y")
    };
  }
};
var rule7 = {
  vgMark: "rule",
  encodeEntry: (model) => {
    const { markDef } = model;
    const orient2 = markDef.orient;
    if (!model.encoding.x && !model.encoding.y && !model.encoding.latitude && !model.encoding.longitude) {
      return {};
    }
    return {
      ...baseEncodeEntry(model, {
        align: "ignore",
        baseline: "ignore",
        color: "include",
        orient: "ignore",
        size: "ignore",
        theta: "ignore"
      }),
      ...pointOrRangePosition("x", model, {
        defaultPos: orient2 === "horizontal" ? "zeroOrMax" : "mid",
        defaultPos2: "zeroOrMin",
        range: orient2 !== "vertical"
        // include x2 for horizontal or line segment rule
      }),
      ...pointOrRangePosition("y", model, {
        defaultPos: orient2 === "vertical" ? "zeroOrMax" : "mid",
        defaultPos2: "zeroOrMin",
        range: orient2 !== "horizontal"
        // include y2 for vertical or line segment rule
      }),
      ...nonPosition("size", model, {
        vgChannel: "strokeWidth"
        // VL's rule size is strokeWidth
      })
    };
  }
};
var text6 = {
  vgMark: "text",
  encodeEntry: (model) => {
    const { config, encoding } = model;
    return {
      ...baseEncodeEntry(model, {
        align: "include",
        baseline: "include",
        color: "include",
        size: "ignore",
        orient: "ignore",
        theta: "include"
      }),
      ...pointPosition("x", model, { defaultPos: "mid" }),
      ...pointPosition("y", model, { defaultPos: "mid" }),
      ...text$1(model),
      ...nonPosition("size", model, {
        vgChannel: "fontSize"
        // VL's text size is fontSize
      }),
      ...nonPosition("angle", model),
      ...valueIfDefined("align", align(model.markDef, encoding, config)),
      ...valueIfDefined("baseline", baseline2(model.markDef, encoding, config)),
      ...pointPosition("radius", model, { defaultPos: null }),
      ...pointPosition("theta", model, { defaultPos: null })
    };
  }
};
function align(markDef, encoding, config) {
  const a4 = getMarkPropOrConfig("align", markDef, config);
  if (a4 === void 0) {
    return "center";
  }
  return void 0;
}
function baseline2(markDef, encoding, config) {
  const b6 = getMarkPropOrConfig("baseline", markDef, config);
  if (b6 === void 0) {
    return "middle";
  }
  return void 0;
}
var tick = {
  vgMark: "rect",
  encodeEntry: (model) => {
    const { config, markDef } = model;
    const orient2 = markDef.orient;
    const vgSizeAxisChannel = orient2 === "horizontal" ? "x" : "y";
    const vgThicknessAxisChannel = orient2 === "horizontal" ? "y" : "x";
    const vgThicknessChannel = orient2 === "horizontal" ? "height" : "width";
    return {
      ...baseEncodeEntry(model, {
        align: "ignore",
        baseline: "ignore",
        color: "include",
        orient: "ignore",
        size: "ignore",
        theta: "ignore"
      }),
      ...rectPosition(model, vgSizeAxisChannel),
      ...pointPosition(vgThicknessAxisChannel, model, {
        defaultPos: "mid",
        vgChannel: vgThicknessAxisChannel === "y" ? "yc" : "xc"
      }),
      [vgThicknessChannel]: signalOrValueRef(getMarkPropOrConfig("thickness", markDef, config))
    };
  }
};
var markCompiler = {
  arc: arc7,
  area: area7,
  bar,
  circle,
  geoshape,
  image: image6,
  line: line7,
  point: point20,
  rect: rect6,
  rule: rule7,
  square,
  text: text6,
  tick,
  trail: trail6
};
function parseMarkGroups(model) {
  if (contains2([LINE, AREA, TRAIL], model.mark)) {
    const details = pathGroupingFields(model.mark, model.encoding);
    if (details.length > 0) {
      return getPathGroups(model, details);
    }
  } else if (model.mark === BAR) {
    const hasCornerRadius6 = VG_CORNERRADIUS_CHANNELS.some((prop) => getMarkPropOrConfig(prop, model.markDef, model.config));
    if (model.stack && !model.fieldDef("size") && hasCornerRadius6) {
      return getGroupsForStackedBarWithCornerRadius(model);
    }
  }
  return getMarkGroup(model);
}
var FACETED_PATH_PREFIX = "faceted_path_";
function getPathGroups(model, details) {
  return [
    {
      name: model.getName("pathgroup"),
      type: "group",
      from: {
        facet: {
          name: FACETED_PATH_PREFIX + model.requestDataName(DataSourceType.Main),
          data: model.requestDataName(DataSourceType.Main),
          groupby: details
        }
      },
      encode: {
        update: {
          width: { field: { group: "width" } },
          height: { field: { group: "height" } }
        }
      },
      // With subfacet for line/area group, need to use faceted data from above.
      marks: getMarkGroup(model, { fromPrefix: FACETED_PATH_PREFIX })
    }
  ];
}
var STACK_GROUP_PREFIX = "stack_group_";
function getGroupsForStackedBarWithCornerRadius(model) {
  var _a2;
  const [mark] = getMarkGroup(model, { fromPrefix: STACK_GROUP_PREFIX });
  const fieldScale = model.scaleName(model.stack.fieldChannel);
  const stackField = (opt = {}) => model.vgField(model.stack.fieldChannel, opt);
  const stackFieldGroup = (func, expr2) => {
    const vgFieldMinMax = [
      stackField({ prefix: "min", suffix: "start", expr: expr2 }),
      stackField({ prefix: "max", suffix: "start", expr: expr2 }),
      stackField({ prefix: "min", suffix: "end", expr: expr2 }),
      stackField({ prefix: "max", suffix: "end", expr: expr2 })
    ];
    return `${func}(${vgFieldMinMax.map((field25) => `scale('${fieldScale}',${field25})`).join(",")})`;
  };
  let groupUpdate;
  let innerGroupUpdate;
  if (model.stack.fieldChannel === "x") {
    groupUpdate = {
      ...pick6(mark.encode.update, ["y", "yc", "y2", "height", ...VG_CORNERRADIUS_CHANNELS]),
      x: { signal: stackFieldGroup("min", "datum") },
      x2: { signal: stackFieldGroup("max", "datum") },
      clip: { value: true }
    };
    innerGroupUpdate = {
      x: { field: { group: "x" }, mult: -1 },
      height: { field: { group: "height" } }
    };
    mark.encode.update = {
      ...omit(mark.encode.update, ["y", "yc", "y2"]),
      height: { field: { group: "height" } }
    };
  } else {
    groupUpdate = {
      ...pick6(mark.encode.update, ["x", "xc", "x2", "width"]),
      y: { signal: stackFieldGroup("min", "datum") },
      y2: { signal: stackFieldGroup("max", "datum") },
      clip: { value: true }
    };
    innerGroupUpdate = {
      y: { field: { group: "y" }, mult: -1 },
      width: { field: { group: "width" } }
    };
    mark.encode.update = {
      ...omit(mark.encode.update, ["x", "xc", "x2"]),
      width: { field: { group: "width" } }
    };
  }
  for (const key4 of VG_CORNERRADIUS_CHANNELS) {
    const configValue = getMarkConfig(key4, model.markDef, model.config);
    if (mark.encode.update[key4]) {
      groupUpdate[key4] = mark.encode.update[key4];
      delete mark.encode.update[key4];
    } else if (configValue) {
      groupUpdate[key4] = signalOrValueRef(configValue);
    }
    if (configValue) {
      mark.encode.update[key4] = { value: 0 };
    }
  }
  const groupby = [];
  if (((_a2 = model.stack.groupbyChannels) == null ? void 0 : _a2.length) > 0) {
    for (const groupbyChannel of model.stack.groupbyChannels) {
      const groupByField = model.fieldDef(groupbyChannel);
      const field25 = vgField(groupByField);
      if (field25) {
        groupby.push(field25);
      }
      if ((groupByField == null ? void 0 : groupByField.bin) || (groupByField == null ? void 0 : groupByField.timeUnit)) {
        groupby.push(vgField(groupByField, { binSuffix: "end" }));
      }
    }
  }
  const strokeProperties = [
    "stroke",
    "strokeWidth",
    "strokeJoin",
    "strokeCap",
    "strokeDash",
    "strokeDashOffset",
    "strokeMiterLimit",
    "strokeOpacity"
  ];
  groupUpdate = strokeProperties.reduce((encode2, prop) => {
    if (mark.encode.update[prop]) {
      return { ...encode2, [prop]: mark.encode.update[prop] };
    } else {
      const configValue = getMarkConfig(prop, model.markDef, model.config);
      if (configValue !== void 0) {
        return { ...encode2, [prop]: signalOrValueRef(configValue) };
      } else {
        return encode2;
      }
    }
  }, groupUpdate);
  if (groupUpdate.stroke) {
    groupUpdate.strokeForeground = { value: true };
    groupUpdate.strokeOffset = { value: 0 };
  }
  return [
    {
      type: "group",
      from: {
        facet: {
          data: model.requestDataName(DataSourceType.Main),
          name: STACK_GROUP_PREFIX + model.requestDataName(DataSourceType.Main),
          groupby,
          aggregate: {
            fields: [
              stackField({ suffix: "start" }),
              stackField({ suffix: "start" }),
              stackField({ suffix: "end" }),
              stackField({ suffix: "end" })
            ],
            ops: ["min", "max", "min", "max"]
          }
        }
      },
      encode: {
        update: groupUpdate
      },
      marks: [
        {
          type: "group",
          encode: { update: innerGroupUpdate },
          marks: [mark]
        }
      ]
    }
  ];
}
function getSort(model) {
  const { encoding, stack: stack2, mark, markDef, config } = model;
  const order = encoding.order;
  if (!isArray22(order) && isValueDef(order) && isNullOrFalse(order.value) || !order && isNullOrFalse(getMarkPropOrConfig("order", markDef, config))) {
    return void 0;
  } else if ((isArray22(order) || isFieldDef(order)) && !stack2) {
    return sortParams(order, { expr: "datum" });
  } else if (isPathMark(mark)) {
    const dimensionChannel = markDef.orient === "horizontal" ? "y" : "x";
    const dimensionChannelDef = encoding[dimensionChannel];
    if (isFieldDef(dimensionChannelDef)) {
      return { field: dimensionChannel };
    }
  }
  return void 0;
}
function getMarkGroup(model, opt = { fromPrefix: "" }) {
  var _a2;
  const { mark, markDef, encoding, config } = model;
  const clip7 = getFirstDefined(markDef.clip, scaleClip(model), projectionClip(model));
  const style6 = getStyles(markDef);
  const key4 = encoding.key;
  const sort4 = getSort(model);
  const interactive2 = interactiveFlag(model);
  if (interactive2 && Object.values(model.component.selection).some((s2) => s2.type === "point" && !s2.bind && // if on is a pointerover (hover) the pointer makes less sense since the mark is not clickable.
  s2.on !== "pointerover")) {
    (_a2 = model.markDef).cursor ?? (_a2.cursor = "pointer");
  }
  const aria2 = getMarkPropOrConfig("aria", markDef, config);
  const postEncodingTransform = markCompiler[mark].postEncodingTransform ? markCompiler[mark].postEncodingTransform(model) : null;
  return [
    {
      name: model.getName("marks"),
      type: markCompiler[mark].vgMark,
      ...clip7 ? { clip: clip7 } : {},
      ...style6 ? { style: style6 } : {},
      ...key4 ? { key: key4.field } : {},
      ...sort4 ? { sort: sort4 } : {},
      ...interactive2 ? interactive2 : {},
      ...aria2 === false ? { aria: aria2 } : {},
      from: { data: opt.fromPrefix + model.requestDataName(DataSourceType.Main) },
      encode: {
        update: markCompiler[mark].encodeEntry(model)
      },
      ...postEncodingTransform ? {
        transform: postEncodingTransform
      } : {}
    }
  ];
}
function scaleClip(model) {
  const xScale = model.getScaleComponent("x");
  const yScale = model.getScaleComponent("y");
  return (xScale == null ? void 0 : xScale.get("selectionExtent")) || (yScale == null ? void 0 : yScale.get("selectionExtent")) ? true : void 0;
}
function projectionClip(model) {
  const projection3 = model.component.projection;
  return projection3 && !projection3.isFit ? true : void 0;
}
function interactiveFlag(model) {
  if (!model.component.selection)
    return null;
  const unitCount = keys4(model.component.selection).length;
  let parentCount = unitCount;
  let parent = model.parent;
  while (parent && parentCount === 0) {
    parentCount = keys4(parent.component.selection).length;
    parent = parent.parent;
  }
  return parentCount ? {
    interactive: unitCount > 0 || model.mark === "geoshape" || !!model.encoding.tooltip || !!model.markDef.tooltip
  } : null;
}
var UnitModel = class extends ModelWithField {
  constructor(spec, parent, parentGivenName, parentGivenSize = {}, config) {
    super(spec, "unit", parent, parentGivenName, config, void 0, isFrameMixins(spec) ? spec.view : void 0);
    __publicField(this, "markDef");
    __publicField(this, "encoding");
    __publicField(this, "specifiedScales", {});
    __publicField(this, "stack");
    __publicField(this, "specifiedAxes", {});
    __publicField(this, "specifiedLegends", {});
    __publicField(this, "specifiedProjection", {});
    __publicField(this, "selection", []);
    __publicField(this, "children", []);
    /**
     * Corrects the data references in marks after assemble.
     */
    __publicField(this, "correctDataNames", (mark) => {
      var _a2, _b, _c2;
      if ((_a2 = mark.from) == null ? void 0 : _a2.data) {
        mark.from.data = this.lookupDataSource(mark.from.data);
        if ("time" in this.encoding) {
          mark.from.data = mark.from.data + CURR;
        }
      }
      if ((_c2 = (_b = mark.from) == null ? void 0 : _b.facet) == null ? void 0 : _c2.data) {
        mark.from.facet.data = this.lookupDataSource(mark.from.facet.data);
      }
      return mark;
    });
    const markDef = isMarkDef(spec.mark) ? { ...spec.mark } : { type: spec.mark };
    const mark = markDef.type;
    if (markDef.filled === void 0) {
      markDef.filled = defaultFilled(markDef, config, {
        graticule: spec.data && isGraticuleGenerator(spec.data)
      });
    }
    const encoding = this.encoding = initEncoding(spec.encoding || {}, mark, markDef.filled, config);
    this.markDef = initMarkdef(markDef, encoding, config);
    this.size = initLayoutSize({
      encoding,
      size: isFrameMixins(spec) ? {
        ...parentGivenSize,
        ...spec.width !== void 0 ? { width: spec.width } : {},
        ...spec.height !== void 0 ? { height: spec.height } : {}
      } : parentGivenSize
    });
    this.stack = stack(this.markDef, encoding);
    this.specifiedScales = this.initScales(mark, encoding);
    this.specifiedAxes = this.initAxes(encoding);
    this.specifiedLegends = this.initLegends(encoding);
    this.specifiedProjection = spec.projection;
    this.selection = (spec.params ?? []).filter((p) => isSelectionParameter(p));
    this.alignStackOrderWithColorDomain();
  }
  get hasProjection() {
    const { encoding } = this;
    const isGeoShapeMark = this.mark === GEOSHAPE;
    const hasGeoPosition = encoding && GEOPOSITION_CHANNELS.some((channel) => isFieldOrDatumDef(encoding[channel]));
    return isGeoShapeMark || hasGeoPosition;
  }
  /**
   * Return specified Vega-Lite scale domain for a particular channel
   * @param channel
   */
  scaleDomain(channel) {
    const scale19 = this.specifiedScales[channel];
    return scale19 ? scale19.domain : void 0;
  }
  axis(channel) {
    return this.specifiedAxes[channel];
  }
  legend(channel) {
    return this.specifiedLegends[channel];
  }
  initScales(mark, encoding) {
    return SCALE_CHANNELS.reduce((scales10, channel) => {
      const fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]);
      if (fieldOrDatumDef) {
        scales10[channel] = this.initScale(fieldOrDatumDef.scale ?? {});
      }
      return scales10;
    }, {});
  }
  initScale(scale19) {
    const { domain: domain3, range: range7 } = scale19;
    const scaleInternal = replaceExprRef(scale19);
    if (isArray22(domain3)) {
      scaleInternal.domain = domain3.map(signalRefOrValue);
    }
    if (isArray22(range7)) {
      scaleInternal.range = range7.map(signalRefOrValue);
    }
    return scaleInternal;
  }
  initAxes(encoding) {
    return POSITION_SCALE_CHANNELS.reduce((_axis, channel) => {
      const channelDef = encoding[channel];
      if (isFieldOrDatumDef(channelDef) || channel === X3 && isFieldOrDatumDef(encoding.x2) || channel === Y3 && isFieldOrDatumDef(encoding.y2)) {
        const axisSpec = isFieldOrDatumDef(channelDef) ? channelDef.axis : void 0;
        _axis[channel] = axisSpec ? this.initAxis({ ...axisSpec }) : axisSpec;
      }
      return _axis;
    }, {});
  }
  initAxis(axis) {
    const props = keys4(axis);
    const axisInternal = {};
    for (const prop of props) {
      const val = axis[prop];
      axisInternal[prop] = isConditionalAxisValue(val) ? signalOrValueRefWithCondition(val) : signalRefOrValue(val);
    }
    return axisInternal;
  }
  initLegends(encoding) {
    return NONPOSITION_SCALE_CHANNELS.reduce((_legend, channel) => {
      const fieldOrDatumDef = getFieldOrDatumDef(encoding[channel]);
      if (fieldOrDatumDef && supportLegend(channel)) {
        const legend = fieldOrDatumDef.legend;
        _legend[channel] = legend ? replaceExprRef(legend) : legend;
      }
      return _legend;
    }, {});
  }
  /**
   * If this unit lacks order encoding but does contain a color domain
   * add transform and encoding that aligns the stack order with the color domain.
   */
  alignStackOrderWithColorDomain() {
    var _a2;
    const { color: color9, fill: fill6, order, xOffset, yOffset } = this.encoding;
    const colorField = fill6 || color9;
    const colorEncoding = isFieldDef(colorField) ? colorField : void 0;
    const field25 = colorEncoding == null ? void 0 : colorEncoding.field;
    const scale19 = colorEncoding == null ? void 0 : colorEncoding.scale;
    const colorEncodingType = colorEncoding == null ? void 0 : colorEncoding.type;
    const domain3 = scale19 == null ? void 0 : scale19.domain;
    const offset9 = xOffset || yOffset;
    const offsetEncoding = isFieldDef(offset9) ? offset9 : void 0;
    const orderFieldName = `_${field25}_sort_index`;
    if (!order && Array.isArray(domain3) && typeof field25 === "string" && colorEncodingType === "nominal") {
      if (offsetEncoding && !offsetEncoding.sort) {
        offsetEncoding.sort = domain3;
      } else {
        if (!this.stack) {
          return;
        }
        const orderExpression = `indexof(${$10(domain3)}, datum['${field25}'])`;
        const sort4 = ((_a2 = this.markDef) == null ? void 0 : _a2.orient) === "horizontal" ? "ascending" : "descending";
        this.transforms.push({ calculate: orderExpression, as: orderFieldName });
        this.encoding.order = { field: orderFieldName, type: "quantitative", sort: sort4 };
      }
    }
  }
  parseData() {
    this.component.data = parseData2(this);
  }
  parseLayoutSize() {
    parseUnitLayoutSize(this);
  }
  parseSelections() {
    this.component.selection = parseUnitSelection(this, this.selection);
  }
  parseMarkGroup() {
    this.component.mark = parseMarkGroups(this);
  }
  parseAxesAndHeaders() {
    this.component.axes = parseUnitAxes(this);
  }
  assembleSelectionTopLevelSignals(signals) {
    return assembleTopLevelSignals(this, signals);
  }
  assembleSignals() {
    return [...assembleAxisSignals(this), ...assembleUnitSelectionSignals(this, [])];
  }
  assembleSelectionData(data3) {
    return assembleUnitSelectionData(this, data3);
  }
  assembleLayout() {
    return null;
  }
  assembleLayoutSignals() {
    return assembleLayoutSignals(this);
  }
  assembleMarks() {
    let marks = this.component.mark ?? [];
    if (!this.parent || !isLayerModel(this.parent)) {
      marks = assembleUnitSelectionMarks(this, marks);
    }
    return marks.map(this.correctDataNames);
  }
  assembleGroupStyle() {
    const { style: style6 } = this.view || {};
    if (style6 !== void 0) {
      return style6;
    }
    if (this.encoding.x || this.encoding.y) {
      return "cell";
    } else {
      return "view";
    }
  }
  getMapping() {
    return this.encoding;
  }
  get mark() {
    return this.markDef.type;
  }
  channelHasField(channel) {
    return channelHasField(this.encoding, channel);
  }
  fieldDef(channel) {
    const channelDef = this.encoding[channel];
    return getFieldDef(channelDef);
  }
  typedFieldDef(channel) {
    const fieldDef = this.fieldDef(channel);
    if (isTypedFieldDef(fieldDef)) {
      return fieldDef;
    }
    return null;
  }
};
var LayerModel = class _LayerModel extends Model {
  constructor(spec, parent, parentGivenName, parentGivenSize, config) {
    super(spec, "layer", parent, parentGivenName, config, spec.resolve, spec.view);
    // HACK: This should be (LayerModel | UnitModel)[], but setting the correct type leads to weird error.
    // So I'm just putting generic Model for now
    __publicField(this, "children");
    const layoutSize = {
      ...parentGivenSize,
      ...spec.width ? { width: spec.width } : {},
      ...spec.height ? { height: spec.height } : {}
    };
    this.children = spec.layer.map((layer, i) => {
      if (isLayerSpec(layer)) {
        return new _LayerModel(layer, this, this.getName(`layer_${i}`), layoutSize, config);
      } else if (isUnitSpec(layer)) {
        return new UnitModel(layer, this, this.getName(`layer_${i}`), layoutSize, config);
      }
      throw new Error(invalidSpec(layer));
    });
  }
  parseData() {
    this.component.data = parseData2(this);
    for (const child of this.children) {
      child.parseData();
    }
  }
  parseLayoutSize() {
    parseLayerLayoutSize(this);
  }
  parseSelections() {
    this.component.selection = {};
    for (const child of this.children) {
      child.parseSelections();
      for (const key4 of keys4(child.component.selection)) {
        this.component.selection[key4] = child.component.selection[key4];
      }
    }
    if (vals(this.component.selection).some((selCmpt) => isTimerSelection(selCmpt))) {
      error23(MULTI_VIEW_ANIMATION_UNSUPPORTED);
    }
  }
  parseMarkGroup() {
    for (const child of this.children) {
      child.parseMarkGroup();
    }
  }
  parseAxesAndHeaders() {
    parseLayerAxes(this);
  }
  assembleSelectionTopLevelSignals(signals) {
    return this.children.reduce((sg, child) => child.assembleSelectionTopLevelSignals(sg), signals);
  }
  // TODO: Support same named selections across children.
  assembleSignals() {
    return this.children.reduce((signals, child) => {
      return signals.concat(child.assembleSignals());
    }, assembleAxisSignals(this));
  }
  assembleLayoutSignals() {
    return this.children.reduce((signals, child) => {
      return signals.concat(child.assembleLayoutSignals());
    }, assembleLayoutSignals(this));
  }
  assembleSelectionData(data3) {
    return this.children.reduce((db, child) => child.assembleSelectionData(db), data3);
  }
  assembleGroupStyle() {
    const uniqueStyles = /* @__PURE__ */ new Set();
    for (const child of this.children) {
      for (const style6 of array21(child.assembleGroupStyle())) {
        uniqueStyles.add(style6);
      }
    }
    const styles = Array.from(uniqueStyles);
    return styles.length > 1 ? styles : styles.length === 1 ? styles[0] : void 0;
  }
  assembleTitle() {
    let title2 = super.assembleTitle();
    if (title2) {
      return title2;
    }
    for (const child of this.children) {
      title2 = child.assembleTitle();
      if (title2) {
        return title2;
      }
    }
    return void 0;
  }
  assembleLayout() {
    return null;
  }
  assembleMarks() {
    return assembleLayerSelectionMarks(this, this.children.flatMap((child) => {
      return child.assembleMarks();
    }));
  }
  assembleLegends() {
    return this.children.reduce((legends, child) => {
      return legends.concat(child.assembleLegends());
    }, assembleLegends(this));
  }
};
function buildModel(spec, parent, parentGivenName, unitSize, config) {
  if (isFacetSpec(spec)) {
    return new FacetModel(spec, parent, parentGivenName, config);
  } else if (isLayerSpec(spec)) {
    return new LayerModel(spec, parent, parentGivenName, unitSize, config);
  } else if (isUnitSpec(spec)) {
    return new UnitModel(spec, parent, parentGivenName, unitSize, config);
  } else if (isAnyConcatSpec(spec)) {
    return new ConcatModel(spec, parent, parentGivenName, config);
  }
  throw new Error(invalidSpec(spec));
}
function compile(inputSpec, opt = {}) {
  if (opt.logger) {
    set6(opt.logger);
  }
  if (opt.fieldTitle) {
    setTitleFormatter(opt.fieldTitle);
  }
  try {
    const config = initConfig(mergeConfig3(opt.config, inputSpec.config));
    const spec = normalize3(inputSpec, config);
    const model = buildModel(spec, null, "", void 0, config);
    model.parse();
    optimizeDataflow(model.component.data, model);
    const vgSpec = assembleTopLevelModel(model, getTopLevelProperties(inputSpec, spec.autosize, config, model), inputSpec.datasets, inputSpec.usermeta);
    return {
      spec: vgSpec,
      normalized: spec
    };
  } finally {
    if (opt.logger) {
      reset2();
    }
    if (opt.fieldTitle) {
      resetTitleFormatter();
    }
  }
}
function getTopLevelProperties(inputSpec, autosize, config, model) {
  const width2 = model.component.layoutSize.get("width");
  const height2 = model.component.layoutSize.get("height");
  if (autosize === void 0) {
    autosize = { type: "pad" };
    if (model.hasAxisOrientSignalRef()) {
      autosize.resize = true;
    }
  } else if (isString14(autosize)) {
    autosize = { type: autosize };
  }
  if (width2 && height2 && isFitType(autosize.type)) {
    if (width2 === "step" && height2 === "step") {
      warn2(droppingFit());
      autosize.type = "pad";
    } else if (width2 === "step" || height2 === "step") {
      const sizeType = width2 === "step" ? "width" : "height";
      warn2(droppingFit(getPositionScaleChannel(sizeType)));
      const inverseSizeType = sizeType === "width" ? "height" : "width";
      autosize.type = getFitType(inverseSizeType);
    }
  }
  return {
    ...keys4(autosize).length === 1 && autosize.type ? autosize.type === "pad" ? {} : { autosize: autosize.type } : { autosize },
    ...extractTopLevelProperties(config, false),
    ...extractTopLevelProperties(inputSpec, true)
  };
}
function assembleTopLevelModel(model, topLevelProperties, datasets = {}, usermeta) {
  const vgConfig = model.config ? stripAndRedirectConfig(model.config) : void 0;
  const rootData = assembleRootData(model.component.data, datasets);
  const data3 = model.assembleSelectionData(rootData);
  const projections2 = model.assembleProjections();
  const title2 = model.assembleTitle();
  const style6 = model.assembleGroupStyle();
  const encodeEntry2 = model.assembleGroupEncodeEntry(true);
  let layoutSignals = model.assembleLayoutSignals();
  layoutSignals = layoutSignals.filter((signal) => {
    if ((signal.name === "width" || signal.name === "height") && signal.value !== void 0) {
      topLevelProperties[signal.name] = +signal.value;
      return false;
    }
    return true;
  });
  const { params: params2, ...otherTopLevelProps } = topLevelProperties;
  return {
    $schema: "https://vega.github.io/schema/vega/v6.json",
    ...model.description ? { description: model.description } : {},
    ...otherTopLevelProps,
    ...title2 ? { title: title2 } : {},
    ...style6 ? { style: style6 } : {},
    ...encodeEntry2 ? { encode: { update: encodeEntry2 } } : {},
    data: data3,
    ...projections2.length > 0 ? { projections: projections2 } : {},
    ...model.assembleGroup([
      ...layoutSignals,
      ...model.assembleSelectionTopLevelSignals([]),
      ...assembleParameterSignals(params2)
    ]),
    ...vgConfig ? { config: vgConfig } : {},
    ...usermeta ? { usermeta } : {}
  };
}
var version2 = pkg.version;

// node_modules/vega-schema-url-parser/dist/parser.modern.js
function e(e3) {
  const [n, r] = /schema\/([\w-]+)\/([\w\.\-]+)\.json$/g.exec(e3).slice(1, 3);
  return { library: n, version: r };
}

// node_modules/vega-themes/build/index.js
var build_exports2 = {};
__export(build_exports2, {
  carbong10: () => carbong10,
  carbong100: () => carbong100,
  carbong90: () => carbong90,
  carbonwhite: () => carbonwhite,
  dark: () => darkTheme,
  excel: () => excelTheme,
  fivethirtyeight: () => fiveThirtyEightTheme,
  ggplot2: () => ggplot2Theme,
  googlecharts: () => googlechartsTheme,
  latimes: () => latimesTheme,
  powerbi: () => powerbiTheme,
  quartz: () => quartzTheme,
  urbaninstitute: () => urbanInstituteTheme,
  version: () => version3,
  vox: () => voxTheme
});
var version$13 = "3.0.0";
var pkg2 = {
  version: version$13
};
var lightColor = "#fff";
var medColor = "#888";
var darkTheme = {
  background: "#333",
  view: {
    stroke: medColor
  },
  title: {
    color: lightColor,
    subtitleColor: lightColor
  },
  style: {
    "guide-label": {
      fill: lightColor
    },
    "guide-title": {
      fill: lightColor
    }
  },
  axis: {
    domainColor: lightColor,
    gridColor: medColor,
    tickColor: lightColor
  }
};
var markColor$7 = "#4572a7";
var excelTheme = {
  background: "#fff",
  arc: { fill: markColor$7 },
  area: { fill: markColor$7 },
  line: { stroke: markColor$7, strokeWidth: 2 },
  path: { stroke: markColor$7 },
  rect: { fill: markColor$7 },
  shape: { stroke: markColor$7 },
  symbol: { fill: markColor$7, strokeWidth: 1.5, size: 50 },
  axis: {
    bandPosition: 0.5,
    grid: true,
    gridColor: "#000000",
    gridOpacity: 1,
    gridWidth: 0.5,
    labelPadding: 10,
    tickSize: 5,
    tickWidth: 0.5
  },
  axisBand: {
    grid: false,
    tickExtra: true
  },
  legend: {
    labelBaseline: "middle",
    labelFontSize: 11,
    symbolSize: 50,
    symbolType: "square"
  },
  range: {
    category: [
      "#4572a7",
      "#aa4643",
      "#8aa453",
      "#71598e",
      "#4598ae",
      "#d98445",
      "#94aace",
      "#d09393",
      "#b9cc98",
      "#a99cbc"
    ]
  }
};
var markColor$6 = "#30a2da";
var axisColor$2 = "#cbcbcb";
var guideLabelColor = "#999";
var guideTitleColor = "#333";
var backgroundColor$2 = "#f0f0f0";
var blackTitle = "#333";
var fiveThirtyEightTheme = {
  arc: { fill: markColor$6 },
  area: { fill: markColor$6 },
  axis: {
    domainColor: axisColor$2,
    grid: true,
    gridColor: axisColor$2,
    gridWidth: 1,
    labelColor: guideLabelColor,
    labelFontSize: 10,
    titleColor: guideTitleColor,
    tickColor: axisColor$2,
    tickSize: 10,
    titleFontSize: 14,
    titlePadding: 10,
    labelPadding: 4
  },
  axisBand: {
    grid: false
  },
  background: backgroundColor$2,
  group: {
    fill: backgroundColor$2
  },
  legend: {
    labelColor: blackTitle,
    labelFontSize: 11,
    padding: 1,
    symbolSize: 30,
    symbolType: "square",
    titleColor: blackTitle,
    titleFontSize: 14,
    titlePadding: 10
  },
  line: {
    stroke: markColor$6,
    strokeWidth: 2
  },
  path: { stroke: markColor$6, strokeWidth: 0.5 },
  rect: { fill: markColor$6 },
  range: {
    category: [
      "#30a2da",
      "#fc4f30",
      "#e5ae38",
      "#6d904f",
      "#8b8b8b",
      "#b96db8",
      "#ff9e27",
      "#56cc60",
      "#52d2ca",
      "#52689e",
      "#545454",
      "#9fe4f8"
    ],
    diverging: ["#cc0020", "#e77866", "#f6e7e1", "#d6e8ed", "#91bfd9", "#1d78b5"],
    heatmap: ["#d6e8ed", "#cee0e5", "#91bfd9", "#549cc6", "#1d78b5"]
  },
  point: {
    filled: true,
    shape: "circle"
  },
  shape: { stroke: markColor$6 },
  bar: {
    binSpacing: 2,
    fill: markColor$6,
    stroke: null
  },
  title: {
    anchor: "start",
    fontSize: 24,
    fontWeight: 600,
    offset: 20
  }
};
var markColor$5 = "#000";
var ggplot2Theme = {
  group: {
    fill: "#e5e5e5"
  },
  arc: { fill: markColor$5 },
  area: { fill: markColor$5 },
  line: { stroke: markColor$5 },
  path: { stroke: markColor$5 },
  rect: { fill: markColor$5 },
  shape: { stroke: markColor$5 },
  symbol: { fill: markColor$5, size: 40 },
  axis: {
    domain: false,
    grid: true,
    gridColor: "#FFFFFF",
    gridOpacity: 1,
    labelColor: "#7F7F7F",
    labelPadding: 4,
    tickColor: "#7F7F7F",
    tickSize: 5.67,
    titleFontSize: 16,
    titleFontWeight: "normal"
  },
  legend: {
    labelBaseline: "middle",
    labelFontSize: 11,
    symbolSize: 40
  },
  range: {
    category: [
      "#000000",
      "#7F7F7F",
      "#1A1A1A",
      "#999999",
      "#333333",
      "#B0B0B0",
      "#4D4D4D",
      "#C9C9C9",
      "#666666",
      "#DCDCDC"
    ]
  }
};
var headlineFontSize = 22;
var headlineFontWeight = "normal";
var labelFont$1 = "Benton Gothic, sans-serif";
var labelFontSize = 11.5;
var labelFontWeight = "normal";
var markColor$4 = "#82c6df";
var titleFont = "Benton Gothic Bold, sans-serif";
var titleFontWeight = "normal";
var titleFontSize$1 = 13;
var colorSchemes$1 = {
  "category-6": ["#ec8431", "#829eb1", "#c89d29", "#3580b1", "#adc839", "#ab7fb4"],
  "fire-7": ["#fbf2c7", "#f9e39c", "#f8d36e", "#f4bb6a", "#e68a4f", "#d15a40", "#ab4232"],
  "fireandice-6": ["#e68a4f", "#f4bb6a", "#f9e39c", "#dadfe2", "#a6b7c6", "#849eae"]
};
var latimesTheme = {
  background: "#ffffff",
  title: {
    anchor: "start",
    color: "#000000",
    font: titleFont,
    fontSize: headlineFontSize,
    fontWeight: headlineFontWeight
  },
  arc: { fill: markColor$4 },
  area: { fill: markColor$4 },
  line: { stroke: markColor$4, strokeWidth: 2 },
  path: { stroke: markColor$4 },
  rect: { fill: markColor$4 },
  shape: { stroke: markColor$4 },
  symbol: { fill: markColor$4, size: 30 },
  axis: {
    labelFont: labelFont$1,
    labelFontSize,
    labelFontWeight,
    titleFont,
    titleFontSize: titleFontSize$1,
    titleFontWeight
  },
  axisX: {
    labelAngle: 0,
    labelPadding: 4,
    tickSize: 3
  },
  axisY: {
    labelBaseline: "middle",
    maxExtent: 45,
    minExtent: 45,
    tickSize: 2,
    titleAlign: "left",
    titleAngle: 0,
    titleX: -45,
    titleY: -11
  },
  legend: {
    labelFont: labelFont$1,
    labelFontSize,
    symbolType: "square",
    titleFont,
    titleFontSize: titleFontSize$1,
    titleFontWeight
  },
  range: {
    category: colorSchemes$1["category-6"],
    diverging: colorSchemes$1["fireandice-6"],
    heatmap: colorSchemes$1["fire-7"],
    ordinal: colorSchemes$1["fire-7"],
    ramp: colorSchemes$1["fire-7"]
  }
};
var markColor$3 = "#ab5787";
var axisColor$1 = "#979797";
var quartzTheme = {
  background: "#f9f9f9",
  arc: { fill: markColor$3 },
  area: { fill: markColor$3 },
  line: { stroke: markColor$3 },
  path: { stroke: markColor$3 },
  rect: { fill: markColor$3 },
  shape: { stroke: markColor$3 },
  symbol: { fill: markColor$3, size: 30 },
  axis: {
    domainColor: axisColor$1,
    domainWidth: 0.5,
    gridWidth: 0.2,
    labelColor: axisColor$1,
    tickColor: axisColor$1,
    tickWidth: 0.2,
    titleColor: axisColor$1
  },
  axisBand: {
    grid: false
  },
  axisX: {
    grid: true,
    tickSize: 10
  },
  axisY: {
    domain: false,
    grid: true,
    tickSize: 0
  },
  legend: {
    labelFontSize: 11,
    padding: 1,
    symbolSize: 30,
    symbolType: "square"
  },
  range: {
    category: [
      "#ab5787",
      "#51b2e5",
      "#703c5c",
      "#168dd9",
      "#d190b6",
      "#00609f",
      "#d365ba",
      "#154866",
      "#666666",
      "#c4c4c4"
    ]
  }
};
var markColor$2 = "#3e5c69";
var voxTheme = {
  background: "#fff",
  arc: { fill: markColor$2 },
  area: { fill: markColor$2 },
  line: { stroke: markColor$2 },
  path: { stroke: markColor$2 },
  rect: { fill: markColor$2 },
  shape: { stroke: markColor$2 },
  symbol: { fill: markColor$2 },
  axis: {
    domainWidth: 0.5,
    grid: true,
    labelPadding: 2,
    tickSize: 5,
    tickWidth: 0.5,
    titleFontWeight: "normal"
  },
  axisBand: {
    grid: false
  },
  axisX: {
    gridWidth: 0.2
  },
  axisY: {
    gridDash: [3],
    gridWidth: 0.4
  },
  legend: {
    labelFontSize: 11,
    padding: 1,
    symbolType: "square"
  },
  range: {
    category: ["#3e5c69", "#6793a6", "#182429", "#0570b0", "#3690c0", "#74a9cf", "#a6bddb", "#e2ddf2"]
  }
};
var markColor$1 = "#1696d2";
var axisColor = "#000000";
var backgroundColor$1 = "#FFFFFF";
var font6 = "Lato";
var labelFont = "Lato";
var sourceFont = "Lato";
var gridColor$1 = "#DEDDDD";
var titleFontSize = 18;
var colorSchemes = {
  "shades-blue": ["#CFE8F3", "#A2D4EC", "#73BFE2", "#46ABDB", "#1696D2", "#12719E", "#0A4C6A", "#062635"],
  "six-groups-cat-1": ["#1696d2", "#ec008b", "#fdbf11", "#000000", "#d2d2d2", "#55b748"],
  "six-groups-seq": ["#cfe8f3", "#a2d4ec", "#73bfe2", "#46abdb", "#1696d2", "#12719e"],
  "diverging-colors": ["#ca5800", "#fdbf11", "#fdd870", "#fff2cf", "#cfe8f3", "#73bfe2", "#1696d2", "#0a4c6a"]
};
var urbanInstituteTheme = {
  background: backgroundColor$1,
  title: {
    anchor: "start",
    fontSize: titleFontSize,
    font: font6
  },
  axisX: {
    domain: true,
    domainColor: axisColor,
    domainWidth: 1,
    grid: false,
    labelFontSize: 12,
    labelFont,
    labelAngle: 0,
    tickColor: axisColor,
    tickSize: 5,
    titleFontSize: 12,
    titlePadding: 10,
    titleFont: font6
  },
  axisY: {
    domain: false,
    domainWidth: 1,
    grid: true,
    gridColor: gridColor$1,
    gridWidth: 1,
    labelFontSize: 12,
    labelFont,
    labelPadding: 8,
    ticks: false,
    titleFontSize: 12,
    titlePadding: 10,
    titleFont: font6,
    titleAngle: 0,
    titleY: -10,
    titleX: 18
  },
  legend: {
    labelFontSize: 12,
    labelFont,
    symbolSize: 100,
    titleFontSize: 12,
    titlePadding: 10,
    titleFont: font6,
    orient: "right",
    offset: 10
  },
  view: {
    stroke: "transparent"
  },
  range: {
    category: colorSchemes["six-groups-cat-1"],
    diverging: colorSchemes["diverging-colors"],
    heatmap: colorSchemes["diverging-colors"],
    ordinal: colorSchemes["six-groups-seq"],
    ramp: colorSchemes["shades-blue"]
  },
  area: {
    fill: markColor$1
  },
  rect: {
    fill: markColor$1
  },
  line: {
    color: markColor$1,
    stroke: markColor$1,
    strokeWidth: 5
  },
  trail: {
    color: markColor$1,
    stroke: markColor$1,
    strokeWidth: 0,
    size: 1
  },
  path: {
    stroke: markColor$1,
    strokeWidth: 0.5
  },
  point: {
    filled: true
  },
  text: {
    font: sourceFont,
    color: markColor$1,
    fontSize: 11,
    align: "center",
    fontWeight: 400,
    size: 11
  },
  style: {
    bar: {
      fill: markColor$1,
      stroke: null
    }
  },
  arc: { fill: markColor$1 },
  shape: { stroke: markColor$1 },
  symbol: { fill: markColor$1, size: 30 }
};
var markColor = "#3366CC";
var gridColor = "#ccc";
var defaultFont$1 = "Arial, sans-serif";
var googlechartsTheme = {
  arc: { fill: markColor },
  area: { fill: markColor },
  path: { stroke: markColor },
  rect: { fill: markColor },
  shape: { stroke: markColor },
  symbol: { stroke: markColor },
  circle: { fill: markColor },
  background: "#fff",
  padding: {
    top: 10,
    right: 10,
    bottom: 10,
    left: 10
  },
  style: {
    "guide-label": {
      font: defaultFont$1,
      fontSize: 12
    },
    "guide-title": {
      font: defaultFont$1,
      fontSize: 12
    },
    "group-title": {
      font: defaultFont$1,
      fontSize: 12
    }
  },
  title: {
    font: defaultFont$1,
    fontSize: 14,
    fontWeight: "bold",
    dy: -3,
    anchor: "start"
  },
  axis: {
    gridColor,
    tickColor: gridColor,
    domain: false,
    grid: true
  },
  range: {
    category: [
      "#4285F4",
      "#DB4437",
      "#F4B400",
      "#0F9D58",
      "#AB47BC",
      "#00ACC1",
      "#FF7043",
      "#9E9D24",
      "#5C6BC0",
      "#F06292",
      "#00796B",
      "#C2185B"
    ],
    heatmap: ["#c6dafc", "#5e97f6", "#2a56c6"]
  }
};
var ptToPx = (value7) => value7 * (1 / 3 + 1);
var fontSmallPx = ptToPx(9);
var legendFontPx = ptToPx(10);
var fontLargePx = ptToPx(12);
var fontStandard = "Segoe UI";
var fontTitle = "wf_standard-font, helvetica, arial, sans-serif";
var firstLevelElementColor = "#252423";
var secondLevelElementColor = "#605E5C";
var backgroundColor = "transparent";
var backgroundSecondaryColor = "#C8C6C4";
var paletteColor1 = "#118DFF";
var paletteColor2 = "#12239E";
var paletteColor3 = "#E66C37";
var paletteColor4 = "#6B007B";
var paletteColor5 = "#E044A7";
var paletteColor6 = "#744EC2";
var paletteColor7 = "#D9B300";
var paletteColor8 = "#D64550";
var divergentColorMax = paletteColor1;
var divergentColorMin = "#DEEFFF";
var divergentPalette = [divergentColorMin, divergentColorMax];
var ordinalPalette = [
  divergentColorMin,
  "#c7e4ff",
  "#b0d9ff",
  "#9aceff",
  "#83c3ff",
  "#6cb9ff",
  "#55aeff",
  "#3fa3ff",
  "#2898ff",
  divergentColorMax
];
var powerbiTheme = {
  view: { stroke: backgroundColor },
  background: backgroundColor,
  font: fontStandard,
  header: {
    titleFont: fontTitle,
    titleFontSize: fontLargePx,
    titleColor: firstLevelElementColor,
    labelFont: fontStandard,
    labelFontSize: legendFontPx,
    labelColor: secondLevelElementColor
  },
  axis: {
    ticks: false,
    grid: false,
    domain: false,
    labelColor: secondLevelElementColor,
    labelFontSize: fontSmallPx,
    titleFont: fontTitle,
    titleColor: firstLevelElementColor,
    titleFontSize: fontLargePx,
    titleFontWeight: "normal"
  },
  axisQuantitative: {
    tickCount: 3,
    grid: true,
    gridColor: backgroundSecondaryColor,
    gridDash: [1, 5],
    labelFlush: false
  },
  axisBand: { tickExtra: true },
  axisX: { labelPadding: 5 },
  axisY: { labelPadding: 10 },
  bar: { fill: paletteColor1 },
  line: {
    stroke: paletteColor1,
    strokeWidth: 3,
    strokeCap: "round",
    strokeJoin: "round"
  },
  text: { font: fontStandard, fontSize: fontSmallPx, fill: secondLevelElementColor },
  arc: { fill: paletteColor1 },
  area: { fill: paletteColor1, line: true, opacity: 0.6 },
  path: { stroke: paletteColor1 },
  rect: { fill: paletteColor1 },
  point: { fill: paletteColor1, filled: true, size: 75 },
  shape: { stroke: paletteColor1 },
  symbol: { fill: paletteColor1, strokeWidth: 1.5, size: 50 },
  legend: {
    titleFont: fontStandard,
    titleFontWeight: "bold",
    titleColor: secondLevelElementColor,
    labelFont: fontStandard,
    labelFontSize: legendFontPx,
    labelColor: secondLevelElementColor,
    symbolType: "circle",
    symbolSize: 75
  },
  range: {
    category: [
      paletteColor1,
      paletteColor2,
      paletteColor3,
      paletteColor4,
      paletteColor5,
      paletteColor6,
      paletteColor7,
      paletteColor8
    ],
    diverging: divergentPalette,
    heatmap: divergentPalette,
    ordinal: ordinalPalette
  }
};
var defaultFont = 'IBM Plex Sans,system-ui,-apple-system,BlinkMacSystemFont,".sfnstext-regular",sans-serif';
var condensedFont = 'IBM Plex Sans Condensed, system-ui, -apple-system, BlinkMacSystemFont, ".SFNSText-Regular", sans-serif';
var fontWeight = 400;
var TOKENS = {
  textPrimary: { g90: "#f4f4f4", g100: "#f4f4f4", white: "#161616", g10: "#161616" },
  textSecondary: { g90: "#c6c6c6", g100: "#c6c6c6", white: "#525252", g10: "#525252" },
  // layer
  layerAccent01: {
    white: "#e0e0e0",
    g10: "#e0e0e0",
    g90: "#525252",
    g100: "#393939"
  },
  // grid
  gridBg: {
    white: "#ffffff",
    g10: "#ffffff",
    g90: "#161616",
    g100: "#161616"
  }
};
var darkCategories = [
  "#8a3ffc",
  "#33b1ff",
  "#007d79",
  "#ff7eb6",
  "#fa4d56",
  "#fff1f1",
  "#6fdc8c",
  "#4589ff",
  "#d12771",
  "#d2a106",
  "#08bdba",
  "#bae6ff",
  "#ba4e00",
  "#d4bbff"
];
var lightCategories = [
  "#6929c4",
  "#1192e8",
  "#005d5d",
  "#9f1853",
  "#fa4d56",
  "#570408",
  "#198038",
  "#002d9c",
  "#ee538b",
  "#b28600",
  "#009d9a",
  "#012749",
  "#8a3800",
  "#a56eff"
];
function genCarbonConfig({ theme, background: background7 }) {
  const type7 = ["white", "g10"].includes(theme) ? "light" : "dark";
  const viewbg = TOKENS.gridBg[theme];
  const titleColor = TOKENS.textPrimary[theme];
  const textColor = TOKENS.textSecondary[theme];
  const category = type7 === "dark" ? darkCategories : lightCategories;
  const markColor2 = type7 === "dark" ? "#d4bbff" : "#6929c4";
  return {
    background: background7,
    arc: { fill: markColor2 },
    area: { fill: markColor2 },
    path: { stroke: markColor2 },
    rect: { fill: markColor2 },
    shape: { stroke: markColor2 },
    symbol: { stroke: markColor2 },
    circle: { fill: markColor2 },
    view: {
      fill: viewbg,
      stroke: viewbg
    },
    group: {
      fill: viewbg
    },
    title: {
      color: titleColor,
      anchor: "start",
      dy: -15,
      fontSize: 16,
      font: defaultFont,
      fontWeight: 600
    },
    axis: {
      // Axis labels
      labelColor: textColor,
      labelFontSize: 12,
      labelFont: condensedFont,
      labelFontWeight: fontWeight,
      // Axis titles
      titleColor,
      titleFontWeight: 600,
      titleFontSize: 12,
      // MISC
      grid: true,
      gridColor: TOKENS.layerAccent01[theme],
      labelAngle: 0
    },
    axisX: {
      titlePadding: 10
    },
    axisY: {
      titlePadding: 2.5
    },
    style: {
      "guide-label": {
        font: defaultFont,
        fill: textColor,
        fontWeight
      },
      "guide-title": {
        font: defaultFont,
        fill: textColor,
        fontWeight
      }
    },
    range: {
      category,
      diverging: [
        "#750e13",
        "#a2191f",
        "#da1e28",
        "#fa4d56",
        "#ff8389",
        "#ffb3b8",
        "#ffd7d9",
        "#fff1f1",
        "#e5f6ff",
        "#bae6ff",
        "#82cfff",
        "#33b1ff",
        "#1192e8",
        "#0072c3",
        "#00539a",
        "#003a6d"
      ],
      heatmap: [
        "#f6f2ff",
        "#e8daff",
        "#d4bbff",
        "#be95ff",
        "#a56eff",
        "#8a3ffc",
        "#6929c4",
        "#491d8b",
        "#31135e",
        "#1c0f30"
      ]
    }
  };
}
var carbonwhite = genCarbonConfig({
  theme: "white",
  background: "#ffffff"
});
var carbong10 = genCarbonConfig({
  theme: "g10",
  background: "#f4f4f4"
});
var carbong90 = genCarbonConfig({
  theme: "g90",
  background: "#262626"
});
var carbong100 = genCarbonConfig({
  theme: "g100",
  background: "#161616"
});
var version3 = pkg2.version;

// node_modules/vega-tooltip/node_modules/vega-util/build/vega-util.js
function accessor23(fn, fields, name) {
  fn.fields = fields || [];
  fn.fname = name;
  return fn;
}
function getter24(path7) {
  return path7.length === 1 ? get123(path7[0]) : getN23(path7);
}
var get123 = (field25) => function(obj) {
  return obj[field25];
};
var getN23 = (path7) => {
  const len = path7.length;
  return function(obj) {
    for (let i = 0; i < len; ++i) {
      obj = obj[path7[i]];
    }
    return obj;
  };
};
function error24(message) {
  throw Error(message);
}
function splitAccessPath23(p) {
  const path7 = [], n = p.length;
  let q = null, b6 = 0, s2 = "", i, j, c5;
  p = p + "";
  function push() {
    path7.push(s2 + p.substring(i, j));
    s2 = "";
    i = j + 1;
  }
  for (i = j = 0; j < n; ++j) {
    c5 = p[j];
    if (c5 === "\\") {
      s2 += p.substring(i, j++);
      i = j;
    } else if (c5 === q) {
      push();
      q = null;
      b6 = -1;
    } else if (q) {
      continue;
    } else if (i === b6 && c5 === '"') {
      i = j + 1;
      q = c5;
    } else if (i === b6 && c5 === "'") {
      i = j + 1;
      q = c5;
    } else if (c5 === "." && !b6) {
      if (j > i) {
        push();
      } else {
        i = j + 1;
      }
    } else if (c5 === "[") {
      if (j > i)
        push();
      b6 = i = j + 1;
    } else if (c5 === "]") {
      if (!b6)
        error24("Access path missing open bracket: " + p);
      if (b6 > 0)
        push();
      b6 = 0;
      i = j + 1;
    }
  }
  if (b6)
    error24("Access path missing closing bracket: " + p);
  if (q)
    error24("Access path missing closing quote: " + p);
  if (j > i) {
    j++;
    push();
  }
  return path7;
}
function field24(field25, name, opt) {
  const path7 = splitAccessPath23(field25);
  field25 = path7.length === 1 ? path7[0] : field25;
  return accessor23((opt && opt.get || getter24)(path7), [field25], name || field25);
}
var id23 = field24("id");
var identity27 = accessor23((_) => _, [], "identity");
var zero27 = accessor23(() => 0, [], "zero");
var one25 = accessor23(() => 1, [], "one");
var truthy23 = accessor23(() => true, [], "true");
var falsy23 = accessor23(() => false, [], "false");
var DisallowedObjectProperties23 = /* @__PURE__ */ new Set([...Object.getOwnPropertyNames(Object.prototype).filter((name) => typeof Object.prototype[name] === "function"), "__proto__"]);
var isArray23 = Array.isArray;
function isObject13(_) {
  return _ === Object(_);
}
function isString15(_) {
  return typeof _ === "string";
}

// node_modules/vega-tooltip/build/index.js
var version$14 = "1.0.0";
var pkg3 = {
  version: version$14
};
function formatValue8(value7, valueToHtml, maxDepth2, baseURL) {
  if (isArray23(value7)) {
    return `[${value7.map((v2) => valueToHtml(isString15(v2) ? v2 : stringify3(v2, maxDepth2))).join(", ")}]`;
  }
  if (isObject13(value7)) {
    let content6 = "";
    const { title: title2, image: image7, ...rest } = value7;
    if (title2) {
      content6 += `<h2>${valueToHtml(title2)}</h2>`;
    }
    if (image7) {
      content6 += `<img src="${new URL(valueToHtml(image7), baseURL || location.href).href}">`;
    }
    const keys5 = Object.keys(rest);
    if (keys5.length > 0) {
      content6 += "<table>";
      for (const key4 of keys5) {
        let val = rest[key4];
        if (val === void 0) {
          continue;
        }
        if (isObject13(val)) {
          val = stringify3(val, maxDepth2);
        }
        content6 += `<tr><td class="key">${valueToHtml(key4)}</td><td class="value">${valueToHtml(val)}</td></tr>`;
      }
      content6 += `</table>`;
    }
    return content6 || "{}";
  }
  return valueToHtml(value7);
}
function replacer(maxDepth2) {
  const stack2 = [];
  return function(key4, value7) {
    if (typeof value7 !== "object" || value7 === null) {
      return value7;
    }
    const pos = stack2.indexOf(this) + 1;
    stack2.length = pos;
    if (stack2.length > maxDepth2) {
      return "[Object]";
    }
    if (stack2.indexOf(value7) >= 0) {
      return "[Circular]";
    }
    stack2.push(value7);
    return value7;
  };
}
function stringify3(obj, maxDepth2) {
  return JSON.stringify(obj, replacer(maxDepth2));
}
var defaultStyle = `#vg-tooltip-element {
  visibility: hidden;
  padding: 8px;
  position: fixed;
  z-index: 1000;
  font-family: sans-serif;
  font-size: 11px;
  border-radius: 3px;
  box-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
  /* The default theme is the light theme. */
  background-color: rgba(255, 255, 255, 0.95);
  border: 1px solid #d9d9d9;
  color: black;
}
#vg-tooltip-element.visible {
  visibility: visible;
}
#vg-tooltip-element h2 {
  margin-top: 0;
  margin-bottom: 10px;
  font-size: 13px;
}
#vg-tooltip-element table {
  border-spacing: 0;
}
#vg-tooltip-element table tr {
  border: none;
}
#vg-tooltip-element table tr td {
  overflow: hidden;
  text-overflow: ellipsis;
  padding-top: 2px;
  padding-bottom: 2px;
}
#vg-tooltip-element table tr td.key {
  color: #808080;
  max-width: 150px;
  text-align: right;
  padding-right: 4px;
}
#vg-tooltip-element table tr td.value {
  display: block;
  max-width: 300px;
  max-height: 7em;
  text-align: left;
}
#vg-tooltip-element.dark-theme {
  background-color: rgba(32, 32, 32, 0.9);
  border: 1px solid #f5f5f5;
  color: white;
}
#vg-tooltip-element.dark-theme td.key {
  color: #bfbfbf;
}
`;
var EL_ID = "vg-tooltip-element";
var DEFAULT_OPTIONS = {
  offsetX: 10,
  offsetY: 10,
  id: EL_ID,
  styleId: "vega-tooltip-style",
  theme: "light",
  disableDefaultStyle: false,
  sanitize: escapeHTML,
  maxDepth: 2,
  formatTooltip: formatValue8,
  baseURL: "",
  anchor: "cursor",
  position: ["top", "bottom", "left", "right", "top-left", "top-right", "bottom-left", "bottom-right"]
};
function escapeHTML(value7) {
  return String(value7).replace(/&/g, "&amp;").replace(/</g, "&lt;");
}
function createDefaultStyle(id24) {
  if (!/^[A-Za-z]+[-:.\w]*$/.test(id24)) {
    throw new Error("Invalid HTML ID");
  }
  return defaultStyle.toString().replaceAll(EL_ID, id24);
}
function calculatePositionRelativeToCursor(event2, tooltipBox, { offsetX, offsetY }) {
  const positions = getPositions({ x1: event2.clientX, x2: event2.clientX, y1: event2.clientY, y2: event2.clientY }, tooltipBox, offsetX, offsetY);
  const postionArr = ["bottom-right", "bottom-left", "top-right", "top-left"];
  for (const p of postionArr) {
    if (tooltipIsInViewport(positions[p], tooltipBox)) {
      return positions[p];
    }
  }
  return positions["top-left"];
}
function calculatePositionRelativeToMark(handler, event2, item, tooltipBox, options) {
  const { position: position2, offsetX, offsetY } = options;
  const containerBox = handler._el.getBoundingClientRect();
  const origin = handler._origin;
  const markBounds = getMarkBounds(containerBox, origin, item);
  const positions = getPositions(markBounds, tooltipBox, offsetX, offsetY);
  const positionArr = Array.isArray(position2) ? position2 : [position2];
  for (const p of positionArr) {
    if (tooltipIsInViewport(positions[p], tooltipBox) && !mouseIsOnTooltip(event2, positions[p], tooltipBox)) {
      return positions[p];
    }
  }
  return calculatePositionRelativeToCursor(event2, tooltipBox, options);
}
function getMarkBounds(containerBox, origin, item) {
  const markBounds = item.isVoronoi ? item.datum.bounds : item.bounds;
  let left = containerBox.left + origin[0] + markBounds.x1;
  let top = containerBox.top + origin[1] + markBounds.y1;
  let parentItem = item;
  while (parentItem.mark.group) {
    parentItem = parentItem.mark.group;
    left += parentItem.x ?? 0;
    top += parentItem.y ?? 0;
  }
  const markWidth = markBounds.x2 - markBounds.x1;
  const markHeight = markBounds.y2 - markBounds.y1;
  return {
    x1: left,
    x2: left + markWidth,
    y1: top,
    y2: top + markHeight
  };
}
function getPositions(markBounds, tooltipBox, offsetX, offsetY) {
  const xc = (markBounds.x1 + markBounds.x2) / 2;
  const yc = (markBounds.y1 + markBounds.y2) / 2;
  const left = markBounds.x1 - tooltipBox.width - offsetX;
  const center = xc - tooltipBox.width / 2;
  const right = markBounds.x2 + offsetX;
  const top = markBounds.y1 - tooltipBox.height - offsetY;
  const middle = yc - tooltipBox.height / 2;
  const bottom = markBounds.y2 + offsetY;
  const positions = {
    top: { x: center, y: top },
    bottom: { x: center, y: bottom },
    left: { x: left, y: middle },
    right: { x: right, y: middle },
    "top-left": { x: left, y: top },
    "top-right": { x: right, y: top },
    "bottom-left": { x: left, y: bottom },
    "bottom-right": { x: right, y: bottom }
  };
  return positions;
}
function tooltipIsInViewport(position2, tooltipBox) {
  return position2.x >= 0 && position2.y >= 0 && position2.x + tooltipBox.width <= window.innerWidth && position2.y + tooltipBox.height <= window.innerHeight;
}
function mouseIsOnTooltip(event2, position2, tooltipBox) {
  return event2.clientX >= position2.x && event2.clientX <= position2.x + tooltipBox.width && event2.clientY >= position2.y && event2.clientY <= position2.y + tooltipBox.height;
}
var Handler6 = class {
  /**
   * Create the tooltip handler and initialize the element and style.
   *
   * @param options Tooltip Options
   */
  constructor(options) {
    /**
     * The handler function. We bind this to this function in the constructor.
     */
    __publicField(this, "call");
    /**
     * Complete tooltip options.
     */
    __publicField(this, "options");
    /**
     * The tooltip html element.
     */
    __publicField(this, "el");
    this.options = { ...DEFAULT_OPTIONS, ...options };
    const elementId = this.options.id;
    this.el = null;
    this.call = this.tooltipHandler.bind(this);
    if (!this.options.disableDefaultStyle && !document.getElementById(this.options.styleId)) {
      const style6 = document.createElement("style");
      style6.setAttribute("id", this.options.styleId);
      style6.innerHTML = createDefaultStyle(elementId);
      const head = document.head;
      if (head.childNodes.length > 0) {
        head.insertBefore(style6, head.childNodes[0]);
      } else {
        head.appendChild(style6);
      }
    }
  }
  /**
   * The tooltip handler function.
   */
  tooltipHandler(handler, event2, item, value7) {
    this.el = document.getElementById(this.options.id);
    if (!this.el) {
      this.el = document.createElement("div");
      this.el.setAttribute("id", this.options.id);
      this.el.classList.add("vg-tooltip");
      const tooltipContainer = document.fullscreenElement ?? document.body;
      tooltipContainer.appendChild(this.el);
    }
    if (value7 == null || value7 === "") {
      this.el.classList.remove("visible", `${this.options.theme}-theme`);
      return;
    }
    this.el.innerHTML = this.options.formatTooltip(value7, this.options.sanitize, this.options.maxDepth, this.options.baseURL);
    this.el.classList.add("visible", `${this.options.theme}-theme`);
    const { x: x9, y: y9 } = this.options.anchor === "mark" ? calculatePositionRelativeToMark(handler, event2, item, this.el.getBoundingClientRect(), this.options) : calculatePositionRelativeToCursor(event2, this.el.getBoundingClientRect(), this.options);
    this.el.style.top = `${y9}px`;
    this.el.style.left = `${x9}px`;
  }
};
var version4 = pkg3.version;

// node_modules/vega-embed/build/embed.js
var __extends = function() {
  var extendStatics = function(d, b6) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b7) {
      d2.__proto__ = b7;
    } || function(d2, b7) {
      for (var p in b7)
        if (b7.hasOwnProperty(p))
          d2[p] = b7[p];
    };
    return extendStatics(d, b6);
  };
  return function(d, b6) {
    extendStatics(d, b6);
    function __() {
      this.constructor = d;
    }
    d.prototype = b6 === null ? Object.create(b6) : (__.prototype = b6.prototype, new __());
  };
}();
var _hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwnProperty(obj, key4) {
  return _hasOwnProperty.call(obj, key4);
}
function _objectKeys(obj) {
  if (Array.isArray(obj)) {
    var keys_1 = new Array(obj.length);
    for (var k3 = 0; k3 < keys_1.length; k3++) {
      keys_1[k3] = "" + k3;
    }
    return keys_1;
  }
  if (Object.keys) {
    return Object.keys(obj);
  }
  var keys5 = [];
  for (var i in obj) {
    if (hasOwnProperty(obj, i)) {
      keys5.push(i);
    }
  }
  return keys5;
}
function _deepClone(obj) {
  switch (typeof obj) {
    case "object":
      return JSON.parse(JSON.stringify(obj));
    case "undefined":
      return null;
    default:
      return obj;
  }
}
function isInteger3(str) {
  var i = 0;
  var len = str.length;
  var charCode;
  while (i < len) {
    charCode = str.charCodeAt(i);
    if (charCode >= 48 && charCode <= 57) {
      i++;
      continue;
    }
    return false;
  }
  return true;
}
function escapePathComponent(path7) {
  if (path7.indexOf("/") === -1 && path7.indexOf("~") === -1)
    return path7;
  return path7.replace(/~/g, "~0").replace(/\//g, "~1");
}
function unescapePathComponent(path7) {
  return path7.replace(/~1/g, "/").replace(/~0/g, "~");
}
function hasUndefined(obj) {
  if (obj === void 0) {
    return true;
  }
  if (obj) {
    if (Array.isArray(obj)) {
      for (var i_1 = 0, len = obj.length; i_1 < len; i_1++) {
        if (hasUndefined(obj[i_1])) {
          return true;
        }
      }
    } else if (typeof obj === "object") {
      var objKeys = _objectKeys(obj);
      var objKeysLength = objKeys.length;
      for (var i = 0; i < objKeysLength; i++) {
        if (hasUndefined(obj[objKeys[i]])) {
          return true;
        }
      }
    }
  }
  return false;
}
function patchErrorMessageFormatter(message, args) {
  var messageParts = [message];
  for (var key4 in args) {
    var value7 = typeof args[key4] === "object" ? JSON.stringify(args[key4], null, 2) : args[key4];
    if (typeof value7 !== "undefined") {
      messageParts.push(key4 + ": " + value7);
    }
  }
  return messageParts.join("\n");
}
var PatchError = (
  /** @class */
  function(_super) {
    __extends(PatchError2, _super);
    function PatchError2(message, name, index4, operation, tree) {
      var _newTarget = this.constructor;
      var _this = _super.call(this, patchErrorMessageFormatter(message, { name, index: index4, operation, tree })) || this;
      _this.name = name;
      _this.index = index4;
      _this.operation = operation;
      _this.tree = tree;
      Object.setPrototypeOf(_this, _newTarget.prototype);
      _this.message = patchErrorMessageFormatter(message, { name, index: index4, operation, tree });
      return _this;
    }
    return PatchError2;
  }(Error)
);
var JsonPatchError = PatchError;
var deepClone = _deepClone;
var objOps = {
  add: function(obj, key4, document2) {
    obj[key4] = this.value;
    return { newDocument: document2 };
  },
  remove: function(obj, key4, document2) {
    var removed = obj[key4];
    delete obj[key4];
    return { newDocument: document2, removed };
  },
  replace: function(obj, key4, document2) {
    var removed = obj[key4];
    obj[key4] = this.value;
    return { newDocument: document2, removed };
  },
  move: function(obj, key4, document2) {
    var removed = getValueByPointer(document2, this.path);
    if (removed) {
      removed = _deepClone(removed);
    }
    var originalValue = applyOperation(document2, { op: "remove", path: this.from }).removed;
    applyOperation(document2, { op: "add", path: this.path, value: originalValue });
    return { newDocument: document2, removed };
  },
  copy: function(obj, key4, document2) {
    var valueToCopy = getValueByPointer(document2, this.from);
    applyOperation(document2, { op: "add", path: this.path, value: _deepClone(valueToCopy) });
    return { newDocument: document2 };
  },
  test: function(obj, key4, document2) {
    return { newDocument: document2, test: _areEquals(obj[key4], this.value) };
  },
  _get: function(obj, key4, document2) {
    this.value = obj[key4];
    return { newDocument: document2 };
  }
};
var arrOps = {
  add: function(arr, i, document2) {
    if (isInteger3(i)) {
      arr.splice(i, 0, this.value);
    } else {
      arr[i] = this.value;
    }
    return { newDocument: document2, index: i };
  },
  remove: function(arr, i, document2) {
    var removedList = arr.splice(i, 1);
    return { newDocument: document2, removed: removedList[0] };
  },
  replace: function(arr, i, document2) {
    var removed = arr[i];
    arr[i] = this.value;
    return { newDocument: document2, removed };
  },
  move: objOps.move,
  copy: objOps.copy,
  test: objOps.test,
  _get: objOps._get
};
function getValueByPointer(document2, pointer) {
  if (pointer == "") {
    return document2;
  }
  var getOriginalDestination = { op: "_get", path: pointer };
  applyOperation(document2, getOriginalDestination);
  return getOriginalDestination.value;
}
function applyOperation(document2, operation, validateOperation, mutateDocument, banPrototypeModifications, index4) {
  if (validateOperation === void 0) {
    validateOperation = false;
  }
  if (mutateDocument === void 0) {
    mutateDocument = true;
  }
  if (banPrototypeModifications === void 0) {
    banPrototypeModifications = true;
  }
  if (index4 === void 0) {
    index4 = 0;
  }
  if (validateOperation) {
    if (typeof validateOperation == "function") {
      validateOperation(operation, 0, document2, operation.path);
    } else {
      validator(operation, 0);
    }
  }
  if (operation.path === "") {
    var returnValue = { newDocument: document2 };
    if (operation.op === "add") {
      returnValue.newDocument = operation.value;
      return returnValue;
    } else if (operation.op === "replace") {
      returnValue.newDocument = operation.value;
      returnValue.removed = document2;
      return returnValue;
    } else if (operation.op === "move" || operation.op === "copy") {
      returnValue.newDocument = getValueByPointer(document2, operation.from);
      if (operation.op === "move") {
        returnValue.removed = document2;
      }
      return returnValue;
    } else if (operation.op === "test") {
      returnValue.test = _areEquals(document2, operation.value);
      if (returnValue.test === false) {
        throw new JsonPatchError("Test operation failed", "TEST_OPERATION_FAILED", index4, operation, document2);
      }
      returnValue.newDocument = document2;
      return returnValue;
    } else if (operation.op === "remove") {
      returnValue.removed = document2;
      returnValue.newDocument = null;
      return returnValue;
    } else if (operation.op === "_get") {
      operation.value = document2;
      return returnValue;
    } else {
      if (validateOperation) {
        throw new JsonPatchError("Operation `op` property is not one of operations defined in RFC-6902", "OPERATION_OP_INVALID", index4, operation, document2);
      } else {
        return returnValue;
      }
    }
  } else {
    if (!mutateDocument) {
      document2 = _deepClone(document2);
    }
    var path7 = operation.path || "";
    var keys5 = path7.split("/");
    var obj = document2;
    var t = 1;
    var len = keys5.length;
    var existingPathFragment = void 0;
    var key4 = void 0;
    var validateFunction = void 0;
    if (typeof validateOperation == "function") {
      validateFunction = validateOperation;
    } else {
      validateFunction = validator;
    }
    while (true) {
      key4 = keys5[t];
      if (key4 && key4.indexOf("~") != -1) {
        key4 = unescapePathComponent(key4);
      }
      if (banPrototypeModifications && (key4 == "__proto__" || key4 == "prototype" && t > 0 && keys5[t - 1] == "constructor")) {
        throw new TypeError("JSON-Patch: modifying `__proto__` or `constructor/prototype` prop is banned for security reasons, if this was on purpose, please set `banPrototypeModifications` flag false and pass it to this function. More info in fast-json-patch README");
      }
      if (validateOperation) {
        if (existingPathFragment === void 0) {
          if (obj[key4] === void 0) {
            existingPathFragment = keys5.slice(0, t).join("/");
          } else if (t == len - 1) {
            existingPathFragment = operation.path;
          }
          if (existingPathFragment !== void 0) {
            validateFunction(operation, 0, document2, existingPathFragment);
          }
        }
      }
      t++;
      if (Array.isArray(obj)) {
        if (key4 === "-") {
          key4 = obj.length;
        } else {
          if (validateOperation && !isInteger3(key4)) {
            throw new JsonPatchError("Expected an unsigned base-10 integer value, making the new referenced value the array element with the zero-based index", "OPERATION_PATH_ILLEGAL_ARRAY_INDEX", index4, operation, document2);
          } else if (isInteger3(key4)) {
            key4 = ~~key4;
          }
        }
        if (t >= len) {
          if (validateOperation && operation.op === "add" && key4 > obj.length) {
            throw new JsonPatchError("The specified index MUST NOT be greater than the number of elements in the array", "OPERATION_VALUE_OUT_OF_BOUNDS", index4, operation, document2);
          }
          var returnValue = arrOps[operation.op].call(operation, obj, key4, document2);
          if (returnValue.test === false) {
            throw new JsonPatchError("Test operation failed", "TEST_OPERATION_FAILED", index4, operation, document2);
          }
          return returnValue;
        }
      } else {
        if (t >= len) {
          var returnValue = objOps[operation.op].call(operation, obj, key4, document2);
          if (returnValue.test === false) {
            throw new JsonPatchError("Test operation failed", "TEST_OPERATION_FAILED", index4, operation, document2);
          }
          return returnValue;
        }
      }
      obj = obj[key4];
      if (validateOperation && t < len && (!obj || typeof obj !== "object")) {
        throw new JsonPatchError("Cannot perform operation at the desired path", "OPERATION_PATH_UNRESOLVABLE", index4, operation, document2);
      }
    }
  }
}
function applyPatch(document2, patch2, validateOperation, mutateDocument, banPrototypeModifications) {
  if (mutateDocument === void 0) {
    mutateDocument = true;
  }
  if (banPrototypeModifications === void 0) {
    banPrototypeModifications = true;
  }
  if (validateOperation) {
    if (!Array.isArray(patch2)) {
      throw new JsonPatchError("Patch sequence must be an array", "SEQUENCE_NOT_AN_ARRAY");
    }
  }
  if (!mutateDocument) {
    document2 = _deepClone(document2);
  }
  var results = new Array(patch2.length);
  for (var i = 0, length_1 = patch2.length; i < length_1; i++) {
    results[i] = applyOperation(document2, patch2[i], validateOperation, true, banPrototypeModifications, i);
    document2 = results[i].newDocument;
  }
  results.newDocument = document2;
  return results;
}
function applyReducer(document2, operation, index4) {
  var operationResult = applyOperation(document2, operation);
  if (operationResult.test === false) {
    throw new JsonPatchError("Test operation failed", "TEST_OPERATION_FAILED", index4, operation, document2);
  }
  return operationResult.newDocument;
}
function validator(operation, index4, document2, existingPathFragment) {
  if (typeof operation !== "object" || operation === null || Array.isArray(operation)) {
    throw new JsonPatchError("Operation is not an object", "OPERATION_NOT_AN_OBJECT", index4, operation, document2);
  } else if (!objOps[operation.op]) {
    throw new JsonPatchError("Operation `op` property is not one of operations defined in RFC-6902", "OPERATION_OP_INVALID", index4, operation, document2);
  } else if (typeof operation.path !== "string") {
    throw new JsonPatchError("Operation `path` property is not a string", "OPERATION_PATH_INVALID", index4, operation, document2);
  } else if (operation.path.indexOf("/") !== 0 && operation.path.length > 0) {
    throw new JsonPatchError('Operation `path` property must start with "/"', "OPERATION_PATH_INVALID", index4, operation, document2);
  } else if ((operation.op === "move" || operation.op === "copy") && typeof operation.from !== "string") {
    throw new JsonPatchError("Operation `from` property is not present (applicable in `move` and `copy` operations)", "OPERATION_FROM_REQUIRED", index4, operation, document2);
  } else if ((operation.op === "add" || operation.op === "replace" || operation.op === "test") && operation.value === void 0) {
    throw new JsonPatchError("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)", "OPERATION_VALUE_REQUIRED", index4, operation, document2);
  } else if ((operation.op === "add" || operation.op === "replace" || operation.op === "test") && hasUndefined(operation.value)) {
    throw new JsonPatchError("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)", "OPERATION_VALUE_CANNOT_CONTAIN_UNDEFINED", index4, operation, document2);
  } else if (document2) {
    if (operation.op == "add") {
      var pathLen = operation.path.split("/").length;
      var existingPathLen = existingPathFragment.split("/").length;
      if (pathLen !== existingPathLen + 1 && pathLen !== existingPathLen) {
        throw new JsonPatchError("Cannot perform an `add` operation at the desired path", "OPERATION_PATH_CANNOT_ADD", index4, operation, document2);
      }
    } else if (operation.op === "replace" || operation.op === "remove" || operation.op === "_get") {
      if (operation.path !== existingPathFragment) {
        throw new JsonPatchError("Cannot perform the operation at a path that does not exist", "OPERATION_PATH_UNRESOLVABLE", index4, operation, document2);
      }
    } else if (operation.op === "move" || operation.op === "copy") {
      var existingValue = { op: "_get", path: operation.from, value: void 0 };
      var error25 = validate([existingValue], document2);
      if (error25 && error25.name === "OPERATION_PATH_UNRESOLVABLE") {
        throw new JsonPatchError("Cannot perform the operation from a path that does not exist", "OPERATION_FROM_UNRESOLVABLE", index4, operation, document2);
      }
    }
  }
}
function validate(sequence4, document2, externalValidator) {
  try {
    if (!Array.isArray(sequence4)) {
      throw new JsonPatchError("Patch sequence must be an array", "SEQUENCE_NOT_AN_ARRAY");
    }
    if (document2) {
      applyPatch(_deepClone(document2), _deepClone(sequence4), externalValidator || true);
    } else {
      externalValidator = externalValidator || validator;
      for (var i = 0; i < sequence4.length; i++) {
        externalValidator(sequence4[i], i, document2, void 0);
      }
    }
  } catch (e3) {
    if (e3 instanceof JsonPatchError) {
      return e3;
    } else {
      throw e3;
    }
  }
}
function _areEquals(a4, b6) {
  if (a4 === b6)
    return true;
  if (a4 && b6 && typeof a4 == "object" && typeof b6 == "object") {
    var arrA = Array.isArray(a4), arrB = Array.isArray(b6), i, length2, key4;
    if (arrA && arrB) {
      length2 = a4.length;
      if (length2 != b6.length)
        return false;
      for (i = length2; i-- !== 0; )
        if (!_areEquals(a4[i], b6[i]))
          return false;
      return true;
    }
    if (arrA != arrB)
      return false;
    var keys5 = Object.keys(a4);
    length2 = keys5.length;
    if (length2 !== Object.keys(b6).length)
      return false;
    for (i = length2; i-- !== 0; )
      if (!b6.hasOwnProperty(keys5[i]))
        return false;
    for (i = length2; i-- !== 0; ) {
      key4 = keys5[i];
      if (!_areEquals(a4[key4], b6[key4]))
        return false;
    }
    return true;
  }
  return a4 !== a4 && b6 !== b6;
}
var core = Object.freeze({
  __proto__: null,
  JsonPatchError,
  _areEquals,
  applyOperation,
  applyPatch,
  applyReducer,
  deepClone,
  getValueByPointer,
  validate,
  validator
});
var beforeDict = /* @__PURE__ */ new WeakMap();
var Mirror = (
  /** @class */
  function() {
    function Mirror2(obj) {
      this.observers = /* @__PURE__ */ new Map();
      this.obj = obj;
    }
    return Mirror2;
  }()
);
var ObserverInfo = (
  /** @class */
  function() {
    function ObserverInfo2(callback, observer) {
      this.callback = callback;
      this.observer = observer;
    }
    return ObserverInfo2;
  }()
);
function getMirror(obj) {
  return beforeDict.get(obj);
}
function getObserverFromMirror(mirror, callback) {
  return mirror.observers.get(callback);
}
function removeObserverFromMirror(mirror, observer) {
  mirror.observers.delete(observer.callback);
}
function unobserve(root, observer) {
  observer.unobserve();
}
function observe(obj, callback) {
  var patches = [];
  var observer;
  var mirror = getMirror(obj);
  if (!mirror) {
    mirror = new Mirror(obj);
    beforeDict.set(obj, mirror);
  } else {
    var observerInfo = getObserverFromMirror(mirror, callback);
    observer = observerInfo && observerInfo.observer;
  }
  if (observer) {
    return observer;
  }
  observer = {};
  mirror.value = _deepClone(obj);
  if (callback) {
    observer.callback = callback;
    observer.next = null;
    var dirtyCheck = function() {
      generate2(observer);
    };
    var fastCheck = function() {
      clearTimeout(observer.next);
      observer.next = setTimeout(dirtyCheck);
    };
    if (typeof window !== "undefined") {
      window.addEventListener("mouseup", fastCheck);
      window.addEventListener("keyup", fastCheck);
      window.addEventListener("mousedown", fastCheck);
      window.addEventListener("keydown", fastCheck);
      window.addEventListener("change", fastCheck);
    }
  }
  observer.patches = patches;
  observer.object = obj;
  observer.unobserve = function() {
    generate2(observer);
    clearTimeout(observer.next);
    removeObserverFromMirror(mirror, observer);
    if (typeof window !== "undefined") {
      window.removeEventListener("mouseup", fastCheck);
      window.removeEventListener("keyup", fastCheck);
      window.removeEventListener("mousedown", fastCheck);
      window.removeEventListener("keydown", fastCheck);
      window.removeEventListener("change", fastCheck);
    }
  };
  mirror.observers.set(callback, new ObserverInfo(callback, observer));
  return observer;
}
function generate2(observer, invertible) {
  if (invertible === void 0) {
    invertible = false;
  }
  var mirror = beforeDict.get(observer.object);
  _generate(mirror.value, observer.object, observer.patches, "", invertible);
  if (observer.patches.length) {
    applyPatch(mirror.value, observer.patches);
  }
  var temp6 = observer.patches;
  if (temp6.length > 0) {
    observer.patches = [];
    if (observer.callback) {
      observer.callback(temp6);
    }
  }
  return temp6;
}
function _generate(mirror, obj, patches, path7, invertible) {
  if (obj === mirror) {
    return;
  }
  if (typeof obj.toJSON === "function") {
    obj = obj.toJSON();
  }
  var newKeys = _objectKeys(obj);
  var oldKeys = _objectKeys(mirror);
  var deleted = false;
  for (var t = oldKeys.length - 1; t >= 0; t--) {
    var key4 = oldKeys[t];
    var oldVal = mirror[key4];
    if (hasOwnProperty(obj, key4) && !(obj[key4] === void 0 && oldVal !== void 0 && Array.isArray(obj) === false)) {
      var newVal = obj[key4];
      if (typeof oldVal == "object" && oldVal != null && typeof newVal == "object" && newVal != null && Array.isArray(oldVal) === Array.isArray(newVal)) {
        _generate(oldVal, newVal, patches, path7 + "/" + escapePathComponent(key4), invertible);
      } else {
        if (oldVal !== newVal) {
          if (invertible) {
            patches.push({ op: "test", path: path7 + "/" + escapePathComponent(key4), value: _deepClone(oldVal) });
          }
          patches.push({ op: "replace", path: path7 + "/" + escapePathComponent(key4), value: _deepClone(newVal) });
        }
      }
    } else if (Array.isArray(mirror) === Array.isArray(obj)) {
      if (invertible) {
        patches.push({ op: "test", path: path7 + "/" + escapePathComponent(key4), value: _deepClone(oldVal) });
      }
      patches.push({ op: "remove", path: path7 + "/" + escapePathComponent(key4) });
      deleted = true;
    } else {
      if (invertible) {
        patches.push({ op: "test", path: path7, value: mirror });
      }
      patches.push({ op: "replace", path: path7, value: obj });
    }
  }
  if (!deleted && newKeys.length == oldKeys.length) {
    return;
  }
  for (var t = 0; t < newKeys.length; t++) {
    var key4 = newKeys[t];
    if (!hasOwnProperty(mirror, key4) && obj[key4] !== void 0) {
      patches.push({ op: "add", path: path7 + "/" + escapePathComponent(key4), value: _deepClone(obj[key4]) });
    }
  }
}
function compare9(tree1, tree2, invertible) {
  if (invertible === void 0) {
    invertible = false;
  }
  var patches = [];
  _generate(tree1, tree2, patches, "", invertible);
  return patches;
}
var duplex = Object.freeze({
  __proto__: null,
  compare: compare9,
  generate: generate2,
  observe,
  unobserve
});
Object.assign({}, core, duplex, {
  JsonPatchError: PatchError,
  deepClone: _deepClone,
  escapePathComponent,
  unescapePathComponent
});
function getDefaultExportFromCjs(x9) {
  return x9 && x9.__esModule && Object.prototype.hasOwnProperty.call(x9, "default") ? x9["default"] : x9;
}
var lrucache;
var hasRequiredLrucache;
function requireLrucache() {
  if (hasRequiredLrucache)
    return lrucache;
  hasRequiredLrucache = 1;
  class LRUCache {
    constructor() {
      this.max = 1e3;
      this.map = /* @__PURE__ */ new Map();
    }
    get(key4) {
      const value7 = this.map.get(key4);
      if (value7 === void 0) {
        return void 0;
      } else {
        this.map.delete(key4);
        this.map.set(key4, value7);
        return value7;
      }
    }
    delete(key4) {
      return this.map.delete(key4);
    }
    set(key4, value7) {
      const deleted = this.delete(key4);
      if (!deleted && value7 !== void 0) {
        if (this.map.size >= this.max) {
          const firstKey = this.map.keys().next().value;
          this.delete(firstKey);
        }
        this.map.set(key4, value7);
      }
      return this;
    }
  }
  lrucache = LRUCache;
  return lrucache;
}
var parseOptions_1;
var hasRequiredParseOptions;
function requireParseOptions() {
  if (hasRequiredParseOptions)
    return parseOptions_1;
  hasRequiredParseOptions = 1;
  const looseOption = Object.freeze({ loose: true });
  const emptyOpts = Object.freeze({});
  const parseOptions = (options) => {
    if (!options) {
      return emptyOpts;
    }
    if (typeof options !== "object") {
      return looseOption;
    }
    return options;
  };
  parseOptions_1 = parseOptions;
  return parseOptions_1;
}
var re2 = { exports: {} };
var constants2;
var hasRequiredConstants;
function requireConstants() {
  if (hasRequiredConstants)
    return constants2;
  hasRequiredConstants = 1;
  const SEMVER_SPEC_VERSION = "2.0.0";
  const MAX_LENGTH = 256;
  const MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
  9007199254740991;
  const MAX_SAFE_COMPONENT_LENGTH = 16;
  const MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
  const RELEASE_TYPES = [
    "major",
    "premajor",
    "minor",
    "preminor",
    "patch",
    "prepatch",
    "prerelease"
  ];
  constants2 = {
    MAX_LENGTH,
    MAX_SAFE_COMPONENT_LENGTH,
    MAX_SAFE_BUILD_LENGTH,
    MAX_SAFE_INTEGER,
    RELEASE_TYPES,
    SEMVER_SPEC_VERSION,
    FLAG_INCLUDE_PRERELEASE: 1,
    FLAG_LOOSE: 2
  };
  return constants2;
}
var debug_1;
var hasRequiredDebug;
function requireDebug() {
  if (hasRequiredDebug)
    return debug_1;
  hasRequiredDebug = 1;
  const debug3 = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
  };
  debug_1 = debug3;
  return debug_1;
}
var hasRequiredRe;
function requireRe() {
  if (hasRequiredRe)
    return re2.exports;
  hasRequiredRe = 1;
  (function(module, exports) {
    const {
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_LENGTH
    } = requireConstants();
    const debug3 = requireDebug();
    exports = module.exports = {};
    const re3 = exports.re = [];
    const safeRe = exports.safeRe = [];
    const src = exports.src = [];
    const safeSrc = exports.safeSrc = [];
    const t = exports.t = {};
    let R = 0;
    const LETTERDASHNUMBER = "[a-zA-Z0-9-]";
    const safeRegexReplacements = [
      ["\\s", 1],
      ["\\d", MAX_LENGTH],
      [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
    ];
    const makeSafeRegex = (value7) => {
      for (const [token, max5] of safeRegexReplacements) {
        value7 = value7.split(`${token}*`).join(`${token}{0,${max5}}`).split(`${token}+`).join(`${token}{1,${max5}}`);
      }
      return value7;
    };
    const createToken = (name, value7, isGlobal) => {
      const safe = makeSafeRegex(value7);
      const index4 = R++;
      debug3(name, index4, value7);
      t[name] = index4;
      src[index4] = value7;
      safeSrc[index4] = safe;
      re3[index4] = new RegExp(value7, isGlobal ? "g" : void 0);
      safeRe[index4] = new RegExp(safe, isGlobal ? "g" : void 0);
    };
    createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
    createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
    createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
    createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})`);
    createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NUMERICIDENTIFIER]}|${src[t.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NUMERICIDENTIFIERLOOSE]}|${src[t.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
    createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
    createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
    createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
    createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
    createToken("FULL", `^${src[t.FULLPLAIN]}$`);
    createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
    createToken("LOOSE", `^${src[t.LOOSEPLAIN]}$`);
    createToken("GTLT", "((?:<|>)?=?)");
    createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
    createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
    createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
    createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COERCEPLAIN", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`);
    createToken("COERCE", `${src[t.COERCEPLAIN]}(?:$|[^\\d])`);
    createToken("COERCEFULL", src[t.COERCEPLAIN] + `(?:${src[t.PRERELEASE]})?(?:${src[t.BUILD]})?(?:$|[^\\d])`);
    createToken("COERCERTL", src[t.COERCE], true);
    createToken("COERCERTLFULL", src[t.COERCEFULL], true);
    createToken("LONETILDE", "(?:~>?)");
    createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true);
    exports.tildeTrimReplace = "$1~";
    createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
    createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("LONECARET", "(?:\\^)");
    createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true);
    exports.caretTrimReplace = "$1^";
    createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
    createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
    createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
    createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
    exports.comparatorTrimReplace = "$1$2$3";
    createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})\\s+-\\s+(${src[t.XRANGEPLAIN]})\\s*$`);
    createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t.XRANGEPLAINLOOSE]})\\s*$`);
    createToken("STAR", "(<|>)?=?\\s*\\*");
    createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
    createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
  })(re2, re2.exports);
  return re2.exports;
}
var identifiers;
var hasRequiredIdentifiers;
function requireIdentifiers() {
  if (hasRequiredIdentifiers)
    return identifiers;
  hasRequiredIdentifiers = 1;
  const numeric = /^[0-9]+$/;
  const compareIdentifiers = (a4, b6) => {
    const anum = numeric.test(a4);
    const bnum = numeric.test(b6);
    if (anum && bnum) {
      a4 = +a4;
      b6 = +b6;
    }
    return a4 === b6 ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a4 < b6 ? -1 : 1;
  };
  const rcompareIdentifiers = (a4, b6) => compareIdentifiers(b6, a4);
  identifiers = {
    compareIdentifiers,
    rcompareIdentifiers
  };
  return identifiers;
}
var semver;
var hasRequiredSemver;
function requireSemver() {
  if (hasRequiredSemver)
    return semver;
  hasRequiredSemver = 1;
  const debug3 = requireDebug();
  const { MAX_LENGTH, MAX_SAFE_INTEGER } = requireConstants();
  const { safeRe: re3, safeSrc: src, t } = requireRe();
  const parseOptions = requireParseOptions();
  const { compareIdentifiers } = requireIdentifiers();
  class SemVer {
    constructor(version6, options) {
      options = parseOptions(options);
      if (version6 instanceof SemVer) {
        if (version6.loose === !!options.loose && version6.includePrerelease === !!options.includePrerelease) {
          return version6;
        } else {
          version6 = version6.version;
        }
      } else if (typeof version6 !== "string") {
        throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version6}".`);
      }
      if (version6.length > MAX_LENGTH) {
        throw new TypeError(
          `version is longer than ${MAX_LENGTH} characters`
        );
      }
      debug3("SemVer", version6, options);
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      const m3 = version6.trim().match(options.loose ? re3[t.LOOSE] : re3[t.FULL]);
      if (!m3) {
        throw new TypeError(`Invalid Version: ${version6}`);
      }
      this.raw = version6;
      this.major = +m3[1];
      this.minor = +m3[2];
      this.patch = +m3[3];
      if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
        throw new TypeError("Invalid major version");
      }
      if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
        throw new TypeError("Invalid minor version");
      }
      if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
        throw new TypeError("Invalid patch version");
      }
      if (!m3[4]) {
        this.prerelease = [];
      } else {
        this.prerelease = m3[4].split(".").map((id24) => {
          if (/^[0-9]+$/.test(id24)) {
            const num = +id24;
            if (num >= 0 && num < MAX_SAFE_INTEGER) {
              return num;
            }
          }
          return id24;
        });
      }
      this.build = m3[5] ? m3[5].split(".") : [];
      this.format();
    }
    format() {
      this.version = `${this.major}.${this.minor}.${this.patch}`;
      if (this.prerelease.length) {
        this.version += `-${this.prerelease.join(".")}`;
      }
      return this.version;
    }
    toString() {
      return this.version;
    }
    compare(other) {
      debug3("SemVer.compare", this.version, this.options, other);
      if (!(other instanceof SemVer)) {
        if (typeof other === "string" && other === this.version) {
          return 0;
        }
        other = new SemVer(other, this.options);
      }
      if (other.version === this.version) {
        return 0;
      }
      return this.compareMain(other) || this.comparePre(other);
    }
    compareMain(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
    }
    comparePre(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      if (this.prerelease.length && !other.prerelease.length) {
        return -1;
      } else if (!this.prerelease.length && other.prerelease.length) {
        return 1;
      } else if (!this.prerelease.length && !other.prerelease.length) {
        return 0;
      }
      let i = 0;
      do {
        const a4 = this.prerelease[i];
        const b6 = other.prerelease[i];
        debug3("prerelease compare", i, a4, b6);
        if (a4 === void 0 && b6 === void 0) {
          return 0;
        } else if (b6 === void 0) {
          return 1;
        } else if (a4 === void 0) {
          return -1;
        } else if (a4 === b6) {
          continue;
        } else {
          return compareIdentifiers(a4, b6);
        }
      } while (++i);
    }
    compareBuild(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      let i = 0;
      do {
        const a4 = this.build[i];
        const b6 = other.build[i];
        debug3("build compare", i, a4, b6);
        if (a4 === void 0 && b6 === void 0) {
          return 0;
        } else if (b6 === void 0) {
          return 1;
        } else if (a4 === void 0) {
          return -1;
        } else if (a4 === b6) {
          continue;
        } else {
          return compareIdentifiers(a4, b6);
        }
      } while (++i);
    }
    // preminor will bump the version up to the next minor release, and immediately
    // down to pre-release. premajor and prepatch work the same way.
    inc(release, identifier, identifierBase) {
      if (release.startsWith("pre")) {
        if (!identifier && identifierBase === false) {
          throw new Error("invalid increment argument: identifier is empty");
        }
        if (identifier) {
          const r = new RegExp(`^${this.options.loose ? src[t.PRERELEASELOOSE] : src[t.PRERELEASE]}$`);
          const match2 = `-${identifier}`.match(r);
          if (!match2 || match2[1] !== identifier) {
            throw new Error(`invalid identifier: ${identifier}`);
          }
        }
      }
      switch (release) {
        case "premajor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor = 0;
          this.major++;
          this.inc("pre", identifier, identifierBase);
          break;
        case "preminor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor++;
          this.inc("pre", identifier, identifierBase);
          break;
        case "prepatch":
          this.prerelease.length = 0;
          this.inc("patch", identifier, identifierBase);
          this.inc("pre", identifier, identifierBase);
          break;
        case "prerelease":
          if (this.prerelease.length === 0) {
            this.inc("patch", identifier, identifierBase);
          }
          this.inc("pre", identifier, identifierBase);
          break;
        case "release":
          if (this.prerelease.length === 0) {
            throw new Error(`version ${this.raw} is not a prerelease`);
          }
          this.prerelease.length = 0;
          break;
        case "major":
          if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
            this.major++;
          }
          this.minor = 0;
          this.patch = 0;
          this.prerelease = [];
          break;
        case "minor":
          if (this.patch !== 0 || this.prerelease.length === 0) {
            this.minor++;
          }
          this.patch = 0;
          this.prerelease = [];
          break;
        case "patch":
          if (this.prerelease.length === 0) {
            this.patch++;
          }
          this.prerelease = [];
          break;
        case "pre": {
          const base = Number(identifierBase) ? 1 : 0;
          if (this.prerelease.length === 0) {
            this.prerelease = [base];
          } else {
            let i = this.prerelease.length;
            while (--i >= 0) {
              if (typeof this.prerelease[i] === "number") {
                this.prerelease[i]++;
                i = -2;
              }
            }
            if (i === -1) {
              if (identifier === this.prerelease.join(".") && identifierBase === false) {
                throw new Error("invalid increment argument: identifier already exists");
              }
              this.prerelease.push(base);
            }
          }
          if (identifier) {
            let prerelease = [identifier, base];
            if (identifierBase === false) {
              prerelease = [identifier];
            }
            if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
              if (isNaN(this.prerelease[1])) {
                this.prerelease = prerelease;
              }
            } else {
              this.prerelease = prerelease;
            }
          }
          break;
        }
        default:
          throw new Error(`invalid increment argument: ${release}`);
      }
      this.raw = this.format();
      if (this.build.length) {
        this.raw += `+${this.build.join(".")}`;
      }
      return this;
    }
  }
  semver = SemVer;
  return semver;
}
var compare_1;
var hasRequiredCompare;
function requireCompare() {
  if (hasRequiredCompare)
    return compare_1;
  hasRequiredCompare = 1;
  const SemVer = requireSemver();
  const compare10 = (a4, b6, loose) => new SemVer(a4, loose).compare(new SemVer(b6, loose));
  compare_1 = compare10;
  return compare_1;
}
var eq_1;
var hasRequiredEq;
function requireEq() {
  if (hasRequiredEq)
    return eq_1;
  hasRequiredEq = 1;
  const compare10 = requireCompare();
  const eq = (a4, b6, loose) => compare10(a4, b6, loose) === 0;
  eq_1 = eq;
  return eq_1;
}
var neq_1;
var hasRequiredNeq;
function requireNeq() {
  if (hasRequiredNeq)
    return neq_1;
  hasRequiredNeq = 1;
  const compare10 = requireCompare();
  const neq = (a4, b6, loose) => compare10(a4, b6, loose) !== 0;
  neq_1 = neq;
  return neq_1;
}
var gt_1;
var hasRequiredGt;
function requireGt() {
  if (hasRequiredGt)
    return gt_1;
  hasRequiredGt = 1;
  const compare10 = requireCompare();
  const gt = (a4, b6, loose) => compare10(a4, b6, loose) > 0;
  gt_1 = gt;
  return gt_1;
}
var gte_1;
var hasRequiredGte;
function requireGte() {
  if (hasRequiredGte)
    return gte_1;
  hasRequiredGte = 1;
  const compare10 = requireCompare();
  const gte = (a4, b6, loose) => compare10(a4, b6, loose) >= 0;
  gte_1 = gte;
  return gte_1;
}
var lt_1;
var hasRequiredLt;
function requireLt() {
  if (hasRequiredLt)
    return lt_1;
  hasRequiredLt = 1;
  const compare10 = requireCompare();
  const lt = (a4, b6, loose) => compare10(a4, b6, loose) < 0;
  lt_1 = lt;
  return lt_1;
}
var lte_1;
var hasRequiredLte;
function requireLte() {
  if (hasRequiredLte)
    return lte_1;
  hasRequiredLte = 1;
  const compare10 = requireCompare();
  const lte = (a4, b6, loose) => compare10(a4, b6, loose) <= 0;
  lte_1 = lte;
  return lte_1;
}
var cmp_1;
var hasRequiredCmp;
function requireCmp() {
  if (hasRequiredCmp)
    return cmp_1;
  hasRequiredCmp = 1;
  const eq = requireEq();
  const neq = requireNeq();
  const gt = requireGt();
  const gte = requireGte();
  const lt = requireLt();
  const lte = requireLte();
  const cmp = (a4, op, b6, loose) => {
    switch (op) {
      case "===":
        if (typeof a4 === "object") {
          a4 = a4.version;
        }
        if (typeof b6 === "object") {
          b6 = b6.version;
        }
        return a4 === b6;
      case "!==":
        if (typeof a4 === "object") {
          a4 = a4.version;
        }
        if (typeof b6 === "object") {
          b6 = b6.version;
        }
        return a4 !== b6;
      case "":
      case "=":
      case "==":
        return eq(a4, b6, loose);
      case "!=":
        return neq(a4, b6, loose);
      case ">":
        return gt(a4, b6, loose);
      case ">=":
        return gte(a4, b6, loose);
      case "<":
        return lt(a4, b6, loose);
      case "<=":
        return lte(a4, b6, loose);
      default:
        throw new TypeError(`Invalid operator: ${op}`);
    }
  };
  cmp_1 = cmp;
  return cmp_1;
}
var comparator4;
var hasRequiredComparator;
function requireComparator() {
  if (hasRequiredComparator)
    return comparator4;
  hasRequiredComparator = 1;
  const ANY = Symbol("SemVer ANY");
  class Comparator {
    static get ANY() {
      return ANY;
    }
    constructor(comp, options) {
      options = parseOptions(options);
      if (comp instanceof Comparator) {
        if (comp.loose === !!options.loose) {
          return comp;
        } else {
          comp = comp.value;
        }
      }
      comp = comp.trim().split(/\s+/).join(" ");
      debug3("comparator", comp, options);
      this.options = options;
      this.loose = !!options.loose;
      this.parse(comp);
      if (this.semver === ANY) {
        this.value = "";
      } else {
        this.value = this.operator + this.semver.version;
      }
      debug3("comp", this);
    }
    parse(comp) {
      const r = this.options.loose ? re3[t.COMPARATORLOOSE] : re3[t.COMPARATOR];
      const m3 = comp.match(r);
      if (!m3) {
        throw new TypeError(`Invalid comparator: ${comp}`);
      }
      this.operator = m3[1] !== void 0 ? m3[1] : "";
      if (this.operator === "=") {
        this.operator = "";
      }
      if (!m3[2]) {
        this.semver = ANY;
      } else {
        this.semver = new SemVer(m3[2], this.options.loose);
      }
    }
    toString() {
      return this.value;
    }
    test(version6) {
      debug3("Comparator.test", version6, this.options.loose);
      if (this.semver === ANY || version6 === ANY) {
        return true;
      }
      if (typeof version6 === "string") {
        try {
          version6 = new SemVer(version6, this.options);
        } catch (er) {
          return false;
        }
      }
      return cmp(version6, this.operator, this.semver, this.options);
    }
    intersects(comp, options) {
      if (!(comp instanceof Comparator)) {
        throw new TypeError("a Comparator is required");
      }
      if (this.operator === "") {
        if (this.value === "") {
          return true;
        }
        return new Range(comp.value, options).test(this.value);
      } else if (comp.operator === "") {
        if (comp.value === "") {
          return true;
        }
        return new Range(this.value, options).test(comp.semver);
      }
      options = parseOptions(options);
      if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
        return false;
      }
      if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
        return false;
      }
      if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
        return true;
      }
      if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
        return true;
      }
      if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
        return true;
      }
      if (cmp(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
        return true;
      }
      if (cmp(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
        return true;
      }
      return false;
    }
  }
  comparator4 = Comparator;
  const parseOptions = requireParseOptions();
  const { safeRe: re3, t } = requireRe();
  const cmp = requireCmp();
  const debug3 = requireDebug();
  const SemVer = requireSemver();
  const Range = requireRange();
  return comparator4;
}
var range6;
var hasRequiredRange;
function requireRange() {
  if (hasRequiredRange)
    return range6;
  hasRequiredRange = 1;
  const SPACE_CHARACTERS = /\s+/g;
  class Range {
    constructor(range7, options) {
      options = parseOptions(options);
      if (range7 instanceof Range) {
        if (range7.loose === !!options.loose && range7.includePrerelease === !!options.includePrerelease) {
          return range7;
        } else {
          return new Range(range7.raw, options);
        }
      }
      if (range7 instanceof Comparator) {
        this.raw = range7.value;
        this.set = [[range7]];
        this.formatted = void 0;
        return this;
      }
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      this.raw = range7.trim().replace(SPACE_CHARACTERS, " ");
      this.set = this.raw.split("||").map((r) => this.parseRange(r.trim())).filter((c5) => c5.length);
      if (!this.set.length) {
        throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
      }
      if (this.set.length > 1) {
        const first = this.set[0];
        this.set = this.set.filter((c5) => !isNullSet(c5[0]));
        if (this.set.length === 0) {
          this.set = [first];
        } else if (this.set.length > 1) {
          for (const c5 of this.set) {
            if (c5.length === 1 && isAny(c5[0])) {
              this.set = [c5];
              break;
            }
          }
        }
      }
      this.formatted = void 0;
    }
    get range() {
      if (this.formatted === void 0) {
        this.formatted = "";
        for (let i = 0; i < this.set.length; i++) {
          if (i > 0) {
            this.formatted += "||";
          }
          const comps = this.set[i];
          for (let k3 = 0; k3 < comps.length; k3++) {
            if (k3 > 0) {
              this.formatted += " ";
            }
            this.formatted += comps[k3].toString().trim();
          }
        }
      }
      return this.formatted;
    }
    format() {
      return this.range;
    }
    toString() {
      return this.range;
    }
    parseRange(range7) {
      const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
      const memoKey = memoOpts + ":" + range7;
      const cached = cache2.get(memoKey);
      if (cached) {
        return cached;
      }
      const loose = this.options.loose;
      const hr = loose ? re3[t.HYPHENRANGELOOSE] : re3[t.HYPHENRANGE];
      range7 = range7.replace(hr, hyphenReplace(this.options.includePrerelease));
      debug3("hyphen replace", range7);
      range7 = range7.replace(re3[t.COMPARATORTRIM], comparatorTrimReplace);
      debug3("comparator trim", range7);
      range7 = range7.replace(re3[t.TILDETRIM], tildeTrimReplace);
      debug3("tilde trim", range7);
      range7 = range7.replace(re3[t.CARETTRIM], caretTrimReplace);
      debug3("caret trim", range7);
      let rangeList = range7.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
      if (loose) {
        rangeList = rangeList.filter((comp) => {
          debug3("loose invalid filter", comp, this.options);
          return !!comp.match(re3[t.COMPARATORLOOSE]);
        });
      }
      debug3("range list", rangeList);
      const rangeMap = /* @__PURE__ */ new Map();
      const comparators = rangeList.map((comp) => new Comparator(comp, this.options));
      for (const comp of comparators) {
        if (isNullSet(comp)) {
          return [comp];
        }
        rangeMap.set(comp.value, comp);
      }
      if (rangeMap.size > 1 && rangeMap.has("")) {
        rangeMap.delete("");
      }
      const result = [...rangeMap.values()];
      cache2.set(memoKey, result);
      return result;
    }
    intersects(range7, options) {
      if (!(range7 instanceof Range)) {
        throw new TypeError("a Range is required");
      }
      return this.set.some((thisComparators) => {
        return isSatisfiable(thisComparators, options) && range7.set.some((rangeComparators) => {
          return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
            return rangeComparators.every((rangeComparator) => {
              return thisComparator.intersects(rangeComparator, options);
            });
          });
        });
      });
    }
    // if ANY of the sets match ALL of its comparators, then pass
    test(version6) {
      if (!version6) {
        return false;
      }
      if (typeof version6 === "string") {
        try {
          version6 = new SemVer(version6, this.options);
        } catch (er) {
          return false;
        }
      }
      for (let i = 0; i < this.set.length; i++) {
        if (testSet(this.set[i], version6, this.options)) {
          return true;
        }
      }
      return false;
    }
  }
  range6 = Range;
  const LRU = requireLrucache();
  const cache2 = new LRU();
  const parseOptions = requireParseOptions();
  const Comparator = requireComparator();
  const debug3 = requireDebug();
  const SemVer = requireSemver();
  const {
    safeRe: re3,
    t,
    comparatorTrimReplace,
    tildeTrimReplace,
    caretTrimReplace
  } = requireRe();
  const { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = requireConstants();
  const isNullSet = (c5) => c5.value === "<0.0.0-0";
  const isAny = (c5) => c5.value === "";
  const isSatisfiable = (comparators, options) => {
    let result = true;
    const remainingComparators = comparators.slice();
    let testComparator = remainingComparators.pop();
    while (result && remainingComparators.length) {
      result = remainingComparators.every((otherComparator) => {
        return testComparator.intersects(otherComparator, options);
      });
      testComparator = remainingComparators.pop();
    }
    return result;
  };
  const parseComparator = (comp, options) => {
    debug3("comp", comp, options);
    comp = replaceCarets(comp, options);
    debug3("caret", comp);
    comp = replaceTildes(comp, options);
    debug3("tildes", comp);
    comp = replaceXRanges(comp, options);
    debug3("xrange", comp);
    comp = replaceStars(comp, options);
    debug3("stars", comp);
    return comp;
  };
  const isX2 = (id24) => !id24 || id24.toLowerCase() === "x" || id24 === "*";
  const replaceTildes = (comp, options) => {
    return comp.trim().split(/\s+/).map((c5) => replaceTilde(c5, options)).join(" ");
  };
  const replaceTilde = (comp, options) => {
    const r = options.loose ? re3[t.TILDELOOSE] : re3[t.TILDE];
    return comp.replace(r, (_, M2, m3, p, pr) => {
      debug3("tilde", comp, _, M2, m3, p, pr);
      let ret;
      if (isX2(M2)) {
        ret = "";
      } else if (isX2(m3)) {
        ret = `>=${M2}.0.0 <${+M2 + 1}.0.0-0`;
      } else if (isX2(p)) {
        ret = `>=${M2}.${m3}.0 <${M2}.${+m3 + 1}.0-0`;
      } else if (pr) {
        debug3("replaceTilde pr", pr);
        ret = `>=${M2}.${m3}.${p}-${pr} <${M2}.${+m3 + 1}.0-0`;
      } else {
        ret = `>=${M2}.${m3}.${p} <${M2}.${+m3 + 1}.0-0`;
      }
      debug3("tilde return", ret);
      return ret;
    });
  };
  const replaceCarets = (comp, options) => {
    return comp.trim().split(/\s+/).map((c5) => replaceCaret(c5, options)).join(" ");
  };
  const replaceCaret = (comp, options) => {
    debug3("caret", comp, options);
    const r = options.loose ? re3[t.CARETLOOSE] : re3[t.CARET];
    const z = options.includePrerelease ? "-0" : "";
    return comp.replace(r, (_, M2, m3, p, pr) => {
      debug3("caret", comp, _, M2, m3, p, pr);
      let ret;
      if (isX2(M2)) {
        ret = "";
      } else if (isX2(m3)) {
        ret = `>=${M2}.0.0${z} <${+M2 + 1}.0.0-0`;
      } else if (isX2(p)) {
        if (M2 === "0") {
          ret = `>=${M2}.${m3}.0${z} <${M2}.${+m3 + 1}.0-0`;
        } else {
          ret = `>=${M2}.${m3}.0${z} <${+M2 + 1}.0.0-0`;
        }
      } else if (pr) {
        debug3("replaceCaret pr", pr);
        if (M2 === "0") {
          if (m3 === "0") {
            ret = `>=${M2}.${m3}.${p}-${pr} <${M2}.${m3}.${+p + 1}-0`;
          } else {
            ret = `>=${M2}.${m3}.${p}-${pr} <${M2}.${+m3 + 1}.0-0`;
          }
        } else {
          ret = `>=${M2}.${m3}.${p}-${pr} <${+M2 + 1}.0.0-0`;
        }
      } else {
        debug3("no pr");
        if (M2 === "0") {
          if (m3 === "0") {
            ret = `>=${M2}.${m3}.${p}${z} <${M2}.${m3}.${+p + 1}-0`;
          } else {
            ret = `>=${M2}.${m3}.${p}${z} <${M2}.${+m3 + 1}.0-0`;
          }
        } else {
          ret = `>=${M2}.${m3}.${p} <${+M2 + 1}.0.0-0`;
        }
      }
      debug3("caret return", ret);
      return ret;
    });
  };
  const replaceXRanges = (comp, options) => {
    debug3("replaceXRanges", comp, options);
    return comp.split(/\s+/).map((c5) => replaceXRange(c5, options)).join(" ");
  };
  const replaceXRange = (comp, options) => {
    comp = comp.trim();
    const r = options.loose ? re3[t.XRANGELOOSE] : re3[t.XRANGE];
    return comp.replace(r, (ret, gtlt, M2, m3, p, pr) => {
      debug3("xRange", comp, ret, gtlt, M2, m3, p, pr);
      const xM = isX2(M2);
      const xm = xM || isX2(m3);
      const xp = xm || isX2(p);
      const anyX = xp;
      if (gtlt === "=" && anyX) {
        gtlt = "";
      }
      pr = options.includePrerelease ? "-0" : "";
      if (xM) {
        if (gtlt === ">" || gtlt === "<") {
          ret = "<0.0.0-0";
        } else {
          ret = "*";
        }
      } else if (gtlt && anyX) {
        if (xm) {
          m3 = 0;
        }
        p = 0;
        if (gtlt === ">") {
          gtlt = ">=";
          if (xm) {
            M2 = +M2 + 1;
            m3 = 0;
            p = 0;
          } else {
            m3 = +m3 + 1;
            p = 0;
          }
        } else if (gtlt === "<=") {
          gtlt = "<";
          if (xm) {
            M2 = +M2 + 1;
          } else {
            m3 = +m3 + 1;
          }
        }
        if (gtlt === "<") {
          pr = "-0";
        }
        ret = `${gtlt + M2}.${m3}.${p}${pr}`;
      } else if (xm) {
        ret = `>=${M2}.0.0${pr} <${+M2 + 1}.0.0-0`;
      } else if (xp) {
        ret = `>=${M2}.${m3}.0${pr} <${M2}.${+m3 + 1}.0-0`;
      }
      debug3("xRange return", ret);
      return ret;
    });
  };
  const replaceStars = (comp, options) => {
    debug3("replaceStars", comp, options);
    return comp.trim().replace(re3[t.STAR], "");
  };
  const replaceGTE0 = (comp, options) => {
    debug3("replaceGTE0", comp, options);
    return comp.trim().replace(re3[options.includePrerelease ? t.GTE0PRE : t.GTE0], "");
  };
  const hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr) => {
    if (isX2(fM)) {
      from = "";
    } else if (isX2(fm)) {
      from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
    } else if (isX2(fp)) {
      from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
    } else if (fpr) {
      from = `>=${from}`;
    } else {
      from = `>=${from}${incPr ? "-0" : ""}`;
    }
    if (isX2(tM)) {
      to = "";
    } else if (isX2(tm)) {
      to = `<${+tM + 1}.0.0-0`;
    } else if (isX2(tp)) {
      to = `<${tM}.${+tm + 1}.0-0`;
    } else if (tpr) {
      to = `<=${tM}.${tm}.${tp}-${tpr}`;
    } else if (incPr) {
      to = `<${tM}.${tm}.${+tp + 1}-0`;
    } else {
      to = `<=${to}`;
    }
    return `${from} ${to}`.trim();
  };
  const testSet = (set7, version6, options) => {
    for (let i = 0; i < set7.length; i++) {
      if (!set7[i].test(version6)) {
        return false;
      }
    }
    if (version6.prerelease.length && !options.includePrerelease) {
      for (let i = 0; i < set7.length; i++) {
        debug3(set7[i].semver);
        if (set7[i].semver === Comparator.ANY) {
          continue;
        }
        if (set7[i].semver.prerelease.length > 0) {
          const allowed = set7[i].semver;
          if (allowed.major === version6.major && allowed.minor === version6.minor && allowed.patch === version6.patch) {
            return true;
          }
        }
      }
      return false;
    }
    return true;
  };
  return range6;
}
var satisfies_1;
var hasRequiredSatisfies;
function requireSatisfies() {
  if (hasRequiredSatisfies)
    return satisfies_1;
  hasRequiredSatisfies = 1;
  const Range = requireRange();
  const satisfies2 = (version6, range7, options) => {
    try {
      range7 = new Range(range7, options);
    } catch (er) {
      return false;
    }
    return range7.test(version6);
  };
  satisfies_1 = satisfies2;
  return satisfies_1;
}
var satisfiesExports = requireSatisfies();
var satisfies = getDefaultExportFromCjs(satisfiesExports);
function post(window2, url, data3) {
  const editor = window2.open(url);
  const step = 250;
  const { origin } = new URL(url);
  let count3 = 40;
  function listen(evt) {
    if (evt.source === editor) {
      count3 = 0;
      window2.removeEventListener("message", listen, false);
    }
  }
  window2.addEventListener("message", listen, false);
  function send() {
    if (count3 <= 0) {
      return;
    }
    editor.postMessage(data3, origin);
    setTimeout(send, step);
    count3 -= 1;
  }
  setTimeout(send, step);
}
var embedStyle = `.vega-embed {
  position: relative;
  display: inline-block;
  box-sizing: border-box;
}
.vega-embed.has-actions {
  padding-right: 38px;
}
.vega-embed details:not([open]) > :not(summary) {
  display: none !important;
}
.vega-embed summary {
  list-style: none;
  position: absolute;
  top: 0;
  right: 0;
  padding: 6px;
  z-index: 1000;
  background: white;
  box-shadow: 1px 1px 3px rgba(0, 0, 0, 0.1);
  color: #1b1e23;
  border: 1px solid #aaa;
  border-radius: 999px;
  opacity: 0.2;
  transition: opacity 0.4s ease-in;
  cursor: pointer;
  line-height: 0px;
}
.vega-embed summary::-webkit-details-marker {
  display: none;
}
.vega-embed summary:active {
  box-shadow: #aaa 0px 0px 0px 1px inset;
}
.vega-embed summary svg {
  width: 14px;
  height: 14px;
}
.vega-embed details[open] summary {
  opacity: 0.7;
}
.vega-embed:hover summary, .vega-embed:focus-within summary {
  opacity: 1 !important;
  transition: opacity 0.2s ease;
}
.vega-embed .vega-actions {
  position: absolute;
  z-index: 1001;
  top: 35px;
  right: -9px;
  display: flex;
  flex-direction: column;
  padding-bottom: 8px;
  padding-top: 8px;
  border-radius: 4px;
  box-shadow: 0 2px 8px 0 rgba(0, 0, 0, 0.2);
  border: 1px solid #d9d9d9;
  background: white;
  animation-duration: 0.15s;
  animation-name: scale-in;
  animation-timing-function: cubic-bezier(0.2, 0, 0.13, 1.5);
  text-align: left;
}
.vega-embed .vega-actions a {
  padding: 8px 16px;
  font-family: sans-serif;
  font-size: 14px;
  font-weight: 600;
  white-space: nowrap;
  color: #434a56;
  text-decoration: none;
}
.vega-embed .vega-actions a:hover, .vega-embed .vega-actions a:focus {
  background-color: #f7f7f9;
  color: black;
}
.vega-embed .vega-actions::before, .vega-embed .vega-actions::after {
  content: "";
  display: inline-block;
  position: absolute;
}
.vega-embed .vega-actions::before {
  left: auto;
  right: 14px;
  top: -16px;
  border: 8px solid rgba(0, 0, 0, 0);
  border-bottom-color: #d9d9d9;
}
.vega-embed .vega-actions::after {
  left: auto;
  right: 15px;
  top: -14px;
  border: 7px solid rgba(0, 0, 0, 0);
  border-bottom-color: #fff;
}
.vega-embed .chart-wrapper.fit-x {
  width: 100%;
}
.vega-embed .chart-wrapper.fit-y {
  height: 100%;
}

.vega-embed-wrapper {
  max-width: 100%;
  overflow: auto;
  padding-right: 14px;
}

@keyframes scale-in {
  from {
    opacity: 0;
    transform: scale(0.6);
  }
  to {
    opacity: 1;
    transform: scale(1);
  }
}
`;
function mergeDeep2(dest, ...src) {
  for (const s2 of src) {
    deepMerge_2(dest, s2);
  }
  return dest;
}
function deepMerge_2(dest, src) {
  for (const property2 of Object.keys(src)) {
    writeConfig(dest, property2, src[property2], true);
  }
}
var version$15 = "7.0.2";
var pkg4 = {
  version: version$15
};
var version5 = pkg4.version;
var vega = vega_module_exports;
var vegaLite = build_exports;
var w7 = typeof window !== "undefined" ? window : void 0;
var _a;
if (vegaLite === void 0 && ((_a = w7 == null ? void 0 : w7.vl) == null ? void 0 : _a.compile)) {
  vegaLite = w7.vl;
}
var DEFAULT_ACTIONS = { export: { svg: true, png: true }, source: true, compiled: true, editor: true };
var I18N = {
  CLICK_TO_VIEW_ACTIONS: "Click to view actions",
  COMPILED_ACTION: "View Compiled Vega",
  EDITOR_ACTION: "Open in Vega Editor",
  PNG_ACTION: "Save as PNG",
  SOURCE_ACTION: "View Source",
  SVG_ACTION: "Save as SVG"
};
var NAMES = {
  vega: "Vega",
  "vega-lite": "Vega-Lite"
};
var VERSION = {
  vega: vega.version,
  "vega-lite": vegaLite ? vegaLite.version : "not available"
};
var PREPROCESSOR = {
  vega: (vgSpec) => vgSpec,
  "vega-lite": (vlSpec, config) => vegaLite.compile(vlSpec, { config }).spec
};
var SVG_CIRCLES = `
<svg viewBox="0 0 16 16" fill="currentColor" stroke="none" stroke-width="1" stroke-linecap="round" stroke-linejoin="round">
  <circle r="2" cy="8" cx="2"></circle>
  <circle r="2" cy="8" cx="8"></circle>
  <circle r="2" cy="8" cx="14"></circle>
</svg>`;
var CHART_WRAPPER_CLASS = "chart-wrapper";
function isTooltipHandler(h6) {
  return typeof h6 === "function";
}
function viewSource(source3, sourceHeader, sourceFooter, mode2) {
  const header = `<html><head>${sourceHeader}</head><body><pre><code class="json">`;
  const footer = `</code></pre>${sourceFooter}</body></html>`;
  const win = window.open("");
  win.document.write(header + source3 + footer);
  win.document.title = `${NAMES[mode2]} JSON Source`;
}
function guessMode(spec, providedMode) {
  if (spec.$schema) {
    const parsed = e(spec.$schema);
    if (providedMode && providedMode !== parsed.library) {
      console.warn(`The given visualization spec is written in ${NAMES[parsed.library]}, but mode argument sets ${NAMES[providedMode] ?? providedMode}.`);
    }
    const mode2 = parsed.library;
    if (!satisfies(VERSION[mode2], `^${parsed.version.slice(1)}`)) {
      console.warn(`The input spec uses ${NAMES[mode2]} ${parsed.version}, but the current version of ${NAMES[mode2]} is v${VERSION[mode2]}.`);
    }
    return mode2;
  }
  if ("mark" in spec || "encoding" in spec || "layer" in spec || "hconcat" in spec || "vconcat" in spec || "facet" in spec || "repeat" in spec) {
    return "vega-lite";
  }
  if ("marks" in spec || "signals" in spec || "scales" in spec || "axes" in spec) {
    return "vega";
  }
  return providedMode ?? "vega";
}
function isLoader(o) {
  return !!(o && "load" in o);
}
function createLoader(opts) {
  return isLoader(opts) ? opts : vega.loader(opts);
}
function embedOptionsFromUsermeta(parsedSpec) {
  var _a2;
  const opts = ((_a2 = parsedSpec.usermeta) == null ? void 0 : _a2.embedOptions) ?? {};
  if (isString(opts.defaultStyle)) {
    opts.defaultStyle = false;
  }
  return opts;
}
async function embed(el, spec, opts = {}) {
  let parsedSpec;
  let loader7;
  if (isString(spec)) {
    loader7 = createLoader(opts.loader);
    parsedSpec = JSON.parse(await loader7.load(spec));
  } else {
    parsedSpec = spec;
  }
  const loadedEmbedOptions = embedOptionsFromUsermeta(parsedSpec);
  const usermetaLoader = loadedEmbedOptions.loader;
  if (!loader7 || usermetaLoader) {
    loader7 = createLoader(opts.loader ?? usermetaLoader);
  }
  const usermetaOpts = await loadOpts(loadedEmbedOptions, loader7);
  const parsedOpts = await loadOpts(opts, loader7);
  const mergedOpts = {
    ...mergeDeep2(parsedOpts, usermetaOpts),
    config: mergeConfig(parsedOpts.config ?? {}, usermetaOpts.config ?? {})
  };
  return await _embed(el, parsedSpec, mergedOpts, loader7);
}
async function loadOpts(opt, loader7) {
  const config = isString(opt.config) ? JSON.parse(await loader7.load(opt.config)) : opt.config ?? {};
  const patch2 = isString(opt.patch) ? JSON.parse(await loader7.load(opt.patch)) : opt.patch;
  return {
    ...opt,
    ...patch2 ? { patch: patch2 } : {},
    ...config ? { config } : {}
  };
}
function getRoot(el) {
  const possibleRoot = el.getRootNode ? el.getRootNode() : document;
  return possibleRoot instanceof ShadowRoot ? { root: possibleRoot, rootContainer: possibleRoot } : { root: document, rootContainer: document.head ?? document.body };
}
async function _embed(el, spec, opts = {}, loader7) {
  const config = opts.theme ? mergeConfig(build_exports2[opts.theme], opts.config ?? {}) : opts.config;
  const actions = isBoolean(opts.actions) ? opts.actions : mergeDeep2({}, DEFAULT_ACTIONS, opts.actions ?? {});
  const i18n = { ...I18N, ...opts.i18n };
  const renderer = opts.renderer ?? "svg";
  const logLevel = opts.logLevel ?? vega.Warn;
  const downloadFileName = opts.downloadFileName ?? "visualization";
  const element7 = typeof el === "string" ? document.querySelector(el) : el;
  if (!element7) {
    throw new Error(`${el} does not exist`);
  }
  if (opts.defaultStyle !== false) {
    const ID = "vega-embed-style";
    const { root, rootContainer } = getRoot(element7);
    if (!root.getElementById(ID)) {
      const style6 = document.createElement("style");
      style6.id = ID;
      style6.innerHTML = opts.defaultStyle === void 0 || opts.defaultStyle === true ? embedStyle.toString() : opts.defaultStyle;
      rootContainer.appendChild(style6);
    }
  }
  const mode2 = guessMode(spec, opts.mode);
  let vgSpec = PREPROCESSOR[mode2](spec, config);
  if (mode2 === "vega-lite") {
    if (vgSpec.$schema) {
      const parsed = e(vgSpec.$schema);
      if (!satisfies(VERSION.vega, `^${parsed.version.slice(1)}`)) {
        console.warn(`The compiled spec uses Vega ${parsed.version}, but current version is v${VERSION.vega}.`);
      }
    }
  }
  element7.classList.add("vega-embed");
  if (actions) {
    element7.classList.add("has-actions");
  }
  element7.innerHTML = "";
  let container = element7;
  if (actions) {
    const chartWrapper = document.createElement("div");
    chartWrapper.classList.add(CHART_WRAPPER_CLASS);
    element7.appendChild(chartWrapper);
    container = chartWrapper;
  }
  const patch2 = opts.patch;
  if (patch2) {
    vgSpec = patch2 instanceof Function ? patch2(vgSpec) : applyPatch(vgSpec, patch2, true, false).newDocument;
  }
  if (opts.formatLocale) {
    vega.formatLocale(opts.formatLocale);
  }
  if (opts.timeFormatLocale) {
    vega.timeFormatLocale(opts.timeFormatLocale);
  }
  if (opts.expressionFunctions) {
    for (const name in opts.expressionFunctions) {
      const expressionFunction2 = opts.expressionFunctions[name];
      if ("fn" in expressionFunction2) {
        vega.expressionFunction(name, expressionFunction2.fn, expressionFunction2["visitor"]);
      } else if (expressionFunction2 instanceof Function) {
        vega.expressionFunction(name, expressionFunction2);
      }
    }
  }
  const { ast } = opts;
  const runtime2 = vega.parse(vgSpec, mode2 === "vega-lite" ? {} : config, { ast });
  const view = new (opts.viewClass || vega.View)(runtime2, {
    loader: loader7,
    logLevel,
    renderer,
    ...ast ? { expr: vega.expressionInterpreter ?? opts.expr ?? expression2 } : {}
  });
  view.addSignalListener("autosize", (_, autosize) => {
    const { type: type7 } = autosize;
    if (type7 == "fit-x") {
      container.classList.add("fit-x");
      container.classList.remove("fit-y");
    } else if (type7 == "fit-y") {
      container.classList.remove("fit-x");
      container.classList.add("fit-y");
    } else if (type7 == "fit") {
      container.classList.add("fit-x", "fit-y");
    } else {
      container.classList.remove("fit-x", "fit-y");
    }
  });
  if (opts.tooltip !== false) {
    const { loader: loader_, tooltip: tooltip2 } = opts;
    const baseURL = loader_ && !isLoader(loader_) ? loader_ == null ? void 0 : loader_.baseURL : void 0;
    const handler = isTooltipHandler(tooltip2) ? tooltip2 : (
      // user provided boolean true or tooltip options
      new Handler6({ baseURL, ...tooltip2 === true ? {} : tooltip2 }).call
    );
    view.tooltip(handler);
  }
  let { hover: hover2 } = opts;
  if (hover2 === void 0) {
    hover2 = mode2 === "vega";
  }
  if (hover2) {
    const { hoverSet, updateSet } = typeof hover2 === "boolean" ? {} : hover2;
    view.hover(hoverSet, updateSet);
  }
  if (opts) {
    if (opts.width != null) {
      view.width(opts.width);
    }
    if (opts.height != null) {
      view.height(opts.height);
    }
    if (opts.padding != null) {
      view.padding(opts.padding);
    }
  }
  await view.initialize(container, opts.bind).runAsync();
  let documentClickHandler;
  if (actions !== false) {
    let wrapper = element7;
    if (opts.defaultStyle !== false || opts.forceActionsMenu) {
      const details = document.createElement("details");
      details.title = i18n.CLICK_TO_VIEW_ACTIONS;
      element7.append(details);
      wrapper = details;
      const summary = document.createElement("summary");
      summary.innerHTML = SVG_CIRCLES;
      details.append(summary);
      documentClickHandler = (ev) => {
        if (!details.contains(ev.target)) {
          details.removeAttribute("open");
        }
      };
      document.addEventListener("click", documentClickHandler);
    }
    const ctrl = document.createElement("div");
    wrapper.append(ctrl);
    ctrl.classList.add("vega-actions");
    if (actions === true || actions.export !== false) {
      for (const ext of ["svg", "png"]) {
        if (actions === true || actions.export === true || actions.export[ext]) {
          const i18nExportAction = i18n[`${ext.toUpperCase()}_ACTION`];
          const exportLink = document.createElement("a");
          const scaleFactor = isObject(opts.scaleFactor) ? opts.scaleFactor[ext] : opts.scaleFactor;
          exportLink.text = i18nExportAction;
          exportLink.href = "#";
          exportLink.target = "_blank";
          exportLink.download = `${downloadFileName}.${ext}`;
          exportLink.addEventListener("mousedown", async function(e3) {
            e3.preventDefault();
            const url = await view.toImageURL(ext, scaleFactor);
            this.href = url;
          });
          ctrl.append(exportLink);
        }
      }
    }
    if (actions === true || actions.source !== false) {
      const viewSourceLink = document.createElement("a");
      viewSourceLink.text = i18n.SOURCE_ACTION;
      viewSourceLink.href = "#";
      viewSourceLink.addEventListener("click", function(e3) {
        viewSource(stringify(spec), opts.sourceHeader ?? "", opts.sourceFooter ?? "", mode2);
        e3.preventDefault();
      });
      ctrl.append(viewSourceLink);
    }
    if (mode2 === "vega-lite" && (actions === true || actions.compiled !== false)) {
      const compileLink = document.createElement("a");
      compileLink.text = i18n.COMPILED_ACTION;
      compileLink.href = "#";
      compileLink.addEventListener("click", function(e3) {
        viewSource(stringify(vgSpec), opts.sourceHeader ?? "", opts.sourceFooter ?? "", "vega");
        e3.preventDefault();
      });
      ctrl.append(compileLink);
    }
    if (actions === true || actions.editor !== false) {
      const editorUrl = opts.editorUrl ?? "https://vega.github.io/editor/";
      const editorLink = document.createElement("a");
      editorLink.text = i18n.EDITOR_ACTION;
      editorLink.href = "#";
      editorLink.addEventListener("click", function(e3) {
        post(window, editorUrl, {
          config,
          mode: patch2 ? "vega" : mode2,
          renderer,
          spec: stringify(patch2 ? vgSpec : spec)
        });
        e3.preventDefault();
      });
      ctrl.append(editorLink);
    }
  }
  function finalize2() {
    if (documentClickHandler) {
      document.removeEventListener("click", documentClickHandler);
    }
    view.finalize();
  }
  return { view, spec, vgSpec, finalize: finalize2, embedOptions: opts };
}
export {
  DEFAULT_ACTIONS,
  embed as default,
  guessMode,
  vega,
  vegaLite,
  version5 as version
};
/*! Bundled license information:

vega-embed/build/embed.js:
  (*!
   * https://github.com/Starcounter-Jack/JSON-Patch
   * (c) 2017-2022 Joachim Wester
   * MIT licensed
   *)
  (*!
   * https://github.com/Starcounter-Jack/JSON-Patch
   * (c) 2017-2021 Joachim Wester
   * MIT license
   *)
*/
//# sourceMappingURL=vega-embed.js.map
