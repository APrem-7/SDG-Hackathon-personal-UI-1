{"version":3,"file":"buildMetricTable.worker-fd3ee5e3.js","sources":["../src/components/pivotTable/utils.ts","../src/workers/buildPivotTable.ts","../src/workers/buildMetricTable.worker.js"],"sourcesContent":["import { IRow } from '../../interfaces';\nimport { INestNode } from './inteface';\n\nconst key_prefix = 'nk_';\n\nfunction insertNode(\n    tree: INestNode,\n    layerKeys: string[],\n    nodeData: IRow,\n    depth: number,\n    collapsedKeyList: string[],\n    sort?: {\n        fid: string;\n        type: 'ascending' | 'descending';\n    }\n) {\n    if (depth >= layerKeys.length) {\n        // tree.key = nodeData[layerKeys[depth]];\n        return;\n    }\n    const key = nodeData[layerKeys[depth]];\n    const uniqueKey = `${tree.uniqueKey}__${key}`;\n\n    let child = tree.children.find((c) => c.key === key);\n    if (!child) {\n        child = {\n            key,\n            value: key,\n            sort: depth === layerKeys.length - 1 && sort ? nodeData[sort.fid] ?? `_${key}` : key,\n            uniqueKey: uniqueKey,\n            fieldKey: layerKeys[depth],\n            children: [],\n            path: [...tree.path, { key: layerKeys[depth], value: key }],\n            height: layerKeys.length - depth - 1,\n            isCollapsed: false,\n        };\n        if (collapsedKeyList.includes(tree.uniqueKey)) {\n            tree.isCollapsed = true;\n        }\n        const reverse = depth === layerKeys.length - 1 && sort?.type === 'descending';\n        tree.children.splice(binarySearchIndex(tree.children, child.sort, reverse), 0, child);\n    }\n    insertNode(child, layerKeys, nodeData, depth + 1, collapsedKeyList, sort);\n}\n\n// Custom binary search function to find appropriate index for insertion.\nfunction binarySearchIndex(arr: INestNode[], keyVal: string | number, reverse = false): number {\n    let start = 0,\n        end = arr.length - 1;\n\n    while (start <= end) {\n        let middle = Math.floor((start + end) / 2);\n        let middleVal = arr[middle].sort;\n        if (typeof middleVal === 'number' && typeof keyVal === 'number') {\n            if (reverse !== middleVal < keyVal) start = middle + 1;\n            else end = middle - 1;\n        } else {\n            let cmp = String(middleVal).localeCompare(String(keyVal));\n            if (reverse !== cmp < 0) start = middle + 1;\n            else end = middle - 1;\n        }\n    }\n    return start;\n}\n\nconst ROOT_KEY = '__root';\nconst TOTAL_KEY = '__total';\n\nfunction insertSummaryNode(node: INestNode): void {\n    if (node.children.length > 0) {\n        node.children.unshift({\n            key: TOTAL_KEY,\n            value: `${node.value}(total)`,\n            sort: '',\n            fieldKey: TOTAL_KEY,\n            uniqueKey: `${node.uniqueKey}${TOTAL_KEY}`,\n            children: [],\n            path: [],\n            height: node.children[0].height,\n            isCollapsed: true,\n        });\n        for (let i = 1; i < node.children.length; i++) {\n            insertSummaryNode(node.children[i]);\n        }\n    }\n}\n\nexport function buildNestTree(\n    layerKeys: string[],\n    data: IRow[],\n    collapsedKeyList: string[],\n    showSummary: boolean,\n    sort?: {\n        fid: string;\n        type: 'ascending' | 'descending';\n    },\n    dataWithoutSort?: IRow[]\n): INestNode {\n    const tree: INestNode = {\n        key: ROOT_KEY,\n        value: 'root',\n        fieldKey: 'root',\n        sort: '',\n        uniqueKey: ROOT_KEY,\n        children: [],\n        path: [],\n        height: layerKeys.length,\n        isCollapsed: false,\n    };\n    for (let row of data) {\n        insertNode(tree, layerKeys, row, 0, collapsedKeyList, sort);\n    }\n    if (dataWithoutSort) {\n        for (let row of dataWithoutSort) {\n            insertNode(tree, layerKeys, row, 0, collapsedKeyList, { fid: '', type: sort?.type ?? 'ascending' });\n        }\n    }\n    if (showSummary) {\n        insertSummaryNode(tree);\n    }\n    return tree;\n}\n\nclass NodeIterator {\n    public tree: INestNode;\n    public nodeStack: INestNode[] = [];\n    public current: INestNode | null = null;\n    constructor(tree: INestNode) {\n        this.tree = tree;\n    }\n    public first() {\n        let node = this.tree;\n        this.nodeStack = [node];\n        while (node.children.length > 0 && !node.isCollapsed) {\n            this.nodeStack.push(node.children[0]);\n            node = node.children[0];\n        }\n        this.current = node;\n        return this.current;\n    }\n    public next(): INestNode | null {\n        let cursorMoved = false;\n        let counter = 0;\n        while (this.nodeStack.length > 1) {\n            counter++;\n            if (counter > 100) break;\n            let node = this.nodeStack[this.nodeStack.length - 1];\n            let parent = this.nodeStack[this.nodeStack.length - 2];\n            let nodeIndex = parent.children.findIndex((n) => n.key === node!.key);\n            if (nodeIndex === -1) break;\n            if (cursorMoved) {\n                if (node.children.length > 0 && !node.isCollapsed) {\n                    this.nodeStack.push(node.children[0]);\n                    continue;\n                } else {\n                    break;\n                }\n            } else {\n                if (nodeIndex < parent.children.length - 1) {\n                    this.nodeStack.pop();\n                    this.nodeStack.push(parent.children[nodeIndex + 1]);\n                    cursorMoved = true;\n                    continue;\n                }\n                if (nodeIndex >= parent.children.length - 1) {\n                    this.nodeStack.pop();\n                    continue;\n                }\n            }\n        }\n        if (cursorMoved) {\n            this.current = this.nodeStack[this.nodeStack.length - 1] || null;\n        } else {\n            this.current = null;\n        }\n        return this.current;\n    }\n    public predicates(): { key: string; value: string | number }[] {\n        return this.nodeStack\n            .filter((node) => node.key !== ROOT_KEY)\n            .map((node) => ({\n                key: node.fieldKey,\n                value: node.value,\n            }));\n    }\n}\n\nexport function buildMetricTableFromNestTree(leftTree: INestNode, topTree: INestNode, data: IRow[]): (IRow | null)[][] {\n    const mat: any[][] = [];\n    const iteLeft = new NodeIterator(leftTree);\n    const iteTop = new NodeIterator(topTree);\n    iteLeft.first();\n    while (iteLeft.current !== null) {\n        const vec: any[] = [];\n        iteTop.first();\n        while (iteTop.current !== null) {\n            const predicates = iteLeft\n                .predicates()\n                .concat(iteTop.predicates())\n                .filter((ele) => ele.key !== TOTAL_KEY);\n            const matchedRows = data.filter((r) => predicates.every((pre) => r[pre.key] === pre.value));\n            if (matchedRows.length > 0) {\n                // If multiple rows are matched, then find the most matched one (the row with smallest number of keys)\n                vec.push(matchedRows.reduce((a, b) => (Object.keys(a).length < Object.keys(b).length ? a : b)));\n            } else {\n                vec.push(undefined);\n            }\n            iteTop.next();\n        }\n        mat.push(vec);\n        iteLeft.next();\n    }\n    return mat;\n}\n\nexport function getAllChildrenSize(node: INestNode, depth: number): number {\n    if (depth === 0) {\n        return node.children.length;\n    }\n    return node.children.reduce((acc, child) => acc + getAllChildrenSize(child, depth + 1), 0);\n}\n","import { INestNode } from '../components/pivotTable/inteface';\nimport { buildMetricTableFromNestTree, buildNestTree } from '../components/pivotTable/utils';\nimport { IViewField, IRow } from '../interfaces';\n\nconst getFirsts = (item: INestNode): INestNode[] => {\n    if (item.children.length > 0) {\n        return [item, ...getFirsts(item.children[0])];\n    }\n    return [item];\n};\n\nexport function buildPivotTable(\n    dimsInRow: IViewField[],\n    dimsInColumn: IViewField[],\n    allData: IRow[],\n    aggData: IRow[],\n    collapsedKeyList: string[],\n    showTableSummary: boolean,\n    sort?: {\n        fid: string;\n        type: 'ascending' | 'descending';\n        mode: 'row' | 'column';\n    }\n): { lt: INestNode; tt: INestNode; metric: (IRow | null)[][] } {\n    let lt: INestNode;\n    let tt: INestNode;\n    if (sort?.mode === 'row') {\n        tt = buildNestTree(\n            dimsInColumn.map((d) => d.fid),\n            allData,\n            collapsedKeyList,\n            showTableSummary\n        );\n        if (dimsInColumn.length > 0) {\n            const ks = dimsInColumn.map((x) => x.fid);\n            const vs = getFirsts(tt.children[0]).map((x) => x.value);\n            // move data of First column to first\n            const mentioned: IRow[] = [];\n            const rest: IRow[] = [];\n            allData.forEach((x) => (ks.every((k, i) => x[k] === vs[i]) ? mentioned.push(x) : rest.push(x)));\n            lt = buildNestTree(\n                dimsInRow.map((d) => d.fid),\n                mentioned,\n                collapsedKeyList,\n                showTableSummary,\n                sort,\n                rest\n            );\n        } else {\n            lt = buildNestTree(\n                dimsInRow.map((d) => d.fid),\n                allData,\n                collapsedKeyList,\n                showTableSummary,\n                sort\n            );\n        }\n    } else {\n        lt = buildNestTree(\n            dimsInRow.map((d) => d.fid),\n            allData,\n            collapsedKeyList,\n            showTableSummary\n        );\n        if (sort && dimsInRow.length > 0) {\n            const ks = dimsInRow.map((x) => x.fid);\n            const vs = getFirsts(lt.children[0]).map((x) => x.value);\n            // move data of First row to first\n            const mentioned: IRow[] = [];\n            const rest: IRow[] = [];\n            allData.forEach((x) => (ks.every((k, i) => x[k] === vs[i]) ? mentioned.push(x) : rest.push(x)));\n            tt = buildNestTree(\n                dimsInColumn.map((d) => d.fid),\n                mentioned,\n                collapsedKeyList,\n                showTableSummary,\n                sort,\n                rest\n            );\n        } else {\n            tt = buildNestTree(\n                dimsInColumn.map((d) => d.fid),\n                allData,\n                collapsedKeyList,\n                showTableSummary,\n                sort\n            );\n        }\n    }\n\n    const metric = buildMetricTableFromNestTree(lt, tt, [...allData, ...aggData]);\n    return { lt, tt, metric };\n}\n","/* eslint no-restricted-globals: 0 */\n/* eslint-disable */ \nimport { buildPivotTable } from \"./buildPivotTable\"\n/**\n * @param {import('../interfaces').IViewField[]} dimsInRow\n * @param {import('../interfaces').IViewField[]} dimsInColumn\n * @param {import('../interfaces').IRow[]} allData\n * @param {import('../interfaces').IRow} aggData\n * @param {string[]} collapsedKeyList\n * @param {boolean} showTableSummary\n * @return {{lt: import('../components/pivotTable/inteface').INestNode, tt: import('../components/pivotTable/inteface').INestNode, metric: import('../interfaces').(IRow | null)[][]}}\n */\n\n/**\n * @param {MessageEvent<{ dimsInRow: import('../interfaces').IViewField[]; dimsInColumn: import('../interfaces').IViewField[]; allData: import('../interfaces').IRow[]; aggData: import('../interfaces').IRow[]; collapsedKeyList: string[]; showTableSummary: boolean }>} e\n */\nconst main = e => {\n    const { dimsInRow, dimsInColumn, allData, aggData, collapsedKeyList, showTableSummary, sort } = e.data;\n    try {\n        const ans = buildPivotTable(dimsInRow, dimsInColumn, allData, aggData, collapsedKeyList, showTableSummary, sort);\n        self.postMessage(ans);\n    } catch (error) {\n        self.postMessage({ error: error.message });\n    }\n};\n\nself.addEventListener('message', main, false);\n"],"names":["insertNode","tree","layerKeys","nodeData","depth","collapsedKeyList","sort","key","uniqueKey","child","c","reverse","binarySearchIndex","arr","keyVal","start","end","middle","middleVal","cmp","ROOT_KEY","TOTAL_KEY","insertSummaryNode","node","i","buildNestTree","data","showSummary","dataWithoutSort","row","NodeIterator","__publicField","cursorMoved","counter","parent","nodeIndex","n","buildMetricTableFromNestTree","leftTree","topTree","mat","iteLeft","iteTop","vec","predicates","ele","matchedRows","r","pre","a","b","getFirsts","item","buildPivotTable","dimsInRow","dimsInColumn","allData","aggData","showTableSummary","lt","tt","d","ks","x","vs","mentioned","rest","k","metric","main","e","ans","error"],"mappings":"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"}